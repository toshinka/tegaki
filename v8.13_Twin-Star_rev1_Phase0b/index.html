<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé® GPT5Êîπ‰øÆÁâà - PixiJS v8.13 „ÅäÁµµ„Åã„Åç„ÉÑ„Éº„É´</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --futaba-maroon: #800000;
            --futaba-light-maroon: #aa5a56;
            --futaba-medium: #cf9c97;
            --futaba-light-medium: #e9c2ba;
            --futaba-cream: #f0e0d6;
            --futaba-background: #ffffee;
            --text-primary: #2c1810;
            --text-secondary: #5d4037;
            --text-inverse: #ffffff;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans JP', sans-serif;
            background: var(--futaba-background);
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 50px 1fr;
            height: 100vh;
            width: 100vw;
            gap: 0;
        }
        
        .sidebar {
            background: var(--futaba-cream);
            border-right: 2px solid var(--futaba-light-medium);
            display: flex;
            flex-direction: column;
            padding: 12px 6px;
            gap: 4px;
            overflow-y: auto;
            position: relative;
            z-index: 100;
        }
        
        .tool-button {
            width: 36px;
            height: 36px;
            border: 2px solid var(--futaba-light-medium);
            background: var(--futaba-background);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--futaba-maroon);
            position: relative;
            user-select: none;
        }
        
        .tool-button svg { width: 20px; height: 20px; stroke: #800000; }
        
        .tool-button:hover {
            background: var(--futaba-medium);
            border-color: var(--futaba-light-maroon);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(128, 0, 0, 0.2);
        }
        
        .tool-button.active {
            background: var(--futaba-maroon);
            color: var(--text-inverse);
            border-color: var(--futaba-maroon);
            box-shadow: 0 2px 8px rgba(128, 0, 0, 0.3);
        }
        
        .tool-button.active svg { stroke: #ffffff; }
        
        .tool-separator {
            height: 1px;
            background: var(--futaba-light-medium);
            margin: 4px 2px;
        }
        
        .canvas-area {
            background: var(--futaba-background);
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #drawing-canvas {
            border: none;
            display: block;
            cursor: crosshair;
            touch-action: none;
        }
        
        .layer-panel-container {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: none;
        }
        
        .layer-add-button {
            width: 36px;
            height: 36px;
            background: var(--futaba-cream);
            border: 2px solid var(--futaba-light-medium);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(128, 0, 0, 0.1);
            pointer-events: all;
        }
        
        .layer-add-button:hover {
            background: var(--futaba-medium);
            transform: scale(1.1);
        }
        
        .layer-add-button svg { width: 18px; height: 18px; stroke: #800000; }
        
        .layer-panel-items {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: transparent;
            border-radius: 8px;
            padding: 8px;
            pointer-events: all;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .layer-item {
            width: 180px;
            height: 64px;
            background: var(--futaba-cream);
            border: 1px solid var(--futaba-light-medium);
            border-radius: 6px;
            padding: 6px 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            display: grid;
            grid-template-columns: 20px 1fr 48px;
            grid-template-rows: 1fr 1fr;
            gap: 4px 8px;
            align-items: center;
            user-select: none;
            position: relative;
            box-shadow: 0 1px 2px rgba(128, 0, 0, 0.05);
        }
        
        .layer-item:hover {
            border-color: var(--futaba-medium);
            background: var(--futaba-background);
        }
        
        .layer-item.active {
            border-color: var(--futaba-maroon);
            background: var(--futaba-light-medium);
            box-shadow: 0 2px 4px rgba(128, 0, 0, 0.15);
        }
        
        .layer-visibility {
            grid-column: 1;
            grid-row: 1 / 3;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
            align-self: center;
        }
        
        .layer-visibility:hover { background: var(--futaba-light-medium); }
        .layer-visibility svg { width: 16px; height: 16px; stroke: #800000; }
        .layer-visibility.hidden svg { opacity: 0.3; }
        
        .layer-opacity {
            grid-column: 2;
            grid-row: 1;
            font-size: 10px;
            color: var(--text-secondary);
            font-family: monospace;
            align-self: start;
            margin-top: 2px;
        }
        
        .layer-name {
            grid-column: 2;
            grid-row: 2;
            font-size: 12px;
            color: var(--text-primary);
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            align-self: end;
            margin-bottom: 2px;
        }
        
        .layer-thumbnail {
            grid-column: 3;
            grid-row: 1 / 3;
            width: 48px;
            height: 48px;
            background: var(--futaba-background);
            border: 1px solid var(--futaba-light-medium);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            align-self: center;
        }
        
        .layer-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 3px;
            transition: opacity 0.2s ease;
        }
        
        .layer-thumbnail-placeholder {
            width: 24px;
            height: 24px;
            background: var(--futaba-light-medium);
            border-radius: 2px;
            opacity: 0.5;
        }
        
        .layer-delete-button {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
            background: rgba(128, 0, 0, 0.1);
            opacity: 0;
        }
        
        .layer-item:hover .layer-delete-button { opacity: 1; }
        .layer-delete-button:hover { background: rgba(128, 0, 0, 0.2); }
        .layer-delete-button svg { width: 10px; height: 10px; stroke: #800000; }
        
        .layer-transform-panel {
            position: fixed;
            background: rgba(240, 224, 214, 0.95);
            border: 2px solid var(--futaba-maroon);
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(128, 0, 0, 0.25);
            padding: 10px 14px;
            z-index: 2000;
            backdrop-filter: blur(12px);
            display: none;
            user-select: none;
            left: 50%;
            top: 20px;
            transform: translateX(-50%);
        }
        
        .layer-transform-panel.show { 
            display: block; 
            animation: slideDown 0.25s ease-out; 
        }
        
        @keyframes slideDown {
            from { opacity: 0; transform: translateX(-50%) translateY(-15px) scale(0.95); }
            to   { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
        }
        
        .panel-sections {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 14px;
            align-items: start;
            min-width: 480px;
        }
        
        .panel-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .compact-slider-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .compact-slider {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .compact-slider-label {
            font-size: 10px;
            color: var(--text-secondary);
            min-width: 12px;
            font-weight: 500;
        }
        
        .compact-slider .slider {
            width: 80px;
            height: 4px;
            background: var(--futaba-light-medium);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }
        
        .compact-slider .slider-track {
            height: 100%;
            background: var(--futaba-maroon);
            border-radius: 2px;
            transition: width 0.1s ease;
        }
        
        .compact-slider .slider-handle {
            width: 12px;
            height: 12px;
            background: var(--futaba-maroon);
            border: 2px solid var(--futaba-background);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .compact-slider .slider-handle:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .compact-slider .slider-value {
            font-size: 10px;
            color: var(--text-secondary);
            font-family: monospace;
            min-width: 35px;
            text-align: right;
        }
        
        .flip-section {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .flip-button {
            padding: 4px 6px;
            border: 1px solid var(--futaba-light-medium);
            border-radius: 4px;
            background: var(--futaba-background);
            color: var(--text-primary);
            font-size: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
            white-space: nowrap;
            min-width: auto;
            width: auto;
        }
        
        .flip-button:hover {
            border-color: var(--futaba-maroon);
        }
        
        .flip-button.active {
            background: var(--futaba-maroon);
            color: var(--text-inverse);
            border-color: var(--futaba-maroon);
        }
        
        .status-panel {
            position: fixed;
            bottom: 20px;
            left: 70px;
            right: 20px;
            background: var(--futaba-cream);
            border: 2px solid var(--futaba-medium);
            border-radius: 12px;
            padding: 8px 16px;
            font-family: monospace;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 16px rgba(128, 0, 0, 0.1);
            z-index: 50;
        }
        
        .status-group {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* „Ç¨„Ç§„Éâ„É©„Ç§„É≥ */
        .guide-lines {
            position: absolute;
            pointer-events: none;
            z-index: 500;
            opacity: 0.8;
        }
        
        .guide-line {
            background: #800000;
            position: absolute;
        }
        
        .guide-line.horizontal {
            height: 1px;
            width: 100%;
        }
        
        .guide-line.vertical {
            width: 1px;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="main-layout">
        <div class="sidebar">
            <div class="tool-button" id="resize-tool" title="„É™„Çµ„Ç§„Ç∫">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#800000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M14 15H9v-5"/><path d="M16 3h5v5"/><path d="M21 3 9 15"/></svg>
            </div>
            
            <div class="tool-separator"></div>
                   
            <div class="tool-button active" id="pen-tool" title="„Éô„ÇØ„Çø„Éº„Éö„É≥ (P)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#800000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M13 21h8"/><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"/></svg>
            </div>
            
            <div class="tool-button" id="eraser-tool" title="Ê∂à„Åó„Ç¥„É† (E)">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#800000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 21H8a2 2 0 0 1-1.42-.587l-3.994-3.999a2 2 0 0 1 0-2.828l10-10a2 2 0 0 1 2.829 0l5.999 6a2 2 0 0 1 0 2.828L12.834 21"/><path d="m5.082 11.09 8.828 8.828"/></svg>
            </div>
        </div>
        
        <div class="canvas-area">
            <div id="drawing-canvas"></div>
        </div>
    </div>
    
    <div class="layer-panel-container" id="layer-panel-container">
        <div class="layer-add-button" id="add-layer-btn" title="„É¨„Ç§„É§„ÉºËøΩÂä†">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#800000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="15" x2="15" y1="12" y2="18"/><line x1="12" x2="18" y1="15" y2="15"/><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2 2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>
        </div>
        
        <div class="layer-panel-items" id="layer-list"></div>
    </div>
    
    <div class="layer-transform-panel" id="layer-transform-panel">
        <div class="panel-sections">
            <div class="panel-section">
                <div class="compact-slider-group">
                    <div class="compact-slider">
                        <div class="compact-slider-label">X</div>
                        <div class="slider" id="layer-x-slider">
                            <div class="slider-track"></div>
                            <div class="slider-handle"></div>
                        </div>
                        <div class="slider-value" id="layer-x-value">0px</div>
                    </div>
                    <div class="compact-slider">
                        <div class="compact-slider-label">Y</div>
                        <div class="slider" id="layer-y-slider">
                            <div class="slider-track"></div>
                            <div class="slider-handle"></div>
                        </div>
                        <div class="slider-value" id="layer-y-value">0px</div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="compact-slider-group">
                    <div class="compact-slider">
                        <div class="compact-slider-label">ÂõûËª¢</div>
                        <div class="slider" id="layer-rotation-slider">
                            <div class="slider-track"></div>
                            <div class="slider-handle"></div>
                        </div>
                        <div class="slider-value" id="layer-rotation-value">0¬∞</div>
                    </div>
                    <div class="compact-slider">
                        <div class="compact-slider-label">Êã°Á∏Æ</div>
                        <div class="slider" id="layer-scale-slider">
                            <div class="slider-track"></div>
                            <div class="slider-handle"></div>
                        </div>
                        <div class="slider-value" id="layer-scale-value">1.00x</div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="flip-section">
                    <div class="flip-button" id="flip-horizontal-btn">Ê∞¥Âπ≥ÂèçËª¢</div>
                    <div class="flip-button" id="flip-vertical-btn">ÂûÇÁõ¥ÂèçËª¢</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="status-panel">
        <div class="status-group">
            <div class="status-item">Canvas: <span id="canvas-info">400√ó400px</span></div>
            <div class="status-item">Tool: <span id="current-tool">„Éô„ÇØ„Çø„Éº„Éö„É≥</span></div>
            <div class="status-item">Layer: <span id="current-layer">„É¨„Ç§„É§„Éº0</span></div>
            <div class="status-item">Â∫ßÊ®ô: <span id="coordinates">x: 0, y: 0</span></div>
            <div class="status-item">Transform: <span id="transform-info">x:0 y:0 s:1.0 r:0¬∞</span></div>
        </div>
        
        <div class="status-group">
            <div class="status-item">Mode: <span id="mode-info">Drawing</span></div>
            <div class="status-item">History: <span id="history-info">1/10</span></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/pixi.min.js"></script>
    
    <script>
// ===============================
//  Configuration
// ===============================
const CONFIG = {
    canvas: {
        width: 400,
        height: 400
    },
    camera: {
        initialScale: 1.0,
        minScale: 0.1,
        maxScale: 10.0,
        wheelZoomSpeed: 0.1,
        dragMoveSpeed: 1.0,
        keyMoveAmount: 10,
        keyRotationDegree: 15,
        dragRotationSpeed: 0.5,
        dragScaleSpeed: 0.005
    },
    pen: {
        size: 16,
        color: 0x800000,
        opacity: 0.85
    },
    background: {
        color: 0xffffee
    },
    layer: {
        minX: -1000,
        maxX: 1000,
        minY: -1000,
        maxY: 1000,
        minRotation: -360,
        maxRotation: 360,
        minScale: 0.1,
        maxScale: 5.0
    },
    debug: false
};

// ===============================
//  Transform Utilities (GPT5Êîπ‰øÆÊ°àÂÆüË£Ö)
// ===============================

function screenToWorld(app, screenX, screenY) {
    const p = app.renderer.plugins.interaction.mapPositionToPoint(new PIXI.Point(), screenX, screenY);
    return p;
}

function transformPointAroundPivot_world(ptWorld, pivotWorld, transform) {
    const dx = ptWorld.x - pivotWorld.x;
    const dy = ptWorld.y - pivotWorld.y;
    
    const sx = transform.scaleX ?? transform.scale ?? 1;
    const sy = transform.scaleY ?? transform.scale ?? sx;
    const angle = (transform.rotationDeg ?? 0) * Math.PI / 180;
    
    let nx = dx * sx;
    let ny = dy * sy;
    
    const cos = Math.cos(angle), sin = Math.sin(angle);
    const rx = nx * cos - ny * sin;
    const ry = nx * sin + ny * cos;
    
    return { 
        x: pivotWorld.x + rx + (transform.tx ?? 0), 
        y: pivotWorld.y + ry + (transform.ty ?? 0) 
    };
}

function applyTransformToPathsNonDestructive(app, layerContainer, transform, pivotScreen) {
    const pivotWorld = screenToWorld(app, pivotScreen.x, pivotScreen.y);
    
    if (!layerContainer.layerData || !layerContainer.layerData.paths) {
        console.warn('Layer has no path data');
        return;
    }
    
    for (const path of layerContainer.layerData.paths) {
        if (!path.points) continue;
        
        for (let i = 0; i < path.points.length; i++) {
            const localPt = path.points[i];
            const worldPt = layerContainer.toGlobal(new PIXI.Point(localPt.x, localPt.y));
            const newWorld = transformPointAroundPivot_world(worldPt, pivotWorld, transform);
            const newLocal = layerContainer.toLocal(new PIXI.Point(newWorld.x, newWorld.y));
            path.points[i].x = newLocal.x;
            path.points[i].y = newLocal.y;
        }
        
        rebuildPathGraphicsFromPoints(layerContainer, path);
    }
    
    layerContainer.position.set(0, 0);
    layerContainer.rotation = 0;
    layerContainer.scale.set(1, 1);
    layerContainer.pivot.set(0, 0);
}

function rebuildPathGraphicsFromPoints(layerContainer, path) {
    if (path.graphics) {
        path.graphics.destroy();
    }
    
    path.graphics = new PIXI.Graphics();
    
    if (path.points && path.points.length > 0) {
        for (let point of path.points) {
            if (typeof point.x === 'number' && typeof point.y === 'number') {
                path.graphics.circle(point.x, point.y, (path.size || 16) / 2);
                path.graphics.fill({ 
                    color: path.color || 0x800000, 
                    alpha: path.opacity || 1.0 
                });
            }
        }
    }
    
    if (path.graphics.parent) {
        path.graphics.parent.removeChild(path.graphics);
    }
    layerContainer.addChild(path.graphics);
}

// ===============================
//  Improved confirmLayerTransform (ÈùûÁ†¥Â£äÁâà)
// ===============================
function confirmLayerTransformNonDestructive(app, activeLayer, transform, pivotMode = "camera") {
    if (!activeLayer) return;
    
    console.log('=== Non-destructive Transform Confirmation ===');
    
    const screenCenter = {
        x: app.renderer.screen.width / 2,
        y: app.renderer.screen.height / 2
    };
    
    const canvasCenter = {
        x: CONFIG.canvas.width / 2,
        y: CONFIG.canvas.height / 2
    };
    
    const pivotScreen = (pivotMode === "camera") ? screenCenter : canvasCenter;
    
    if (isTransformSignificant(transform)) {
        console.log('Applying significant transform:', transform);
        applyTransformToPathsNonDestructive(app, activeLayer, transform, pivotScreen);
        console.log('Non-destructive transform applied to paths');
    } else {
        console.log('Transform not significant, skipping');
    }
}

function isTransformSignificant(transform) {
    const threshold = 0.001;
    return (Math.abs(transform.tx || 0) > threshold ||
            Math.abs(transform.ty || 0) > threshold ||
            Math.abs((transform.rotationDeg || 0)) > threshold ||
            Math.abs((transform.scaleX || 1) - 1) > threshold ||
            Math.abs((transform.scaleY || 1) - 1) > threshold ||
            Math.abs((transform.scale || 1) - 1) > threshold);
}

// ===============================
//  Improved Clipboard System (ÈùûÁ†¥Â£äÁâà)
// ===============================
function generateNewId(prefix = "id") {
    return prefix + "_" + Math.random().toString(36).substr(2, 9);
}

function deepCloneLayerData(layer) {
    if (!layer || !layer.layerData) return null;
    
    const clone = JSON.parse(JSON.stringify(layer.layerData));
    clone.id = generateNewId("layer");
    
    if (clone.paths) {
        clone.paths = clone.paths.map(p => ({
            ...p,
            id: generateNewId("path"),
            points: p.points ? p.points.map(pt => ({ x: pt.x, y: pt.y })) : []
        }));
    }
    
    return clone;
}

let _TegakiClipboard = null;

function copyActiveLayerToClipboard(activeLayer) {
    if (!activeLayer || !activeLayer.layerData) {
        console.warn('No active layer to copy');
        return;
    }
    
    console.log('Non-destructive copy started');
    
    const clonedData = deepCloneLayerData(activeLayer);
    if (!clonedData) {
        console.error('Failed to clone layer data');
        return;
    }
    
    _TegakiClipboard = {
        layerData: clonedData,
        copiedAt: Date.now(),
        metadata: {
            originalId: activeLayer.layerData.id,
            pathCount: clonedData.paths ? clonedData.paths.length : 0,
            isNonDestructive: true
        }
    };
    
    console.log(`Non-destructive copy completed: ${_TegakiClipboard.metadata.pathCount} paths preserved`);
}

function pasteClipboardAsLayer(app, layerManager) {
    if (!_TegakiClipboard) {
        console.warn('No clipboard data to paste');
        return;
    }
    
    if (!layerManager || typeof layerManager.createLayer !== 'function') {
        console.error('LayerManager not available or invalid');
        return;
    }
    
    try {
        console.log('Non-destructive paste started');
        
        const clipData = _TegakiClipboard;
        const layerName = generateUniqueLayerName(clipData.layerData.name + '_copy', layerManager);
        
        const { layer, index } = layerManager.createLayer(layerName, false);
        
        if (clipData.layerData.paths && clipData.layerData.paths.length > 0) {
            clipData.layerData.paths.forEach(pathData => {
                if (pathData.points && pathData.points.length > 0) {
                    const newPath = {
                        id: pathData.id,
                        points: [...pathData.points],
                        color: pathData.color || 0x800000,
                        size: pathData.size || 16,
                        opacity: pathData.opacity || 1.0,
                        isComplete: true,
                        graphics: null
                    };
                    
                    rebuildPathGraphicsFromPoints(layer, newPath);
                    layer.layerData.paths.push(newPath);
                }
            });
        }
        
        layer.layerData.visible = clipData.layerData.visible !== false;
        layer.layerData.opacity = clipData.layerData.opacity || 1.0;
        layer.visible = layer.layerData.visible;
        layer.alpha = layer.layerData.opacity;
        
        layerManager.setActiveLayer(index);
        layerManager.updateLayerPanelUI();
        layerManager.updateStatusDisplay();
        layerManager.requestThumbnailUpdate(index);
        
        console.log(`Non-destructive paste completed: ${clipData.metadata.pathCount} paths restored`);
        
    } catch (error) {
        console.error('Failed to paste layer non-destructively:', error);
    }
}

function generateUniqueLayerName(baseName, layerManager) {
    let name = baseName;
    let counter = 1;
    
    while (layerManager.layers && layerManager.layers.some(layer => layer.layerData.name === name)) {
        name = `${baseName}_${counter}`;
        counter++;
    }
    
    return name;
}

// ===============================
//  Core Engine Classes
// ===============================

class CameraSystem {
    constructor(app) {
        this.app = app;
        this.isDragging = false;
        this.isScaleRotateDragging = false;
        this.lastPoint = { x: 0, y: 0 };
        this.panSpeed = CONFIG.camera.dragMoveSpeed;
        this.zoomSpeed = CONFIG.camera.wheelZoomSpeed;
        this.rotation = 0;
        
        this.initialState = {
            position: null,
            scale: CONFIG.camera.initialScale,
            rotation: 0
        };
        
        this.worldContainer = new PIXI.Container();
        this.worldContainer.label = 'worldContainer';
        app.stage.addChild(this.worldContainer);
        
        this.canvasContainer = new PIXI.Container();
        this.canvasContainer.label = 'canvasContainer';
        this.worldContainer.addChild(this.canvasContainer);
        
        this.cameraFrame = new PIXI.Graphics();
        this.cameraFrame.label = 'cameraFrame';
        this.worldContainer.addChild(this.cameraFrame);
        
        this.guideLines = new PIXI.Container();
        this.guideLines.label = 'guideLines';
        this.worldContainer.addChild(this.guideLines);
        this.createGuideLines();
        
        this.canvasMask = new PIXI.Graphics();
        this.canvasMask.rect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
        this.canvasMask.fill(0xffffff);
        this.worldContainer.addChild(this.canvasMask);
        this.canvasContainer.mask = this.canvasMask;
        
        this.spacePressed = false;
        this.shiftPressed = false;
        this.vKeyPressed = false;
        
        this.layerManager = null;
        this.drawingEngine = null;
        
        this.setupEvents();
        this.initializeCamera();
        this.drawCameraFrame();
    }
    
    createGuideLines() {
        this.guideLines.removeChildren();
        
        const centerX = CONFIG.canvas.width / 2;
        const centerY = CONFIG.canvas.height / 2;
        
        const verticalLine = new PIXI.Graphics();
        verticalLine.rect(centerX - 0.5, 0, 1, CONFIG.canvas.height);
        verticalLine.fill({ color: 0x800000, alpha: 0.8 });
        this.guideLines.addChild(verticalLine);
        
        const horizontalLine = new PIXI.Graphics();
        horizontalLine.rect(0, centerY - 0.5, CONFIG.canvas.width, 1);
        horizontalLine.fill({ color: 0x800000, alpha: 0.8 });
        this.guideLines.addChild(horizontalLine);
        
        this.guideLines.visible = false;
    }
    
    initializeCamera() {
        const centerX = this.app.screen.width / 2;
        const centerY = this.app.screen.height / 2;
        
        this.canvasContainer.position.set(0, 0);
        
        const initialX = centerX - CONFIG.canvas.width / 2;
        const initialY = centerY - CONFIG.canvas.height / 2;
        this.worldContainer.position.set(initialX, initialY);
        this.worldContainer.scale.set(CONFIG.camera.initialScale);
        
        this.initialState.position = { x: initialX, y: initialY };
    }
    
    setupEvents() {
        this.app.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        this.app.canvas.addEventListener('pointerdown', (e) => {
            if (this.vKeyPressed) return;
            
            if ((e.button === 2 || this.spacePressed) && !this.shiftPressed) {
                this.isDragging = true;
                this.lastPoint = { x: e.clientX, y: e.clientY };
                this.app.canvas.style.cursor = 'move';
                e.preventDefault();
            } else if ((e.button === 2 || this.spacePressed) && this.shiftPressed) {
                this.isScaleRotateDragging = true;
                this.lastPoint = { x: e.clientX, y: e.clientY };
                this.app.canvas.style.cursor = 'grab';
                e.preventDefault();
            }
        });
        
        this.app.canvas.addEventListener('pointermove', (e) => {
            if (this.isDragging) {
                const dx = (e.clientX - this.lastPoint.x) * this.panSpeed;
                const dy = (e.clientY - this.lastPoint.y) * this.panSpeed;
                
                this.worldContainer.x += dx;
                this.worldContainer.y += dy;
                
                this.lastPoint = { x: e.clientX, y: e.clientY };
                this.updateTransformDisplay();
            } else if (this.isScaleRotateDragging) {
                const dx = e.clientX - this.lastPoint.x;
                const dy = e.clientY - this.lastPoint.y;
                
                const centerX = CONFIG.canvas.width / 2;
                const centerY = CONFIG.canvas.height / 2;
                const worldCenter = this.worldContainer.toGlobal({ x: centerX, y: centerY });
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.rotation += (dx * CONFIG.camera.dragRotationSpeed);
                    this.worldContainer.rotation = (this.rotation * Math.PI) / 180;
                    
                    const newWorldCenter = this.worldContainer.toGlobal({ x: centerX, y: centerY });
                    this.worldContainer.x += worldCenter.x - newWorldCenter.x;
                    this.worldContainer.y += worldCenter.y - newWorldCenter.y;
                } else {
                    const scaleFactor = 1 + (dy * CONFIG.camera.dragScaleSpeed);
                    const newScale = this.worldContainer.scale.x * scaleFactor;
                    
                    if (newScale >= CONFIG.camera.minScale && newScale <= CONFIG.camera.maxScale) {
                        this.worldContainer.scale.set(newScale);
                        const newWorldCenter = this.worldContainer.toGlobal({ x: centerX, y: centerY });
                        this.worldContainer.x += worldCenter.x - newWorldCenter.x;
                        this.worldContainer.y += worldCenter.y - newWorldCenter.y;
                    }
                }
                
                this.lastPoint = { x: e.clientX, y: e.clientY };
                this.updateTransformDisplay();
            }
            
            this.updateCoordinates(e.clientX, e.clientY);
        });
        
        this.app.canvas.addEventListener('pointerup', (e) => {
            if (this.isDragging) {
                this.isDragging = false;
                this.updateCursor();
            }
            if (this.isScaleRotateDragging) {
                this.isScaleRotateDragging = false;
                this.updateCursor();
            }
            
            if (e.button !== 0) return;
            if (this.drawingEngine) {
                this.drawingEngine.stopDrawing();
            }
        });
        
        this.app.canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            if (this.vKeyPressed) return;
            
            const centerX = CONFIG.canvas.width / 2;
            const centerY = CONFIG.canvas.height / 2;
            
            if (this.shiftPressed) {
                const rotationDelta = e.deltaY < 0 ? 
                    CONFIG.camera.keyRotationDegree : -CONFIG.camera.keyRotationDegree;
                
                const worldCenter = this.worldContainer.toGlobal({ x: centerX, y: centerY });
                
                this.rotation += rotationDelta;
                this.worldContainer.rotation = (this.rotation * Math.PI) / 180;
                
                const newWorldCenter = this.worldContainer.toGlobal({ x: centerX, y: centerY });
                this.worldContainer.x += worldCenter.x - newWorldCenter.x;
                this.worldContainer.y += worldCenter.y - newWorldCenter.y;
            } else {
                const scaleFactor = e.deltaY < 0 ? 1 + this.zoomSpeed : 1 - this.zoomSpeed;
                const newScale = this.worldContainer.scale.x * scaleFactor;
                
                if (newScale >= CONFIG.camera.minScale && newScale <= CONFIG.camera.maxScale) {
                    const worldCenter = this.worldContainer.toGlobal({ x: centerX, y: centerY });
                    
                    this.worldContainer.scale.set(newScale);
                    
                    const newWorldCenter = this.worldContainer.toGlobal({ x: centerX, y: centerY });
                    this.worldContainer.x += worldCenter.x - newWorldCenter.x;
                    this.worldContainer.y += worldCenter.y - newWorldCenter.y;
                }
            }
            
            this.updateTransformDisplay();
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.code === 'Digit0') {
                this.resetCanvas();
                e.preventDefault();
                return;
            }
            
            if (e.code === 'Space') {
                this.spacePressed = true;
                this.updateCursor();
                e.preventDefault();
            }
            if (e.shiftKey) this.shiftPressed = true;
            
            if (this.vKeyPressed) return;
            
            if (this.spacePressed && !this.shiftPressed && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                const moveAmount = CONFIG.camera.keyMoveAmount;
                switch(e.code) {
                    case 'ArrowDown': this.worldContainer.y += moveAmount; break;
                    case 'ArrowUp': this.worldContainer.y -= moveAmount; break;
                    case 'ArrowRight': this.worldContainer.x += moveAmount; break;
                    case 'ArrowLeft': this.worldContainer.x -= moveAmount; break;
                }
                this.updateTransformDisplay();
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                this.spacePressed = false;
                this.updateCursor();
            }
            if (!e.shiftKey) this.shiftPressed = false;
        });
    }
    
    resetCanvas() {
        this.worldContainer.position.set(
            this.initialState.position.x,
            this.initialState.position.y
        );
        this.worldContainer.scale.set(this.initialState.scale);
        this.worldContainer.rotation = 0;
        this.rotation = 0;
        this.updateTransformDisplay();
    }
    
    setVKeyPressed(pressed) {
        this.vKeyPressed = pressed;
        this.updateCursor();
    }
    
    showGuideLines() {
        this.guideLines.visible = true;
    }
    
    hideGuideLines() {
        this.guideLines.visible = false;
    }
    
    updateCursor() {
        if (this.vKeyPressed) {
            this.app.canvas.style.cursor = 'grab';
        } else if (this.isDragging || (this.spacePressed && !this.shiftPressed)) {
            this.app.canvas.style.cursor = 'move';
        } else if (this.isScaleRotateDragging || (this.spacePressed && this.shiftPressed)) {
            this.app.canvas.style.cursor = 'grab';
        } else {
            const tool = this.drawingEngine ? this.drawingEngine.currentTool : 'pen';
            this.app.canvas.style.cursor = tool === 'eraser' ? 'cell' : 'crosshair';
        }
    }
    
    screenToCanvasForDrawing(screenX, screenY) {
        const globalPoint = { x: screenX, y: screenY };
        return this.canvasContainer.toLocal(globalPoint);
    }
    
    updateCoordinates(screenX, screenY) {
        const canvasPoint = this.screenToCanvasForDrawing(screenX, screenY);
        const element = document.getElementById('coordinates');
        if (element) {
            element.textContent = `x: ${Math.round(canvasPoint.x)}, y: ${Math.round(canvasPoint.y)}`;
        }
    }
    
    updateTransformDisplay() {
        const element = document.getElementById('transform-info');
        if (element) {
            const x = Math.round(this.worldContainer.x);
            const y = Math.round(this.worldContainer.y);
            const s = Math.abs(this.worldContainer.scale.x).toFixed(2);
            const r = Math.round(this.rotation % 360);
            element.textContent = `x:${x} y:${y} s:${s} r:${r}¬∞`;
        }
    }
    
    drawCameraFrame() {
        this.cameraFrame.clear();
        this.cameraFrame.rect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
        this.cameraFrame.stroke({ width: 2, color: 0xff0000, alpha: 0.5 });
    }
    
    setLayerManager(layerManager) {
        this.layerManager = layerManager;
    }
    
    setDrawingEngine(drawingEngine) {
        this.drawingEngine = drawingEngine;
    }
}

class LayerManager {
    constructor(canvasContainer, app, cameraSystem) {
        this.canvasContainer = canvasContainer;
        this.app = app;
        this.cameraSystem = cameraSystem;
        this.layers = [];
        this.activeLayerIndex = -1;
        this.layerCounter = 0;
        this.thumbnailUpdateQueue = new Set();
        
        this.layersContainer = new PIXI.Container();
        this.layersContainer.label = 'layersContainer';
        this.canvasContainer.addChild(this.layersContainer);
        
        this.vKeyPressed = false;
        this.isLayerMoveMode = false;
        this.isLayerDragging = false;
        this.layerDragLastPoint = { x: 0, y: 0 };
        
        this.layerTransforms = new Map();
        this.layerTransformPanel = null;
        
        this.setupLayerOperations();
        this.setupLayerTransformPanel();
    }
    
    getCanvasCenter() {
        return {
            x: CONFIG.canvas.width / 2,
            y: CONFIG.canvas.height / 2
        };
    }
    
    enterLayerMoveModeSafe() {
        if (this.isLayerMoveMode) return;
        
        const activeLayer = this.getActiveLayer();
        if (!activeLayer) return;
        
        console.log('=== Safe Layer Move Mode Entry ===');
        
        this.isLayerMoveMode = true;
        this.vKeyPressed = true;
        this.cameraSystem.setVKeyPressed(true);
        
        if (this.layerTransformPanel) {
            this.layerTransformPanel.classList.add('show');
            this.updateLayerTransformPanelValues();
        }
        this.cameraSystem.showGuideLines();
        this.updateCursor();
        this.updateModeDisplay('Layer Transform');
        
        console.log('=== Safe Entry Completed ===');
    }
    
    exitLayerMoveMode() {
        if (!this.isLayerMoveMode) return;
        
        this.isLayerMoveMode = false;
        this.vKeyPressed = false;
        this.isLayerDragging = false;
        this.cameraSystem.setVKeyPressed(false);
        
        if (this.layerTransformPanel) {
            this.layerTransformPanel.classList.remove('show');
        }
        
        this.cameraSystem.hideGuideLines();
        this.updateCursor();
        this.updateModeDisplay('Drawing');
        
        this.confirmLayerTransform();
    }
    
    toggleLayerMoveMode() {
        if (this.isLayerMoveMode) {
            this.exitLayerMoveMode();
        } else {
            this.enterLayerMoveModeSafe();
        }
    }
    
    confirmLayerTransform() {
        const activeLayer = this.getActiveLayer();
        if (!activeLayer) return;
        
        const transform = {
            tx: activeLayer.position.x - this.getCanvasCenter().x,
            ty: activeLayer.position.y - this.getCanvasCenter().y,
            rotationDeg: activeLayer.rotation * 180 / Math.PI,
            scaleX: activeLayer.scale.x,
            scaleY: activeLayer.scale.y
        };
        
        if (isTransformSignificant(transform)) {
            console.log('Confirming layer transform with non-destructive method');
            confirmLayerTransformNonDestructive(this.app, activeLayer, transform, "camera");
        }
    }
    
    setupLayerTransformPanel() {
        this.layerTransformPanel = document.getElementById('layer-transform-panel');
        
        if (!this.layerTransformPanel) return;
        
        this.setupLayerSlider('layer-x-slider', CONFIG.layer.minX, CONFIG.layer.maxX, 0, (value) => {
            this.updateActiveLayerTransform('x', value);
            return Math.round(value) + 'px';
        });
        
        this.setupLayerSlider('layer-y-slider', CONFIG.layer.minY, CONFIG.layer.maxY, 0, (value) => {
            this.updateActiveLayerTransform('y', value);
            return Math.round(value) + 'px';
        });
        
        this.setupLayerSlider('layer-rotation-slider', CONFIG.layer.minRotation, CONFIG.layer.maxRotation, 0, (value) => {
            this.updateActiveLayerTransform('rotation', value * Math.PI / 180);
            return Math.round(value) + '¬∞';
        });
        
        this.setupLayerSlider('layer-scale-slider', CONFIG.layer.minScale, CONFIG.layer.maxScale, 1.0, (value) => {
            this.updateActiveLayerTransform('scale', value);
            return value.toFixed(2) + 'x';
        });
        
        const flipHorizontalBtn = document.getElementById('flip-horizontal-btn');
        const flipVerticalBtn = document.getElementById('flip-vertical-btn');
        
        if (flipHorizontalBtn) {
            flipHorizontalBtn.addEventListener('click', () => {
                this.flipActiveLayer('horizontal');
            });
        }
        
        if (flipVerticalBtn) {
            flipVerticalBtn.addEventListener('click', () => {
                this.flipActiveLayer('vertical');
            });
        }
    }
    
    setupLayerSlider(sliderId, min, max, initial, callback) {
        const container = document.getElementById(sliderId);
        if (!container) return;

        const track = container.querySelector('.slider-track');
        const handle = container.querySelector('.slider-handle');
        const valueDisplay = container.parentNode.querySelector('.slider-value');

        if (!track || !handle || !valueDisplay) return;

        let value = initial;
        let dragging = false;

        const update = (newValue, fromSlider = false) => {
            value = Math.max(min, Math.min(max, newValue));
            const percentage = ((value - min) / (max - min)) * 100;
            
            track.style.width = percentage + '%';
            handle.style.left = percentage + '%';
            valueDisplay.textContent = callback(value, fromSlider);
        };

        const getValue = (clientX) => {
            const rect = container.getBoundingClientRect();
            const percentage = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
            return min + (percentage * (max - min));
        };

        container.addEventListener('mousedown', (e) => {
            dragging = true;
            update(getValue(e.clientX), true);
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (dragging) update(getValue(e.clientX), true);
        });

        document.addEventListener('mouseup', () => {
            dragging = false;
        });

        container.updateValue = (newValue) => {
            update(newValue, false);
        };

        update(initial);
    }
    
    updateActiveLayerTransform(property, value) {
        const activeLayer = this.getActiveLayer();
        if (!activeLayer) return;
        
        const center = this.getCanvasCenter();
        
        switch(property) {
            case 'x':
                activeLayer.position.x = center.x + value;
                break;
            case 'y':
                activeLayer.position.y = center.y + value;
                break;
            case 'rotation':
                activeLayer.rotation = value;
                break;
            case 'scale':
                const hFlipped = activeLayer.scale.x < 0;
                const vFlipped = activeLayer.scale.y < 0;
                activeLayer.scale.x = hFlipped ? -value : value;
                activeLayer.scale.y = vFlipped ? -value : value;
                break;
        }
        
        this.requestThumbnailUpdate(this.activeLayerIndex);
    }
    
    flipActiveLayer(direction) {
        const activeLayer = this.getActiveLayer();
        if (!activeLayer) return;
        
        if (direction === 'horizontal') {
            activeLayer.scale.x *= -1;
        } else if (direction === 'vertical') {
            activeLayer.scale.y *= -1;
        }
        
        this.updateFlipButtons();
        this.requestThumbnailUpdate(this.activeLayerIndex);
    }
    
    updateFlipButtons() {
        const activeLayer = this.getActiveLayer();
        if (!activeLayer) return;
        
        const flipHorizontalBtn = document.getElementById('flip-horizontal-btn');
        const flipVerticalBtn = document.getElementById('flip-vertical-btn');
        
        if (flipHorizontalBtn) {
            if (activeLayer.scale.x < 0) {
                flipHorizontalBtn.classList.add('active');
            } else {
                flipHorizontalBtn.classList.remove('active');
            }
        }
        
        if (flipVerticalBtn) {
            if (activeLayer.scale.y < 0) {
                flipVerticalBtn.classList.add('active');
            } else {
                flipVerticalBtn.classList.remove('active');
            }
        }
    }
    
    updateLayerTransformPanelValues() {
        const activeLayer = this.getActiveLayer();
        if (!activeLayer) return;
        
        const center = this.getCanvasCenter();
        const xOffset = activeLayer.position.x - center.x;
        const yOffset = activeLayer.position.y - center.y;
        
        const xSlider = document.getElementById('layer-x-slider');
        if (xSlider && xSlider.updateValue) {
            xSlider.updateValue(xOffset);
        }
        
        const ySlider = document.getElementById('layer-y-slider');
        if (ySlider && ySlider.updateValue) {
            ySlider.updateValue(yOffset);
        }
        
        const rotationSlider = document.getElementById('layer-rotation-slider');
        if (rotationSlider && rotationSlider.updateValue) {
            rotationSlider.updateValue(activeLayer.rotation * 180 / Math.PI);
        }
        
        const scaleSlider = document.getElementById('layer-scale-slider');
        if (scaleSlider && scaleSlider.updateValue) {
            scaleSlider.updateValue(Math.abs(activeLayer.scale.x));
        }
        
        this.updateFlipButtons();
    }
    
    setupLayerOperations() {
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyV' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                this.toggleLayerMoveMode();
                e.preventDefault();
            }
            
            if (e.code === 'KeyP' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                if (this.isLayerMoveMode) {
                    this.exitLayerMoveMode();
                }
                e.preventDefault();
            }
            
            if (e.code === 'KeyE' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                if (this.isLayerMoveMode) {
                    this.exitLayerMoveMode();
                }
                e.preventDefault();
            }
            
            // Copy/Paste
            if (e.ctrlKey && e.code === 'KeyC' && !e.altKey && !e.metaKey) {
                copyActiveLayerToClipboard(this.getActiveLayer());
                e.preventDefault();
            }
            
            if (e.ctrlKey && e.code === 'KeyV' && !e.altKey && !e.metaKey) {
                pasteClipboardAsLayer(this.app, this);
                e.preventDefault();
            }
        });
        
        this.app.canvas.addEventListener('pointerdown', (e) => {
            if (this.vKeyPressed && e.button === 0) {
                this.isLayerDragging = true;
                this.layerDragLastPoint = { x: e.clientX, y: e.clientY };
                this.app.canvas.style.cursor = 'move';
                e.preventDefault();
            }
        });
        
        this.app.canvas.addEventListener('pointermove', (e) => {
            if (this.isLayerDragging && this.vKeyPressed) {
                const activeLayer = this.getActiveLayer();
                if (activeLayer) {
                    const dx = e.clientX - this.layerDragLastPoint.x;
                    const dy = e.clientY - this.layerDragLastPoint.y;
                    
                    const worldScale = this.cameraSystem.worldContainer.scale.x;
                    const adjustedDx = dx / worldScale;
                    const adjustedDy = dy / worldScale;
                    
                    activeLayer.position.x += adjustedDx;
                    activeLayer.position.y += adjustedDy;
                    
                    this.layerDragLastPoint = { x: e.clientX, y: e.clientY };
                    this.updateLayerTransformPanelValues();
                    this.requestThumbnailUpdate(this.activeLayerIndex);
                }
            }
        });
        
        this.app.canvas.addEventListener('pointerup', (e) => {
            if (this.isLayerDragging) {
                this.isLayerDragging = false;
                this.updateCursor();
            }
        });
    }
    
    updateCursor() {
        if (this.vKeyPressed) {
            this.app.canvas.style.cursor = 'grab';
        }
    }
    
    createLayer(name, isBackground = false) {
        const layer = new PIXI.Container();
        const layerId = `layer_${this.layerCounter++}`;
        
        layer.label = layerId;
        layer.layerData = {
            id: layerId,
            name: name,
            visible: true,
            opacity: 1.0,
            isBackground: isBackground,
            paths: []
        };

        this.layerTransforms.set(layerId, {
            x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1
        });

        if (isBackground) {
            const bg = new PIXI.Graphics();
            bg.rect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
            bg.fill(CONFIG.background.color);
            layer.addChild(bg);
            layer.layerData.backgroundGraphics = bg;
        }

        this.layers.push(layer);
        this.layersContainer.addChild(layer);
        return { layer, index: this.layers.length - 1 };
    }

    setActiveLayer(index) {
        if (index >= 0 && index < this.layers.length) {
            this.activeLayerIndex = index;
            this.updateLayerPanelUI();
            this.updateStatusDisplay();
            
            if (this.isLayerMoveMode) {
                this.updateLayerTransformPanelValues();
            }
        }
    }

    getActiveLayer() {
        return this.activeLayerIndex >= 0 ? this.layers[this.activeLayerIndex] : null;
    }

    addPathToLayer(layerIndex, path) {
        if (layerIndex >= 0 && layerIndex < this.layers.length) {
            const layer = this.layers[layerIndex];
            layer.layerData.paths.push(path);
            layer.addChild(path.graphics);
            this.requestThumbnailUpdate(layerIndex);
        }
    }

    requestThumbnailUpdate(layerIndex) {
        this.thumbnailUpdateQueue.add(layerIndex);
    }

    processThumbnailUpdates() {
        if (!this.app?.renderer || this.thumbnailUpdateQueue.size === 0) return;

        this.thumbnailUpdateQueue.forEach(layerIndex => {
            this.updateThumbnail(layerIndex);
        });
        this.thumbnailUpdateQueue.clear();
    }

    updateThumbnail(layerIndex) {
        if (!this.app?.renderer || layerIndex < 0 || layerIndex >= this.layers.length) return;

        const layer = this.layers[layerIndex];
        const layerItems = document.querySelectorAll('.layer-item');
        const panelIndex = this.layers.length - 1 - layerIndex;
        
        if (panelIndex < 0 || panelIndex >= layerItems.length) return;
        
        const thumbnail = layerItems[panelIndex].querySelector('.layer-thumbnail');
        if (!thumbnail) return;

        try {
            const thumbnailSize = 48;
            
            const renderTexture = PIXI.RenderTexture.create({
                width: CONFIG.canvas.width,
                height: CONFIG.canvas.height,
                resolution: 1
            });
            
            const tempContainer = new PIXI.Container();
            
            const originalPos = { x: layer.position.x, y: layer.position.y };
            const originalScale = { x: layer.scale.x, y: layer.scale.y };
            const originalRotation = layer.rotation;
            const originalPivot = { x: layer.pivot.x, y: layer.pivot.y };
            
            layer.position.set(0, 0);
            layer.scale.set(1, 1);
            layer.rotation = 0;
            layer.pivot.set(0, 0);
            
            tempContainer.addChild(layer);
            
            this.app.renderer.render(tempContainer, { renderTexture });
            
            layer.position.set(originalPos.x, originalPos.y);
            layer.scale.set(originalScale.x, originalScale.y);
            layer.rotation = originalRotation;
            layer.pivot.set(originalPivot.x, originalPivot.y);
            
            tempContainer.removeChild(layer);
            this.layersContainer.addChildAt(layer, layerIndex);
            
            const sourceCanvas = this.app.renderer.extract.canvas(renderTexture);
            const targetCanvas = document.createElement('canvas');
            targetCanvas.width = thumbnailSize;
            targetCanvas.height = thumbnailSize;
            
            const ctx = targetCanvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(sourceCanvas, 0, 0, thumbnailSize, thumbnailSize);
            
            let img = thumbnail.querySelector('img');
            if (!img) {
                img = document.createElement('img');
                thumbnail.innerHTML = '';
                thumbnail.appendChild(img);
            }
            img.src = targetCanvas.toDataURL();
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            
            renderTexture.destroy();
            tempContainer.destroy();
            
        } catch (error) {
            console.warn('Thumbnail update failed:', error);
        }
    }

    updateLayerPanelUI() {
        const layerList = document.getElementById('layer-list');
        if (!layerList) return;

        layerList.innerHTML = '';

        for (let i = this.layers.length - 1; i >= 0; i--) {
            const layer = this.layers[i];
            const layerItem = document.createElement('div');
            layerItem.className = `layer-item ${i === this.activeLayerIndex ? 'active' : ''}`;
            layerItem.dataset.layerId = layer.layerData.id;
            layerItem.dataset.layerIndex = i;

            layerItem.innerHTML = `
                <div class="layer-visibility ${layer.layerData.visible ? '' : 'hidden'}">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        ${layer.layerData.visible ? 
                            '<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>' :
                            '<path d="m15 18-.722-3.25"/><path d="m2 2 20 20"/><path d="M6.71 6.71C3.4 8.27 2 12 2 12s3 7 10 7c1.59 0 2.84-.3 3.79-.73"/><path d="m8.5 10.5 7 7"/><path d="M9.677 4.677C10.495 4.06 11.608 4 12 4c7 0 10 7 10 7a13.16 13.16 0 0 1-.64.77"/>'}
                    </svg>
                </div>
                <div class="layer-opacity">100%</div>
                <div class="layer-name">${layer.layerData.name}</div>
                <div class="layer-thumbnail">
                    <div class="layer-thumbnail-placeholder"></div>
                </div>
                <div class="layer-delete-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m18 6-12 12"/><path d="m6 6 12 12"/>
                    </svg>
                </div>
            `;

            layerItem.addEventListener('click', (e) => {
                const target = e.target.closest('[class*="layer-"]');
                if (target) {
                    const action = target.className;
                    if (action.includes('layer-visibility')) {
                        this.toggleLayerVisibility(i);
                        e.stopPropagation();
                    } else if (action.includes('layer-delete')) {
                        this.deleteLayer(i);
                        e.stopPropagation();
                    } else {
                        this.setActiveLayer(i);
                    }
                } else {
                    this.setActiveLayer(i);
                }
            });

            layerList.appendChild(layerItem);
        }
        
        for (let i = 0; i < this.layers.length; i++) {
            this.requestThumbnailUpdate(i);
        }
    }

    toggleLayerVisibility(layerIndex) {
        if (layerIndex >= 0 && layerIndex < this.layers.length) {
            const layer = this.layers[layerIndex];
            layer.layerData.visible = !layer.layerData.visible;
            layer.visible = layer.layerData.visible;
            this.updateLayerPanelUI();
        }
    }

    deleteLayer(layerIndex) {
        if (this.layers.length <= 1) return;
        if (layerIndex < 0 || layerIndex >= this.layers.length) return;

        const layer = this.layers[layerIndex];
        const layerId = layer.layerData.id;
        
        layer.layerData.paths.forEach(path => {
            if (path.graphics && path.graphics.destroy) {
                path.graphics.destroy();
            }
        });

        this.layerTransforms.delete(layerId);

        this.layersContainer.removeChild(layer);
        layer.destroy();
        this.layers.splice(layerIndex, 1);

        if (this.activeLayerIndex === layerIndex) {
            this.activeLayerIndex = Math.min(this.activeLayerIndex, this.layers.length - 1);
        } else if (this.activeLayerIndex > layerIndex) {
            this.activeLayerIndex--;
        }

        this.updateLayerPanelUI();
        this.updateStatusDisplay();
    }

    updateStatusDisplay() {
        const statusElement = document.getElementById('current-layer');
        if (statusElement && this.activeLayerIndex >= 0) {
            const layer = this.layers[this.activeLayerIndex];
            statusElement.textContent = layer.layerData.name;
        }
    }
    
    updateModeDisplay(mode) {
        const element = document.getElementById('mode-info');
        if (element) {
            element.textContent = mode;
        }
    }
}

class DrawingEngine {
    constructor(cameraSystem, layerManager) {
        this.cameraSystem = cameraSystem;
        this.layerManager = layerManager;
        this.currentTool = 'pen';
        this.brushSize = CONFIG.pen.size;
        this.brushColor = CONFIG.pen.color;
        this.brushOpacity = CONFIG.pen.opacity;
        this.isDrawing = false;
        this.currentPath = null;
        this.lastPoint = null;
    }

    startDrawing(screenX, screenY) {
        if (this.isDrawing || this.cameraSystem.spacePressed || this.cameraSystem.isDragging || 
            this.layerManager.vKeyPressed) return;

        const canvasPoint = this.cameraSystem.screenToCanvasForDrawing(screenX, screenY);
        
        if (canvasPoint.x < -50 || canvasPoint.x > CONFIG.canvas.width + 50 ||
            canvasPoint.y < -50 || canvasPoint.y > CONFIG.canvas.height + 50) {
            return;
        }
        
        this.isDrawing = true;
        this.lastPoint = canvasPoint;

        const activeLayer = this.layerManager.getActiveLayer();
        if (!activeLayer) return;

        const color = this.currentTool === 'eraser' ? CONFIG.background.color : this.brushColor;
        const opacity = this.currentTool === 'eraser' ? 1.0 : this.brushOpacity;

        this.currentPath = {
            id: `path_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            graphics: new PIXI.Graphics(),
            points: [{ x: canvasPoint.x, y: canvasPoint.y }],
            color: color,
            size: this.brushSize,
            opacity: opacity,
            isComplete: false
        };

        this.currentPath.graphics.circle(canvasPoint.x, canvasPoint.y, this.brushSize / 2);
        this.currentPath.graphics.fill({ color: color, alpha: opacity });

        this.addPathToActiveLayer(this.currentPath);
    }

    continueDrawing(screenX, screenY) {
        if (!this.isDrawing || !this.currentPath || this.cameraSystem.spacePressed || 
            this.cameraSystem.isDragging || this.layerManager.vKeyPressed) return;

        const canvasPoint = this.cameraSystem.screenToCanvasForDrawing(screenX, screenY);
        const lastPoint = this.lastPoint;
        
        const distance = Math.sqrt(
            Math.pow(canvasPoint.x - lastPoint.x, 2) + 
            Math.pow(canvasPoint.y - lastPoint.y, 2)
        );

        if (distance < 1) return;

        const steps = Math.max(1, Math.floor(distance / 1));
        for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            const x = lastPoint.x + (canvasPoint.x - lastPoint.x) * t;
            const y = lastPoint.y + (canvasPoint.y - lastPoint.y) * t;

            this.currentPath.graphics.circle(x, y, this.brushSize / 2);
            this.currentPath.graphics.fill({ 
                color: this.currentPath.color, 
                alpha: this.currentPath.opacity 
            });

            this.currentPath.points.push({ x, y });
        }

        this.lastPoint = canvasPoint;
    }

    stopDrawing() {
        if (!this.isDrawing) return;

        if (this.currentPath) {
            this.currentPath.isComplete = true;
            this.layerManager.requestThumbnailUpdate(this.layerManager.activeLayerIndex);
        }

        this.isDrawing = false;
        this.currentPath = null;
        this.lastPoint = null;
    }
    
    addPathToActiveLayer(path) {
        const activeLayer = this.layerManager.getActiveLayer();
        if (!activeLayer) return;
        
        activeLayer.layerData.paths.push(path);
        activeLayer.addChild(path.graphics);
    }

    setTool(tool) {
        this.currentTool = tool;
    }

    setBrushSize(size) {
        this.brushSize = Math.max(0.1, Math.min(100, size));
    }

    setBrushOpacity(opacity) {
        this.brushOpacity = Math.max(0, Math.min(1, opacity));
    }
}

class CoreEngine {
    constructor(app) {
        this.app = app;
        
        this.cameraSystem = new CameraSystem(app);
        this.layerManager = new LayerManager(this.cameraSystem.canvasContainer, app, this.cameraSystem);
        this.drawingEngine = new DrawingEngine(this.cameraSystem, this.layerManager);
        
        this.setupCrossReferences();
    }
    
    setupCrossReferences() {
        this.cameraSystem.setLayerManager(this.layerManager);
        this.cameraSystem.setDrawingEngine(this.drawingEngine);
    }
    
    getCameraSystem() {
        return this.cameraSystem;
    }
    
    getLayerManager() {
        return this.layerManager;
    }
    
    getDrawingEngine() {
        return this.drawingEngine;
    }
    
    setupCanvasEvents() {
        this.app.canvas.addEventListener('pointerdown', (e) => {
            if (e.button !== 0) return;

            const rect = this.app.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            this.drawingEngine.startDrawing(x, y);
            e.preventDefault();
        });

        this.app.canvas.addEventListener('pointermove', (e) => {
            const rect = this.app.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            this.drawingEngine.continueDrawing(x, y);
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'p' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                this.switchTool('pen');
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'e' && !e.ctrlKey && !e.altKey && !e.metaKey) {
                this.switchTool('eraser');
                e.preventDefault();
            }
        });
    }
    
    switchTool(tool) {
        this.drawingEngine.setTool(tool);
        
        if (this.layerManager.isLayerMoveMode) {
            this.layerManager.exitLayerMoveMode();
        }
        
        document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
        const toolBtn = document.getElementById(tool + '-tool');
        if (toolBtn) toolBtn.classList.add('active');

        const toolNames = { pen: '„Éô„ÇØ„Çø„Éº„Éö„É≥', eraser: 'Ê∂à„Åó„Ç¥„É†' };
        const toolElement = document.getElementById('current-tool');
        if (toolElement) {
            toolElement.textContent = toolNames[tool] || tool;
        }

        this.cameraSystem.updateCursor();
    }
    
    processThumbnailUpdates() {
        this.layerManager.processThumbnailUpdates();
    }
    
    initialize() {
        this.layerManager.createLayer('ËÉåÊôØ', true);
        this.layerManager.createLayer('„É¨„Ç§„É§„Éº1');
        this.layerManager.setActiveLayer(1);
        
        this.layerManager.updateLayerPanelUI();
        this.layerManager.updateStatusDisplay();
        
        this.setupCanvasEvents();
        this.setupUI();
        
        this.app.ticker.add(() => {
            this.processThumbnailUpdates();
        });
        
        console.log('‚úÖ GPT5Êîπ‰øÆÁâà CoreEngine initialized');
        return this;
    }
    
    setupUI() {
        // Add layer button
        const addLayerBtn = document.getElementById('add-layer-btn');
        if (addLayerBtn) {
            addLayerBtn.addEventListener('click', () => {
                const layerCount = this.layerManager.layers.length;
                const { layer, index } = this.layerManager.createLayer(`„É¨„Ç§„É§„Éº${layerCount}`);
                this.layerManager.setActiveLayer(index);
            });
        }
        
        // Tool buttons
        document.getElementById('pen-tool')?.addEventListener('click', () => {
            this.switchTool('pen');
        });
        
        document.getElementById('eraser-tool')?.addEventListener('click', () => {
            this.switchTool('eraser');
        });
        
        // Update canvas info
        const element = document.getElementById('canvas-info');
        if (element) {
            element.textContent = `${CONFIG.canvas.width}√ó${CONFIG.canvas.height}px`;
        }
    }
}

// ===============================
//  Application Bootstrap
// ===============================

class DrawingApp {
    constructor() {
        this.pixiApp = null;
        this.coreEngine = null;
    }

    async initialize() {
        const containerEl = document.getElementById('drawing-canvas');
        if (!containerEl) {
            throw new Error('Canvas container not found');
        }

        this.pixiApp = new PIXI.Application();
        
        const screenWidth = window.innerWidth - 50;
        const screenHeight = window.innerHeight;
        
        await this.pixiApp.init({
            width: screenWidth,
            height: screenHeight,
            backgroundAlpha: 0,
            resolution: 1,
            antialias: true,
            eventMode: 'static',
            eventFeatures: {
                move: true,
                globalMove: true,
                click: true,
                wheel: true,
            }
        });
        
        containerEl.innerHTML = '';
        containerEl.appendChild(this.pixiApp.canvas);

        this.pixiApp.canvas.style.width = `${screenWidth}px`;
        this.pixiApp.canvas.style.height = `${screenHeight}px`;

        this.coreEngine = new CoreEngine(this.pixiApp);
        this.coreEngine.initialize();
        
        this.setupWindowResize();
        
        return true;
    }
    
    setupWindowResize() {
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth - 50;
            const newHeight = window.innerHeight;
            
            this.pixiApp.renderer.resize(newWidth, newHeight);
            this.pixiApp.canvas.style.width = `${newWidth}px`;
            this.pixiApp.canvas.style.height = `${newHeight}px`;
            
            const cameraSystem = this.coreEngine.getCameraSystem();
            cameraSystem.initializeCamera();
        });
    }
}

window.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('Initializing GPT5Êîπ‰øÆÁâà Drawing App...');
        
        const app = new DrawingApp();
        await app.initialize();
        
        window.drawingApp = app;
        
        console.log('üé® GPT5Êîπ‰øÆÁâà Drawing App initialized successfully!');
        console.log('üîß GPT5Êîπ‰øÆÊ°àÂÆüË£ÖÂÆå‰∫Ü:');
        console.log('  - ‚úÖ ÈùûÁ†¥Â£äÂ§âÂΩ¢: „Ç´„É°„É©‰∏≠ÂøÉÂü∫Ê∫ñ„ÅÆÂõûËª¢„ÉªÊã°Á∏Æ„ÉªÂèçËª¢');
        console.log('  - ‚úÖ ÊîπËâØ„Ç≥„Éî„Éº&„Éö„Éº„Çπ„Éà: „Éë„Çπ„Éá„Éº„ÇøÂÆåÂÖ®‰øùÊåÅ„ÉªÂä£ÂåñÈò≤Ê≠¢');
        console.log('  - ‚úÖ Áµ±‰∏ÄÂ∫ßÊ®ôÁ≥ª: ÁßªÂãïÂæå„ÇÇ‰∏ÄË≤´„Åó„ÅüÂ§âÂΩ¢Âü∫Ê∫ñ');
        console.log('  - ‚úÖ ÂÆâÂÖ®„Å™Á∑®ÈõÜ„É¢„Éº„Éâ: Â∫ßÊ®ôÈ£õ„Å≥Èò≤Ê≠¢„ÉªÁä∂ÊÖã‰øùÊåÅ');
        console.log('  - ‚úÖ „É¨„Ç§„É§„ÉºÂ§âÂΩ¢Á¢∫ÂÆö: „Éë„ÇπÂ∫ßÊ®ô„Å∏„ÅÆÁÑº„Åç‰ªò„ÅëÂá¶ÁêÜ');
        
    } catch (error) {
        console.error('Failed to initialize GPT5Êîπ‰øÆÁâà Drawing App:', error);
    }
});
    </script>
</body>
</html>