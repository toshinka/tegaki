# Tegaki 重要な修正 - エラー解決・描画・ポップアップ問題

---

## 🔴 **現在のエラー・問題の整理**

| 問題 | 原因 | 影響 | 優先度 |
|------|------|------|--------|
| BrushSettings メソッドなし | `setPressureCorrection()` 等未実装 | EventBus エラー | **P1** ✅ 修正済 |
| ポップアップが非表示 | popup-manager.js + show/hide ロジック | UI使用不可 | **P1** |
| 描画できない | core-runtime.js ポインタイベント？ | 描画機能なし | **P1** |
| リサイズ時背景色が透明に | Camera/Layer座標系混在？ | 視覚的問題 | **P2** |
| 操作が重い | DOM再描画多重実行？ | パフォーマンス | **P2** |

---

## ✅ **修正1完了: BrushSettings**

**修正内容:**
- `setPressureCorrection()`, `setSmoothing()`, `setPressureCurve()` 等を追加
- すべてのgetter/setter メソッドを実装
- `getCurrentSettings()` 完全実装

**アーティファクト**: `BrushSettings - ブラシ設定管理クラス（完全版）`

---

## 🔧 **修正2: ポップアップが表示されない問題**

### **原因の特定**

```
popup-manager.js:192 👁️ Popup "quickAccess" shown
popup-manager.js:212 🙈 Popup "quickAccess" hidden
```

→ show() 直後に hide() が呼ばれている

### **原因推測**

1. **popup-manager.js の `hideAll()` が quickAccess も隠している**
   ```javascript
   // 現在の問題コード
   hideAll(exceptName = null) {
     this.popups.forEach((popupData, name) => {
       if (name !== exceptName && popupData.instance) {
         popupData.instance.hide();  // ← exceptName 以外は全て非表示
       }
     });
   }
   ```
   
   show() → hideAll('quickAccess') が呼ばれているはずだが、exceptName が正しく機能していない

2. **quick-access-popup.js の initialize() が呼ばれていない**
   - `.show()` が呼ばれても `.initialize()` が実行されていない
   - DOM が作成されていない可能性

### **修正方法**

#### **Step 1: quick-access-popup.js に initialize() を追加**

```javascript
// ui/quick-access-popup.js に追加

initialize() {
  if (this.initialized) return;
  
  this._ensurePanelExists();
  this._cacheElements();
  this._attachEventListeners();
  
  this.initialized = true;
  console.log('✅ QuickAccessPopup initialized');
}

show() {
  if (!this.initialized) {
    this.initialize();
  }
  
  if (!this.panel) {
    this._ensurePanelExists();
  }
  
  this.panel.classList.add('show');
  this.isVisible = true;
  console.log('👁️ QuickAccessPopup shown');
}

hide() {
  if (this.panel) {
    this.panel.classList.remove('show');
  }
  this.isVisible = false;
  console.log('🙈 QuickAccessPopup hidden');
}

toggle() {
  if (this.isVisible) {
    this.hide();
  } else {
    this.show();
  }
}
```

#### **Step 2: popup-manager.js の hideAll() を修正**

```javascript
// popup-manager.js 修正

show(name) {
  const instance = this.get(name);
  
  if (!instance) {
    console.error(`❌ Cannot show popup "${name}": not ready`);
    return false;
  }
  
  // ✅ 修正: exceptName を明示的に渡す
  this.hideAll(name);  // ← name を除外対象として渡す
  
  instance.show();
  this.activePopup = name;
  
  this.eventBus.emit('popup:show', { name });
  console.log(`👁️ Popup "${name}" shown`);
  
  return true;
}

hideAll(exceptName = null) {
  let hiddenCount = 0;
  
  // インスタンス経由での非表示
  this.popups.forEach((popupData, name) => {
    // ✅ 修正: exceptName の場合はスキップ
    if (name === exceptName) {
      return;
    }
    
    if (popupData.instance && popupData.status === 'ready') {
      if (this.isVisible(name)) {
        popupData.instance.hide();
        hiddenCount++;
      }
    }
  });
  
  if (exceptName !== null) {
    this.activePopup = exceptName;
  } else {
    this.activePopup = null;
  }
  
  if (hiddenCount > 0) {
    this.eventBus.emit('popup:all-hidden', { exceptName, hiddenCount });
  }
}
```

---

## 🎨 **修正3: 描画できない問題**

### **原因推測**

ポインタイベントが drawingEngine に伝播していない

### **確認手順**

```javascript
// Console で実行
console.log('=== Pointer Event Debug ===');
console.log('DrawingEngine:', window.coreEngine?.getDrawingEngine?.());
console.log('DrawingEngine.isDrawing:', window.coreEngine?.getDrawingEngine?.().isDrawing);
console.log('DrawingEngine.currentTool:', window.coreEngine?.getDrawingEngine?.().currentTool);

// ポインタイベントがキャッチされているか確認
const canvas = document.querySelector('canvas');
canvas.addEventListener('pointerdown', (e) => {
  console.log('✅ Canvas pointerdown fired:', e.clientX, e.clientY);
});
```

### **修正内容**

**core-runtime.js の handlePointerDown を確認:**

```javascript
handlePointerDown(event) {
  const currentTool = this.internal.drawingEngine?.currentTool || 'pen';
  const isDrawingTool = currentTool === 'pen' || currentTool === 'eraser';
  
  // ✅ 確認: LayerMoveMode チェック
  if (this.internal.drawingEngine && 
      !this.internal.layerManager?.isLayerMoveMode && 
      isDrawingTool) {
    
    console.log('🖌️ Starting draw:', event.global.x, event.global.y);  // デバッグ追加
    this.internal.drawingEngine.startDrawing(event.global.x, event.global.y, event);
  } else {
    console.log('⚠️ Draw blocked:', {
      hasDrawingEngine: !!this.internal.drawingEngine,
      isLayerMoveMode: this.internal.layerManager?.isLayerMoveMode,
      currentTool,
      isDrawingTool
    });
  }
}
```

---

## 🎨 **修正4: リサイズ時に背景色が透明に**

### **原因**

レイヤーシステムで背景色設定がリセットされている

### **確認**

```javascript
// Console で実行
const layerSystem = window.coreEngine?.getLayerManager?.();
const activeLayer = layerSystem?.getActiveLayer?.();
console.log('Active layer background:', activeLayer?.layerData?.isBackground);
console.log('Background color:', window.TEGAKI_CONFIG?.background?.color);
```

### **修正内容（layer-system.js）**

```javascript
// リサイズイベントハンドラ修正
updateLayerSizesAfterResize(newWidth, newHeight) {
  this.cuts.forEach(cut => {
    cut.layers.forEach(layer => {
      if (layer.layerData?.isBackground) {
        // ✅ 修正: 背景色を保持
        const bgColor = window.TEGAKI_CONFIG?.background?.color || 0xf0e0d6;
        
        if (layer.layerData.backgroundGraphics) {
          layer.layerData.backgroundGraphics.clear();
          
          const squareSize = 16;
          for (let y = 0; y < newHeight; y += squareSize) {
            for (let x = 0; x < newWidth; x += squareSize) {
              const isEvenX = (x / squareSize) % 2 === 0;
              const isEvenY = (y / squareSize) % 2 === 0;
              const color = (isEvenX === isEvenY) ? 0xe9c2ba : 0xf0e0d6;
              
              layer.layerData.backgroundGraphics.rect(x, y, squareSize, squareSize);
              layer.layerData.backgroundGraphics.fill({ color });
            }
          }
        }
      }
    });
  });
}
```

---

## ⚡ **修正5: 操作が重い問題**

### **原因**

DOM の過度な再描画

### **対策**

```javascript
// layer-panel-renderer.js の requestAnimationFrame 使用

let pendingRender = false;

updateLayerPanelUI() {
  if (pendingRender) return;  // ✅ 既に予約済みならスキップ
  
  pendingRender = true;
  
  requestAnimationFrame(() => {
    // 重い処理をここで実行
    this._renderLayerPanelSync();
    pendingRender = false;
  });
}
```

---

## 📋 **実装チェックリスト**

- [ ] **BrushSettings**: 全メソッド実装完了 ✅
- [ ] **drawing-engine.js**: EventBus 購読安全化 ✅
- [ ] **quick-access-popup.js**: `initialize()` `toggle()` 追加
- [ ] **popup-manager.js**: `show()` と `hideAll()` 修正
- [ ] **core-runtime.js**: ポインタイベントデバッグログ追加
- [ ] **layer-system.js**: リサイズ時背景色保持
- [ ] **layer-panel-renderer.js**: requestAnimationFrame 化

---

## 🔍 **デバッグコマンド**

```javascript
// 一括デバッグ実行

console.log('=== Tegaki Debug Report ===');

// 1. BrushSettings
const bs = window.coreEngine?.getDrawingEngine?.().settings;
console.log('BrushSettings methods:', {
  getCurrentSettings: typeof bs.getCurrentSettings,
  setPressureCorrection: typeof bs.setPressureCorrection,
  setSmoothing: typeof bs.setSmoothing
});

// 2. PopupManager
const pm = window.PopupManager;
console.log('PopupManager statuses:', pm?.getAllStatuses?.());

// 3. DrawingEngine
const de = window.coreEngine?.getDrawingEngine?.();
console.log('DrawingEngine:', {
  currentTool: de?.currentTool,
  isDrawing: de?.isDrawing,
  canDraw: typeof de?.startDrawing === 'function'
});

// 4. Canvas
const canvas = document.querySelector('canvas');
console.log('Canvas:', {
  width: canvas?.width,
  height: canvas?.height,
  hasEventListeners: !!canvas?.onpointerdown
});
```

---

## ✅ **修正の優先順位**

1. **quick-access-popup.js**: `initialize()` + `toggle()` 追加 → **ポップアップ表示**
2. **popup-manager.js**: `hideAll()` 修正 → **ポップアップ非表示問題解決**
3. **core-runtime.js**: ポインタイベント デバッグ追加 → **描画可能か確認**
4. **layer-system.js**: 背景色保持 → **リサイズ対応**
5. **layer-panel-renderer.js**: パフォーマンス改善 → **操作軽量化**