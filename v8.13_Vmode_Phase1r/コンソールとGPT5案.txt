config.js:514 ✅ config.js (Phase 1: ペン高精度化設定追加版) loaded
config.js:515    🆕 Phase 1: ベースラインキャリブレーション設定追加
config.js:516    🆕 Phase 1: devicePixelRatio対応設定追加
batch-api.js:382 ✅ batch-api.js (Phase 6: History統合版) loaded
event-bus.js:143 ✅ system/event-bus.js Phase 2: 優先度機能追加版 loaded
popup-manager.js:425 ✅ popup-manager.js loaded
drawing-clipboard.js:603 ✅ drawing-clipboard.js Phase4改修版+確定イベント loaded
drawing-clipboard.js:604    - ✅ CTRL+V behavior: overwrite active layer
drawing-clipboard.js:605    - ✅ Commit events: paste:commit, operation:commit
drawing-clipboard.js:606    - ✅ Thumbnail auto-update on paste
history.js:179 ✅ history.js (Phase 2: EventBus修正版) loaded
animation-system.js:1428 ✅ animation-system.js (Phase 4.1: CUT自動採番対応版) loaded
export-manager.js:259 ✅ export-manager.js loaded
png-exporter.js:85 ✅ png-exporter.js (単一フレーム専用・プレビュー対応) loaded
apng-exporter.js:236 ✅ apng-exporter.js (PixiJS v8.13完全対応版) loaded
gif-exporter.js:300 ✅ gif-exporter.js (PixiJS v8.13完全対応版) loaded
slider-utils.js:197 ✅ ui/slider-utils.js loaded
slider-utils.js:198    - 責務: スライダーUIの統一実装
slider-utils.js:199    - DRY原則: settings-popup.js と ui-panels.js で共有
slider-utils.js:200    - API: createSlider() / createSimpleSlider()
resize-popup.js:538 ✅ resize-popup.js (PopupManager統一版) loaded
timeline-ui.js:969 ✅ timeline-ui.js (Frame表記・UI改善版) loaded
album-popup.js:477 ✅ album-popup.js (PopupManager対応版 + display修正) loaded
settings-popup.js:486 ✅ settings-popup.js (PopupManager対応版) loaded
quick-access-popup.js:428 ✅ quick-access-popup.js loaded (Phase1修正版・resize-slider.jsパターン)
export-popup.js:429 ✅ export-popup.js (PopupManager対応版) loaded
drawing-clipboard.js:19 DrawingClipboard: Initializing...
drawing-clipboard.js:26 ✅ DrawingClipboard initialized (Phase4改修版 + 確定イベント)
popup-manager.js:19 ✅ PopupManager initialized
popup-manager.js:52 📋 Popup "settings" registered (priority: 1)
popup-manager.js:52 📋 Popup "quickAccess" registered (priority: 2)
popup-manager.js:52 📋 Popup "album" registered (priority: 3)
popup-manager.js:52 📋 Popup "export" registered (priority: 4)
popup-manager.js:124 🔧 Initializing all popups...
popup-manager.js:106 ✅ Popup "settings" initialized successfully
popup-manager.js:106 ✅ Popup "quickAccess" initialized successfully
popup-manager.js:106 ✅ Popup "album" initialized successfully
popup-manager.js:83 ⏳ Popup "export" waiting for: TEGAKI_EXPORT_MANAGER
popup-manager.js:141 📊 Popup initialization: 3 ready, 1 deferred
popup-manager.js:106 ✅ Popup "export" initialized successfully
popup-manager.js:181 ✅ All deferred popups initialized
popup-manager.js:232 👁️ Popup "quickAccess" shown


※以下はGPT5検査（あくまで参考程度に）

結論 → 主な原因は ポップアップの HTML テンプレートと DOM 取得の不一致（ID が無い／要素が null） と、スライダーの初期表示/幅（getBoundingClientRect().width）が 0 の状態で計算してしまう、さらに グローバルイベントリスナーの管理不足（destroy 時に除去していない） の組合せです。これらが合わさって「● が動かない」「±ボタンで値がほとんど変わらない」挙動を生んでいます。

短い原因まとめ（要点）

quick-access-popup.js の panel.innerHTML に id="pen-size-slider" 等の要素が見当たらない／欠落しています。
→ そのため this.sizeHandle 等が null になり、あるいは想定外の要素参照になっている可能性が高い。

スライダー算出に使う rect.width が 0（非表示状態や CSS で幅が決まっていない）だと、percent が NaN / 無効になり視覚更新が不安定に。

document.addEventListener('mousemove', ...) / mouseup を登録しているが、destroy() で除去していない（メモリリーク・複数登録の原因）。

±ボタンでの変化が小さく見える問題は、単位 / スケールの不一致（BrushSettings の get/set が想定単位と違う）や、_update... 側で clamp が働いているために変化が十分に伝わっていない、という可能性があります。

検証ポイント（あなたが今すぐコンソールで確認できること）

クイックアクセスポップアップの DOM に以下の ID が実在するか。
pen-size-slider / pen-size-track / pen-size-handle / pen-size-display / pen-size-decrease / pen-size-increase （同様に opacity 系）
— コンソール: document.getElementById('pen-size-handle') など。null ならテンプレート不整合確定。

スライダー領域の幅: document.getElementById('pen-size-slider').getBoundingClientRect() → width が 0 でないか。

ブラシ設定の値: window.BrushSettings?.getSize() と window.BrushSettings?.getOpacity() の返り値を確認。単位（px / 0-1）を把握。

その場で使える修正パッチ（差し替えるべき最小のコード）

下記は ui/quick-access-popup.js に対する 確実に動作する最小修正です。主な変更点:

pop-up の innerHTML を「ID が揃った実体 DOM」に差し替え

_cacheElements() を追加して DOM を panel 内で確実に拾う（グローバル getElementById 依存を避ける）

スライダーセットアップで要素の存在チェックと rect.width === 0 の保護を追加

グローバルリスナーをインスタンス変数で保持し、destroy() で確実に除去する

quick patch（置換用） — quick-access-popup.js の該当箇所を以下に丸ごと置き換えてください（_createPanel / _attachEventListeners / _setupSizeSlider / _setupOpacitySlider / _update... / destroy をこの内容に差し替えればOKです）:

// --- quick-access-popup.js : 修正差し替え部分 ---
// (既存のファイル内で _createPanel() から destroy() までをこのブロックに置き換えてください)

_createPanel() {
    this.panel = document.createElement('div');
    this.panel.id = 'quick-access-popup';
    this.panel.className = 'popup-panel';
    this.panel.style.cssText = 'left: 70px; top: 60px;';
    // 明示的に必要な ID を持つ DOM を用意する（サイズ/透明度スライダー）
    this.panel.innerHTML = `
      <div class="popup-row">
        <div class="label">筆圧</div>
        <div class="slider-row">
          <button id="pen-size-decrease" type="button" class="step-btn">◀</button>
          <div id="pen-size-slider" class="slider-container">
            <div id="pen-size-track" class="slider-track"></div>
            <div id="pen-size-handle" class="slider-handle" role="slider" tabindex="0"></div>
          </div>
          <button id="pen-size-increase" type="button" class="step-btn">▶</button>
          <div id="pen-size-display" class="slider-value">1.0px</div>
        </div>
      </div>

      <div class="popup-row">
        <div class="label">透明度</div>
        <div class="slider-row">
          <button id="pen-opacity-decrease" type="button" class="step-btn">◀</button>
          <div id="pen-opacity-slider" class="slider-container">
            <div id="pen-opacity-track" class="slider-track"></div>
            <div id="pen-opacity-handle" class="slider-handle" role="slider" tabindex="0"></div>
          </div>
          <button id="pen-opacity-increase" type="button" class="step-btn">▶</button>
          <div id="pen-opacity-display" class="slider-value">100%</div>
        </div>
      </div>
    `;
    document.body.appendChild(this.panel);

    // panel 内で探す（グローバル依存を避ける）
    this._cacheElements();
}

_cacheElements() {
    this.sizeSlider = this.panel.querySelector('#pen-size-slider');
    this.sizeTrack = this.panel.querySelector('#pen-size-track');
    this.sizeHandle = this.panel.querySelector('#pen-size-handle');
    this.sizeDisplay = this.panel.querySelector('#pen-size-display');

    this.opacitySlider = this.panel.querySelector('#pen-opacity-slider');
    this.opacityTrack = this.panel.querySelector('#pen-opacity-track');
    this.opacityHandle = this.panel.querySelector('#pen-opacity-handle');
    this.opacityDisplay = this.panel.querySelector('#pen-opacity-display');

    // step buttons
    this.sizeDecreaseBtn = this.panel.querySelector('#pen-size-decrease');
    this.sizeIncreaseBtn = this.panel.querySelector('#pen-size-increase');
    this.opacityDecreaseBtn = this.panel.querySelector('#pen-opacity-decrease');
    this.opacityIncreaseBtn = this.panel.querySelector('#pen-opacity-increase');
}

_attachEventListeners() {
    // color buttons (既存処理があれば残す)
    const colorButtons = this.panel.querySelectorAll('.color-button');
    colorButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            const color = parseInt(btn.getAttribute('data-color'));
            if (window.BrushSettings) window.BrushSettings.setColor(color);
            colorButtons.forEach(b => { b.style.border = b === btn ? '3px solid #ff8c42' : '2px solid var(--futaba-light-medium)'; });
            if (this.eventBus) this.eventBus.emit('brush:color-changed', { color });
        });
    });

    // スライダー有効性チェック
    this._setupSizeSlider();
    this._setupOpacitySlider();
}

_setupSizeSlider() {
    if (!this.sizeSlider || !this.sizeHandle || !this.sizeTrack || !this.sizeDisplay) return;

    const MIN_SIZE = 0.5, MAX_SIZE = 30;
    // ハンドラをインスタンスに保持（destroyで除去するため）
    this._sizeMouseMove = (e) => {
        if (!this.isDraggingSize) return;
        const rect = this.sizeSlider.getBoundingClientRect();
        if (!rect || rect.width <= 0) return;
        const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        const value = MIN_SIZE + ((MAX_SIZE - MIN_SIZE) * percent / 100);
        this._updateSizeSlider(value);
    };
    this._sizeMouseUp = (e) => {
        if (this.isDraggingSize) {
            this.isDraggingSize = false;
            if (this.sizeHandle) this.sizeHandle.style.cursor = 'grab';
        }
    };

    // ハンドル開始（存在チェック済み）
    this.sizeHandle.addEventListener('mousedown', (e) => {
        this.isDraggingSize = true;
        this.sizeHandle.style.cursor = 'grabbing';
        e.preventDefault(); e.stopPropagation();
    });

    // スライダークリック
    this.sizeSlider.addEventListener('click', (e) => {
        if (e.target === this.sizeHandle) return;
        const rect = this.sizeSlider.getBoundingClientRect();
        if (!rect || rect.width <= 0) return;
        const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        const value = MIN_SIZE + ((MAX_SIZE - MIN_SIZE) * percent / 100);
        this._updateSizeSlider(value);
    });

    // ±ボタン
    if (this.sizeDecreaseBtn) this.sizeDecreaseBtn.addEventListener('click', () => {
        const current = (window.BrushSettings?.getSize?.() ?? 1);
        this._updateSizeSlider(Math.max(MIN_SIZE, current - 0.5));
    });
    if (this.sizeIncreaseBtn) this.sizeIncreaseBtn.addEventListener('click', () => {
        const current = (window.BrushSettings?.getSize?.() ?? 1);
        this._updateSizeSlider(Math.min(MAX_SIZE, current + 0.5));
    });

    // グローバル登録（同一ハンドラを複数登録しないため remove してから add しておく）
    document.removeEventListener('mousemove', this._sizeMouseMove);
    document.removeEventListener('mouseup', this._sizeMouseUp);
    document.addEventListener('mousemove', this._sizeMouseMove);
    document.addEventListener('mouseup', this._sizeMouseUp);
}

_setupOpacitySlider() {
    if (!this.opacitySlider || !this.opacityHandle || !this.opacityTrack || !this.opacityDisplay) return;

    const MIN_OPACITY = 0, MAX_OPACITY = 100;
    this._opacityMouseMove = (e) => {
        if (!this.isDraggingOpacity) return;
        const rect = this.opacitySlider.getBoundingClientRect();
        if (!rect || rect.width <= 0) return;
        const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        const value = MIN_OPACITY + ((MAX_OPACITY - MIN_OPACITY) * percent / 100);
        this._updateOpacitySlider(value);
    };
    this._opacityMouseUp = (e) => {
        if (this.isDraggingOpacity) {
            this.isDraggingOpacity = false;
            if (this.opacityHandle) this.opacityHandle.style.cursor = 'grab';
        }
    };

    this.opacityHandle.addEventListener('mousedown', (e) => {
        this.isDraggingOpacity = true;
        this.opacityHandle.style.cursor = 'grabbing';
        e.preventDefault(); e.stopPropagation();
    });

    this.opacitySlider.addEventListener('click', (e) => {
        if (e.target === this.opacityHandle) return;
        const rect = this.opacitySlider.getBoundingClientRect();
        if (!rect || rect.width <= 0) return;
        const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        const value = MIN_OPACITY + ((MAX_OPACITY - MIN_OPACITY) * percent / 100);
        this._updateOpacitySlider(value);
    });

    if (this.opacityDecreaseBtn) this.opacityDecreaseBtn.addEventListener('click', () => {
        const current = (window.BrushSettings?.getOpacity?.() ?? 1) * 100;
        this._updateOpacitySlider(Math.max(MIN_OPACITY, current - 5));
    });
    if (this.opacityIncreaseBtn) this.opacityIncreaseBtn.addEventListener('click', () => {
        const current = (window.BrushSettings?.getOpacity?.() ?? 1) * 100;
        this._updateOpacitySlider(Math.min(MAX_OPACITY, current + 5));
    });

    document.removeEventListener('mousemove', this._opacityMouseMove);
    document.removeEventListener('mouseup', this._opacityMouseUp);
    document.addEventListener('mousemove', this._opacityMouseMove);
    document.addEventListener('mouseup', this._opacityMouseUp);
}

_updateSizeSlider(value) {
    const MIN_SIZE = 0.5, MAX_SIZE = 30;
    const clampedValue = Math.max(MIN_SIZE, Math.min(MAX_SIZE, value));
    const percent = ((clampedValue - MIN_SIZE) / (MAX_SIZE - MIN_SIZE)) * 100;

    if (this.sizeTrack) this.sizeTrack.style.width = percent + '%';
    if (this.sizeHandle) this.sizeHandle.style.left = percent + '%';
    if (this.sizeDisplay) this.sizeDisplay.textContent = clampedValue.toFixed(1) + 'px';

    if (window.BrushSettings && typeof window.BrushSettings.setSize === 'function') {
        window.BrushSettings.setSize(clampedValue);
    }
    if (this.eventBus) this.eventBus.emit('brush:size-changed', { size: clampedValue });
}

_updateOpacitySlider(value) {
    const MIN_OPACITY = 0, MAX_OPACITY = 100;
    const clampedValue = Math.max(MIN_OPACITY, Math.min(MAX_OPACITY, value));
    const percent = ((clampedValue - MIN_OPACITY) / (MAX_OPACITY - MIN_OPACITY)) * 100;

    if (this.opacityTrack) this.opacityTrack.style.width = percent + '%';
    if (this.opacityHandle) this.opacityHandle.style.left = percent + '%';
    if (this.opacityDisplay) this.opacityDisplay.textContent = Math.round(clampedValue) + '%';

    if (window.BrushSettings && typeof window.BrushSettings.setOpacity === 'function') {
        window.BrushSettings.setOpacity(clampedValue / 100);
    }
    if (this.eventBus) this.eventBus.emit('brush:opacity-changed', { opacity: clampedValue / 100 });
}

destroy() {
    // remove global handlers if set
    if (this._sizeMouseMove) document.removeEventListener('mousemove', this._sizeMouseMove);
    if (this._sizeMouseUp) document.removeEventListener('mouseup', this._sizeMouseUp);
    if (this._opacityMouseMove) document.removeEventListener('mousemove', this._opacityMouseMove);
    if (this._opacityMouseUp) document.removeEventListener('mouseup', this._opacityMouseUp);

    if (this.panel && this.panel.parentNode) this.panel.parentNode.removeChild(this.panel);
    this.panel = null;
    this.isVisible = false;
    // clear cached refs
    this.sizeSlider = this.sizeTrack = this.sizeHandle = this.sizeDisplay = null;
    this.opacitySlider = this.opacityTrack = this.opacityHandle = this.opacityDisplay = null;
}


重要: 上の差し替えは既存のコード構造を壊さないように最小限にしています。もし QuickAccessPopup が外部で new QuickAccessPopup({ eventBus: ... }) のように生成されているなら、そのまま動きます。

CSS 側の注意点（必須チェック）

スライダーが可視的に動くために以下 CSS が必要です（styles/main.css に追加／確認）:

.slider-container { position: relative; width: 160px; height: 14px; cursor: pointer; display:inline-block; vertical-align: middle; }
.slider-track { position: absolute; left:0; top:50%; height:6px; transform: translateY(-50%); background: var(--futaba-maroon); border-radius:3px; width: 50%; }
.slider-handle { position: absolute; top:50%; left:0%; transform: translate(-50%, -50%); width:16px; height:16px; border-radius:50%; background: var(--futaba-maroon); border:2px solid var(--futaba-background); cursor:grab; transition: left 0.08s linear; }
.slider-value { display:inline-block; min-width:48px; text-align:right; margin-left:10px; }
.step-btn { width:28px; height:28px; }


slider-container に position: relative と幅（width）があることを必ず確認してください。幅が未指定だと getBoundingClientRect().width が 0 になります。

± ボタンで数値がほとんど動かない場合の追加チェック

window.BrushSettings.getSize() の返り値の単位を確認してください（px 単位なら上の ±0.5 はわかりやすい。もし内部でスケーリングされているなら増分を調整する必要があります）。

getOpacity() が 0..1 なのか 0..100 なのかを確認。上のコードは getOpacity() が 0..1 の想定です（*100 して ±5 単位で操作）。

コンソールで確認:

console.log('Brush size:', window.BrushSettings?.getSize());
console.log('Brush opacity:', window.BrushSettings?.getOpacity());

その他の改善・堅牢化（推奨）

スライダーの keyboard 操作（左右キーでステップ）を keydown で追加するとアクセシビリティが向上します。

touch イベント対応（touchstart / touchmove / touchend）を実装すればタブレットでも安定します。

スライダー実装は slider-utils.js に切り出すと今後の整備が楽になります（あなたの改修方針にも合致）。