===============================================
【デバッグコマンド集】
===============================================

## 1. スライダーDOM存在確認
```javascript
// resize-popup.js 用
const slider = document.getElementById('canvas-width-slider');
const handle = document.getElementById('canvas-width-handle');
const track = document.getElementById('canvas-width-track');
console.log('Slider:', slider, 'Handle:', handle, 'Track:', track);
```

## 2. イベントリスナー確認
```javascript
// Chrome DevTools で実行
getEventListeners(document.getElementById('canvas-width-handle'))
getEventListeners(document.getElementById('canvas-width-slider'))
getEventListeners(document)  // mousemove/mouseup を確認
```

## 3. PopupManager 統合状態確認
```javascript
window.PopupManager.diagnose()
window.PopupManager.getStatus('resize')
window.PopupManager.getStatus('quickAccess')
```

## 4. BrushSettings API確認
```javascript
console.log('BrushSettings:', window.BrushSettings);
console.log('Methods:', Object.getOwnPropertyNames(window.BrushSettings.__proto__));
console.log('getOpacity:', typeof window.BrushSettings?.getOpacity);  // undefined
console.log('getAlpha:', typeof window.BrushSettings?.getAlpha);    // function
```

## 5. スライダー動作テスト
```javascript
// リサイズポップアップを表示
window.PopupManager.show('resize');

// 手動でスライダー更新を試行
const popup = window.PopupManager.get('resize');
if (popup && popup.sliders && popup.sliders.width) {
    popup.sliders.width.setValue(500);
}
```

## 6. quick-access-popup のスライダー動作テスト
```javascript
// ペン設定ポップアップを表示
window.PopupManager.show('quickAccess');

// DOM要素確認
const penSlider = document.getElementById('pen-size-slider');
const penHandle = document.getElementById('pen-size-handle');
console.log('Pen Slider:', penSlider, 'Handle:', penHandle);

// イベントリスナー確認
getEventListeners(penHandle)
getEventListeners(document)

// BrushSettings の値確認
console.log('Current size:', window.BrushSettings?.getSize());
console.log('Current alpha:', window.BrushSettings?.getAlpha());
```

## 7. EventBus イベント発火確認
```javascript
// デバッグモード有効化
window.TegakiEventBus.setDebug(true);

// スライダーを動かして、イベントが発火されるか確認
// brush:size-changed
// brush:opacity-changed（存在しない可能性）
// brush:alpha-changed
```

## 8. メモリリーク確認
```javascript
// ポップアップを複数回開閉
for (let i = 0; i < 10; i++) {
    window.PopupManager.toggle('quickAccess');
}

// イベントリスナーの数を確認
getEventListeners(document).mousemove.length  // 増え続けていればリーク
```


===============================================
【改修計画】
===============================================

## Phase 1: BrushSettings API統一（最優先）

### 対象ファイル
- system/drawing/brush-settings.js

### 改修内容
```javascript
// getOpacity() / setOpacity() メソッドを追加

/**
 * 透明度取得（0-100%形式）
 */
getOpacity() {
    return this.alpha * 100;
}

/**
 * 透明度設定（0-100%形式）
 */
setOpacity(opacity) {
    this.setAlpha(opacity / 100);
}
```

### EventBus イベント追加
```javascript
// brush:opacity-changed イベントの追加
subscribeToEvents() {
    // 既存
    this.eventBus.on('brush:alpha-changed', ({ alpha }) => {
        this.setAlpha(alpha);
    });
    
    // 追加
    this.eventBus.on('brush:opacity-changed', ({ opacity }) => {
        this.setOpacity(opacity);
    });
}
```


## Phase 2: resize-slider.js パターンの完全適用

### 対象ファイル
- ui/quick-access-popup.js
- ui/resize-popup.js

### 改修方針
resize-slider.js の実装パターンを完全にコピーする

### 重要な実装パターン
1. **グローバル変数ではなくクラス変数で状態管理**
   ```javascript
   constructor() {
       this.isDraggingWidth = false;
       this.isDraggingHeight = false;
   }
   ```

2. **イベントリスナーの参照を保持**
   ```javascript
   constructor() {
       this.mouseMoveHandler = null;
       this.mouseUpHandler = null;
   }
   
   _setupSliders() {
       this.mouseMoveHandler = (e) => {
           if (this.isDraggingWidth) { ... }
       };
       document.addEventListener('mousemove', this.mouseMoveHandler);
   }
   
   destroy() {
       if (this.mouseMoveHandler) {
           document.removeEventListener('mousemove', this.mouseMoveHandler);
       }
   }
   ```

3. **ハンドルに mousedown、documentに mousemove/mouseup**
   ```javascript
   // resize-slider.js の実装を完全にコピー
   this.widthHandle.addEventListener('mousedown', (e) => {
       this.isDraggingWidth = true;
       e.preventDefault();
   });
   
   this.mouseMoveHandler = (e) => {
       if (this.isDraggingWidth) {
           const rect = this.widthSlider.getBoundingClientRect();
           // ... 計算処理
       }
   };
   
   this.mouseUpHandler = () => {
       this.isDraggingWidth = false;
       this.isDraggingHeight = false;
   };
   
   document.addEventListener('mousemove', this.mouseMoveHandler);
   document.addEventListener('mouseup', this.mouseUpHandler);
   ```

4. **スライダー領域クリックの実装**
   ```javascript
   this.widthSlider.addEventListener('click', (e) => {
       if (e.target === this.widthHandle) return;  // ハンドルクリックは無視
       const rect = this.widthSlider.getBoundingClientRect();
       const percent = ((e.clientX - rect.left) / rect.width) * 100;
       // ... 値更新
   });
   ```


## Phase 3: quick-access-popup.js の完全書き換え

### クラス変数の整理
```javascript
constructor(config = {}) {
    this.config = config;
    this.eventBus = config.eventBus || window.TegakiEventBus;
    this.panel = null;
    this.isVisible = false;
    this.initialized = false;  // 追加
    
    // ドラッグ状態フラグ
    this.isDraggingSize = false;
    this.isDraggingOpacity = false;
    
    // DOM要素キャッシュ
    this.elements = {};
    
    // グローバルイベントリスナー参照
    this.mouseMoveHandler = null;
    this.mouseUpHandler = null;
    
    this._createPanel();
}
```

### _cacheElements() メソッド追加
```javascript
_cacheElements() {
    this.elements = {
        sizeSlider: document.getElementById('pen-size-slider'),
        sizeTrack: document.getElementById('pen-size-track'),
        sizeHandle: document.getElementById('pen-size-handle'),
        sizeDisplay: document.getElementById('pen-size-display'),
        sizeDecrease: document.getElementById('pen-size-decrease'),
        sizeIncrease: document.getElementById('pen-size-increase'),
        
        opacitySlider: document.getElementById('pen-opacity-slider'),
        opacityTrack: document.getElementById('pen-opacity-track'),
        opacityHandle: document.getElementById('pen-opacity-handle'),
        opacityDisplay: document.getElementById('pen-opacity-display'),
        opacityDecrease: document.getElementById('pen-opacity-decrease'),
        opacityIncrease: document.getElementById('pen-opacity-increase')
    };
}
```

### 初期化フローの変更
```javascript
show() {
    if (!this.initialized) {
        this._cacheElements();
        this._attachEventListeners();
        this.initialized = true;
    }
    
    this._loadCurrentSettings();
    this.panel.classList.add('show');
    this.isVisible = true;
    
    if (this.eventBus) {
        this.eventBus.emit('popup:shown', { name: 'quickAccess' });
    }
}
```

### スライダー設定の完全書き換え
```javascript
_setupSizeSlider() {
    const MIN_SIZE = 0.5;
    const MAX_SIZE = 30;
    
    // マウスムーブハンドラー
    const handleMouseMove = (e) => {
        if (!this.isDraggingSize) return;
        const rect = this.elements.sizeSlider.getBoundingClientRect();
        const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        const value = MIN_SIZE + ((MAX_SIZE - MIN_SIZE) * percent / 100);
        this._updateSizeSlider(value);
    };
    
    // マウスアップハンドラー
    const handleMouseUp = () => {
        if (this.isDraggingSize) {
            this.isDraggingSize = false;
        }
        if (this.isDraggingOpacity) {
            this.isDraggingOpacity = false;
        }
    };
    
    // 参照を保持
    if (!this.mouseMoveHandler) {
        this.mouseMoveHandler = handleMouseMove;
        this.mouseUpHandler = handleMouseUp;
        
        document.addEventListener('mousemove', this.mouseMoveHandler);
        document.addEventListener('mouseup', this.mouseUpHandler);
    }
    
    // ハンドルドラッグ開始
    this.elements.sizeHandle.addEventListener('mousedown', (e) => {
        this.isDraggingSize = true;
        e.preventDefault();
        e.stopPropagation();
    });
    
    // スライダー直接クリック
    this.elements.sizeSlider.addEventListener('click', (e) => {
        if (e.target === this.elements.sizeHandle) return;
        const rect = this.elements.sizeSlider.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        const value = MIN_SIZE + ((MAX_SIZE - MIN_SIZE) * percent / 100);
        this._updateSizeSlider(value);
    });
    
    // ステップボタン
    this.elements.sizeDecrease.addEventListener('click', () => {
        const current = window.BrushSettings?.getSize() || 1;
        this._updateSizeSlider(Math.max(MIN_SIZE, current - 0.5));
    });
    
    this.elements.sizeIncrease.addEventListener('click', () => {
        const current = window.BrushSettings?.getSize() || 1;
        this._updateSizeSlider(Math.min(MAX_SIZE, current + 0.5));
    });
}
```

### 透明度スライダーの修正
```javascript
_setupOpacitySlider() {
    const MIN_OPACITY = 0;
    const MAX_OPACITY = 100;
    
    // 既に mouseMoveHandler/mouseUpHandler は _setupSizeSlider() で設定済み
    
    // ハンドルドラッグ開始
    this.elements.opacityHandle.addEventListener('mousedown', (e) => {
        this.isDraggingOpacity = true;
        e.preventDefault();
        e.stopPropagation();
    });
    
    // スライダー直接クリック
    this.elements.opacitySlider.addEventListener('click', (e) => {
        if (e.target === this.elements.opacityHandle) return;
        const rect = this.elements.opacitySlider.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        const value = MIN_OPACITY + ((MAX_OPACITY - MIN_OPACITY) * percent / 100);
        this._updateOpacitySlider(value);
    });
    
    // ステップボタン
    this.elements.opacityDecrease.addEventListener('click', () => {
        const current = window.BrushSettings?.getOpacity() || 100;  // ✅ 修正済み
        this._updateOpacitySlider(Math.max(MIN_OPACITY, current - 5));
    });
    
    this.elements.opacityIncrease.addEventListener('click', () => {
        const current = window.BrushSettings?.getOpacity() || 100;  // ✅ 修正済み
        this._updateOpacitySlider(Math.min(MAX_OPACITY, current + 5));
    });
}
```

### mouseMoveHandler の共通化
```javascript
_attachEventListeners() {
    // カラーパレット設定
    // ...
    
    // グローバルマウスムーブハンドラー（共通）
    this.mouseMoveHandler = (e) => {
        if (this.isDraggingSize) {
            const MIN_SIZE = 0.5;
            const MAX_SIZE = 30;
            const rect = this.elements.sizeSlider.getBoundingClientRect();
            const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
            const value = MIN_SIZE + ((MAX_SIZE - MIN_SIZE) * percent / 100);
            this._updateSizeSlider(value);
        }
        
        if (this.isDraggingOpacity) {
            const MIN_OPACITY = 0;
            const MAX_OPACITY = 100;
            const rect = this.elements.opacitySlider.getBoundingClientRect();
            const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
            const value = MIN_OPACITY + ((MAX_OPACITY - MIN_OPACITY) * percent / 100);
            this._updateOpacitySlider(value);
        }
    };
    
    this.mouseUpHandler = () => {
        this.isDraggingSize = false;
        this.isDraggingOpacity = false;
    };
    
    document.addEventListener('mousemove', this.mouseMoveHandler);
    document.addEventListener('mouseup', this.mouseUpHandler);
    
    // 個別スライダー設定
    this._setupSizeSlider();
    this._setupOpacitySlider();
}
```

### destroy() の修正
```javascript
destroy() {
    // グローバルイベントリスナーの削除
    if (this.mouseMoveHandler) {
        document.removeEventListener('mousemove', this.mouseMoveHandler);
    }
    if (this.mouseUpHandler) {
        document.removeEventListener('mouseup', this.mouseUpHandler);
    }
    
    this.mouseMoveHandler = null;
    this.mouseUpHandler = null;
    this.elements = {};
    this.initialized = false;
    
    if (this.panel && this.panel.parentNode) {
        this.panel.parentNode.removeChild(this.panel);
    }
    this.panel = null;
    this.isVisible = false;
}
```


## Phase 4: resize-popup.js の完全書き換え

### _createSlider() メソッドの削除
resize-popup.js の `_createSlider()` メソッドは削除し、resize-slider.js のパターンを直接実装

### クラス変数の追加
```javascript
constructor(dependencies) {
    // 既存の変数
    this.coreEngine = dependencies.coreEngine;
    this.history = dependencies.history;
    this.eventBus = window.TegakiEventBus;
    
    this.popup = null;
    this.isVisible = false;
    this.initialized = false;
    
    // ドラッグ状態フラグ
    this.isDraggingWidth = false;
    this.isDraggingHeight = false;
    
    // DOM要素キャッシュ
    this.elements = {};
    
    // グローバルイベントリスナー参照
    this.mouseMoveHandler = null;
    this.mouseUpHandler = null;
    
    // 現在値
    this.currentWidth = 0;
    this.currentHeight = 0;
    this.horizontalAlign = 'center';
    this.verticalAlign = 'center';
    
    this.MIN_SIZE = 100;
    this.MAX_SIZE = 2000;
    
    this._ensurePopupElement();
}
```

### _setupSliders() の完全書き換え
```javascript
_setupSliders() {
    // DOM要素キャッシュ
    this.elements = {
        widthSlider: document.getElementById('canvas-width-slider'),
        widthTrack: document.getElementById('canvas-width-track'),
        widthHandle: document.getElementById('canvas-width-handle'),
        widthDisplay: document.getElementById('canvas-width-display'),
        widthDecrease: document.getElementById('width-decrease'),
        widthIncrease: document.getElementById('width-increase'),
        
        heightSlider: document.getElementById('canvas-height-slider'),
        heightTrack: document.getElementById('canvas-height-track'),
        heightHandle: document.getElementById('canvas-height-handle'),
        heightDisplay: document.getElementById('canvas-height-display'),
        heightDecrease: document.getElementById('height-decrease'),
        heightIncrease: document.getElementById('height-increase')
    };
    
    // グローバルマウスハンドラー
    this.mouseMoveHandler = (e) => {
        if (this.isDraggingWidth) {
            const rect = this.elements.widthSlider.getBoundingClientRect();
            const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
            const value = this.MIN_SIZE + ((this.MAX_SIZE - this.MIN_SIZE) * percent / 100);
            this._updateWidthSlider(Math.round(value));
        }
        if (this.isDraggingHeight) {
            const rect = this.elements.heightSlider.getBoundingClientRect();
            const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
            const value = this.MIN_SIZE + ((this.MAX_SIZE - this.MIN_SIZE) * percent / 100);
            this._updateHeightSlider(Math.round(value));
        }
    };
    
    this.mouseUpHandler = () => {
        this.isDraggingWidth = false;
        this.isDraggingHeight = false;
    };
    
    document.addEventListener('mousemove', this.mouseMoveHandler);
    document.addEventListener('mouseup', this.mouseUpHandler);
    
    // 幅ハンドル
    this.elements.widthHandle.addEventListener('mousedown', (e) => {
        this.isDraggingWidth = true;
        e.preventDefault();
    });
    
    // 高さハンドル
    this.elements.heightHandle.addEventListener('mousedown', (e) => {
        this.isDraggingHeight = true;
        e.preventDefault();
    });
    
    // スライダークリック
    this.elements.widthSlider.addEventListener('click', (e) => {
        if (e.target === this.elements.widthHandle) return;
        const rect = this.elements.widthSlider.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        const value = this.MIN_SIZE + ((this.MAX_SIZE - this.MIN_SIZE) * percent / 100);
        this._updateWidthSlider(Math.round(value));
    });
    
    this.elements.heightSlider.addEventListener('click', (e) => {
        if (e.target === this.elements.heightHandle) return;
        const rect = this.elements.heightSlider.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        const value = this.MIN_SIZE + ((this.MAX_SIZE - this.MIN_SIZE) * percent / 100);
        this._updateHeightSlider(Math.round(value));
    });
    
    // ステップボタン
    this.elements.widthDecrease.addEventListener('click', () => {
        this._updateWidthSlider(this.currentWidth - 1);
    });
    
    this.elements.widthIncrease.addEventListener('click', () => {
        this._updateWidthSlider(this.currentWidth + 1);
    });
    
    this.elements.heightDecrease.addEventListener('click', () => {
        this._updateHeightSlider(this.currentHeight - 1);
    });
    
    this.elements.heightIncrease.addEventListener('click', () => {
        this._updateHeightSlider(this.currentHeight + 1);
    });
}

_updateWidthSlider(value) {
    this.currentWidth = Math.max(this.MIN_SIZE, Math.min(this.MAX_SIZE, value));
    const percent = ((this.currentWidth - this.MIN_SIZE) / (this.MAX_SIZE - this.MIN_SIZE)) * 100;
    this.elements.widthTrack.style.width = percent + '%';
    this.elements.widthHandle.style.left = percent + '%';
    this.elements.widthDisplay.textContent = this.currentWidth + 'px';
}

_updateHeightSlider(value) {
    this.currentHeight = Math.max(this.MIN_SIZE, Math.min(this.MAX_SIZE, value));
    const percent = ((this.currentHeight - this.MIN_SIZE) / (this.MAX_SIZE - this.MIN_SIZE)) * 100;
    this.elements.heightTrack.style.width = percent + '%';
    this.elements.heightHandle.style.left = percent + '%';
    this.elements.heightDisplay.textContent = this.currentHeight + 'px';
}
```

### destroy() の修正
```javascript
destroy() {
    // グローバルイベントリスナーの削除
    if (this.mouseMoveHandler) {
        document.removeEventListener('mousemove', this.mouseMoveHandler);
    }
    if (this.mouseUpHandler) {
        document.removeEventListener('mouseup', this.mouseUpHandler);
    }
    
    this.mouseMoveHandler = null;
    this.mouseUpHandler = null;
    this.elements = {};
    this.initialized = false;
}
```


===============================================
【改修完了チェックリスト】
===============================================

## BrushSettings API
- [ ] getOpacity() メソッド実装
- [ ] setOpacity() メソッド実装
- [ ] brush:opacity-changed イベント購読追加

## quick-access-popup.js
- [ ] クラス変数に mouseMoveHandler/mouseUpHandler 追加
- [ ] _cacheElements() メソッド追加
- [ ] show() で遅延初期化
- [ ] _attachEventListeners() でグローバルハンドラー設定
- [ ] _setupSizeSlider() を resize-slider.js パターンに書き換え
- [ ] _setupOpacitySlider() を resize-slider.js パターンに書き換え
- [ ] destroy() でイベントリスナー削除
- [ ] getOpacity() 呼び出しを全て修正

## resize-popup.js
- [ ] クラス変数に isDraggingWidth/Height 追加
- [ ] クラス変数に mouseMoveHandler/mouseUpHandler 追加
- [ ] _createSlider() メソッド削除
- [ ] _setupSliders() を resize-slider.js パターンに完全書き換え
- [ ] _updateWidthSlider() メソッド追加
- [ ] _updateHeightSlider() メソッド追加
- [ ] destroy() でイベントリスナー削除

## 動作確認
- [ ] resize-popup.js のスライダーが滑らかに動く
- [ ] quick-access-popup.js のペンサイズスライダーが動く
- [ ] quick-access-popup.js の透明度スライダーが動く
- [ ] ステップボタン（◀▶）が機能する
- [ ] スライダー領域クリックで値が変更される
- [ ] ポップアップ開閉でメモリリークしない


===============================================
【重要な実装ポイント】
===============================================

## 1. resize-slider.js の成功パターン

### ✅ 正しいイベントフロー
```
1. ハンドルに mousedown
   → isDragging = true に設定

2. document に mousemove（グローバル）
   → isDragging が true なら処理実行

3. document に mouseup（グローバル）
   → isDragging = false に設定
```

### ✅ スコープ管理
```javascript
// IIFE内のグローバル変数として定義
let isDraggingWidth = false;

// 関数内から参照可能
function handleMouseMove(e) {
    if (isDraggingWidth) {  // ✅ 常にアクセス可能
        // ...
    }
}
```

### ✅ クラス版への変換時の注意点
```javascript
// ❌ 間違い: ローカル変数
_createSlider() {
    let dragging = false;  // この変数はこの関数内でしか使えない
    
    const handleMove = (e) => {
        if (dragging) { ... }  // クロージャーで参照可能だが...
    };
    
    container.addEventListener('mousedown', () => {
        dragging = true;  // ここで設定しても
    });
    
    document.addEventListener('mousemove', handleMove);  // 動作するはず
}

// ✅ 正しい: クラス変数
constructor() {
    this.isDragging = false;  // クラス全体で共有
}

_setupSlider() {
    this.handle.addEventListener('mousedown', () => {
        this.isDragging = true;  // ✅
    });
    
    this.mouseMoveHandler = (e) => {
        if (this.isDragging) { ... }  // ✅ アロー関数でthis保持
    };
    
    document.addEventListener('mousemove', this.mouseMoveHandler);
}
```


## 2. アロー関数の重要性

### ❌ 通常の関数（this が変わる）
```javascript
_setupSlider() {
    document.addEventListener('mousemove', function(e) {
        if (this.isDragging) { ... }  // ❌ this は document を指す
    });
}
```

### ✅ アロー関数（this を保持）
```javascript
_setupSlider() {
    document.addEventListener('mousemove', (e) => {
        if (this.isDragging) { ... }  // ✅ this はクラスインスタンスを指す
    });
}
```

### ✅ 参照を保持する理由
```javascript
// ❌ 削除できない
document.addEventListener('mousemove', (e) => { ... });
// destroy() で削除不可能

// ✅ 削除できる
this.mouseMoveHandler = (e) => { ... };
document.addEventListener('mousemove', this.mouseMoveHandler);

destroy() {
    document.removeEventListener('mousemove', this.mouseMoveHandler);
}
```


## 3. DOM要素キャッシュのタイミング

### ❌ コンストラクタで即座に取得
```javascript
constructor() {
    this._createPanel();  // DOM生成
    this.slider = document.getElementById('slider');  // ❌ 取得できない可能性
}

_createPanel() {
    this.panel = document.createElement('div');
    this.panel.innerHTML = '<div id="slider">...</div>';
    // まだDOMに追加していない
}
```

### ✅ DOM追加後に取得
```javascript
constructor() {
    this._createPanel();  // DOM生成
}

_createPanel() {
    this.panel = document.createElement('div');
    this.panel.innerHTML = '<div id="slider">...</div>';
    document.body.appendChild(this.panel);  // ✅ DOM追加
}

show() {
    if (!this.initialized) {
        this._cacheElements();  // ✅ この時点で取得
        this.initialized = true;
    }
}

_cacheElements() {
    this.elements = {
        slider: document.getElementById('slider')  // ✅ 確実に存在
    };
}
```


## 4. イベントリスナーの重複登録防止

### ❌ 毎回登録
```javascript
show() {
    document.addEventListener('mousemove', this.mouseMoveHandler);
    // 何度も show() すると重複登録
}
```

### ✅ 一度だけ登録
```javascript
constructor() {
    this.initialized = false;
}

show() {
    if (!this.initialized) {
        document.addEventListener('mousemove', this.mouseMoveHandler);
        this.initialized = true;
    }
}
```


## 5. スライダー値の計算方法（resize-slider.js準拠）

```javascript
// 1. クリック位置からパーセンテージ計算
const rect = slider.getBoundingClientRect();
const percent = ((e.clientX - rect.left) / rect.width) * 100;

// 2. パーセンテージから値を計算
const value = MIN + ((MAX - MIN) * percent / 100);

// 3. 値をクランプ
const clampedValue = Math.max(MIN, Math.min(MAX, Math.round(value)));

// 4. UI更新
track.style.width = ((clampedValue - MIN) / (MAX - MIN) * 100) + '%';
handle.style.left = ((clampedValue - MIN) / (MAX - MIN) * 100) + '%';
display.textContent = clampedValue + 'px';
```


===============================================
【API不一致・断片化チェック結果】
===============================================

## 1. BrushSettings API の不統一

### 問題
- `getAlpha()` / `setAlpha()` → 0.0-1.0 範囲
- `getOpacity()` / `setOpacity()` → 存在しない（0-100%想定）

### 影響
- quick-access-popup.js が `getOpacity()` を呼び出してエラー
- UI側は 0-100% 表記、内部は 0.0-1.0 で不整合

### 解決策
BrushSettings に以下を追加：
```javascript
getOpacity() {
    return this.alpha * 100;
}

setOpacity(opacity) {
    this.setAlpha(opacity / 100);
}
```


## 2. EventBus イベント名の不統一

### 現状
```javascript
// BrushSettings.js で購読
'brush:size-changed'
'brush:color-changed'
'brush:alpha-changed'  // ← alpha

// quick-access-popup.js で発行
'brush:size-changed'
'brush:color-changed'
'brush:opacity-changed'  // ← opacity（受信されない）
```

### 問題
- alpha と opacity の表記揺れ
- EventBus経由の通知が正しく届かない

### 解決策
BrushSettings.subscribeToEvents() に追加：
```javascript
this.eventBus.on('brush:opacity-changed', ({ opacity }) => {
    this.setOpacity(opacity);
});
```


## 3. PopupManager統合の不完全性

### 現状
```javascript
// resize-popup.js
window.TegakiUI.ResizePopup  // ✅ 正しく登録

// quick-access-popup.js
window.TegakiUI.QuickAccessPopup  // ✅ 正しく登録

// PopupManager登録（core-initializer.js）
popupManager.register('quickAccess', ...)  // ✅
popupManager.register('resize', ...)  // ❌ 未登録
```

### 問題
- resize-popup.js が PopupManager に登録されていない
- ResizeSlider（IIFE版）が併存している

### 解決策
core-initializer.js に追加：
```javascript
popupManager.register('resize', window.TegakiUI.ResizePopup, {
    coreEngine: coreEngine,
    history: coreEngine.getHistory()
}, { priority: 5 });
```


## 4. 設定参照の混在

### 問題
```javascript
// BrushSettings から取得
window.BrushSettings?.getSize()

// TEGAKI_CONFIG から直接取得
window.TEGAKI_CONFIG.pen.size

// どちらが正なのか不明確
```

### 解決策
- BrushSettings を唯一の情報源とする
- TEGAKI_CONFIG は初期値のみに使用


## 5. 二重実装の存在

### resize-slider.js と resize-popup.js
- 同じ機能の IIFE版とクラス版が併存
- ResizeSlider.init() が呼ばれている

### 解決策
Phase 4完了後に resize-slider.js を削除
- core-initializer.js から ResizeSlider.init() 呼び出しを削除
- PopupManager経由のみで動作させる


===============================================
【デバッグ情報収集手順】
===============================================

## ステップ1: 環境確認
```javascript
// ブラウザコンソールで実行
console.log('=== Environment Check ===');
console.log('PIXI:', typeof PIXI);
console.log('TegakiEventBus:', typeof window.TegakiEventBus);
console.log('PopupManager:', typeof window.PopupManager);
console.log('BrushSettings:', typeof window.BrushSettings);
console.log('coreEngine:', typeof window.coreEngine);
```

## ステップ2: BrushSettings API確認
```javascript
console.log('=== BrushSettings API ===');
const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(window.BrushSettings));
console.log('Available methods:', methods);
console.log('Has getOpacity:', methods.includes('getOpacity'));
console.log('Has getAlpha:', methods.includes('getAlpha'));
console.log('Has setOpacity:', methods.includes('setOpacity'));
console.log('Has setAlpha:', methods.includes('setAlpha'));
```

## ステップ3: PopupManager 状態確認
```javascript
console.log('=== PopupManager Status ===');
window.PopupManager.diagnose();
```

## ステップ4: quick-access-popup DOM確認
```javascript
console.log('=== QuickAccessPopup DOM ===');
window.PopupManager.show('quickAccess');

setTimeout(() => {
    const elements = {
        sizeSlider: document.getElementById('pen-size-slider'),
        sizeHandle: document.getElementById('pen-size-handle'),
        sizeTrack: document.getElementById('pen-size-track'),
        opacitySlider: document.getElementById('pen-opacity-slider'),
        opacityHandle: document.getElementById('pen-opacity-handle'),
        opacityTrack: document.getElementById('pen-opacity-track')
    };
    
    console.log('Elements:', elements);
    
    Object.entries(elements).forEach(([key, el]) => {
        if (!el) {
            console.error(`❌ ${key} not found`);
        } else {
            console.log(`✅ ${key}:`, el.id);
        }
    });
}, 500);
```

## ステップ5: イベントリスナー確認
```javascript
console.log('=== Event Listeners ===');
const handle = document.getElementById('pen-size-handle');
if (handle) {
    const listeners = getEventListeners(handle);
    console.log('Handle listeners:', listeners);
}

const docListeners = getEventListeners(document);
console.log('Document mousemove count:', docListeners.mousemove?.length || 0);
console.log('Document mouseup count:', docListeners.mouseup?.length || 0);
```

## ステップ6: スライダー動作テスト
```javascript
console.log('=== Slider Operation Test ===');
const popup = window.PopupManager.get('quickAccess');

if (popup) {
    console.log('Popup instance:', popup);
    console.log('isDraggingSize:', popup.isDraggingSize);
    console.log('isDraggingOpacity:', popup.isDraggingOpacity);
    console.log('mouseMoveHandler:', typeof popup.mouseMoveHandler);
    console.log('mouseUpHandler:', typeof popup.mouseUpHandler);
    
    // 手動でスライダー更新
    if (popup._updateSizeSlider) {
        popup._updateSizeSlider(5.0);
        console.log('✅ Size slider updated to 5.0');
    }
    
    if (popup._updateOpacitySlider) {
        popup._updateOpacitySlider(50);
        console.log('✅ Opacity slider updated to 50%');
    }
}
```

## ステップ7: メモリリークテスト
```javascript
console.log('=== Memory Leak Test ===');
const initialCount = getEventListeners(document).mousemove?.length || 0;
console.log('Initial mousemove count:', initialCount);

for (let i = 0; i < 5; i++) {
    window.PopupManager.toggle('quickAccess');
}

setTimeout(() => {
    const finalCount = getEventListeners(document).mousemove?.length || 0;
    console.log('Final mousemove count:', finalCount);
    
    if (finalCount > initialCount) {
        console.error(`❌ Memory leak detected: ${finalCount - initialCount} listeners added`);
    } else {
        console.log('✅ No memory leak');
    }
}, 1000);
```


===============================================
【改修実施順序】
===============================================

## Phase 1: BrushSettings API統一（10分）
1. brush-settings.js を開く
2. getOpacity() メソッド追加
3. setOpacity() メソッド追加
4. subscribeToEvents() に brush:opacity-changed 購読追加
5. ブラウザリロードして確認

## Phase 2: quick-access-popup.js 修正（30分）
1. クラス変数追加（mouseMoveHandler等）
2. _cacheElements() メソッド追加
3. show() に遅延初期化追加
4. _attachEventListeners() を完全書き換え
5. _setupSizeSlider() を resize-slider.js パターンに書き換え
6. _setupOpacitySlider() を resize-slider.js パターンに書き換え
7. destroy() にイベントリスナー削除追加
8. 動作確認

## Phase 3: resize-popup.js 修正（30分）
1. クラス変数追加（isDragging等）
2. _createSlider() メソッド削除
3. _setupSliders() を完全書き換え
4. _updateWidthSlider() メソッド追加
5. _updateHeightSlider() メソッド追加
6. destroy() にイベントリスナー削除追加
7. 動作確認

## Phase 4: PopupManager統合（10分）
1. core-initializer.js に resize 登録追加
2. ResizeSlider.init() 呼び出し削除
3. 動作確認

## Phase 5: 最終検証（10分）
1. 全てのスライダーが動作するか確認
2. メモリリークがないか確認
3. EventBus通知が正しく動作するか確認


===============================================
【完了条件】
===============================================

1. ✅ resize-popup.js のスライダーが滑らかに動く
2. ✅ quick-access-popup.js のペンサイズスライダーが動く
3. ✅ quick-access-popup.js の透明度スライダーが動く
4. ✅ ステップボタン（◀▶）が全て機能する
5. ✅ スライダー領域クリックで値が変更される
6. ✅ ポップアップ開閉でメモリリークしない
7. ✅ BrushSettings の値が正しく反映される
8. ✅ EventBus 通知が正しく動作する
9. ✅ PopupManager 経由で全ポップアップが動作する
10. ✅ resize-slider.js（IIFE版）を削除しても動作する


===============================================
END OF DOCUMENT
==============================================================================================
Tegaki ポップアップシステム デバッグ・改修計画書 v3.0
根本原因分析版
===============================================

【実行日時】2025-10-23
【分析対象】quick-access-popup.js スライダー動作不良
【検証基準】resize-popup.js（動作確認済み）

===============================================
【前提条件の訂正】
===============================================

## 動作確認状況
- ✅ resize-slider.js（IIFE版）→ 動作確認済み
- ❌ resize-popup.js（クラス版）→ 動作しない
- ❌ quick-access-popup.js（クラス版）→ 動作しない

## 重要な示唆
resize-slider.js（IIFE版）のみが動作している
→ クラス変換時に何かが失われた可能性が高い

===============================================
【根本原因の特定】
===============================================

## 1. BrushSettings APIの不一致（最重要）

### 問題箇所
```javascript
// quick-access-popup.js:180-184
document.getElementById('pen-opacity-decrease').addEventListener('click', () => {
    const current = (window.BrushSettings?.getOpacity() || 1) * 100;  // ❌ エラー
    this._updateOpacitySlider(Math.max(MIN_OPACITY, current - 5));
});
```

### 原因
- BrushSettings.js には `getOpacity()` メソッドが存在しない
- 実装されているのは `getAlpha()` と `setAlpha()` のみ
- quick-access-popup.js は存在しないメソッドを呼び出している

### 影響範囲
- ペン透明度スライダー全体が機能不全
- ステップボタン（◀▶）クリック時に undefined エラー
- `_loadCurrentSettings()` での初期値取得も失敗

### 検証結果
```
BrushSettings.js 実装メソッド:
  ✅ getSize() / setSize()
  ✅ getColor() / setColor()
  ✅ getAlpha() / setAlpha()  ← 0.0-1.0 の範囲
  ❌ getOpacity() / setOpacity()  ← 存在しない
```


## 2. イベントリスナーのメモリリーク

### 問題箇所
```javascript
// quick-access-popup.js:131-147, 168-184
_setupSizeSlider() {
    const handleMouseMove = (e) => { ... };
    const handleMouseUp = () => { ... };
    
    // グローバルイベントリスナー登録
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    // ❌ 参照を保持していないため destroy() で削除できない
}
```

### 原因
- グローバルイベントリスナーへの参照を保持していない
- `destroy()` メソッドで削除できない
- ポップアップを開閉するたびにリスナーが累積

### 影響範囲
- メモリリーク発生
- ポップアップを何度も開くと動作が重くなる可能性

### 正しい実装（resize-popup.js参考）
```javascript
// クラス変数として参照を保持
constructor() {
    this.mouseMoveHandler = null;
    this.mouseUpHandler = null;
}

destroy() {
    if (this.mouseMoveHandler) {
        document.removeEventListener('mousemove', this.mouseMoveHandler);
    }
}
```


## 3. DOM要素キャッシュの不完全性

### 問題箇所
```javascript
// quick-access-popup.js:94-103
_createPanel() {
    // ... innerHTML設定 ...
    
    // DOM要素の取得（コンストラクタ直後）
    this.sizeSlider = document.getElementById('pen-size-slider');
    this.sizeTrack = document.getElementById('pen-size-track');
    // ...
}
```

### 原因
- `_createPanel()` 内でDOM要素を取得しているが、この時点でDOMに追加されていない可能性
- resize-popup.js は `_cacheElements()` という独立したメソッドで管理

### 影響範囲
- 初回表示時にスライダーが動作しない可能性
- 要素取得のタイミング問題


## 4. クラス変換時のthisバインディング喪失（最重要）

### resize-slider.js（IIFE版・動作確認済み）の実装
```javascript
function setupDragHandlers(elements) {
    const handleMouseMove = (e) => {
        if (isDraggingWidth) {  // ✅ グローバル変数を直接参照
            const rect = elements.widthSlider.getBoundingClientRect();
            // ...
        }
    };
    
    const handleMouseUp = () => {
        isDraggingWidth = false;  // ✅ グローバル変数を直接操作
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
}
```

### resize-popup.js（クラス版・動作不良）の実装
```javascript
_createSlider(options) {
    let dragging = false;  // ❌ ローカル変数
    
    const handleMouseDown = (e) => {
        dragging = true;  // ❌ ローカル変数を操作
        // ...
    };
    
    const handleMouseMove = (e) => {
        if (!dragging) return;  // ❌ ローカル変数を参照
        // ...
    };
    
    // ❌ handleMouseDown は container にバインド
    // ❌ handleMouseMove は document にバインド
    // → スコープが異なり、dragging 変数が共有されない可能性
    container.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
}
```

### 原因分析
1. **イベントリスナーの分離問題**
   - mousedown は container 要素にバインド
   - mousemove/mouseup は document にバインド
   - クロージャー内のローカル変数 dragging が正しく共有されない可能性

2. **thisコンテキストの喪失**
   - クラスメソッド内でアロー関数を使用しているが、_createSlider() の戻り値として返されたメソッドは this を保持しない
   - destroy() で参照が取れない

3. **ハンドルとスライダーの分離**
   - resize-slider.js: ハンドルに mousedown、document に mousemove/mouseup
   - resize-popup.js: container に mousedown、document に mousemove/mouseup
   - この違いが動作に影響している可能性

### 検証コマンド
```javascript
// ブラウザコンソールで実行
// 1. スライダーが存在するか確認
document.getElementById('canvas-width-slider')
document.getElementById('canvas-width-handle')

// 2. イベントリスナーの確認
getEventListeners(document.getElementById('canvas-width-handle'))
getEventListeners(document)

// 3. dragging 状態の確認（グローバル変数がないため確認不可）
```


## 5. 初期化フローの不統一

### 比較分析

#### resize-slider.js（IIFE版・動作確認済み）
```javascript
function init() {
    const elements = getElements();  // ✅ 要素を取得
    
    // ✅ 現在の設定を読み込み
    currentWidth = window.TEGAKI_CONFIG?.canvas?.width || 344;
    
    // ✅ スライダー初期化
    updateWidthSlider(currentWidth, elements);
    
    // ✅ イベントリスナー設定
    setupDragHandlers(elements);
    setupClickHandlers(elements);
}

// ✅ グローバル変数で状態管理
let isDraggingWidth = false;
let isDraggingHeight = false;
```

#### resize-popup.js（クラス版・動作不良）
```javascript
constructor(dependencies) {
    this.initialized = false;
    this._ensurePopupElement();  // DOM確保
}

show() {
    if (!this.initialized) {
        this.initialize();  // 遅延初期化
    }
}

_createSlider(options) {
    let dragging = false;  // ❌ ローカル変数（共有されない）
}
```

#### quick-access-popup.js（問題あり）
```javascript
constructor(config = {}) {
    // ❌ 初期化フラグなし
    this._init();  // 即座に初期化
}

_init() {
    this._createPanel();
    this._attachEventListeners();  // DOM追加前に実行される可能性
    this._loadCurrentSettings();
}
```

### 原因
- コンストラクタで即座に初期化している
- DOMが完全に構築される前にイベントリスナーを設定している可能性

### 推奨パターン
```javascript
constructor(config) {
    this.initialized = false;
    this._createPanel();  // DOM作成のみ
}

show() {
    if (!this.initialized) {
        this._attachEventListeners();  // 初回表示時に設定
        this.initialized = true;
    }
}
```


===============================================
【メソッド・シンボル辞典】
===============================================

## quick-access-popup.js

### クラス変数
```
this.config              - 設定オブジェクト
this.eventBus            - TegakiEventBus参照
this.panel               - ポップアップDOM要素
this.isVisible           - 表示状態フラグ
this.isDraggingSize      - サイズスライダードラッグ中フラグ
this.isDraggingOpacity   - 透明度スライダードラッグ中フラグ
this.sizeSlider          - サイズスライダーコンテナ
this.sizeTrack           - サイズスライダートラック
this.sizeHandle          - サイズスライダーハンドル
this.sizeDisplay         - サイズ表示要素
this.opacitySlider       - 透明度スライダーコンテナ
this.opacityTrack        - 透明度スライダートラック
this.opacityHandle       - 透明度スライダーハンドル
this.opacityDisplay      - 透明度表示要素

❌ 不足: mouseMoveHandler / mouseUpHandler の参照
```

### メソッド
```
constructor(config)            - コンストラクタ
_init()                        - 初期化処理
_createPanel()                 - DOM作成
_attachEventListeners()        - イベントリスナー設定
_setupSizeSlider()             - サイズスライダー設定
_setupOpacitySlider()          - 透明度スライダー設定
_updateSizeSlider(value)       - サイズスライダー更新
_updateOpacitySlider(value)    - 透明度スライダー更新
_loadCurrentSettings()         - 現在の設定読込
show()                         - 表示
hide()                         - 非表示
toggle()                       - 表示切替
isReady()                      - 準備完了確認
destroy()                      - 破棄

❌ 不足: initialize() メソッド（遅延初期化用）
```


## BrushSettings.js

### 実装済みAPI
```
getSize()              - サイズ取得
setSize(size)          - サイズ設定
getColor()             - 色取得
setColor(color)        - 色設定
getAlpha()             - 透明度取得（0.0-1.0）
setAlpha(alpha)        - 透明度設定（0.0-1.0）
getCurrentSettings()   - 現在の設定一括取得
setCurrentSettings()   - 設定一括設定
resetToDefaults()      - デフォルトにリセット
```

### ❌ 欠落しているAPI
```
getOpacity()           - 透明度取得（0-100%）← 実装されていない
setOpacity(opacity)    - 透明度設定（0-100%）← 実装されていない
```

### EventBus購読
```
brush:size-changed     - サイズ変更イベント
brush:color-changed    - 色変更イベント
brush:alpha-changed    - 透明度変更イベント

❌ 不統