# Drawing System Refactoring Plan v2.0
ベクター消しゴム実装のための段階的改修計画（最小侵襲アプローチ）

## 改修方針の転換

### v1.0の失敗分析
- ❌ Phase 1で既存APIを破壊
- ❌ ToolManager/DataManager等の大規模な抽象化を先行
- ❌ 初期化順序・依存関係が複雑化
- ❌ 段階的検証ができない

### v2.0の新方針
- ✅ **既存DrawingEngineは一切変更しない**
- ✅ **消しゴム機能を最小限の追加で実装**
- ✅ **各ステップで動作確認可能**
- ✅ **リファクタリングは動作後に実施**

---

## 前提条件の確認

### 既存システムの構造
```
DrawingEngine (改修前)
├─ settings: BrushSettings          // ブラシ設定管理
├─ recorder: StrokeRecorder         // ポイント記録
├─ renderer: StrokeRenderer         // 描画実行
├─ pressureHandler: PressureHandler // 筆圧処理
├─ transformer: StrokeTransformer   // スムージング
├─ currentPath: Object              // 描画中のパス
├─ isDrawing: boolean
└─ currentTool: 'pen' | 'eraser'
```

### データの所在
- **ストロークデータ**: `layerManager` → `activeLayer.layerData.paths[]`
- **Graphics**: 各path.graphics (PIXI.Graphics)
- **History**: window.History (undo/redo管理)

### 座標系
- **ワールド座標**: Canvas上の絶対座標 (cameraSystem.screenToCanvas変換後)
- **全ての計算はワールド座標で実施**

---

## Phase 0: ベクター演算基盤のみ追加

### 目的
消しゴムに必要な幾何演算機能を独立したユーティリティとして実装

### 新規作成ファイル

**system/drawing/processing/vector-operations.js**
```javascript
// 役割: ストローク幾何演算（既存システムに依存しない）
class VectorOperations {
  // 点と線分の距離計算
  static pointToSegmentDistance(point, segStart, segEnd) { }
  
  // 円とストロークの交差判定
  static testCircleStrokeIntersection(center, radius, points) { }
  
  // 円との交差でストロークを分割
  static splitStrokeByCircle(points, center, radius, minLength) {
    // 戻り値: 分割された複数のストローク配列
    // [ [point1, point2, ...], [point5, point6, ...] ]
  }
  
  // ストロークの長さ計算
  static calculateStrokeLength(points) { }
}
```

**依存関係**: なし（純粋な数学関数）

### 検証方法
```javascript
// コンソールでテスト
const points = [{x:0,y:0}, {x:100,y:0}, {x:100,y:100}];
const result = VectorOperations.splitStrokeByCircle(
  points, 
  {x:50, y:0}, 
  20, 
  5
);
console.log('分割結果:', result);
```

### 完了条件
- [ ] vector-operations.js が独立して動作
- [ ] splitStrokeByCircle が正しく分割
- [ ] 既存システムに影響なし

---

## Phase 1: 消しゴムツール最小実装

### 目的
DrawingEngineに消しゴム機能を**追加**（既存コードは変更しない）

### 改修ファイル

**system/drawing/drawing-engine.js**
- **変更方針**: 既存メソッドは一切変更せず、新規メソッドのみ追加

```javascript
class DrawingEngine {
  // === 既存コードは全て維持 ===
  constructor() { /* 既存のまま */ }
  startDrawing() { /* 既存のまま */ }
  continueDrawing() { /* 既存のまま */ }
  stopDrawing() { 
    // 既存処理の最後に追加
    if (this.currentTool === 'eraser' && this.currentPath) {
      this.applyEraserEffect(this.currentPath);
    }
    // 以降は既存のまま
  }
  
  // === 新規追加メソッド ===
  
  /**
   * 消しゴム効果の適用
   * currentPathで描いた軌跡に沿って、既存ストロークを削除/分割
   */
  applyEraserEffect(eraserPath) {
    const eraserPoints = eraserPath.points;
    const eraserRadius = eraserPath.size / 2;
    
    // アクティブレイヤーから全ストローク取得
    const activeLayer = this.layerManager.getActiveLayer();
    if (!activeLayer?.layerData?.paths) return;
    
    const affectedPaths = [];
    const modifications = []; // { original, segments }
    
    // 各ストロークに対して消去判定
    for (const path of activeLayer.layerData.paths) {
      if (path === eraserPath) continue; // 自身はスキップ
      
      let hasIntersection = false;
      
      // 消しゴムの軌跡上の各点で判定
      for (const eraserPoint of eraserPoints) {
        if (VectorOperations.testCircleStrokeIntersection(
          eraserPoint, 
          eraserRadius, 
          path.points
        )) {
          hasIntersection = true;
          break;
        }
      }
      
      if (hasIntersection) {
        // 分割実行
        const segments = this.splitPathByEraserTrail(
          path, 
          eraserPoints, 
          eraserRadius
        );
        modifications.push({ original: path, segments });
      }
    }
    
    // 変更を適用
    this.applyPathModifications(modifications);
  }
  
  /**
   * 消しゴムの軌跡全体でパスを分割
   */
  splitPathByEraserTrail(path, eraserPoints, eraserRadius) {
    let remainingPoints = [...path.points];
    
    // 消しゴムの各点で順次分割
    for (const eraserPoint of eraserPoints) {
      const newSegments = [];
      
      for (const segment of remainingPoints) {
        if (Array.isArray(segment)) {
          const splits = VectorOperations.splitStrokeByCircle(
            segment,
            eraserPoint,
            eraserRadius,
            5 // 最小長さ閾値
          );
          newSegments.push(...splits);
        }
      }
      
      remainingPoints = newSegments.length > 0 ? newSegments : [remainingPoints];
    }
    
    return remainingPoints;
  }
  
  /**
   * パス変更の適用とHistory記録
   */
  applyPathModifications(modifications) {
    const activeLayer = this.layerManager.getActiveLayer();
    const removedPaths = [];
    const addedPaths = [];
    
    for (const { original, segments } of modifications) {
      // 元のパスを削除
      removedPaths.push(original);
      activeLayer.layerData.paths = 
        activeLayer.layerData.paths.filter(p => p !== original);
      
      if (original.graphics) {
        activeLayer.removeChild(original.graphics);
        original.graphics.destroy();
      }
      
      // 分割後のパスを追加
      for (const segmentPoints of segments) {
        if (segmentPoints.length < 2) continue;
        
        const newPath = {
          ...original,
          points: segmentPoints,
          graphics: new PIXI.Graphics()
        };
        
        // 再描画
        const options = {
          ...original.strokeOptions,
          color: original.color,
          alpha: original.opacity
        };
        this.renderer.renderStroke(segmentPoints, options, newPath.graphics);
        
        activeLayer.addChild(newPath.graphics);
        activeLayer.layerData.paths.push(newPath);
        addedPaths.push(newPath);
      }
    }
    
    // History記録
    if (window.History && removedPaths.length > 0) {
      const layerIndex = this.layerManager.activeLayerIndex;
      const command = {
        name: 'eraser-applied',
        undo: () => {
          // 追加したパスを削除
          const layer = this.layerManager.layers[layerIndex];
          for (const path of addedPaths) {
            layer.layerData.paths = 
              layer.layerData.paths.filter(p => p !== path);
            if (path.graphics) {
              layer.removeChild(path.graphics);
              path.graphics.destroy();
            }
          }
          // 元のパスを復元
          for (const path of removedPaths) {
            layer.layerData.paths.push(path);
            layer.addChild(path.graphics);
          }
          this.layerManager.requestThumbnailUpdate(layerIndex);
        },
        do: () => {
          // 元のパスを削除
          const layer = this.layerManager.layers[layerIndex];
          for (const path of removedPaths) {
            layer.layerData.paths = 
              layer.layerData.paths.filter(p => p !== path);
            if (path.graphics) {
              layer.removeChild(path.graphics);
              path.graphics.destroy();
            }
          }
          // 分割後を追加
          for (const path of addedPaths) {
            layer.layerData.paths.push(path);
            layer.addChild(path.graphics);
          }
          this.layerManager.requestThumbnailUpdate(layerIndex);
        },
        meta: { type: 'eraser', layerIndex }
      };
      window.History.push(command);
    }
    
    this.layerManager.requestThumbnailUpdate();
  }
}
```

### 検証方法
```javascript
// 1. ペンで描画（既存機能）
drawingEngine.setTool('pen');
// マウスで描画

// 2. 消しゴムに切り替え
drawingEngine.setTool('eraser');
// マウスで描画（ストロークが削除されるはず）

// 3. Undo/Redoテスト
window.History.undo();
window.History.redo();
```

### 完了条件
- [ ] ペン描画が既存通り動作
- [ ] 消しゴムでストロークが削除される
- [ ] 部分削除時に分割される
- [ ] Undo/Redoが動作
- [ ] 既存機能に影響なし

---

## Phase 2: 消しゴムUX改善

### 目的
消しゴムの視覚的フィードバックとパフォーマンス向上

### 改修内容

**system/drawing/drawing-engine.js**
```javascript
class DrawingEngine {
  continueDrawing(screenX, screenY, pressureOrEvent) {
    // 既存処理...
    
    // 消しゴムモード時: プレビュー円を表示
    if (this.currentTool === 'eraser') {
      this.updateEraserPreview(canvasPoint);
    }
  }
  
  updateEraserPreview(worldPos) {
    if (!this.eraserPreviewGraphics) {
      this.eraserPreviewGraphics = new PIXI.Graphics();
      this.layerManager.getActiveLayer().addChild(this.eraserPreviewGraphics);
    }
    
    this.eraserPreviewGraphics.clear();
    this.eraserPreviewGraphics.circle(worldPos.x, worldPos.y, this.brushSize / 2);
    this.eraserPreviewGraphics.stroke({ width: 1, color: 0xFF0000, alpha: 0.5 });
  }
}
```

**最適化**:
- 消しゴム軌跡のサンプリング間隔を調整
- 大量ストローク時の空間分割検索（将来）

### 検証方法
```javascript
// 消しゴムカーソルが表示されるか確認
drawingEngine.setTool('eraser');
// マウス移動で赤い円が追従するはず
```

### 完了条件
- [ ] 消しゴムカーソルが表示
- [ ] 高速移動でも途切れない消去
- [ ] 100ストローク描画でも60fps維持

---

## Phase 3: アーキテクチャ整理（オプション）

### 目的
動作確認後のリファクタリング（必須ではない）

### 実施内容
- ツール抽象化（PenTool/EraserTool分離）
- DataManager導入
- レンダリングパイプライン整理

**前提**: Phase 1-2が完璧に動作している場合のみ実施

---

## 段階的チェックリスト

### Phase 0
```javascript
// ✅ vector-operations.js 読み込み確認
console.log('VectorOperations:', window.TegakiDrawing?.VectorOperations);

// ✅ 分割テスト
const testPoints = [{x:0,y:0},{x:100,y:0}];
const result = VectorOperations.splitStrokeByCircle(testPoints, {x:50,y:0}, 10, 5);
console.log('分割結果:', result);
```

### Phase 1
```javascript
// ✅ DrawingEngine初期化確認
console.log('DrawingEngine:', window.drawingEngine);
console.log('既存メソッド:', typeof drawingEngine.startDrawing);
console.log('新規メソッド:', typeof drawingEngine.applyEraserEffect);

// ✅ ペン描画テスト
drawingEngine.setTool('pen');
// 描画...

// ✅ 消しゴムテスト
drawingEngine.setTool('eraser');
// 描画（既存ストロークを横切る）

// ✅ レイヤー確認
const layer = layerManager.getActiveLayer();
console.log('ストローク数:', layer.layerData.paths.length);
```

### Phase 2
```javascript
// ✅ プレビュー確認
drawingEngine.setTool('eraser');
// マウス移動でカーソル表示確認

// ✅ パフォーマンステスト
// 100本のストロークを描画
for (let i = 0; i < 100; i++) {
  // ペンで描画...
}
// FPS確認: Ctrl+Shift+I → Performance モニター
```

---

## 改修時の厳守事項

### DO
- ✅ 各Phase完了後に必ず動作確認
- ✅ 既存コードはコメントアウトせず残す
- ✅ 新規メソッドは既存メソッドの後に追加
- ✅ console.log は最小限（エラー時のみ）
- ✅ 座標はワールド座標で統一

### DON'T
- 🚫 既存メソッドの引数・戻り値を変更
- 🚫 複数Phaseを同時に実装
- 🚫 動作確認前に次のPhaseへ進む
- 🚫 localStorage使用
- 🚫 APIの二重実装

---

## ロールバック手順

各Phase失敗時の対応:

**Phase 0失敗**: vector-operations.js を削除
**Phase 1失敗**: drawing-engine.js を元ファイルに戻す
**Phase 2失敗**: Phase 1の状態に戻す（新規メソッドのみ削除）

---

## 最終ゴール

```
【Phase 0-1完了時点】
- ペン描画: 既存通り動作 ✅
- 消しゴム: ストローク削除・分割が動作 ✅
- Undo/Redo: 正常動作 ✅
- 既存機能: 一切影響なし ✅

【Phase 2完了時点】
- 消しゴムカーソル表示 ✅
- パフォーマンス最適化 ✅

【Phase 3（オプション）】
- コード整理・抽象化
- 将来の拡張性確保
```

このアプローチなら、各ステップで確実に動作確認しながら進められます。