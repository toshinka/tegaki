# サムネイル生成方式の完全比較表

## 🔍 調査結果サマリー

### Canvas2D使用状況

| ファイル | メソッド | Canvas2D使用 | 用途 | 行番号 |
|---------|---------|------------|------|-------|
| **thumbnail-system.js** | `generateFrameThumbnail()` | ✅ **使用** | フレームサムネイルのリサイズ | L263-268 |
| **thumbnail-system.js** | `_renderLayerThumbnail()` | ❌ 不使用 | レイヤーサムネイル生成 | L200-220 |
| **animation-system.js** | `generateFrameThumbnail()` | ✅ **使用** | タイムラインサムネイル | L754-783 |
| **layer-panel-renderer.js** | `_generateAndDisplayThumbnail()` | ❌ 不使用 | レイヤーパネル表示 | L156-191 |

### 問題の核心

**レイヤーサムネイルは生成されていない（layerCacheSize: 0）**
→ `layer-panel-renderer.js` が `ThumbnailSystem.generateLayerThumbnail()` を呼んでいるが、**キャッシュに保存されていない**

---

## 📊 詳細比較表

### 1. レイヤーサムネイル生成（レイヤーパネル用）

#### A. thumbnail-system.js: `generateLayerThumbnail()`

```javascript
// 呼び出し元: layer-panel-renderer.js
// Canvas2D使用: ❌ なし（PixiJS extract.canvas()のみ）
```

| 項目 | 実装内容 | 座標系 |
|------|---------|-------|
| **レンダリング方式** | `app.renderer.render({ container: layer, target: rt })` | レイヤーのローカル座標 |
| **Canvas生成** | `app.renderer.extract.canvas(rt)` | PixiJS内部処理 |
| **Canvas2D使用** | ❌ なし | - |
| **キャッシュキー** | `layer_${layerId}_${width}_${height}_${transform}` | transform = position/rotation/scale |
| **Transform反映** | ✅ キャッシュキーに含む | layer.position, layer.rotation, layer.scale |
| **Vモード対応** | ✅ `vKeyModeActive` でキャッシュスキップ | - |

**問題点:**
```javascript
// L153-167: キャッシュ生成コード
const canvas = await this._renderLayerThumbnail(layer, width, height);

if (canvas) {
    // キャッシュに保存
    this.layerThumbnailCache.set(cacheKey, canvas);
}
```

**しかし、実際には `layerCacheSize: 0` = キャッシュが空**

**原因候補:**
1. `generateLayerThumbnail()` が呼ばれていない
2. `_renderLayerThumbnail()` が `null` を返している
3. レイヤーの `position/rotation/scale` が変化しているためキャッシュヒットしない

---

#### B. layer-panel-renderer.js: `_generateAndDisplayThumbnail()`

```javascript
// 呼び出し: createThumbnail() → _generateAndDisplayThumbnail()
// Canvas2D使用: ❌ なし
```

| 項目 | 実装内容 | 備考 |
|------|---------|------|
| **呼び出し** | `ThumbnailSystem.generateLayerThumbnail(layer, 64, 64)` | thumbnail-system.js に委譲 |
| **Canvas2D** | ❌ なし | - |
| **DataURL変換** | `canvas.toDataURL('image/png')` | Canvas2D API使用 |
| **img要素表示** | `img.src = dataURL` | DOM更新 |

**問題点:**
```javascript
// L180-182: DataURL変換でCanvas2D API使用
const dataURL = canvas.toDataURL('image/png');
img.src = dataURL;
```

**Canvas2D使用箇所:**
- `canvas.toDataURL()` - Canvas2D APIだがPixiJSが生成したCanvasに対して使用
- 運用ガイドライン違反ではあるが、**サムネイル未生成問題とは無関係**

---

### 2. フレームサムネイル生成（タイムライン用）

#### A. thumbnail-system.js: `generateFrameThumbnail()`

```javascript
// 呼び出し元: animation-system.js
// Canvas2D使用: ✅ あり（リサイズ処理）
```

| 項目 | 実装内容 | Canvas2D使用 |
|------|---------|-------------|
| **フルサイズレンダリング** | `app.renderer.render({ container: frame, target: fullRT })` | ❌ |
| **Canvas取得** | `app.renderer.extract.canvas(fullRT)` | ❌ |
| **リサイズCanvas作成** | `document.createElement('canvas')` | ✅ Canvas2D |
| **リサイズ描画** | `ctx.drawImage(fullCanvas, 0, 0, thumbWidth, thumbHeight)` | ✅ Canvas2D |
| **キャッシュ保存** | `frameThumbnailCache.set(cacheKey, thumbCanvas)` | - |

**Canvas2D使用箇所（L263-268）:**
```javascript
const thumbCanvas = document.createElement('canvas');
thumbCanvas.width = thumbWidth;
thumbCanvas.height = thumbHeight;
const ctx = thumbCanvas.getContext('2d');

ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';
ctx.drawImage(fullCanvas, 0, 0, thumbWidth, thumbHeight);
```

**運用ガイドライン違反:**
- ✅ 禁止事項に該当（Canvas2D完全禁止）
- 代替手段: PixiJS RenderTexture でリサイズ

---

#### B. animation-system.js: `generateFrameThumbnail()`

```javascript
// 呼び出し元: timeline-ui.js
// Canvas2D使用: ✅ あり（リサイズ処理）
```

| 項目 | 実装内容 | Canvas2D使用 |
|------|---------|-------------|
| **RenderTexture取得** | `layerSystem.getFrameRenderTexture(frame.id)` | ❌ |
| **Canvas取得** | `app.renderer.extract.canvas(renderTexture)` | ❌ |
| **リサイズCanvas作成** | `document.createElement('canvas')` | ✅ Canvas2D |
| **アスペクト比計算** | 手動計算（offsetX, offsetY） | - |
| **リサイズ描画** | `ctx.drawImage(sourceCanvas, ...)` | ✅ Canvas2D |
| **frame保存** | `frame.thumbnailCanvas = thumbCanvas` | - |

**Canvas2D使用箇所（L754-783）:**
```javascript
const thumbCanvas = document.createElement('canvas');
thumbCanvas.width = thumbDisplayW;
thumbCanvas.height = thumbDisplayH;

const ctx = thumbCanvas.getContext('2d');
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

// アスペクト比を保持してリサイズ
ctx.drawImage(
    sourceCanvas, 
    0, 0, sourceCanvas.width, sourceCanvas.height,
    offsetX, offsetY, drawW, drawH
);

frame.thumbnailCanvas = thumbCanvas;
```

**運用ガイドライン違反:**
- ✅ 禁止事項に該当（Canvas2D完全禁止）

---

## 🔥 座標系とローカル座標の管理

### レイヤーサムネイル（問題あり）

| 要素 | 座標系 | Transform適用 | 問題 |
|------|-------|--------------|------|
| **レイヤーコンテナ** | World座標系（親: worldContainer） | ✅ position/rotation/scale | - |
| **PixiJS render()** | レイヤーのローカル座標でレンダリング | ✅ Transform自動適用 | - |
| **キャッシュキー** | `${pos.x}_${pos.y}_${rot}_${scale.x}_${scale.y}` | ✅ Transform値を含む | **Vモードで毎回変化 → キャッシュミス** |
| **座標変換** | coordinate-system.js 未使用 | - | **worldToLocal()を使っていない** |

**問題:**
```javascript
// キャッシュキー生成（L143-146）
const pos = layer.position;
const rot = layer.rotation;
const scale = layer.scale;
const transform = `${pos.x.toFixed(2)}_${pos.y.toFixed(2)}_${rot.toFixed(4)}_${scale.x.toFixed(3)}_${scale.y.toFixed(3)}`;
```

**Vモードでドラッグすると:**
- `layer.position` が毎フレーム変化
- `transform` 文字列が毎回変化
- キャッシュキーが一致しない → 毎回 `_renderLayerThumbnail()` 実行
- しかし `vKeyModeActive = true` なのでキャッシュに保存されない（L132-135）
- **結果: キャッシュが永遠に空（layerCacheSize: 0）**

---

### フレームサムネイル（Canvas2D問題）

| 要素 | 座標系 | Transform適用 | 問題 |
|------|-------|--------------|------|
| **フレームコンテナ** | World座標系 | ✅ 全レイヤーを含む | - |
| **RenderTexture** | フルサイズ（canvasWidth × canvasHeight） | ✅ 全Transform適用 | - |
| **Canvas2Dリサイズ** | サムネイルサイズ（72×54等） | ✅ アスペクト比保持 | **Canvas2D使用** |
| **キャッシュキー** | `frame_${frameId}_${canvasWidth}_${canvasHeight}_${thumbWidth}_${thumbHeight}` | ✅ 固定値 | キャッシュヒット率高い |

**問題:**
- Canvas2D使用（運用ガイドライン違反）
- しかし **タイムラインサムネイルは正常動作している**
- **レイヤーサムネイルとの差異 = キャッシュ戦略の違い**

---

## 🎯 根本原因の特定

### レイヤーサムネイルが生成されない理由

#### 原因1: Vモード中のキャッシュ無効化

```javascript
// thumbnail-system.js L132-135
if (this.disableCacheDuringVMode && this.vKeyModeActive) {
    return await this._renderLayerThumbnail(layer, width, height);
}
```

**問題:**
- Vモード中は `_renderLayerThumbnail()` を直接呼び出し
- **キャッシュに保存されない**
- Vモード終了後もキャッシュは空のまま

#### 原因2: Vモード終了後のキャッシュ再生成なし

```javascript
// thumbnail-system.js L50-57
this.eventBus.on('keyboard:vkey-released', () => {
    this.vKeyModeActive = false;
});
```

**問題:**
- Vモード終了時にキャッシュを再生成していない
- **サムネイルが古いまま**

#### 原因3: Transform値のキャッシュキー問題

```javascript
// キャッシュキー: layer_${layerId}_64_64_${transform}
// transform = position/rotation/scaleの文字列化
```

**問題:**
- Vモードでレイヤーを動かすと毎回違うキャッシュキー
- 元の位置に戻してもキャッシュヒットしない（小数点誤差）
- **キャッシュが無限に増える可能性**

---

### タイムラインサムネイルが動作する理由

#### 成功要因1: フレーム単位のキャッシュ

```javascript
// キャッシュキー: frame_${frameId}_${canvasWidth}_${canvasHeight}_${thumbWidth}_${thumbHeight}
```

**利点:**
- `frameId` は固定（フレーム削除まで不変）
- `canvasWidth/Height` もリサイズしない限り固定
- **キャッシュヒット率が高い**

#### 成功要因2: 明示的な再生成トリガー

```javascript
// timeline-ui.js L184
this.eventBus.on('layer:transform-updated', ({ layerId }) => {
    this.requestThumbnailUpdate();
});

// L194-200: 即時更新（0ms遅延）
requestThumbnailUpdate() {
    this.thumbnailUpdateTimer = setTimeout(() => {
        this.updateCurrentFrameThumbnail();
    }, 0);
}
```

**利点:**
- `layer:transform-updated` で即座に更新リクエスト
- **throttleがほぼ無い（0ms）**
- `generateFrameThumbnail()` が確実に呼ばれる

---

## 🛠️ 修正方針

### Phase 1: Vモード終了時のキャッシュ再生成

**thumbnail-system.js 修正:**

```javascript
this.eventBus.on('keyboard:vkey-released', () => {
    this.vKeyModeActive = false;
    
    // Vモード終了時に全レイヤーサムネイルを再生成
    const layerMgr = window.CoreRuntime?.internal?.layerManager;
    if (layerMgr) {
        const layers = layerMgr.getLayers();
        layers.forEach((layer, index) => {
            // キャッシュクリア
            this._invalidateLayerCacheByLayerId(layer.layerData?.id);
            
            // 再生成トリガー
            this.eventBus.emit('thumbnail:layer-updated', {
                component: 'thumbnail-system',
                action: 'vmode-exit-refresh',
                data: { layerIndex: index, layerId: layer.layerData?.id, immediate: true }
            });
        });
    }
});
```

---

### Phase 2: キャッシュキー戦略の変更

**thumbnail-system.js 修正:**

```javascript
// 現状: transform値をキャッシュキーに含む
const transform = `${pos.x.toFixed(2)}_${pos.y.toFixed(2)}_${rot.toFixed(4)}_${scale.x.toFixed(3)}_${scale.y.toFixed(3)}`;
const cacheKey = `layer_${layerId}_${width}_${height}_${transform}`;

// ↓ 修正案1: layerIdのみをキーにする（タイムライン方式）
const cacheKey = `layer_${layerId}_${width}_${height}`;

// ↓ 修正案2: paths更新回数をキーに含む
const pathsVersion = layer.layerData?.paths?.length || 0;
const cacheKey = `layer_${layerId}_${width}_${height}_${pathsVersion}`;
```

**トレードオフ:**
- 修正案1: Transform変更が反映されない（Vモード操作が見えない）
- 修正案2: ストローク追加のみ検知、Transform変更は検知できない

**推奨: 修正案1 + 明示的な無効化**
- キャッシュキーは `layerId` のみ
- `layer:transform-updated` で明示的に無効化
- Vモード終了時に再生成

---

### Phase 3: Canvas2D撲滅（運用ガイドライン準拠）

#### 方法A: PixiJS RenderTextureでリサイズ

**thumbnail-system.js と animation-system.js 両方を修正:**

```javascript
// Canvas2D使用コード（削除）
const thumbCanvas = document.createElement('canvas');
const ctx = thumbCanvas.getContext('2d');
ctx.drawImage(fullCanvas, 0, 0, thumbWidth, thumbHeight);

// ↓ PixiJS RenderTexture使用（追加）
const thumbRT = PIXI.RenderTexture.create({
    width: thumbWidth,
    height: thumbHeight,
    resolution: 1
});

// スケールを計算
const scaleX = thumbWidth / fullCanvas.width;
const scaleY = thumbHeight / fullCanvas.height;

// 一時スプライト作成
const tempSprite = PIXI.Sprite.from(fullRT);
tempSprite.scale.set(scaleX, scaleY);

// リサイズレンダリング
this.app.renderer.render({
    container: tempSprite,
    target: thumbRT
});

// Canvas取得
const thumbCanvas = this.app.renderer.extract.canvas(thumbRT);

// クリーンアップ
tempSprite.destroy();
thumbRT.destroy();
```

**利点:**
- Canvas2D完全撲滅
- PixiJS内で完結
- GPU加速によるパフォーマンス向上

---

#### 方法B: ライブラリ使用（Pica.js等）

**デメリット:**
- 外部ライブラリ依存
- ガイドライン「ライブラリ有効活用」には合致
- しかしCanvas2D APIを内部で使用している可能性

**非推奨**

---

## 📋 完全修正チェックリスト

### Phase 1: Vモード終了時の再生成（優先度: 最高）

- [ ] `thumbnail-system.js`: `keyboard:vkey-released` 購読に再生成処理追加
- [ ] Vモード終了後にレイヤーサムネイルが更新されることを確認
- [ ] `layerCacheSize > 0` になることを確認

### Phase 2: キャッシュキー戦略変更（優先度: 高）

- [ ] `thumbnail-system.js`: `generateLayerThumbnail()` のキャッシュキー生成を修正
- [ ] `layerId` のみをキーにする方式に変更
- [ ] `layer:transform-updated` でキャッシュ無効化を確認

### Phase 3: Canvas2D撲滅（優先度: 中）

- [ ] `thumbnail-system.js`: `generateFrameThumbnail()` を PixiJS RenderTexture 方式に変更
- [ ] `animation-system.js`: `generateFrameThumbnail()` を PixiJS RenderTexture 方式に変更
- [ ] Canvas2D API（`getContext('2d')`）の使用が0件になることを確認

### Phase 4: 統一性確保（優先度: 中）

- [ ] レイヤーサムネイルとフレームサムネイルの生成方式を統一
- [ ] 両方とも PixiJS RenderTexture のみ使用
- [ ] キャッシュ戦略を統一（layerId/frameIdのみをキーにする）

---

## 🎯 推奨修正順序

1. **Phase 1実施** → サムネイル未生成問題の即時解決（30分）
2. **Phase 2実施** → キャッシュ効率化（1時間）
3. **動作確認** → Vモード・タイムライン両方でサムネイル確認
4. **Phase 3実施** → Canvas2D撲滅（2時間）
5. **Phase 4実施** → 最終統一（1時間）

**合計所要時間: 4.5時間**

---

## 📚 参考情報

### PixiJS RenderTexture リサイズの実装例

```javascript
function resizeRenderTexture(sourceRT, targetWidth, targetHeight, renderer) {
    // 出力用RenderTexture作成
    const outputRT = PIXI.RenderTexture.create({
        width: targetWidth,
        height: targetHeight,
        resolution: 1
    });
    
    // ソースからスプライト作成
    const sprite = PIXI.Sprite.from(sourceRT);
    
    // スケール計算（アスペクト比保持）
    const scaleX = targetWidth / sourceRT.width;
    const scaleY = targetHeight / sourceRT.height;
    const scale = Math.min(scaleX, scaleY);
    
    sprite.scale.set(scale, scale);
    
    // 中央配置
    sprite.x = (targetWidth - sourceRT.width * scale) / 2;
    sprite.y = (targetHeight - sourceRT.height * scale) / 2;
    
    // レンダリング
    renderer.render({
        container: sprite,
        target: outputRT,
        clear: true
    });
    
    // スプライトクリーンアップ
    sprite.destroy();
    
    return outputRT;
}
```

---

## 🔗 関連ファイル

- `thumbnail-system.js` - レイヤー・フレームサムネイル生成の中核
- `animation-system.js` - タイムラインサムネイル生成
- `layer-panel-renderer.js` - レイヤーパネルUI・サムネイル表示
- `timeline-ui.js` - タイムラインUI・サムネイル表示
- `coordinate-system.js` - 座標変換（レイヤーサムネイルで未使用）

---

**次のアクション: Phase 1の修正ファイルを作成しますか？**