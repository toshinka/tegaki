═══════════════════════════════════════════════════════════════
サムネイル即時更新・改修計画書 v1.0
═══════════════════════════════════════════════════════════════
対象問題: レイヤーサムネイル更新遅延
作成日: 2025-10-28
対象バージョン: v8.13_Drawing_54
═══════════════════════════════════════════════════════════════

【現状の問題】

1. Vモード変形中、アクティブレイヤーのサムネイル更新が遅延
2. 回転・拡縮の変形がサムネイルに即座に反映されない
3. 非アクティブレイヤーのサムネイル更新が大幅遅延
4. layer:transform-updated イベント発火後も実際の更新が遅い

【根本原因】

- generateLayerThumbnailCanvas() が変形行列を適用していない
- サムネイル生成時に layer.position/rotation/scale を反映していない
- setTimeout() による遅延処理が多すぎる（50ms, 100ms, 150ms）
- Canvas2D の ctx.save()/restore() が正しく使われていない

───────────────────────────────────────────────────────────

【Phase 1: サムネイル生成に変形適用】

■ 改修ファイル
ui/layer-panel-renderer.js

■ 参考ファイル
system/layer-transform.js (transforms Map、applyTransform)
config.js (canvas.width/height)

■ 改修箇所
generateLayerThumbnailCanvas() メソッド

■ 改修内容
1. layerTransform.getTransform(layerId) で変形データ取得
2. Canvas2D に ctx.save() → ctx.translate(centerX, centerY)
3. ctx.rotate(transform.rotation)
4. ctx.scale(transform.scaleX, transform.scaleY)
5. ctx.translate(-centerX, -centerY)
6. この変形後の座標系でパスを描画
7. ctx.restore()

■ 使用メソッド
- window.layerTransform?.getTransform(layerId)
- ctx.save() / ctx.restore()
- ctx.translate(x, y)
- ctx.rotate(angleInRadians)
- ctx.scale(sx, sy)

■ 座標系
- Canvas2D のコンテキスト変換
- キャンバス中心 (centerX, centerY) を pivot として変形
- パスポイントはローカル座標のまま描画

■ 検証項目
□ Vモード中に回転したレイヤーのサムネイルが回転表示
□ 拡大縮小がサムネイルに即座に反映
□ 水平/垂直反転がサムネイルに反映
□ 移動（position）がサムネイル内で正しく表示

───────────────────────────────────────────────────────────

【Phase 2: イベント購読の最適化】

■ 改修ファイル
ui/layer-panel-renderer.js

■ 参考ファイル
system/layer-transform.js (_emitTransformUpdated)

■ 改修箇所
_setupEventListeners() メソッド

■ 改修内容
1. layer:transform-updated の setTimeout を 50ms → 0ms に短縮
2. requestAnimationFrame() を使った即時更新に変更
3. 更新フラグで連続呼び出しを防止（debounce不要）

■ 実装パターン
```javascript
this.eventBus.on('layer:transform-updated', ({ layerId }) => {
    if (this.updateScheduled) return;
    this.updateScheduled = true;
    
    requestAnimationFrame(() => {
        this.updateAllThumbnails();
        this.updateScheduled = false;
    });
});
```

■ 検証項目
□ layer:transform-updated 発火後、次フレームでサムネイル更新
□ 連続変形中も過剰更新が発生しない
□ UI がブロックされない

───────────────────────────────────────────────────────────

【Phase 3: 全レイヤーサムネイル即時更新】

■ 改修ファイル
ui/layer-panel-renderer.js

■ 参考ファイル
system/layer-system.js (getLayers)

■ 改修箇所
updateAllThumbnails() メソッド

■ 改修内容
1. 現在の実装を維持（全レイヤーをループ）
2. generateLayerThumbnailCanvas() が Phase 1 で変形対応済み
3. 非同期処理を削除し同期処理に統一
4. DOM 更新を innerHTML ではなく replaceChild で最適化

■ 最適化ポイント
- forEach を使った同期ループ（async/await 不要）
- サムネイル生成は軽量（Canvas2D のみ）
- PixiJS の extract.canvas() を使わない

■ 検証項目
□ 全レイヤーのサムネイルが同時更新される
□ 非アクティブレイヤーも即座に更新
□ パフォーマンス低下なし（60fps維持）

───────────────────────────────────────────────────────────

【Phase 4: タイムラインサムネイル同期】

■ 改修ファイル
ui/timeline-ui.js

■ 参考ファイル
ui/layer-panel-renderer.js (generateLayerThumbnailCanvas)

■ 改修箇所
setupThumbnailAutoUpdate() メソッド
layer:transform-updated イベント購読追加

■ 改修内容
1. layer:transform-updated イベントを購読
2. requestThumbnailUpdate() を呼び出し
3. 現在フレームのサムネイルを即座に再生成

■ 実装パターン
```javascript
this.eventBus.on('layer:transform-updated', ({ layerId }) => {
    this.requestThumbnailUpdate();
});
```

■ 検証項目
□ Vモード変形がタイムラインサムネイルに反映
□ レイヤーパネルとタイムラインが同期
□ フレーム切り替え時も正確

───────────────────────────────────────────────────────────

【改修順序】

Phase 1 → Phase 2 → Phase 3 → Phase 4

理由:
- Phase 1 でサムネイル生成ロジックを変形対応
- Phase 2 でイベント処理を最適化
- Phase 3 で全体更新を高速化
- Phase 4 でタイムライン連携完成

───────────────────────────────────────────────────────────

【重要な実装原則】

1. Canvas2D の変形は save()/restore() で必ず囲む
2. setTimeout() は最小限（できれば requestAnimationFrame）
3. 変形行列の適用順序: translate(center) → rotate → scale → translate(-center)
4. layerTransform.getTransform() で最新の変形データ取得
5. 非同期処理（async/await）は不要（Canvas2D は同期）

───────────────────────────────────────────────────────────

【Phase 1 実装詳細】

改修対象メソッド: generateLayerThumbnailCanvas(layer)

処理フロー:
1. 既存のバウンディングボックス計算（minX, minY, maxX, maxY）
2. layerId 取得: layer.layerData.id
3. transform 取得: window.layerTransform?.getTransform(layerId)
4. transform が存在する場合:
   a. キャンバス中心を計算: centerX, centerY
   b. ctx.save()
   c. サムネイル座標系で中心に移動
   d. 変形適用（rotate, scale）
   e. 中心から戻す
   f. パス描画
   g. ctx.restore()
5. transform が null の場合: 既存処理（変形なし）

変形行列の適用:
```javascript
const centerX = canvasWidth / 2;
const centerY = canvasHeight / 2;

// サムネイル座標系での中心
const thumbCenterX = thumbSize / 2;
const thumbCenterY = thumbSize / 2;

ctx.save();
ctx.translate(thumbCenterX, thumbCenterY);
ctx.rotate(transform.rotation);
ctx.scale(transform.scaleX, transform.scaleY);
ctx.translate(-thumbCenterX, -thumbCenterY);

// パス描画（既存ロジック）

ctx.restore();
```

注意点:
- サムネイル座標系とキャンバス座標系の区別
- scale がマイナス（反転）の場合も正しく動作
- パスポイントの座標変換は不要（Canvas2D が自動処理）

───────────────────────────────────────────────────────────

【Phase 2 実装詳細】

改修対象メソッド: _setupEventListeners()

変更前:
```javascript
this.eventBus.on('layer:transform-updated', ({ layerId }) => {
    setTimeout(() => {
        this.updateAllThumbnails();
    }, 100);
});
```

変更後:
```javascript
this.eventBus.on('layer:transform-updated', ({ layerId }) => {
    if (this.thumbnailUpdateScheduled) return;
    this.thumbnailUpdateScheduled = true;
    
    requestAnimationFrame(() => {
        this.updateAllThumbnails();
        this.thumbnailUpdateScheduled = false;
    });
});
```

追加プロパティ:
```javascript
constructor() {
    // ...既存コード
    this.thumbnailUpdateScheduled = false;
}
```

───────────────────────────────────────────────────────────

【Phase 3 実装詳細】

改修対象メソッド: updateAllThumbnails()

最適化ポイント:
1. 同期ループ（forEach）
2. innerHTML 置き換えではなく、img.src 更新
3. Canvas 再利用（毎回 createElement しない）

改善後のフロー:
```javascript
updateAllThumbnails() {
    if (!this.container || !this.layerSystem) return;

    const items = this.container.querySelectorAll('.layer-item');
    const layers = this.layerSystem.getLayers();
    
    items.forEach((item, index) => {
        if (index >= layers.length) return;
        
        const layer = layers[index];
        const thumbnail = item.querySelector('.layer-thumbnail');
        
        if (thumbnail && layer) {
            const canvas = this.generateLayerThumbnailCanvas(layer);
            if (canvas) {
                let img = thumbnail.querySelector('img');
                if (!img) {
                    img = document.createElement('img');
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'contain';
                    thumbnail.innerHTML = '';
                    thumbnail.appendChild(img);
                }
                img.src = canvas.toDataURL('image/png');
            }
        }
    });
}
```

───────────────────────────────────────────────────────────

【Phase 4 実装詳細】

改修対象メソッド: setupThumbnailAutoUpdate()

追加コード:
```javascript
setupThumbnailAutoUpdate() {
    if (!this.eventBus) return;
    
    // 既存のイベント購読...
    
    // 追加: レイヤー変形イベント
    this.eventBus.on('layer:transform-updated', ({ layerId }) => {
        this.requestThumbnailUpdate();
    });
}
```

requestThumbnailUpdate() の変更:
```javascript
requestThumbnailUpdate() {
    if (this.thumbnailUpdateInProgress) return;
    
    if (this.thumbnailUpdateTimer) {
        clearTimeout(this.thumbnailUpdateTimer);
    }
    
    // 50ms → 0ms に短縮
    this.thumbnailUpdateTimer = setTimeout(() => {
        this.updateCurrentFrameThumbnail();
    }, 0);
}
```

───────────────────────────────────────────────────────────

【検証手順】

Phase 1 完了後:
1. Vキーでレイヤー移動モード
2. ホイール+Shift で回転
3. レイヤーパネルのサムネイルが即座に回転

Phase 2 完了後:
1. Vキーでレイヤー移動
2. 連続してホイール操作
3. サムネイルが滑らかに更新（遅延なし）

Phase 3 完了後:
1. 複数レイヤー作成
2. アクティブレイヤーを変形
3. 全レイヤーのサムネイルが同時更新

Phase 4 完了後:
1. タイムラインを開く
2. Vモードでレイヤー変形
3. タイムラインサムネイルも即座に更新

───────────────────────────────────────────────────────────

【パフォーマンス目標】

- サムネイル更新: 16ms以内（60fps維持）
- イベント発火からDOM更新まで: 32ms以内（2フレーム）
- 全レイヤーサムネイル更新（10レイヤー）: 50ms以内

───────────────────────────────────────────────────────────

【終わり】


═══════════════════════════════════════════════════════════════
ブラウザお絵かきツール v8.13 - 段階的改修計画書
═══════════════════════════════════════════════════════════════
改修対象: 4つの不具合修正
作成日: 2025-10-28
対象バージョン: v8.13_Drawing_54
═══════════════════════════════════════════════════════════════

【改修対象の不具合一覧】

1. リサイズが左上原点 → 中央基準になっていない
2. レイヤーサムネイルが古い（変形・回転が反映されない）
3. Vモード編集が反映されていない（タイムラインは正しいがレイヤーパネルは古い）
4. Vキー移動モード時のアクティブレイヤー反転ボタンが効かない

───────────────────────────────────────────────────────────

【Phase 1: リサイズ中央基準化】

■ 目的
リサイズ時にキャンバスコンテンツが左上原点ではなく中央基準で配置される

■ 改修ファイル
- ui/resize-popup.js (_applyResize メソッド)
- system/camera-system.js (resizeCanvas メソッド)

■ 処理フロー
1. resize-popup.js で alignOptions (horizontal/vertical) を渡す
2. camera-system.js の resizeCanvas() が alignOptions を受け取る
3. 新旧サイズ差分を計算し、align に応じて worldContainer.position を調整
4. renderer.resize() 実行
5. camera:resized イベント発火

■ 使用するメソッド
- cameraSystem.resizeCanvas(width, height, alignOptions)
- worldContainer.position.set(offsetX, offsetY)
- renderer.resize(newWidth, newHeight)
- eventBus.emit('camera:resized', { width, height })

■ 座標系
- Canvas座標系でリサイズ処理
- worldContainer の position offset で中央揃え実現
- alignOptions: { horizontal: 'left'|'center'|'right', vertical: 'top'|'center'|'bottom' }

■ 検証項目
□ 中央揃えでリサイズ後、既存描画が中央に配置される
□ 左揃え・右揃え・上揃え・下揃えが正しく動作
□ Undo/Redo で正しく元に戻る

───────────────────────────────────────────────────────────

【Phase 2: レイヤーサムネイル自動更新（変形・回転対応）】

■ 目的
レイヤーに変形（移動・回転・スケール）を適用した際、サムネイルが即座に更新される

■ 改修ファイル
- ui/layer-panel-renderer.js (generateLayerThumbnailCanvas メソッド)
- system/layer-transform.js (_emitTransformUpdated を確認)

■ 処理フロー
1. layer-transform.js が layer:transform-updated イベントを発火（既存）
2. layer-panel-renderer.js が layer:transform-updated を購読（既存）
3. generateLayerThumbnailCanvas() 内でレイヤーの transform (position/rotation/scale) を適用してサムネイル生成
4. 変形後の座標でパスを描画

■ 使用するメソッド
- layer.position, layer.rotation, layer.scale の値を取得
- Canvas2D の ctx.translate(), ctx.rotate(), ctx.scale() で変形適用
- layerTransform.getTransform(layerId) から変形データ取得

■ 座標系
- Local座標系でパスを取得
- Canvas2D のコンテキスト変換で変形を適用
- サムネイル内で相対座標変換を実施

■ 検証項目
□ Vキー移動モードでレイヤー移動後、サムネイルが更新される
□ 回転・スケール後もサムネイルが正確に反映される
□ 非アクティブレイヤーのサムネイルも正しく更新される

───────────────────────────────────────────────────────────

【Phase 3: タイムライン連携強化（Vモード編集反映）】

■ 目的
Vモードでレイヤーを編集した際、タイムラインとレイヤーパネルが同期する

■ 改修ファイル
- ui/timeline-ui.js (updateFrameThumbnails メソッド)
- ui/layer-panel-renderer.js (layer:transform-updated 購読を再確認)
- system/layer-transform.js (イベント発火確認)

■ 処理フロー
1. layer-transform.js で transform 更新時に layer:transform-updated 発火
2. layer-panel-renderer.js が購読してサムネイル更新（Phase 2で実装済み）
3. timeline-ui.js も同イベントを購読し、現在フレームのサムネイルを更新
4. animationSystem の現在フレーム状態を保存

■ 使用するメソッド
- eventBus.on('layer:transform-updated', callback)
- timelineUI.updateCurrentFrameThumbnail()
- animationSystem.getCurrentFrame()

■ 座標系
- タイムラインサムネイルもLocal座標系のパスを変形して描画
- layer-panel-renderer と同じ変形ロジックを使用

■ 検証項目
□ Vモードで移動後、タイムラインサムネイルが更新される
□ レイヤーパネルとタイムラインのサムネイルが一致する
□ フレーム切り替え時も正しいサムネイルが表示される

───────────────────────────────────────────────────────────

【Phase 4: Vモード時の反転ボタン有効化】

■ 目的
Vキー移動モード時、アクティブレイヤーの反転ボタン（H/Shift+H）が機能する

■ 改修ファイル
- system/layer-transform.js (_setupFlipKeyEvents メソッド)
- ui/ui-panels.js (反転ボタンのイベントハンドラ確認)

■ 処理フロー
1. layer-transform.js の _setupFlipKeyEvents で Vキー押下中の H キー判定を確認
2. isVKeyPressed === true 時のみ反転処理を実行（既存）
3. onFlipRequest コールバックが正しく設定されているか確認
4. flipLayer() メソッドで transform.scaleX/scaleY を反転
5. layer:transform-updated イベント発火でサムネイル更新

■ 使用するメソッド
- layerTransform.flipLayer(layer, 'horizontal' | 'vertical')
- transform.scaleX *= -1 (水平反転)
- transform.scaleY *= -1 (垂直反転)
- applyTransform() で変形適用

■ 座標系
- pivot を中央 (centerX, centerY) に設定
- scale.x/y を負の値にして反転実現
- position を pivot 分調整

■ 検証項目
□ Vモード時に H キーで水平反転が動作
□ Vモード時に Shift+H で垂直反転が動作
□ 反転後のサムネイルが正しく更新される
□ 反転ボタンの active 状態が正しく表示される

───────────────────────────────────────────────────────────

【座標系統合の確認事項】

■ 座標変換パイプライン
Screen (clientX/Y) 
  → Canvas (renderer pixels)
  → World (worldContainer space)
  → Local (layer space)

■ 使用する変換メソッド（coordinate-system.js）
- screenClientToWorld(clientX, clientY)
- worldToLocal(worldX, worldY, container)
- localToWorld(container, localPoint)

■ Phase 3統合済み箇所
- layer-transform.js の _setupDragEvents（ドラッグ処理）
- drawing-engine.js のポインター処理（描画座標変換）

■ 今回の改修での座標系注意点
1. サムネイル生成は Local座標で完結（変形のみ適用）
2. リサイズは Canvas座標で処理（worldContainer offset調整）
3. 反転は pivot中心のscale反転（Local座標系の変形）

───────────────────────────────────────────────────────────

【改修順序の推奨】

Phase 1 → Phase 4 → Phase 2 → Phase 3

理由:
- Phase 1 はリサイズ処理の基盤改修（他に影響少ない）
- Phase 4 は Vモード機能の完成（Phase 2,3 の前提）
- Phase 2 でサムネイル更新ロジック確立
- Phase 3 で Phase 2 のロジックをタイムラインに展開

───────────────────────────────────────────────────────────

【各Phase完了後の確認項目】

Phase 1完了:
□ リサイズポップアップで中央揃えが選択可能
□ 適用ボタンでキャンバスが中央基準でリサイズされる
□ Undo で正しく元のサイズ・配置に戻る

Phase 4完了:
□ Vキー押下中に H キーで反転が動作
□ 反転ボタンの active 表示が正しい
□ 反転後も描画位置がずれない

Phase 2完了:
□ レイヤー移動後のサムネイルが即座に更新
□ 回転・スケール後のサムネイルが正確
□ 非アクティブレイヤーのサムネイルも更新

Phase 3完了:
□ Vモード編集がタイムラインに反映
□ フレーム切り替え時も正しいサムネイル表示
□ レイヤーパネルとタイムラインが完全同期

───────────────────────────────────────────────────────────

【重要な実装原則】

1. 座標変換は coordinate-system.js 経由で統一
2. EventBus で変更通知を疎結合に実装
3. サムネイル生成は Canvas2D（PixiJS使用不可）
4. transform は pivot中心の回転・スケールで実現
5. 二重変換を避ける（drawing-engine で変換済みの座標を recorder に渡す）

───────────────────────────────────────────────────────────

【参考API】

■ PIXI.Container変形API
- container.position.set(x, y)
- container.pivot.set(x, y)
- container.rotation (ラジアン)
- container.scale.set(x, y)

■ Canvas2D変形API
- ctx.translate(x, y)
- ctx.rotate(angle)
- ctx.scale(x, y)
- ctx.save() / ctx.restore()

■ EventBus
- eventBus.emit('event:name', data)
- eventBus.on('event:name', callback)

───────────────────────────────────────────────────────────

【終わり】