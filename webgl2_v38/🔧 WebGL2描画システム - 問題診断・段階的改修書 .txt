================================================================================
WebGL2描画システム - 問題診断・段階的改修書
================================================================================

【発見された根本的問題】

■ 問題1: coordinate-system.js worldToLocal() 符号ミス
⚠️ Phase 1.7で「減算→加算」と修正されているが、逆変換としては「減算」が正しい
   現在: x += node.position.x  ← 誤り
   正解: x -= node.position.x  ← 正しい逆変換

■ 問題2: テクスチャサイズとboundsの不一致（Phase 2.0で一部改善）
⚠️ 2の累乗への丸め込みで元のアスペクト比が崩れる可能性
   例: bounds 100x50 → texture 128x64 にすると比率が変わる

■ 問題3: カメラフレーム外クリッピング未実装
❌ 描画がキャンバス外にも表示される
   → bounds計算時にカメラフレーム範囲内に制限する処理が不在

■ 問題4: PixiJS責任分界の曖昧さ
⚠️ brush-core.jsでsprite配置を直接操作
   → Phase 2.4で width/height 変更削除は正しいが、配置ロジックも分離すべき


================================================================================
【システムアーキテクチャ】
================================================================================

【座標変換フロー】

PointerEvent (Screen座標)
  ↓ [drawing-engine.js]
  ↓ screenClientToCanvas() ← coordinate-system.js
Canvas座標 (clientX/clientY → canvasX/canvasY)
  ↓ canvasToWorld() ← coordinate-system.js
World座標 (worldContainer基準の相対座標)
  ↓ worldToLocal() ← coordinate-system.js
Local座標 (activeLayer基準の相対座標)
  ↓ [brush-core.js → stroke-recorder.js]
記録された座標 (Local座標のまま保存)
  ↓ [brush-core.js → gl-stroke-processor.js]
PerfectFreehand → ポリゴン頂点 (Local座標のまま)
  ↓ [gl-msdf-pipeline.js]
Shader処理 (uBoundsMin/uBoundsSizeで正規化)
  ↓ [gl-texture-bridge.js]
PIXI.Sprite生成
  ↓ [brush-core.js]
sprite.x = bounds.minX ← Local座標での配置
sprite.y = bounds.minY


【親子階層構造】

📁 index.html
  └─ core-initializer.js ★エントリーポイント
      ├─ core-engine.js ★システム統合初期化
      │   ├─ camera-system.js (worldContainer管理)
      │   ├─ layer-system.js (レイヤー管理)
      │   ├─ coordinate-system.js (座標変換パイプライン)
      │   └─ drawing-engine.js (描画エンジン)
      │       └─ brush-core.js (ブラシ統合処理)
      │           ├─ stroke-recorder.js (座標記録)
      │           ├─ gl-stroke-processor.js (ポリゴン生成)
      │           ├─ gl-msdf-pipeline.js (MSDF生成)
      │           └─ gl-texture-bridge.js (Sprite変換)
      └─ webgl2-drawing-layer.js (WebGL2コンテキスト管理)


【ファイル責務辞典】

📁 coordinate-system.js (Phase 1.7)
責務: Screen/Canvas/World/Local座標変換
親依存: なし（独立）
子依存: drawing-engine.js, brush-core.js
重要メソッド:
  - screenClientToCanvas(clientX, clientY) → {canvasX, canvasY}
  - canvasToWorld(canvasX, canvasY) → {worldX, worldY}
  - worldToLocal(worldX, worldY, container) → {localX, localY}
🔍 問題箇所:
  ⚠️ worldToLocal()内の position符号 (line 147)
     現在: x += node.position.x  ← 誤り
     正解: x -= node.position.x  ← 正しい逆変換
     理由: Worldからの逆変換なので親の位置を「引く」必要がある


📁 drawing-engine.js (v8.14.3 Phase 1.2)
責務: PointerEvent受信→座標変換実行→BrushCoreへ委譲
親依存: coordinate-system.js, camera-system.js, layer-system.js, brush-core.js
子依存: core-engine.js (初期化・renderPreview呼び出し元)
重要メソッド:
  - _transformPointerToLocal(e) → {localX, localY, worldX, worldY, ...}
  - _handlePointerDown/Move/Up(e)
  - flushPendingPoints()
フロー:
  PointerEvent → screenClientToCanvas → canvasToWorld → worldToLocal → BrushCore
✅ 正常動作: 座標変換の実行ロジック自体は正しい
⚠️ 問題: coordinate-system.js側の符号ミスの影響を受ける


📁 brush-core.js (Phase 2.4)
責務: ストローク統合処理・WebGL2コンポーネント統合
親依存: stroke-recorder, gl-stroke-processor, gl-msdf-pipeline, gl-texture-bridge, layer-system
子依存: drawing-engine.js (startStroke/updateStroke呼び出し元)
重要メソッド:
  - startStroke(localX, localY, pressure)
  - updateStroke(localX, localY, pressure)
  - renderPreview() → _updatePreview()
  - finalizeStroke() → _finalizeMSDFStroke()
⚠️ 問題箇所:
  - sprite.x = bounds.minX (line 424, 583)
    → Local座標での配置だが、親container基準なのか要確認
  - カメラフレーム外判定なし → クリッピング処理が不在


📁 gl-stroke-processor.js (Phase 1.7)
責務: PerfectFreehand → GPU頂点バッファ生成
親依存: perfect-freehand, earcut-triangulator, config.js, webgl2-drawing-layer.js
子依存: brush-core.js
重要メソッド:
  - createPolygonVertexBuffer(points, baseSize) → {buffer, vertexCount, bounds}
  - createEdgeBuffer(points, baseSize) → {buffer, edgeCount, bounds}
  - calculateBounds(points, margin)
✅ 正常動作: Local座標のまま維持（Phase 1.7修正済み）
📌 重要: bounds計算時にカメラフレーム判定を追加すべき


📁 gl-msdf-pipeline.js (Phase 2.0)
責務: MSDF距離場生成（JFA: Jump Flooding Algorithm）
親依存: webgl2-drawing-layer.js
子依存: brush-core.js
重要メソッド:
  - generateMSDF(edgeBufferData, bounds, ...) → {texture, width, height}
  - _calculateTextureSize(bounds) → {width, height}
🔧 Phase 2.0改善: boundsベースの動的サイズ対応
⚠️ 問題箇所:
  - _calculateTextureSize() (line 270)
    → 2の累乗への丸めでアスペクト比が変化
    例: bounds 100x50 → texture 128x64 (比率 2:1 → 2:1維持)
    例: bounds 120x50 → texture 128x64 (比率 2.4:1 → 2:1に変化)
🔍 要確認: 2の累乗丸めがアスペクト比に与える影響


📁 gl-texture-bridge.js (Phase 5)
責務: WebGLTexture → PIXI.Sprite変換
親依存: webgl2-drawing-layer.js
子依存: brush-core.js
重要メソッド:
  - createSpriteFromGLTexture(texture, width, height) → PIXI.Sprite
✅ 正常動作: テクスチャサイズそのままでSprite生成


📁 camera-system.js (Phase 3.1)
責務: worldContainer管理・カメラ変換
親依存: なし
子依存: coordinate-system.js, drawing-engine.js
重要プロパティ:
  - worldContainer (PIXI.Container)
  - cameraFrame { x, y, width, height }
📌 重要: cameraFrameサイズを取得して描画クリッピングに使用可能


📁 layer-system.js (Phase 9)
責務: レイヤー管理・アクティブレイヤー取得
重要メソッド:
  - getActiveLayer() → Layer
  - getLayerById(id) → Layer
📌 重要: activeLayerの親コンテナ構造確認


================================================================================
【座標変換検証実験】
================================================================================

■ coordinate-system.js worldToLocal() 符号問題の検証

【想定されるシナリオ】

worldContainer.position = (200, 100)
activeLayer.position = (50, 50)
World座標 = (300, 200)

【現在の実装 (Phase 1.7 - 誤り)】
x += node.position.x  ← 加算
結果: localX = 300 + 50 = 350 ← 誤り

【正しい実装】
x -= node.position.x  ← 減算
結果: localX = 300 - 50 = 250 ← 正しい

【理由】
Worldから見た座標 (300, 200) は:
- worldContainer基準で (300 - 200, 200 - 100) = (100, 100)
- activeLayer基準で (100 - 50, 100 - 50) = (50, 50)

逆変換は「親の位置を引く」必要がある
Forward: Local → World は「親の位置を足す」
Inverse: World → Local は「親の位置を引く」


================================================================================
【段階的改修プラン】
================================================================================

【Phase 3.0: 座標変換符号修正 - 最優先】

🔧 coordinate-system.js (line 147付近)
修正内容:
```
// 🔧 Phase 1.7 Critical Fix: 位置の逆変換（加算に修正）
if (node.position) {
  x += node.position.x || 0;  ← ❌ 誤り
  y += node.position.y || 0;  ← ❌ 誤り
}
```
↓
```
// 🔧 Phase 3.0 Critical Fix: 位置の逆変換（減算に修正）
if (node.position) {
  x -= node.position.x || 0;  ← ✅ 正しい
  y -= node.position.y || 0;  ← ✅ 正しい
}
```

検証方法:
1. window.TegakiDebug.drawing.enableDebug()
2. 描画テスト実行
3. コンソールでLocal座標が正しいか確認

影響範囲: 全描画処理（最重要修正）


【Phase 3.1: カメラフレーム外クリッピング実装 - 高優先】

🔧 gl-stroke-processor.js
新規メソッド追加:
```
_clipBoundsToCamera(bounds) {
  const cameraSystem = window.cameraSystem;
  if (!cameraSystem?.cameraFrame) return bounds;
  
  const cf = cameraSystem.cameraFrame;
  return {
    minX: Math.max(bounds.minX, cf.x),
    minY: Math.max(bounds.minY, cf.y),
    maxX: Math.min(bounds.maxX, cf.x + cf.width),
    maxY: Math.min(bounds.maxY, cf.y + cf.height),
    width: Math.min(bounds.width, cf.width),
    height: Math.min(bounds.height, cf.height)
  };
}
```

calculateBounds()内で適用:
```
_calculateBoundsFromPoints(points, margin = 20) {
  // 既存のbounds計算
  ...
  const bounds = { minX, minY, maxX, maxY, width, height };
  
  // カメラフレームでクリッピング
  return this._clipBoundsToCamera(bounds);
}
```

影響範囲: カメラフレーム外描画防止


【Phase 3.2: テクスチャサイズとアスペクト比保持 - 中優先】

🔧 gl-msdf-pipeline.js _calculateTextureSize()
修正方針:
- 2の累乗丸めを「元のアスペクト比を維持」する方法に変更
- 最小サイズ制限は維持

実装案:
```
_calculateTextureSize(bounds) {
  if (!bounds || !bounds.width || !bounds.height) {
    return { width: this.minTextureSize, height: this.minTextureSize };
  }

  let width = Math.ceil(bounds.width);
  let height = Math.ceil(bounds.height);
  
  // アスペクト比保持
  const aspectRatio = width / height;
  
  // 2の累乗に丸める
  width = Math.pow(2, Math.ceil(Math.log2(width)));
  height = Math.pow(2, Math.ceil(Math.log2(height)));
  
  // アスペクト比再調整
  const newAspectRatio = width / height;
  if (Math.abs(newAspectRatio - aspectRatio) > 0.1) {
    // アスペクト比が大きく変わった場合は補正
    if (aspectRatio > newAspectRatio) {
      width = Math.pow(2, Math.ceil(Math.log2(height * aspectRatio)));
    } else {
      height = Math.pow(2, Math.ceil(Math.log2(width / aspectRatio)));
    }
  }
  
  // 範囲制限
  width = Math.max(this.minTextureSize, Math.min(width, this.maxTextureSize));
  height = Math.max(this.minTextureSize, Math.min(height, this.maxTextureSize));
  
  return { width, height };
}
```

影響範囲: ストローク描画の変形防止


【Phase 3.3: PixiJS責任分界の明確化 - 低優先】

🔧 brush-core.js
Sprite配置ロジックを専用メソッドに分離:
```
_applySpriteTransform(sprite, bounds, opacity) {
  sprite.x = bounds.minX;
  sprite.y = bounds.minY;
  sprite.alpha = opacity;
  sprite.visible = true;
}
```

_updatePreview(), _finalizeMSDFStroke()で使用:
```
this._applySpriteTransform(
  this.previewSprite,
  bounds,
  previewSettings.opacity
);
```

影響範囲: コード可読性向上・責務分離


【Phase 3.4: シェーダーファイル統合確認 - 低優先】

🔍 調査項目:
- render.vert.glsl, render.frag.glsl が実際に使用されているか確認
- 使用されていない場合は削除
- JavaScript内シェーダーに完全統合

影響範囲: ファイル構造のクリーンアップ


================================================================================
【デバッグコマンド】
================================================================================

■ 座標変換テスト
```
window.TegakiDebug.drawing.enableDebug()
window.TegakiDebug.drawing.testTransform(500, 300)
```

■ CoordinateSystem状態確認
```
window.CoordinateSystem.dumpState()
```

■ Bounds確認
```
const layer = window.layerManager.getActiveLayer();
const container = layer.drawingContainer || layer.container;
console.log('Sprites:', container.children.map(c => ({
  x: c.x, y: c.y,
  width: c.width, height: c.height,
  textureWidth: c.texture?.width,
  textureHeight: c.texture?.height
})));
```

■ カメラフレーム確認
```
console.log('CameraFrame:', window.cameraSystem.cameraFrame);
```


================================================================================
【改修優先順位まとめ】
================================================================================

1. ⚠️⚠️⚠️ Phase 3.0: coordinate-system.js 符号修正
   影響: 全描画処理の座標ズレを解決
   工数: 5分
   リスク: 極小（1行修正）

2. ⚠️⚠️ Phase 3.1: カメラフレーム外クリッピング
   影響: キャンバス外描画を防止
   工数: 30分
   リスク: 小（新規メソッド追加）

3. ⚠️ Phase 3.2: テクスチャアスペクト比保持
   影響: ストローク変形を防止
   工数: 60分
   リスク: 中（既存ロジック変更）

4. 🔧 Phase 3.3: Sprite配置ロジック分離
   影響: コード可読性向上
   工数: 20分
   リスク: 極小（リファクタリング）

5. 🔍 Phase 3.4: シェーダーファイル調査
   影響: ファイル構造整理
   工数: 30分
   リスク: 極小（調査のみ）


================================================================================
【検証手順】
================================================================================

【Phase 3.0検証】
1. coordinate-system.js修正
2. ブラウザリロード
3. 描画テスト（円・直線・曲線）
4. console.log で Local座標確認
5. sprite.x/y が bounds.minX/minY と一致するか確認

【Phase 3.1検証】
1. カメラズームアウト
2. カメラフレーム外で描画
3. 描画が表示されないことを確認
4. カメラ移動後に描画が正しい位置に表示されるか確認

【Phase 3.2検証】
1. 横長ストローク描画 (幅200, 高さ50)
2. 縦長ストローク描画 (幅50, 高さ200)
3. アスペクト比が維持されているか目視確認
4. テクスチャサイズをconsole.logで確認


================================================================================
【最終確認項目】
================================================================================

✅ 座標変換フローの一貫性
   - PointerEvent → Canvas → World → Local が正しく動作
   - Local座標での記録・描画が正しい

✅ カメラフレーム判定
   - フレーム外描画が表示されない
   - フレーム内描画が正しい位置に表示

✅ テクスチャサイズとアスペクト比
   - boundsサイズとテクスチャサイズの関係が正しい
   - ストローク形状が変形しない

✅ PixiJS責任分界
   - WebGL2が描画責務を持つ
   - PixiJSはSprite配置・表示のみ
   - 座標変換はCoordinateSystemが担当

✅ シェーダー管理
   - 使用中のシェーダーが明確
   - 未使用ファイルは削除

================================================================================