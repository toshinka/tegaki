================================================================================
モダン消しゴム実装計画書 - ハイブリッド段階実装方式
PixiJS v8.13 Drawing Tool - Modern Eraser Implementation Plan
================================================================================

【設計理念】
- Phase 1: 動作する基盤を最速構築（RenderTextureマスク）
- Phase 2: GPU最適化で性能向上（CustomShader活用）
- Phase 3: 差別化機能追加（SDF距離場オプション）

【技術スタック】
- PixiJS v8.13（RenderTexture, CustomShader, BlendMode.ERASE）
- WebGL 2.0（GPU演算、距離場生成）
- ES2023（class構文、async/await）

【禁止事項】
- Canvas2D直接操作（サムネイルを除く）
- 曖昧なフォールバック処理
- 二重実装・冗長化


================================================================================
Phase 1: RenderTextureマスク基盤構築【即効性・安定性重視】
================================================================================

目的: 動作する消しゴム機能を最短で実装
期間: 1-2日
難易度: ★☆☆

────────────────────────────────────────
Step 1.1: LayerModel.initializeMask() 実装
────────────────────────────────────────
ファイル: system/data-models.js
参照: LayerModel.destroyMask() (既存実装)
行: 55付近 initializeMask()

処理フロー:
1. RenderTexture.create() でマスクテクスチャ生成
2. 白矩形(0xFFFFFF)で全体塗りつぶし → 全表示状態
3. PIXI.Sprite(maskTexture) 生成
4. this.maskTexture, this.maskSprite, this._maskInitialized 設定

実装キーポイント:
```javascript
initializeMask(width, height, renderer) {
    if (this._maskInitialized) this.destroyMask();
    
    this.maskTexture = PIXI.RenderTexture.create({ width, height });
    
    const whiteRect = new PIXI.Graphics();
    whiteRect.rect(0, 0, width, height).fill({ color: 0xFFFFFF });
    
    renderer.render({ container: whiteRect, target: this.maskTexture, clear: true });
    whiteRect.destroy();
    
    this.maskSprite = new PIXI.Sprite(this.maskTexture);
    this.maskSprite.label = 'mask_sprite';
    this._maskInitialized = true;
    
    return true;
}
```

注意事項:
- renderer.render() はPixiJS v8.13構文使用
- clear: true で確実に初期化
- 白=表示、黒=非表示の規約


────────────────────────────────────────
Step 1.2: LayerSystem.setApp() でマスク初期化
────────────────────────────────────────
ファイル: system/layer-system.js
参照: init(), createLayer() (既存パターン)
行: 873-882 setApp()

処理フロー:
1. app.renderer取得確認
2. 全レイヤー走査してhasMask()チェック
3. 未初期化レイヤーにinitializeMask()実行
4. maskSpriteをレイヤーの最初の子として追加
5. _applyMaskToLayerGraphics()でGraphicsにマスク適用

実装キーポイント:
```javascript
setApp(app) {
    this.app = app;
    // 既存Transform初期化...
    
    if (app && app.renderer) {
        const layers = this.getLayers();
        for (const layer of layers) {
            if (layer.layerData && !layer.layerData.hasMask()) {
                const ok = layer.layerData.initializeMask(
                    this.config.canvas.width,
                    this.config.canvas.height,
                    app.renderer
                );
                if (ok && layer.layerData.maskSprite) {
                    layer.addChildAt(layer.layerData.maskSprite, 0);
                    this._applyMaskToLayerGraphics(layer);
                }
            }
        }
    }
}

_applyMaskToLayerGraphics(layer) {
    if (!layer.layerData?.maskSprite) return;
    for (const child of layer.children) {
        if (child === layer.layerData.maskSprite || 
            child === layer.layerData.backgroundGraphics) continue;
        if (child instanceof PIXI.Graphics) {
            child.mask = layer.layerData.maskSprite;
        }
    }
}
```

注意事項:
- maskSpriteは必ずindex 0に配置
- backgroundGraphicsはマスク対象外
- maskSprite自身にはマスク設定しない


────────────────────────────────────────
Step 1.3: LayerSystem.createLayer() 統合
────────────────────────────────────────
ファイル: system/layer-system.js
参照: init()のレイヤー作成パターン
行: 686-738 createLayer()

処理フロー:
1. LayerModel作成
2. Container作成
3. initializeMask()実行
4. maskSpriteをlayer.addChild()
5. History記録（undo時のdestroyMask()含む）

実装キーポイント:
```javascript
createLayer(name, isBackground = false) {
    const layerModel = new window.TegakiDataModels.LayerModel({
        name: name || `レイヤー${this.currentCutContainer.children.length + 1}`,
        isBackground
    });
    const layer = new PIXI.Container();
    layer.label = layerModel.id;
    layer.layerData = layerModel;
    
    // マスク初期化
    if (this.app?.renderer) {
        const ok = layerModel.initializeMask(
            this.config.canvas.width,
            this.config.canvas.height,
            this.app.renderer
        );
        if (ok && layerModel.maskSprite) {
            layer.addChild(layerModel.maskSprite);
        }
    }
    
    // Transform設定...
    // Background Graphics追加...
    
    // History記録
    const entry = {
        name: 'layer-create',
        do: () => { /* 追加処理 */ },
        undo: () => {
            this.currentCutContainer.removeChild(layer);
            layer.layerData?.destroyMask(); // 追加
            // 既存undo処理...
        }
    };
    // ...
}
```


────────────────────────────────────────
Step 1.4: LayerSystem.deleteLayer() マスク破棄
────────────────────────────────────────
ファイル: system/layer-system.js
参照: destroyMask() (data-models.js)
行: 887-954 deleteLayer()

処理フロー:
1. レイヤー削除前にdestroyMask()呼び出し
2. History記録（undo時の再初期化含む）

実装キーポイント:
```javascript
deleteLayer(layerIndex) {
    // 検証処理...
    
    const entry = {
        name: 'layer-delete',
        do: () => {
            layer.layerData?.destroyMask(); // 追加
            this.currentCutContainer.removeChild(layer);
            // 既存処理...
        },
        undo: () => {
            // 再初期化
            if (layer.layerData && this.app?.renderer) {
                layer.layerData.initializeMask(
                    this.config.canvas.width,
                    this.config.canvas.height,
                    this.app.renderer
                );
                if (layer.layerData.maskSprite) {
                    layer.addChildAt(layer.layerData.maskSprite, 0);
                    this._applyMaskToLayerGraphics(layer);
                }
            }
            this.currentCutContainer.addChildAt(layer, layerIndex);
            // 既存処理...
        }
    };
}
```


────────────────────────────────────────
Step 1.5: LayerSystem.addPathToActiveLayer() マスク適用
────────────────────────────────────────
ファイル: system/layer-system.js
参照: rebuildPathGraphics() (Graphics生成パターン)
行: 241-264 addPathToActiveLayer()

処理フロー:
1. path.graphics生成後にマスク適用
2. layer.addChild()前に設定

実装キーポイント:
```javascript
addPathToActiveLayer(path) {
    const activeLayer = this.getActiveLayer();
    // paths配列追加...
    this.rebuildPathGraphics(path);
    
    if (path.graphics) {
        // マスク適用追加
        if (activeLayer.layerData?.maskSprite) {
            path.graphics.mask = activeLayer.layerData.maskSprite;
        }
        activeLayer.addChild(path.graphics);
    }
    // 既存処理...
}
```


────────────────────────────────────────
Step 1.6: DrawingEngine - eraserRenderer初期化
────────────────────────────────────────
ファイル: system/drawing/drawing-engine.js
参照: strokeRenderer初期化パターン
行: 16-30 constructor

処理フロー:
1. EraserMaskRendererインスタンス化
2. プロパティ追加

実装キーポイント:
```javascript
constructor(app, layerSystem, cameraSystem, history) {
    this.app = app;
    this.layerSystem = layerSystem;
    // 既存初期化...
    
    this.strokeRenderer = new StrokeRenderer(app);
    this.eraserRenderer = new EraserMaskRenderer(app); // 追加
    
    // 既存プロパティ...
}
```


────────────────────────────────────────
Step 1.7: DrawingEngine.stopDrawing() 消しゴム処理
────────────────────────────────────────
ファイル: system/drawing/drawing-engine.js
参照: finalizeStroke() (既存ストローク確定パターン)
行: 134-165 stopDrawing()

処理フロー:
1. tool === 'eraser' 判定
2. layerData.hasMask()確認
3. eraserRenderer.renderEraserToMask()実行
4. History記録（before/after snapshot）
5. サムネイル更新

実装キーポイント:
```javascript
stopDrawing() {
    if (!this.isDrawing) return;
    
    const strokeData = this.strokeRecorder.endStroke();
    this.clearPreview();
    this.clearEraserPreview();
    const tool = this.currentTool;
    
    // 消しゴム処理分岐
    if (tool === 'eraser' && this.currentLayer && strokeData.points.length > 0) {
        const layerData = this.currentLayer.layerData;
        
        if (layerData?.hasMask?.()) {
            const radius = this.currentSettings.size / 2;
            
            // スナップショット取得
            const beforeSnapshot = this.eraserRenderer.captureMaskSnapshot(layerData);
            
            // マスクに消しゴム描画
            const ok = this.eraserRenderer.renderEraserToMask(
                layerData,
                strokeData.points,
                radius
            );
            
            if (ok) {
                const afterSnapshot = this.eraserRenderer.captureMaskSnapshot(layerData);
                
                // History記録
                const entry = {
                    name: 'Erase',
                    do: async () => {
                        if (afterSnapshot) {
                            await this.eraserRenderer.restoreMaskSnapshot(layerData, afterSnapshot);
                        }
                        this.layerSystem.requestThumbnailUpdate(this.layerSystem.activeLayerIndex);
                    },
                    undo: async () => {
                        if (beforeSnapshot) {
                            await this.eraserRenderer.restoreMaskSnapshot(layerData, beforeSnapshot);
                        }
                        this.layerSystem.requestThumbnailUpdate(this.layerSystem.activeLayerIndex);
                    },
                    meta: { type: 'erase', layerId: layerData.id, tool: 'eraser' }
                };
                
                this.history?.push(entry);
                this.eventBus?.emit('layer:erased', { layerId: layerData.id });
                this.layerSystem.requestThumbnailUpdate(this.layerSystem.activeLayerIndex);
            }
        }
    } else {
        // ペンツール: 通常の確定描画
        this.finalizeStroke(strokeData, tool);
    }
    
    // 既存クリーンアップ...
}
```


────────────────────────────────────────
Step 1.8: DrawingEngine.finalizeStroke() マスク適用
────────────────────────────────────────
ファイル: system/drawing/drawing-engine.js
参照: strokeRenderer.renderFinalStroke() (既存)
行: 241-258 finalizeStroke()

処理フロー:
1. strokeObject生成後にマスク適用
2. layer.addChild()で追加

実装キーポイント:
```javascript
finalizeStroke(strokeData, tool = null) {
    // 既存ストローク生成...
    const strokeObject = this.strokeRenderer.renderFinalStroke(strokeData, this.currentSettings);
    
    // マスク適用追加
    const layerData = this.currentLayer.layerData;
    if (layerData?.hasMask?.() && layerData.maskSprite) {
        strokeObject.mask = layerData.maskSprite;
    }
    
    // 既存History記録...
}
```


────────────────────────────────────────
Phase 1 検証手順
────────────────────────────────────────

コンソール実行テスト:
```javascript
// 1. システム初期化確認
const ls = window.layerSystem || window.coreEngine?.layerSystem;
console.log('LayerSystem:', ls);

// 2. レイヤーマスク確認
ls.getLayers().forEach((layer, i) => {
    console.log(`Layer ${i}:`, {
        hasMask: layer.layerData?.hasMask(),
        maskTexture: !!layer.layerData?.maskTexture,
        maskSprite: !!layer.layerData?.maskSprite
    });
});

// 3. 消しゴムツール選択
window.TegakiEventBus?.emit('tool:select', { tool: 'eraser' });

// 4. DrawingEngine確認
const de = window.drawingEngine || window.coreEngine?.drawingEngine;
console.log('Current Tool:', de?.currentTool);
console.log('Eraser Renderer:', de?.eraserRenderer);
```

手動テスト項目:
□ ページリロード後、エラーなく起動
□ 既存レイヤーにマスクが存在
□ 新規レイヤー作成時にマスク自動作成
□ ペンツールで描画できる
□ 消しゴムツールに切り替えられる
□ 消しゴムで描画した部分が消える
□ 消した部分から下のレイヤーが透けて見える
□ Ctrl+Z でUndo → 消しゴムが復元
□ Ctrl+Shift+Z でRedo → 再び消える
□ レイヤー削除時にメモリリークなし
□ 複数回の描画・消去を繰り返しても安定動作


================================================================================
Phase 2: GPU最適化レイヤー【パフォーマンス・品質向上】
================================================================================

目的: BlendMode.ERASEとCustomShaderでGPU処理を最適化
期間: 2-3日
難易度: ★★☆

────────────────────────────────────────
Step 2.1: EraserMaskRenderer - BlendMode.ERASE活用
────────────────────────────────────────
ファイル: system/drawing/eraser-mask-renderer.js
参照: renderEraserToMask() (既存実装)
行: 全体リファクタリング

現状問題点:
- globalCompositeOperation = 'destination-out' 使用（Canvas2D的）
- PixiJS v8.13のBlendMode.ERASE未活用

改善方針:
```javascript
renderEraserToMask(layerData, points, radius) {
    if (!layerData.maskTexture) return false;
    
    const eraserGraphics = new PIXI.Graphics();
    eraserGraphics.blendMode = PIXI.BLEND_MODES.ERASE; // 追加
    
    // 既存パス描画処理...
    eraserGraphics.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
        eraserGraphics.lineTo(points[i].x, points[i].y);
    }
    eraserGraphics.stroke({ width: radius * 2, color: 0x000000 });
    
    // RenderTextureに直接描画
    this.renderer.render({
        container: eraserGraphics,
        target: layerData.maskTexture,
        clear: false // 既存内容保持
    });
    
    eraserGraphics.destroy();
    return true;
}
```

利点:
- GPU直接処理で高速化
- PixiJS標準機能のみで実装
- Canvas2D依存を完全排除


────────────────────────────────────────
Step 2.2: リアルタイム消去プレビュー最適化
────────────────────────────────────────
ファイル: system/drawing/drawing-engine.js
参照: updatePreview() (既存プレビュー処理)
新規メソッド: updateEraserMaskPreview()

処理フロー:
1. continueDrawing()中に増分ポイントのみ処理
2. マスクテクスチャに直接書き込み（clear: false）
3. 毎フレーム全再描画を避ける

実装キーポイント:
```javascript
updateEraserMaskPreview(newPoints) {
    if (!this.currentLayer?.layerData?.hasMask()) return;
    
    const layerData = this.currentLayer.layerData;
    const radius = this.currentSettings.size / 2;
    
    // 増分ポイントのみ描画
    const incrementalGraphics = new PIXI.Graphics();
    incrementalGraphics.blendMode = PIXI.BLEND_MODES.ERASE;
    
    for (let i = 0; i < newPoints.length - 1; i++) {
        const p1 = newPoints[i];
        const p2 = newPoints[i + 1];
        incrementalGraphics.moveTo(p1.x, p1.y);
        incrementalGraphics.lineTo(p2.x, p2.y);
    }
    incrementalGraphics.stroke({ width: radius * 2, color: 0x000000 });
    
    this.app.renderer.render({
        container: incrementalGraphics,
        target: layerData.maskTexture,
        clear: false
    });
    
    incrementalGraphics.destroy();
}
```


────────────────────────────────────────
Step 2.3: RenderTexture高速コピー（History最適化）
────────────────────────────────────────
ファイル: system/drawing/eraser-mask-renderer.js
参照: captureMaskSnapshot() (既存DataURL方式)
改善: renderer.texture.copyTexture() 使用

現状問題点:
- toDataURL()でCPU転送発生
- Base64エンコード/デコードオーバーヘッド

改善方針:
```javascript
captureMaskSnapshot(layerData) {
    if (!layerData.maskTexture) return null;
    
    // GPU内コピー（高速）
    const backup = PIXI.RenderTexture.create({
        width: layerData.maskTexture.width,
        height: layerData.maskTexture.height
    });
    
    this.renderer.texture.copyTexture(
        layerData.maskTexture,
        backup
    );
    
    return backup; // RenderTextureを直接返す
}

async restoreMaskSnapshot(layerData, snapshotTexture) {
    if (!layerData.maskTexture || !snapshotTexture) return false;
    
    // GPU内コピーで復元
    this.renderer.texture.copyTexture(
        snapshotTexture,
        layerData.maskTexture
    );
    
    return true;
}
```

注意事項:
- History.undo/redo がasync対応必須
- RenderTextureのライフサイクル管理
- メモリ上限に達したら古いスナップショット破棄


────────────────────────────────────────
Step 2.4: CustomShader導入準備（オプション）
────────────────────────────────────────
ファイル: 新規 system/drawing/mask-shader.js
参照: PixiJS v8 CustomShader API

目的:
- 距離減衰（ソフト消しゴム）のGPU実装
- アンチエイリアス品質向上

実装例（Fragment Shader）:
```javascript
class MaskShader extends PIXI.Shader {
    constructor() {
        const vertex = `
            attribute vec2 aPosition;
            varying vec2 vUV;
            void main() {
                vUV = aPosition * 0.5 + 0.5;
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;
        
        const fragment = `
            precision mediump float;
            varying vec2 vUV;
            uniform sampler2D uMask;
            uniform vec2 uBrushPos;
            uniform float uBrushRadius;
            uniform float uHardness; // 0.0-1.0
            
            void main() {
                vec4 maskColor = texture2D(uMask, vUV);
                float dist = distance(vUV * vec2(1920.0, 1080.0), uBrushPos);
                float fadeStart = uBrushRadius * uHardness;
                float alpha = 1.0 - smoothstep(fadeStart, uBrushRadius, dist);
                
                gl_FragColor = vec4(maskColor.rgb * (1.0 - alpha), maskColor.a);
            }
        `;
        
        super(PIXI.Program.from(vertex, fragment));
    }
}
```

Phase 2 完了時の性能目標:
- 消しゴム描画: 60fps維持（4K解像度でも）
- Undo/Redo: 50ms以下
- メモリ使用量: スナップショット10個まで安定


================================================================================
Phase 3: SDF距離場オプション【差別化機能】
================================================================================

目的: 高精度レイヤー向けSDF/MSDF距離場レンダリング
期間: 3-5日
難易度: ★★★

────────────────────────────────────────
Step 3.1: LayerModel拡張 - SDFモードフラグ
────────────────────────────────────────
ファイル: system/data-models.js
参照: 既存LayerModelプロパティ
追加プロパティ:

```javascript
class LayerModel {
    constructor(data) {
        // 既存プロパティ...
        this.maskMode = data.maskMode || 'raster'; // 'raster' | 'sdf' | 'msdf'
        this.sdfTexture = null; // SDF用テクスチャ
        this.sdfRange = 20.0;   // 距離エンコード範囲
    }
    
    initializeMask(width, height, renderer, mode = 'raster') {
        this.maskMode = mode;
        
        if (mode === 'raster') {
            // Phase 1の実装（既存）
        } else if (mode === 'sdf' || mode === 'msdf') {
            // SDF用RenderTexture（float精度）
            this.sdfTexture = PIXI.RenderTexture.create({
                width: width,
                height: height,
                format: mode === 'msdf' ? PIXI.FORMATS.RGBA : PIXI.FORMATS.R32F
            });
            // 中間距離値で初期化
            // ...
        }
    }
}
```


────────────────────────────────────────
Step 3.2: SDF生成パイプライン（CPU）
────────────────────────────────────────
ファイル: 新規 system/drawing/sdf-generator.js
参照: ベクター・ラスター併用について.txt (文書1) のサンプルコード

処理フロー:
1. ベクターストロークポイントからカプセル形状生成
2. 各ピクセルで最短距離計算
3. 符号付き距離（内側=負、外側=正）
4. [0,1]にエンコードしてテクスチャ書き込み

実装キーポイント:
```javascript
class SDFGenerator {
    static generateFromStroke(points, radius, texSize) {
        const data = new Float32Array(texSize * texSize);
        const range = radius * 2.0;
        
        for (let y = 0; y < texSize; y++) {
            for (let x = 0; x < texSize; x++) {
                const px = x / texSize;
                const py = y / texSize;
                
                let minDist = Infinity;
                
                // 全セグメントとの最短距離
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const dist = this._distanceToSegment(px, py, p1, p2);
                    if (dist < minDist) minDist = dist;
                }
                
                // 符号付き距離 → [0,1]エンコード
                const signedDist = minDist - radius;
                const encoded = (signedDist / (2 * range)) + 0.5;
                data[y * texSize + x] = Math.max(0, Math.min(1, encoded));
            }
        }
        
        return data;
    }
    
    static _distanceToSegment(px, py, p1, p2) {
        const vx = p2.x - p1.x, vy = p2.y - p1.y;
        const wx = px - p1.x, wy = py - p1.y;
        const len2 = vx * vx + vy * vy;
        let t = 0;
        if (len2 > 1e-6) t = Math.max(0, Math.min(1, (wx * vx + wy * vy) / len2));
        const cx = p1.x + vx * t, cy = p1.y + vy * t;
        const dx = px - cx, dy = py - cy;
        return Math.sqrt(dx * dx + dy * dy);
    }
}
```


────────────────────────────────────────
Step 3.3: SDF合成シェーダ
────────────────────────────────────────
ファイル: 新規 system/drawing/sdf-composite-shader.js
参照: 文書1のMSDF decodeパターン

処理:
- SDFテクスチャから距離デコード
- smoothstepでアルファ生成
- レイヤー合成時に適用

実装例（Fragment Shader）:
```javascript
const sdfCompositeFragment = `
precision mediump float;
varying vec2 vUV;
uniform sampler2D uSDF;
uniform float uRange;
uniform float uSmoothness;

void main() {
    float sdfValue = texture2D(uSDF, vUV).r;
    float signedDist = (sdfValue - 0.5) * uRange * 2.0;
    float alpha = smoothstep(uSmoothness, -uSmoothness, signedDist);
    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
}
`;
```


────────────────────────────────────────
Step 3.4: EraserMaskRenderer - SDF対応
────────────────────────────────────────
ファイル: system/drawing/eraser-mask-renderer.js
参照: renderEraserToMask() (Phase 1実装)

処理フロー分岐:
```javascript
renderEraserToMask(layerData, points, radius) {
    if (layerData.maskMode === 'raster') {
        // Phase 1の実装（既存）
        return this._renderRasterErase(layerData, points, radius);
    } else if (layerData.maskMode === 'sdf') {
        // SDF生成 → 距離場合成
        return this._renderSDFErase(layerData, points, radius);
    }
}

_renderSDFErase(layerData, points, radius) {
    const sdfData = SDFGenerator.generateFromStroke(points, radius, 256);
    const tempTexture = this._createTextureFromFloat(sdfData, 256, 256);
    
    // 既存SDF距離場とmax合成（消しゴム=距離を増やす）
    const compositeShader = new SDFCompositeShader();
    compositeShader.uniforms.uOldSDF = layerData.sdfTexture;
    compositeShader.uniforms.uNewSDF = tempTexture;
    compositeShader.uniforms.uIsErase = 1;
    
    this.renderer.render({
        container: compositeShader,
        target: layerData.sdfTexture,
        clear: false
    });
    
    tempTexture.destroy();
    return true;
}
```


────────────────────────────────────────
Step 3.5: MSDF対応（オプション高精度モード）
────────────────────────────────────────
ファイル: system/drawing/msdf-generator.js
参照: 文書1のMSDF生成フロー

処理フロー:
1. ベクターストロークのエッジ検出
2. 接線角度で3チャンネル割り当て（0-120度→R, 120-240度→G, 240-360度→B）
3. 各チャンネルに符号付き距離エンコード

実装キーポイント:
```javascript
class MSDFGenerator {
    static generateFromStroke(points, radius, texSize) {
        const data = new Uint8Array(texSize * texSize * 4);
        const range = radius * 2.0;
        
        for (let y = 0; y < texSize; y++) {
            for (let x = 0; x < texSize; x++) {
                const px = x / texSize;
                const py = y / texSize;
                
                let minDist = Infinity;
                let tangentAngle = 0;
                
                // 最短セグメント検索
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i], p2 = points[i + 1];
                    const dist = this._distanceToSegment(px, py, p1, p2);
                    if (dist < minDist) {
                        minDist = dist;
                        tangentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    }
                }
                
                // 角度でチャンネル選択
                const signedDist = minDist - radius;
                const encoded = this._encodeDistance(signedDist, range);
                
                if (tangentAngle < 0) tangentAngle += Math.PI * 2;
                const bin = Math.floor(tangentAngle / (Math.PI * 2 / 3)) % 3;
                
                const idx = (y * texSize + x) * 4;
                const mid = 128;
                data[idx] = bin === 0 ? encoded : mid;     // R
                data[idx + 1] = bin === 1 ? encoded : mid; // G
                data[idx + 2] = bin === 2 ? encoded : mid; // B
                data[idx + 3] = 255;                       // A
            }
        }
        
        return data;
    }
    
    static _encodeDistance(signedDist, range) {
        const normalized = (signedDist / (2 * range)) + 0.5;
        return Math.round(Math.max(0, Math.min(1, normalized)) * 255);
    }
}
```

MSDF Decodeシェーダ:
```javascript
const msdfFragment = `
precision mediump float;
varying vec2 vUV;
uniform sampler2D uMSDF;
uniform float uRange;
uniform float uSmoothness;

float median(float r, float g, float b) {
    return max(min(r, g), min(max(r, g), b));
}

void main() {
    vec3 sample = texture2D(uMSDF, vUV).rgb;
    float sd = (median(sample.r, sample.g, sample.b) - 0.5) * uRange;
    float alpha = smoothstep(uSmoothness, -uSmoothness, sd);
    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
}
`;
```


────────────────────────────────────────
Step 3.6: UIレイヤー設定パネル拡張
────────────────────────────────────────
ファイル: ui/layer-panel-renderer.js
参照: 既存レイヤーオプションUI

追加UI要素:
- マスクモード選択（Raster / SDF / MSDF）
- SDF品質設定（解像度、smoothness）

実装例:
```javascript
_createLayerOptions(layerData) {
    // 既存オプション...
    
    const maskModeSelect = this.domBuilder.create('select', {
        class: 'mask-mode-select',
        value: layerData.maskMode || 'raster'
    });
    
    ['raster', 'sdf', 'msdf'].forEach(mode => {
        const option = this.domBuilder.create('option', {
            value: mode,
            textContent: mode.toUpperCase()
        });
        maskModeSelect.appendChild(option);
    });
    
    maskModeSelect.addEventListener('change', (e) => {
        this._changeMaskMode(layerData, e.target.value);
    });
    
    // 既存UIに追加...
}

_changeMaskMode(layerData, newMode) {
    if (layerData.maskMode === newMode) return;
    
    // マスク再初期化
    layerData.destroyMask();
    layerData.initializeMask(
        this.config.canvas.width,
        this.config.canvas.height,
        this.app.renderer,
        newMode
    );
    
    // レイヤー再構築
    this.layerSystem.rebuildLayer(layerData.id);
}
```


────────────────────────────────────────
Phase 3 実装判断基準
────────────────────────────────────────

実装推奨条件:
□ Phase 1/2が完全安定動作
□ 高精度線画レイヤーの需要確認
□ パフォーマンステスト通過（60fps維持）
□ メモリ使用量が許容範囲（+50MB以内）

実装スキップ条件:
□ RasterマスクでUX十分
□ SDF生成コストが高すぎる（>100ms）
□ GPU互換性問題（古いデバイス）

Phase 3はオプション機能として実装し、デフォルトはRasterモードを推奨。


================================================================================
Phase 4: 統合テストと最適化
================================================================================

────────────────────────────────────────
総合テストシナリオ
────────────────────────────────────────

機能テスト:
□ レイヤー作成/削除でマスク正常動作
□ ペン→消しゴム→ペン の切り替え
□ 複数レイヤー間での消しゴム独立動作
□ Undo/Redo 50回以上の連続動作
□ ブラシサイズ変更（1px〜200px）
□ 筆圧対応消しゴム（Wacomタブレット）
□ レイヤー不透明度との併用
□ クリッピングマスクとの併用

パフォーマンステスト:
□ 4K解像度（3840x2160）で60fps
□ 1000ストローク描画後も安定
□ メモリ使用量: 500MB以内
□ Undo履歴100個でも快適
□ CPU使用率: 30%以下（アイドル時）

互換性テスト:
□ Chrome最新版
□ ローカルfile://起動
□ 4K/Retinaディスプレイ
□ Wacom/XP-Pen/Huionタブレット
□ タッチスクリーン（オプション）


────────────────────────────────────────
最適化チェックリスト
────────────────────────────────────────

メモリ最適化:
□ RenderTexture再利用（不要な再作成を避ける）
□ スナップショット自動クリーンアップ（履歴上限）
□ Graphics.destroy()の徹底
□ WeakMapでの参照管理

描画最適化:
□ BlendMode.ERASE活用（Canvas2D排除）
□ clear: false で増分描画
□ RenderTexture解像度の動的調整
□ GPU Profilerでボトルネック特定

コード品質:
□ 各Phaseでコンソールエラーゼロ
□ 命名規則統一（maskTexture, maskSprite, maskMode）
□ EventBus経由の疎結合
□ 依存関係の明確化（DI原則）


================================================================================
実装優先順位とスケジュール
================================================================================

Week 1:
Phase 1 Step 1.1-1.5 (LayerModel, LayerSystem統合)
→ 目標: レイヤー作成時にマスク自動生成

Week 2:
Phase 1 Step 1.6-1.8 (DrawingEngine統合)
→ 目標: 消しゴムが動作する

Week 2-3:
Phase 1 検証・バグ修正
→ 目標: 全機能テスト通過

Week 3-4:
Phase 2 (GPU最適化)
→ 目標: 60fps安定動作

Week 5以降（オプション）:
Phase 3 (SDF/MSDF)
→ 目標: 高精度レイヤーオプション提供


================================================================================
トラブルシューティング
================================================================================

問題: マスクが表示されない
原因: maskSpriteがレイヤーの子として追加されていない
対処: setApp()でaddChildAt(maskSprite, 0)確認

問題: 消しゴムで全体が消える
原因: マスクが黒で初期化されている
対処: initializeMask()で白矩形(0xFFFFFF)塗りつぶし確認

問題: Undo/Redoでエラー
原因: async/await処理が未対応
対処: History.apply()をasync関数に変更

問題: メモリリーク
原因: RenderTextureがdestroyされていない
対処: destroyMask()でdestroy(true)呼び出し確認

問題: 描画が遅い
原因: 毎フレーム全体再描画している
対処: clear: false で増分描画に変更

問題: PixiJS v8.13 APIエラー
原因: v7構文使用
対処: renderer.render({ container, target })構文使用


================================================================================
参照ファイル一覧
================================================================================

必須改修ファイル:
- system/data-models.js (LayerModel.initializeMask)
- system/layer-system.js (setApp, createLayer, deleteLayer, addPathToActiveLayer)
- system/drawing/drawing-engine.js (constructor, stopDrawing, finalizeStroke)

既存参照ファイル:
- system/drawing/eraser-mask-renderer.js (完全実装済み・Phase2で拡張)
- system/drawing/stroke-renderer.js (finalizeStroke参考)
- system/drawing/brush-settings.js (ブラシサイズ取得)
- system/history.js (Undo/Redo統合)

新規作成ファイル（Phase 3のみ）:
- system/drawing/sdf-generator.js
- system/drawing/msdf-generator.js
- system/drawing/sdf-composite-shader.js
- system/drawing/mask-shader.js


================================================================================
メソッド定義一覧
================================================================================

LayerModel (system/data-models.js):
- initializeMask(width, height, renderer, mode='raster'): boolean
- destroyMask(): void (既存)
- hasMask(): boolean (既存)

LayerSystem (system/layer-system.js):
- setApp(app): void (拡張)
- createLayer(name, isBackground): object (拡張)
- deleteLayer(index): boolean (拡張)
- addPathToActiveLayer(path): void (拡張)
- _applyMaskToLayerGraphics(layer): void (新規private)

DrawingEngine (system/drawing/drawing-engine.js):
- constructor(...) (eraserRenderer追加)
- stopDrawing(): void (消しゴム分岐追加)
- finalizeStroke(strokeData, tool): void (マスク適用追加)
- updateEraserMaskPreview(newPoints): void (Phase2新規)

EraserMaskRenderer (system/drawing/eraser-mask-renderer.js):
- renderEraserToMask(layerData, points, radius): boolean (Phase2でBlendMode.ERASE化)
- captureMaskSnapshot(layerData): RenderTexture (Phase2でGPUコピー化)
- restoreMaskSnapshot(layerData, snapshot): Promise<boolean> (Phase2でGPU復元)
- _renderRasterErase(layerData, points, radius): boolean (Phase3分岐用)
- _renderSDFErase(layerData, points, radius): boolean (Phase3新規)


================================================================================
EventBus イベント定義
================================================================================

発行イベント:
- 'layer:erased' { layerId, pointCount }
- 'layer:mask-initialized' { layerId, mode }
- 'layer:mask-mode-changed' { layerId, oldMode, newMode }

購読イベント:
- 'tool:select' { tool } (既存・消しゴム切り替え)
- 'brush:size-changed' { size } (既存・消しゴムサイズ)


================================================================================
設定パラメータ (config.js拡張案)
================================================================================

Phase 2以降で追加:
```javascript
eraser: {
    defaultMode: 'raster',        // 'raster' | 'sdf' | 'msdf'
    blendMode: 'erase',           // 'erase' | 'destination-out'
    snapshotLimit: 50,            // Undo履歴の最大スナップショット数
    realtimePreview: true,        // リアルタイムプレビュー有効化
    gpuOptimization: true,        // GPU最適化有効化
    
    sdf: {
        textureSize: 256,         // SDF生成解像度
        range: 20.0,              // 距離エンコード範囲
        smoothness: 2.0           // アンチエイリアス強度
    }
}
```


================================================================================
完了チェックリスト
================================================================================

Phase 1完了条件:
□ 全Step実装完了
□ コンソールエラーゼロ
□ 手動テスト項目全通過
□ メモリリークなし
□ Undo/Redo安定動作

Phase 2完了条件:
□ BlendMode.ERASE統合
□ RenderTexture GPUコピー実装
□ 60fps安定（1080p）
□ リアルタイムプレビュー動作

Phase 3完了条件（オプション）:
□ SDF/MSDF生成パイプライン
□ レイヤーモード切替UI
□ 高精度レイヤーで品質向上確認
□ パフォーマンス劣化なし


================================================================================
以上
================================================================================

本計画書に従い、Phase 1から順次実装を進めてください。
各Stepで動作確認を行い、問題があれば該当箇所のみを修正してください。

【重要】
- Phase 1のみで十分な品質が得られる可能性が高い
- Phase 2は性能向上が必要な場合のみ実装
- Phase 3は差別化機能として余裕があれば実装

初心者向け推奨: Phase 1完全完了 → 運用 → 必要に応じてPhase 2/3検討