================================================================================
ブラウザお絵かきツール v8.13 
段階的改修計画書 完全版
================================================================================

【改修概要】
既存問題4件の修正 + 新規仕様3件の実装
Phase 1-4: 既存問題修正（Phase 1,4は対応済み）
Phase 5-9: 新規仕様実装

【改修優先度】
優先度S（即対応）: Phase 2, 3, 5
優先度A（重要）: Phase 6, 7, 8
優先度B（拡張）: Phase 9


================================================================================
■ システムアーキテクチャ概要
================================================================================

【主要グローバルオブジェクト】
- window.brushSettings         : ブラシ設定（size/color/opacity）
- window.CoordinateSystem       : 座標変換API（screen→canvas→world→local）
- window.TegakiEventBus         : イベントバス
- window.layerManager           : レイヤー管理（= layerSystem）
- window.strokeRecorder         : ストローク座標記録
- window.strokeRenderer         : 描画レンダラー
- window.BrushCore              : 描画コア統合
- window.ThumbnailSystem        : サムネイル生成

【描画フロー】
PointerEvent
  → pointer-handler.js (clientX/Y取得)
  → coordinate-system.js (screen→canvas→world→local変換)
  → brush-core.js (startStroke/updateStroke/finalizeStroke)
    → window.brushSettings から設定取得
  → stroke-recorder.js (ローカル座標記録)
  → stroke-renderer.js (描画オブジェクト生成)
  → layer-system.js (レイヤーへ追加)
  → EventBus.emit('layer:path-added')
  → layer-panel-renderer.js (サムネイル更新)

【レイヤーパネルUI構造】
layer-panel-renderer.js
  → createLayerElement()
    - .layer-visibility (目アイコン)
    - .layer-opacity (透明度表示)
    - .layer-name (レイヤー名)
    - .layer-thumbnail (サムネイル画像)
    - .layer-delete-button (削除ボタン)

【主要イベント】
- brush:size-changed            : ペンサイズ変更
- brush:color-changed           : 色変更
- brush:opacity-changed         : 不透明度変更
- layer:path-added              : パス追加完了
- layer:visibility-changed      : レイヤー表示切替
- layer:activated               : アクティブレイヤー変更
- thumbnail:layer-updated       : サムネイル更新要求


================================================================================
Phase 1: ペン設定統合 ✅ 対応済み
================================================================================

【対応状況】
- brush-settings.js : シングルトンパターン実装済み
- brush-core.js : window.brushSettings参照に変更済み
- quick-access-popup.js : EventBus経由で設定変更済み

【確認事項】
- Qキーポップアップで色・サイズ・透明度変更が即座に反映されるか
- EventBusイベントが正しく発火しているか

【テスト項目】
□ Qキー押下でポップアップ表示
□ 色変更 → 描画に反映
□ サイズ変更 → 描画に反映
□ 透明度変更 → 描画に反映


================================================================================
Phase 2: 背景チェックパターン実装 ⚠️ 要対応
================================================================================

【目的】
背景レイヤー非表示時に透明チェックパターンを表示し、
消しゴムの透明度を視覚的に確認可能にする

【改修ファイル】
1. layer-system.js
   - _createCheckerPatternBackground() : 16x16pxチェッカー生成
   - createLayer() : 背景レイヤー作成時にチェッカー参照を保持
   - toggleLayerVisibility() : 背景レイヤー非表示時にチェッカー表示

2. camera-system.js または core-engine.js
   - worldContainer初期化時にチェッカーをz-index最背面に配置
   - 背景レイヤーのvisibility連動制御

【実装方針】
```javascript
// layer-system.js
_createCheckerPatternBackground(width, height) {
    const g = new PIXI.Graphics();
    const color1 = 0xe0e0e0;
    const color2 = 0xffffff;
    const squareSize = 16;
    
    for (let y = 0; y < height; y += squareSize) {
        for (let x = 0; x < width; x += squareSize) {
            const isEvenX = Math.floor(x / squareSize) % 2 === 0;
            const isEvenY = Math.floor(y / squareSize) % 2 === 0;
            const color = (isEvenX === isEvenY) ? color1 : color2;
            g.rect(x, y, squareSize, squareSize);
            g.fill({ color });
        }
    }
    
    g.visible = false;
    g.label = 'checkerPattern';
    return g;
}

// toggleLayerVisibility() に追加
if (layer.layerData?.isBackground) {
    if (this.checkerPattern) {
        this.checkerPattern.visible = !layer.layerData.visible;
    }
}
```

【参考メソッド】
- layer-system.js : createLayer(), toggleLayerVisibility()
- camera-system.js : init(), setupWorldContainer()

【テスト項目】
□ 背景レイヤー非表示 → チェックパターン表示
□ 背景レイヤー表示 → チェックパターン非表示
□ 消しゴム使用時に透明部分がチェックパターンで確認可能
□ キャンバスリサイズ時にチェックパターンも追従


================================================================================
Phase 3: 消しゴム透明化修正 ⚠️ 要対応
================================================================================

【目的】
消しゴムを真の透明化ツールとして機能させる
現状: #ffffee色のペンとして動作
目標: 完全透明化（アルファ削除）

【調査項目】
1. PixiJS v8のblendMode='erase'がレイヤー内で機能するか
2. レイヤーコンテナのblendMode設定が必要か
3. マスク処理との競合確認
4. WebGPU/Legacy描画での差異確認

【改修ファイル】
1. stroke-renderer.js
   - renderPreview() : 消しゴムモード時のblendMode設定
   - renderFinalStroke() : 最終描画時のblendMode確認
   - setTool('eraser') : ツール切替時の処理

2. layer-system.js
   - レイヤーコンテナのblendMode初期設定確認
   - マスク処理との競合チェック

3. brush-core.js
   - setMode('eraser') : 消しゴムモード切替時の処理確認

【実装方針A: blendMode修正】
```javascript
// stroke-renderer.js
renderPreview(points, settings, targetGraphics) {
    if (this.currentTool === 'eraser') {
        // レイヤーコンテナ自体のblendMode確認
        const parentLayer = targetGraphics.parent;
        if (parentLayer && !parentLayer._blendModeSet) {
            parentLayer.blendMode = 'normal';
            parentLayer._blendModeSet = true;
        }
        
        // 消しゴムグラフィックスのblendMode設定
        targetGraphics.blendMode = 'erase';
        targetGraphics.fill({ color: 0xFFFFFF, alpha: 1.0 });
    } else {
        targetGraphics.blendMode = 'normal';
        targetGraphics.fill({ color: settings.color, alpha: settings.opacity });
    }
}
```

【実装方針B: マスク処理】
blendModeが機能しない場合、マスク処理で実装:
```javascript
// 消しゴムパスを反転マスクとして使用
const eraserMask = new PIXI.Graphics();
// 消しゴムパスを描画
eraserMask.blendMode = 'erase';
layer.mask = eraserMask;
```

【参考メソッド】
- stroke-renderer.js : renderPreview(), renderFinalStroke()
- brush-core.js : setMode(), startStroke()
- layer-system.js : _applyMaskToLayerGraphics()

【テスト項目】
□ 消しゴムで描画 → 完全に透明になる
□ 下のレイヤーの絵が見える
□ チェックパターン（Phase 2）が見える
□ 色が残らない
□ Undo/Redoが正常動作


================================================================================
Phase 4: レイヤー名連番修正 ✅ 対応済み
================================================================================

【対応状況】
- layer-system.js : createLayer()でレイヤー名自動連番対応済み
- 非背景レイヤーの数をカウントして「レイヤーN」を生成

【確認事項】
- 起動時: 「背景」「レイヤー1」
- レイヤー追加: 「レイヤー2」「レイヤー3」...
- レイヤー削除後に追加: 連番継続（最大値+1）


================================================================================
Phase 5: 背景レイヤー仕様実装 ⚠️ 要対応
================================================================================

【目的】
背景レイヤーに色変更機能を追加し、PSD互換性を確保

【背景レイヤー仕様】
- 最下層固定、常に不透明、透明ピクセル無し
- 色変更: バケツアイコンクリック → 現在のペンカラーで塗る
- 透明度表示「100%」を削除（常に100%）
- 表示/非表示切り替え可能
- PSD出力時は「Background Layer」として扱う

【改修ファイル】
1. ui/layer-panel-renderer.js
   - createLayerElement() : 背景レイヤー専用UI作成
     - バケツアイコン追加（目アイコンの隣）
     - 透明度表示を非表示
     - 削除ボタンを非表示

2. layer-system.js
   - 背景レイヤー色変更メソッド追加
   - EventBus経由でバケツアイコンクリックをハンドリング

3. system/exporters/psd-exporter.js（未実装の場合は後回し）
   - 背景レイヤーをPSD「Background Layer」として出力

【実装方針】
```javascript
// layer-panel-renderer.js
createLayerElement(layer, index, isActive, animationSystem) {
    // ... 既存コード ...
    
    if (layer.layerData?.isBackground) {
        // バケツアイコン追加
        const bucketIcon = document.createElement('div');
        bucketIcon.className = 'layer-background-color-button';
        bucketIcon.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" 
                 viewBox="0 0 24 24" fill="none" stroke="#800000" 
                 stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/>
                <path d="m5 2 5 5"/>
                <path d="M2 13h15"/>
                <path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z"/>
            </svg>
        `;
        bucketIcon.style.gridColumn = '2';
        bucketIcon.style.gridRow = '1';
        bucketIcon.style.cursor = 'pointer';
        layerDiv.appendChild(bucketIcon);
        
        bucketIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            if (window.TegakiEventBus) {
                window.TegakiEventBus.emit('ui:background-color-change-requested', {
                    layerIndex: index,
                    layerId: layer.layerData.id
                });
            }
        });
        
        // 透明度表示を削除
        const opacityDiv = layerDiv.querySelector('.layer-opacity');
        if (opacityDiv) opacityDiv.remove();
        
        // 削除ボタンを削除
        const deleteBtn = layerDiv.querySelector('.layer-delete-button');
        if (deleteBtn) deleteBtn.remove();
    }
}
```

```javascript
// layer-system.js
_setupEventListeners() {
    // ... 既存コード ...
    
    this.eventBus.on('ui:background-color-change-requested', ({ layerIndex, layerId }) => {
        this._changeBackgroundLayerColor(layerIndex, layerId);
    });
}

_changeBackgroundLayerColor(layerIndex, layerId) {
    const layer = this.getLayers()[layerIndex];
    if (!layer?.layerData?.isBackground) return;
    
    // 現在のペンカラーを取得
    const color = window.brushSettings?.getColor() || 0xf0e0d6;
    
    // 背景グラフィックスを再生成
    const bg = layer.layerData.backgroundGraphics;
    if (bg) {
        bg.clear();
        bg.rect(0, 0, this.config.canvas.width, this.config.canvas.height);
        bg.fill({ color });
    }
    
    // サムネイル更新
    this.requestThumbnailUpdate(layerIndex);
    
    // EventBus通知
    this.eventBus.emit('layer:background-color-changed', {
        layerIndex,
        layerId,
        color
    });
}
```

【参考メソッド】
- layer-panel-renderer.js : createLayerElement(), createThumbnail()
- layer-system.js : createLayer(), _createCheckerPatternBackground()
- brush-settings.js : getColor()

【テスト項目】
□ 背景レイヤーにバケツアイコン表示
□ バケツアイコンクリック → 現在のペンカラーで塗られる
□ 透明度表示が非表示
□ 削除ボタンが非表示
□ 階層移動が無効


================================================================================
Phase 6: レイヤー透明度UI実装 ⚠️ 要対応
================================================================================

【目的】
一般レイヤー（非背景）に透明度調整機能を実装

【仕様】
- 透明度表示: 「◀ 100% ▶」形式
- 「100%」の上でドラッグ → 透明度変更
- 「◀」ボタンクリック → -10%
- 「▶」ボタンクリック → +10%
- 範囲: 0% ～ 100%

【改修ファイル】
1. ui/layer-panel-renderer.js
   - createLayerElement() : 透明度UI構築
   - _setupOpacityDrag() : ドラッグイベント処理

2. layer-system.js
   - setLayerOpacity() : レイヤー透明度設定メソッド追加
   - EventBus通知

3. data-models.js
   - LayerModel : opacity プロパティ追加（デフォルト1.0）

【実装方針】
```javascript
// layer-panel-renderer.js
createLayerElement(layer, index, isActive, animationSystem) {
    // ... 既存コード ...
    
    if (!layer.layerData?.isBackground) {
        // 透明度UIコンテナ
        const opacityContainer = document.createElement('div');
        opacityContainer.className = 'layer-opacity-control';
        opacityContainer.style.gridColumn = '2';
        opacityContainer.style.gridRow = '1';
        
        // ◀ ボタン
        const decreaseBtn = document.createElement('button');
        decreaseBtn.textContent = '◀';
        decreaseBtn.className = 'layer-opacity-decrease';
        decreaseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this._adjustLayerOpacity(index, -0.1);
        });
        
        // 透明度表示（ドラッグ可能）
        const opacityValue = document.createElement('span');
        opacityValue.className = 'layer-opacity-value';
        opacityValue.textContent = `${Math.round((layer.alpha || 1.0) * 100)}%`;
        opacityValue.style.cursor = 'ew-resize';
        this._setupOpacityDrag(opacityValue, index);
        
        // ▶ ボタン
        const increaseBtn = document.createElement('button');
        increaseBtn.textContent = '▶';
        increaseBtn.className = 'layer-opacity-increase';
        increaseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this._adjustLayerOpacity(index, 0.1);
        });
        
        opacityContainer.appendChild(decreaseBtn);
        opacityContainer.appendChild(opacityValue);
        opacityContainer.appendChild(increaseBtn);
        layerDiv.appendChild(opacityContainer);
    }
}

_setupOpacityDrag(element, layerIndex) {
    let isDragging = false;
    let startX = 0;
    let startOpacity = 0;
    
    element.addEventListener('pointerdown', (e) => {
        isDragging = true;
        startX = e.clientX;
        const layer = this.layerSystem.getLayers()[layerIndex];
        startOpacity = layer.alpha || 1.0;
        element.setPointerCapture(e.pointerId);
        e.stopPropagation();
    });
    
    element.addEventListener('pointermove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const delta = dx / 100; // 100pxで1.0変化
        const newOpacity = Math.max(0, Math.min(1, startOpacity + delta));
        this._setLayerOpacity(layerIndex, newOpacity);
    });
    
    element.addEventListener('pointerup', (e) => {
        if (!isDragging) return;
        isDragging = false;
        element.releasePointerCapture(e.pointerId);
    });
}

_adjustLayerOpacity(layerIndex, delta) {
    const layer = this.layerSystem.getLayers()[layerIndex];
    const currentOpacity = layer.alpha || 1.0;
    const newOpacity = Math.max(0, Math.min(1, currentOpacity + delta));
    this._setLayerOpacity(layerIndex, newOpacity);
}

_setLayerOpacity(layerIndex, opacity) {
    if (this.layerSystem.setLayerOpacity) {
        this.layerSystem.setLayerOpacity(layerIndex, opacity);
    }
    
    // UI更新
    const layerDiv = this.container.querySelectorAll('.layer-item')[
        this.layerSystem.getLayers().length - 1 - layerIndex
    ];
    const opacityValue = layerDiv?.querySelector('.layer-opacity-value');
    if (opacityValue) {
        opacityValue.textContent = `${Math.round(opacity * 100)}%`;
    }
}
```

```javascript
// layer-system.js
setLayerOpacity(layerIndex, opacity) {
    const layers = this.getLayers();
    if (layerIndex < 0 || layerIndex >= layers.length) return;
    
    const layer = layers[layerIndex];
    if (layer.layerData?.isBackground) return;
    
    opacity = Math.max(0, Math.min(1, opacity));
    
    layer.alpha = opacity;
    if (layer.layerData) {
        layer.layerData.opacity = opacity;
    }
    
    this.requestThumbnailUpdate(layerIndex);
    
    if (this.eventBus) {
        this.eventBus.emit('layer:opacity-changed', {
            layerIndex,
            layerId: layer.layerData?.id,
            opacity
        });
    }
}
```

【参考メソッド】
- layer-panel-renderer.js : createLayerElement()
- layer-system.js : toggleLayerVisibility()
- ui/slider-utils.js : スライダー実装の参考

【テスト項目】
□ 透明度UI「◀ 100% ▶」表示
□ ドラッグで透明度変更
□ ◀ボタンで-10%
□ ▶ボタンで+10%
□ 0%～100%範囲制限
□ 背景レイヤーには表示されない


================================================================================
Phase 7: レイヤードラッグレスポンス改善 ⚠️ 要対応
================================================================================

【目的】
レイヤー階層移動時のドラッグUIレスポンスを改善し、
移動先が視覚的にわかりやすくする

【現状の問題】
- ドラッグ中のレイヤーパネルがほぼ動かない
- 移動先が不明確
- ユーザーストレスが高い

【改修方針】
- ドラッグ中のパネルをカーソルに追従させる
- 挿入位置にガイドラインを表示
- SortableJSのオプション最適化

【改修ファイル】
1. ui/layer-panel-renderer.js
   - initializeSortable() : SortableJS設定変更

2. styles/main.css
   - .sortable-ghost : ドラッグ中の外観
   - .sortable-drag : ドラッグ要素のスタイル
   - .sortable-chosen : 選択時のスタイル

【実装方針】
```javascript
// layer-panel-renderer.js
initializeSortable() {
    if (!window.Sortable) return;
    
    try {
        if (this.sortable) {
            this.sortable.destroy();
        }

        this.sortable = Sortable.create(this.container, {
            animation: 150,
            ghostClass: 'sortable-ghost',
            dragClass: 'sortable-drag',
            chosenClass: 'sortable-chosen',
            forceFallback: true,  // カスタムドラッグ外観を強制
            fallbackOnBody: true,
            swapThreshold: 0.65,
            
            onChoose: (evt) => {
                // ドラッグ開始
                evt.item.style.opacity = '0.5';
            },
            
            onStart: (evt) => {
                // ドラッグ中
                evt.item.style.cursor = 'grabbing';
            },
            
            onEnd: (evt) => {
                // ドロップ完了
                evt.item.style.opacity = '';
                evt.item.style.cursor = '';
                
                if (this.layerSystem?.reorderLayers) {
                    this.layerSystem.reorderLayers(evt.oldIndex, evt.newIndex);
                }
            }
        });
    } catch (error) {
        if (this.debugEnabled) {
            console.warn('Sortable initialization failed:', error);
        }
    }
}
```

```css
/* styles/main.css */
.sortable-ghost {
    opacity: 0.3;
    background-color: var(--futaba-light-maroon);
}

.sortable-drag {
    opacity: 1.0 !important;
    transform: rotate(2deg);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    cursor: grabbing !important;
}

.sortable-chosen {
    background-color: var(--futaba-accent);
}

.layer-item {
    cursor: grab;
}

.layer-item:active {
    cursor: grabbing;
}
```

【参考メソッド】
- layer-panel-renderer.js : initializeSortable()
- layer-system.js : reorderLayers()

【テスト項目】
□ レイヤードラッグ時にカーソルに追従
□ ドラッグ中の外観がわかりやすい
□ 挿入位置が明確
□ ドロップ後の階層変更が正常
□ Undo/Redo対応


================================================================================
Phase 8: アクティブ/準アクティブUI改善 ⚠️ 要対応
================================================================================

【目的】
レイヤーパネルとタイムラインのアクティブ表示を改善し、
最後に触った方を橙色、もう一方を準アクティブ色（#aa5a56）にする

【仕様】
- レイヤーパネルのレイヤーを触った後にタイムラインのフレームを触った場合
  - タイムライン: 橙色（アクティブ）
  - レイヤーパネル: #aa5a56（準アクティブ）
- その逆も同様
- コピー/ペースト操作時にどちらに対する操作か明確化

【改修ファイル】
1. ui/layer-panel-renderer.js
   - setActiveStyle() : アクティブ/準アクティブスタイル切替

2. ui/timeline-ui.js
   - setActiveStyle() : アクティブ/準アクティブスタイル切替

3. system/state-manager.js
   - lastActivePanel : 'layer' | 'timeline' を記録

4. styles/main.css
   - --futaba-accent: 橙色
   - --futaba-light-maroon: #aa5a56（準アクティブ）

【実装方針】
```javascript
// state-manager.js
class StateManager {
    constructor() {
        // ... 既存コード ...
        this.lastActivePanel = 'layer'; // 'layer' | 'timeline'
    }
    
    setLastActivePanel(panel) {
        if (panel !== 'layer' && panel !== 'timeline') return;
        
        const oldPanel = this.lastActivePanel;
        this.lastActivePanel = panel;
        
        if (this.eventBus) {
            this.eventBus.emit('ui:active-panel-changed', {
                activePanel: panel,
                inactivePanel: oldPanel === 'layer' ? 'timeline' : 'layer'
            });
        }
    }
}
```

```javascript
// layer-panel-renderer.js
_setupEventListeners() {
    // ... 既存コード ...
    
    this.eventBus.on('ui:active-panel-changed', ({ activePanel, inactivePanel }) => {
        this._updatePanelActiveState(activePanel === 'layer');
    });
}

_updatePanelActiveState(isActive) {
    const activeLayer = this.container.querySelector('.layer-item.active');
    if (!activeLayer) return;
    
    if (isActive) {
        activeLayer.style.borderColor = 'var(--futaba-accent)';
    } else {
        activeLayer.style.borderColor = 'var(--futaba-light-maroon)';
    }
}

createLayerElement(layer, index, isActive, animationSystem) {
    // ... 既存コード ...
    
    layerDiv.addEventListener('click', (e) => {
        if (e.target !== checkbox) {
            // StateManager更新
            if (window.stateManager) {
                window.stateManager.setLastActivePanel('layer');
            }
            
            if (window.TegakiEventBus) {
                window.TegakiEventBus.emit('ui:layer-selected', { 
                    layerIndex: index,
                    layerId: layer.layerData?.id
                });
            }
        }
    });
}
```

```javascript
// timeline-ui.js
_setupEventListeners() {
    // ... 既存コード ...
    
    this.eventBus.on('ui:active-panel-changed', ({ activePanel, inactivePanel }) => {
        this._updateFrameActiveState(activePanel === 'timeline');
    });
}

_updateFrameActiveState(isActive) {
    const activeFrame = this.container.querySelector('.frame-item.active');
    if (!activeFrame) return;
    
    if (isActive) {
        activeFrame.style.borderColor = 'var(--futaba-accent)';
    } else {
        activeFrame.style.borderColor = 'var(--futaba-light-maroon)';
    }
}

// フレームクリック時
frameItem.addEventListener('click', () => {
    // StateManager更新
    if (window.stateManager) {
        window.stateManager.setLastActivePanel('timeline');
    }
    
    // ... 既存コード ...
});
```

【参考メソッド】
- layer-panel-renderer.js : createLayerElement()
- timeline-ui.js : renderFrames()
- state-manager.js : 全体

【テスト項目】
□ レイヤー選択 → レイヤーパネルが橙、タイムラインが#aa5a56
□ フレーム選択 → タイムラインが橙、レイヤーパネルが#aa5a56
□ コピー/ペースト時に対象が明確
□ キーボードショートカットでのアクティブ切替


================================================================================
Phase 9: フォルダ機能実装 ⚠️ 要対応
================================================================================

【目的】
レイヤーをフォルダで階層管理できるようにする

【仕様】
- フォルダ追加ボタンを機能させる
- フォルダパネルデザイン: 左上に出っ張り
- フォルダカラー: #f0e0d6
- レイヤーカラー: #ffffee
- フォルダの展開/折りたたみ
- ドラッグ&ドロップでフォルダに入れる

【改修ファイル】
1. system/data-models.js
   - FolderModel : フォルダデータモデル追加
   - LayerModel : parentFolderId プロパティ追加

2. layer-system.js
   - createFolder() : フォルダ作成
   - moveLayerToFolder() : レイヤーをフォルダに移動
   - toggleFolderExpansion() : 展開/折りたたみ

3. ui/layer-panel-renderer.js
   - createFolderElement() : フォルダUI作成
   - 階層構造表示
   - ドラッグ&ドロップ処理

4. styles/main.css
   - .folder-item : フォルダパネルスタイル
   - .folder-toggle : 展開/折りたたみボタン

【実装方針】
```javascript
// data-models.js
class FolderModel {
    constructor(options = {}) {
        this.id = options.id || `folder_${Date.now()}_${Math.random()}`;
        this.name = options.name || 'フォルダー';
        this.expanded = options.expanded !== undefined ? options.expanded : true;
        this.visible = options.visible !== undefined ? options.visible : true;
        this.opacity = options.opacity || 1.0;
        this.layerIds = options.layerIds || [];
    }
}

class LayerModel {
    constructor(options = {}) {
        // ... 既存コード ...
        this.parentFolderId = options.parentFolderId || null;
    }
}
```

```javascript
// layer-system.js
createFolder(name) {
    if (!this.currentFrameContainer) return null;
    
    const folderModel = new window.TegakiDataModels.FolderModel({ name });
    
    // フォルダをレイヤーリストに追加（特殊な扱い）
    if (!this.folders) {
        this.folders = new Map();
    }
    this.folders.set(folderModel.id, folderModel);
    
    this.updateLayerPanelUI();
    
    if (this.eventBus) {
        this.eventBus.emit('folder:created', { folderId: folderModel.id, name: folderModel.name });
    }
    
    return folderModel;
}

moveLayerToFolder(layerIndex, folderId) {
    const layers = this.getLayers();
    if (layerIndex < 0 || layerIndex >= layers.length) return false;
    
    const layer = layers[layerIndex];
    const folder = this.folders.get(folderId);
    if (!folder) return false;
    
    layer.layerData.parentFolderId = folderId;
    folder.layerIds.push(layer.layerData.id);
    
    this.updateLayerPanelUI();
    
    if (this.eventBus) {
        this.eventBus.emit('layer:moved-to-folder', {
            layerIndex,
            layerId: layer.layerData.id,
            folderId
        });
    }
    
    return true;
}

toggleFolderExpansion(folderId) {
    const folder = this.folders?.get(folderId);
    if (!folder) return;
    
    folder.expanded = !folder.expanded;
    this.updateLayerPanelUI();
    
    if (this.eventBus) {
        this.eventBus.emit('folder:expansion-toggled', {
            folderId,
            expanded: folder.expanded
        });
    }
}
```

```javascript
// layer-panel-renderer.js
render(layers, activeIndex, animationSystem = null) {
    if (!this.container) return;
    if (!layers || layers.length === 0) return;

    this.container.innerHTML = '';
    
    // フォルダーとレイヤーの階層構造を構築
    const structure = this._buildHierarchy(layers);
    
    structure.forEach(item => {
        if (item.type === 'folder') {
            const folderElement = this.createFolderElement(item.folder);
            this.container.insertBefore(folderElement, this.container.firstChild);
            
            if (item.folder.expanded) {
                item.children.forEach(childLayer => {
                    const layerElement = this.createLayerElement(
                        childLayer.layer,
                        childLayer.index,
                        childLayer.index === activeIndex,
                        animationSystem
                    );
                    layerElement.style.marginLeft = '20px'; // インデント
                    this.container.insertBefore(layerElement, this.container.firstChild);
                });
            }
        } else {
            const layerElement = this.createLayerElement(
                item.layer,
                item.index,
                item.index === activeIndex,
                animationSystem
            );
            this.container.insertBefore(layerElement, this.container.firstChild);
        }
    });

    this.initializeSortable();
}

_buildHierarchy(layers) {
    const folders = this.layerSystem?.folders || new Map();
    const structure = [];
    
    // フォルダーを先に追加
    folders.forEach((folder, folderId) => {
        const folderItem = {
            type: 'folder',
            folder: folder,
            children: []
        };
        
        // フォルダー内のレイヤーを収集
        layers.forEach((layer, index) => {
            if (layer.layerData?.parentFolderId === folderId) {
                folderItem.children.push({ layer, index });
            }
        });
        
        structure.push(folderItem);
    });
    
    // フォルダーに属さないレイヤーを追加
    layers.forEach((layer, index) => {
        if (!layer.layerData?.parentFolderId) {
            structure.push({ type: 'layer', layer, index });
        }
    });
    
    return structure;
}

createFolderElement(folder) {
    const folderDiv = document.createElement('div');
    folderDiv.className = 'folder-item';
    folderDiv.style.backgroundColor = '#f0e0d6'; // フォルダカラー
    folderDiv.dataset.folderId = folder.id;
    
    // 左上の出っ張り
    folderDiv.style.position = 'relative';
    folderDiv.style.paddingTop = '8px';
    const tab = document.createElement('div');
    tab.style.position = 'absolute';
    tab.style.top = '-8px';
    tab.style.left = '0';
    tab.style.width = '50%';
    tab.style.height = '8px';
    tab.style.backgroundColor = '#f0e0d6';
    tab.style.borderTopLeftRadius = '4px';
    tab.style.borderTopRightRadius = '4px';
    folderDiv.appendChild(tab);
    
    // 展開/折りたたみボタン
    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'folder-toggle';
    toggleBtn.textContent = folder.expanded ? '▼' : '▶';
    toggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (this.layerSystem?.toggleFolderExpansion) {
            this.layerSystem.toggleFolderExpansion(folder.id);
        }
    });
    folderDiv.appendChild(toggleBtn);
    
    // フォルダ名
    const nameSpan = document.createElement('span');
    nameSpan.className = 'folder-name';
    nameSpan.textContent = folder.name;
    folderDiv.appendChild(nameSpan);
    
    return folderDiv;
}
```

【参考メソッド】
- data-models.js : LayerModel
- layer-system.js : createLayer(), getLayers()
- layer-panel-renderer.js : render(), createLayerElement()

【テスト項目】
□ フォルダ追加ボタンでフォルダ作成
□ フォルダの展開/折りたたみ
□ レイヤーをドラッグ&ドロップでフォルダに移動
□ フォルダ内のレイヤーがインデント表示
□ フォルダカラー#f0e0d6、レイヤーカラー#ffffee
□ フォルダの表示/非表示が子レイヤーに影響


================================================================================
■ 改修時の注意事項
================================================================================

【DRY/SOLID原則】
- 設定は window.brushSettings のみ
- 描画は stroke-renderer.js のみ
- 座標変換は coordinate-system.js のみ
- サムネイル生成は ThumbnailSystem のみ

【イベント駆動アーキテクチャ】
- 設定変更時は必ずEventBus.emit()
- 購読側で処理実行
- 直接メソッド呼び出しは最小限

【コンソールログクリーンアップ】
- デバッグ用console.logは改修完了後に削除
- エラーログのみ残す
- 重要な状態遷移のみログ出力

【後方互換性】
- 既存の描画データは保持
- 設定の移行パス不要（揮発性）

【テスト戦略】
- Phase毎に独立してテスト
- Phase 2と3はセットでテスト（チェックパターン + 消しゴム）
- Phase 6と7は UI/UX確認を重点的に


================================================================================
■ Phase実装順序の推奨
================================================================================

【第1弾（優先度S）】
Phase 2 → Phase 3 → Phase 5
理由: 描画基盤の修正が最優先

【第2弾（優先度A）】
Phase 6 → Phase 7 → Phase 8
理由: UI/UX改善

【第3弾（優先度B）】
Phase 9
理由: 拡張機能


================================================================================
END
================================================================================