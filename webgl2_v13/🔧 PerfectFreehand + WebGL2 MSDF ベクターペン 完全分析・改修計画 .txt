# PerfectFreehand + WebGL2 MSDF ãƒ™ã‚¯ã‚¿ãƒ¼ãƒšãƒ³ å®Œå…¨åˆ†æãƒ»æ”¹ä¿®è¨ˆç”»

## ğŸ“ ç†æƒ³çš„ãªãƒ•ãƒ­ãƒ¼ï¼ˆãƒšãƒ³å…¥åŠ› â†’ æœ€çµ‚æç”»ï¼‰

### **Phase 1: ãƒã‚¤ãƒ³ã‚¿å…¥åŠ›å–å¾—**
```
ãƒ¦ãƒ¼ã‚¶ãƒ¼PointerEvent
  â†“
pointer-handler.js
  - æ­£è¦åŒ–ã•ã‚ŒãŸ pressure (0.0-1.0)
  - tiltX, tiltY å–å¾—
  - EventEmitterçµŒç”±ã§é…ä¿¡
```

### **Phase 2: åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³**
```
drawing-engine.js
  â†“ screenClientToCanvas()
  â†“ canvasToWorld()
  â†“ worldToLocal() â† â˜…åº§æ¨™ä¸ä¸€è‡´ã®åŸå› ç®‡æ‰€
  â†“
Localåº§æ¨™ç¢ºå®š (localX, localY)
```

### **Phase 3: ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯è¨˜éŒ²**
```
stroke-recorder.js
  - Localåº§æ¨™ãƒã‚¤ãƒ³ãƒˆã‚’é…åˆ—ã«è¿½åŠ 
  - åº§æ¨™å¤‰æ›ã¯ä¸€åˆ‡è¡Œã‚ãªã„ï¼ˆäºŒé‡å¤‰æ›é˜²æ­¢ï¼‰
  - { x, y, pressure, tiltX, tiltY } ä¿å­˜
```

### **Phase 4: ãƒãƒªã‚´ãƒ³ç”Ÿæˆï¼ˆPerfectFreehandï¼‰**
```
vector-operations.js
  â†“ generateStrokePolygon(points, size)
  â†“ PerfectFreehandå®Ÿè¡Œ
  â†“ è¼ªéƒ­ãƒãƒªã‚´ãƒ³å–å¾—
```

### **Phase 5: GPUé ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆ**
```
gl-stroke-processor.js
  â†“ createPolygonVertexBuffer()
    - PerfectFreehandè¼ªéƒ­ â†’ Earcutä¸‰è§’å½¢åˆ†å‰²
    - 7 floats/vertex å½¢å¼ã§ VBO ä½œæˆ
  â†“ createEdgeBuffer()
    - ã‚¨ãƒƒã‚¸æƒ…å ±ï¼ˆå§‹ç‚¹ãƒ»çµ‚ç‚¹ãƒ»æ³•ç·šï¼‰
    - 8 floats/edge å½¢å¼ã§ SSBO ä½œæˆ
  â†“ calculateBounds()
    - ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹è¨ˆç®—
```

### **Phase 6: MSDFç”Ÿæˆï¼ˆè·é›¢å ´è¨ˆç®—ï¼‰**
```
gl-msdf-pipeline.js
  â†“ seedInitPass() - åˆæœŸåŒ–
  â†“ executeJFA() - Jump Flooding Algorithm ã§æœ€è¿‘æ¥ãƒ”ã‚¯ã‚»ãƒ«è¨ˆç®—
  â†“ encodePass() - è·é›¢å ´ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
  â†“ renderPass() - æœ€çµ‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚¹é©ç”¨ï¼‰
  â†“ 
WebGLTextureç”Ÿæˆï¼ˆ512x512 å›ºå®š â† â˜…ã‚¸ãƒ£ã‚®ãƒ¼ã®åŸå› ï¼‰
```

### **Phase 7: Spriteå¤‰æ›ãƒ»é…ç½®**
```
gl-texture-bridge.js
  â†“ createSpriteFromGLTexture(texture, width, height)
  â†“ WebGLTexture â†’ Canvas â†’ PIXI.Texture â†’ PIXI.Sprite
  â†“
sprite.x = bounds.minX â† â˜…åº§æ¨™ã‚ºãƒ¬ã®åŸå› ç®‡æ‰€
sprite.y = bounds.minY
```

### **Phase 8: ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é…ç½®**
```
brush-core.js
  â†“ _finalizeMSDFStroke()
  â†“ container.addChild(sprite)
  â†“ activeLayer.paths.push(pathData)
```

---

## ğŸ—‚ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¾å…¸

### **åº§æ¨™å¤‰æ›ã‚·ã‚¹ãƒ†ãƒ **
| ãƒ•ã‚¡ã‚¤ãƒ« | ã‚¯ãƒ©ã‚¹/ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ | ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰ | è²¬å‹™ |
|---------|------------------|-------------|------|
| coordinate-system.js | CoordinateSystem | screenClientToCanvas()<br>canvasToWorld()<br>worldToLocal() | åº§æ¨™å¤‰æ›ã®ä¸€å…ƒç®¡ç†<br>worldContaineré€†è¡Œåˆ—è¨ˆç®— |

### **æç”»ã‚¨ãƒ³ã‚¸ãƒ³**
| ãƒ•ã‚¡ã‚¤ãƒ« | ã‚¯ãƒ©ã‚¹/ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ | ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰ | è²¬å‹™ |
|---------|------------------|-------------|------|
| drawing-engine.js | DrawingEngine | _handlePointerDown/Move/Up()<br>_transformPointerToLocal()<br>flushPendingPoints() | PointerEventå—ä¿¡<br>åº§æ¨™å¤‰æ›å®Ÿè¡Œ<br>BrushCoreã¸å§”è­² |
| brush-core.js | BrushCore | startStroke()<br>updateStroke()<br>finalizeStroke()<br>renderPreview() | æç”»çµ±åˆç®¡ç†<br>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼<br>æœ€çµ‚æç”»å®Ÿè¡Œ |

### **ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å‡¦ç†**
| ãƒ•ã‚¡ã‚¤ãƒ« | ã‚¯ãƒ©ã‚¹/ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ | ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰ | è²¬å‹™ |
|---------|------------------|-------------|------|
| stroke-recorder.js | StrokeRecorder | startStroke()<br>addPoint()<br>endStroke()<br>getRawPoints() | Localåº§æ¨™ãƒã‚¤ãƒ³ãƒˆè¨˜éŒ²<br>PerfectFreehandäº’æ›å½¢å¼æä¾› |
| vector-operations.js | VectorOperations | generateStrokePolygon(points, size) | PerfectFreehandå®Ÿè¡Œ<br>è¼ªéƒ­ãƒãƒªã‚´ãƒ³ç”Ÿæˆ |

### **WebGL2ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³**
| ãƒ•ã‚¡ã‚¤ãƒ« | ã‚¯ãƒ©ã‚¹/ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ | ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰ | è²¬å‹™ |
|---------|------------------|-------------|------|
| webgl2-drawing-layer.js | WebGL2DrawingLayer | getGL()<br>createFBO()<br>deleteFBO() | WebGL2ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†<br>FBOç”Ÿæˆãƒ»ç ´æ£„ |
| gl-stroke-processor.js | GLStrokeProcessor | createPolygonVertexBuffer()<br>createEdgeBuffer()<br>calculateBounds()<br>uploadToGPU() | PerfectFreehandâ†’GPUå¤‰æ›<br>Earcutä¸‰è§’å½¢åˆ†å‰²<br>VBO/SSBOç”Ÿæˆ |
| gl-msdf-pipeline.js | GLMSDFPipeline | generateMSDF()<br>seedInitPass()<br>executeJFA()<br>encodePass()<br>renderPass() | MSDFè·é›¢å ´ç”Ÿæˆ<br>Jump Floodingå®Ÿè¡Œ<br>ã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚¹é©ç”¨ |
| gl-texture-bridge.js | GLTextureBridge | createSpriteFromGLTexture() | WebGLTextureâ†’Spriteå¤‰æ›<br>Yè»¸åè»¢å‡¦ç† |
| gl-mask-layer.js | GLMaskLayer | renderStrokeMask()<br>applyMask() | æ¶ˆã—ã‚´ãƒ ãƒã‚¹ã‚¯ç”Ÿæˆ<br>åˆæˆå‡¦ç† |

### **ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—**
| ãƒ•ã‚¡ã‚¤ãƒ« | ã‚¯ãƒ©ã‚¹/ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ | ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰ | è²¬å‹™ |
|---------|------------------|-------------|------|
| core-engine.js | CoreEngine | _renderLoop()<br>flushPointerBatch() | ãƒã‚¹ã‚¿ãƒ¼ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—<br>previewâ†’renderçµ±åˆ |

---

## ğŸ› ç¾çŠ¶ã®å•é¡Œåˆ†æ

### **å•é¡Œ1: åº§æ¨™ä¸ä¸€è‡´ï¼ˆå³ä¸‹ã«ã‚ºãƒ¬ã‚‹ï¼‰**

#### æ ¹æœ¬åŸå› 
1. **boundsè¨ˆç®—ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆå•é¡Œ**
   ```javascript
   // gl-stroke-processor.js - createPolygonVertexBuffer()
   const bounds = this._calculateBoundsFromPoints(processedPoints, baseSize);
   const offsetX = bounds.minX;  // â† ã“ã“ã§ã‚ªãƒ•ã‚»ãƒƒãƒˆ
   const offsetY = bounds.minY;
   
   // ãƒãƒªã‚´ãƒ³é ‚ç‚¹ã‚’ã‚ªãƒ•ã‚»ãƒƒãƒˆåˆ†æ¸›ç®—
   flat.push(
     outlinePoints[i][0] - offsetX,  // â† Localåº§æ¨™ã‹ã‚‰ã•ã‚‰ã«æ¸›ç®—
     outlinePoints[i][1] - offsetY
   );
   ```

2. **renderPassã§ã®Uniformè¨­å®š**
   ```javascript
   // gl-msdf-pipeline.js - _drawStroke()
   gl.uniform2f(uOffset, bounds.minX, bounds.minY);  // â† ã‚ªãƒ•ã‚»ãƒƒãƒˆåŠ ç®—
   
   // Vertex Shaderå†…
   vec2 position = aPosition + uOffset;  // â† å†åº¦åŠ ç®—
   ```

3. **Spriteé…ç½®æ™‚ã®åº§æ¨™**
   ```javascript
   // brush-core.js - _finalizeMSDFStroke()
   sprite.x = bounds.minX;  // â† 3é‡ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆé©ç”¨ï¼Ÿ
   sprite.y = bounds.minY;
   ```

#### ä¿®æ­£æ–¹é‡
- **ã‚ªãƒ•ã‚»ãƒƒãƒˆé©ç”¨ã‚’1ç®‡æ‰€ã«çµ±ä¸€**
- gl-stroke-processorå†…ã§Localåº§æ¨™ã‚’ãã®ã¾ã¾ä¿æŒ
- renderPasså†…ã§ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—ã‚’å‰Šé™¤
- Spriteé…ç½®æ™‚ã«bounds.minXã‚’æ­£ã—ãé©ç”¨

---

### **å•é¡Œ2: ãƒ•ãƒªãƒƒã‚«ãƒ¼ï¼ˆãƒãƒ©ã¤ãï¼‰**

#### æ ¹æœ¬åŸå› 
```javascript
// core-engine.js - _renderLoop()
_renderLoop() {
  // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆ60fpsï¼‰ã§renderPreviewãŒå‘¼ã°ã‚Œã‚‹
  if (window.BrushCore.isDrawing) {
    window.BrushCore.renderPreview();  // â† 60fpså‘¼ã³å‡ºã—
  }
  requestAnimationFrame(() => this._renderLoop());
}

// brush-core.js - renderPreview()
async _updatePreview(points) {
  // æ—¢å­˜ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå‰Šé™¤
  if (this.previewSprite) {
    this.previewContainer.removeChild(this.previewSprite);
    this.previewSprite.destroy({ children: true });  // â† æ¯å›ç ´æ£„
  }
  
  // æ–°ã—ã„ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆç”Ÿæˆï¼ˆéåŒæœŸå‡¦ç†ï¼‰
  const sprite = await this.textureBridge.createSpriteFromGLTexture(...);
  this.previewContainer.addChild(sprite);  // â† æ¯å›è¿½åŠ 
}
```

#### å•é¡Œç‚¹
1. **ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ç”Ÿæˆãƒ»ç ´æ£„ãŒé«˜é »åº¦** â†’ GPU/CPUãƒªã‚½ãƒ¼ã‚¹æµªè²»
2. **éåŒæœŸå‡¦ç†ã®å®Œäº†ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒä¸å®š** â†’ æç”»ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãšã‚Œ
3. **throttleï¼ˆ16msï¼‰ã§ã¯ä¸ååˆ†** â†’ ãƒã‚¤ãƒ³ãƒˆè¿½åŠ ã¯æ•°msé–“éš”

#### ä¿®æ­£æ–¹é‡
- **ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°é »åº¦ã‚’å‰Šæ¸›**ï¼ˆ100msç¨‹åº¦ã«å»¶é•·ï¼‰
- **ãƒ†ã‚¯ã‚¹ãƒãƒ£å†åˆ©ç”¨** - æ—¢å­˜FBOã«ä¸Šæ›¸ã
- **åŒæœŸçš„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°** - WebGLæç”»ã‚’Promiseä¸è¦ã«

---

### **å•é¡Œ3: ã‚¸ãƒ£ã‚®ãƒ¼ï¼ˆã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚¹ä¸è¶³ï¼‰**

#### æ ¹æœ¬åŸå› 
```javascript
// gl-msdf-pipeline.js
constructor() {
  this.textureSize = 512;  // â† å›ºå®šã‚µã‚¤ã‚º
}

generateMSDF() {
  const width = this.textureSize;   // 512pxå›ºå®š
  const height = this.textureSize;  // 512pxå›ºå®š
  
  // å®Ÿéš›ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚µã‚¤ã‚ºã«é–¢ã‚ã‚‰ãš512x512ã§ç”Ÿæˆ
  const msdfFBO = createFBO(width, height, { float: false });
}
```

#### å•é¡Œç‚¹
- ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãŒ1000x1000pxã§ã‚‚512x512ã«åœ§ç¸®
- æ‹¡å¤§æ™‚ã«ãƒ”ã‚¯ã‚»ãƒ«åŒ–ãŒé¡•è‘—
- MSDFè·é›¢å ´ã®è§£åƒåº¦ä¸è¶³

#### ä¿®æ­£æ–¹é‡
1. **å‹•çš„ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚º** - ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯boundsã«å¿œã˜ã¦2ã®ã¹ãä¹—ã§ç”Ÿæˆ
2. **æœ€å°512pxã€æœ€å¤§2048px** - GPUåˆ¶é™ã‚’è€ƒæ…®
3. **é©åˆ‡ãªpadding** - ã‚¨ãƒƒã‚¸ã®ã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚¹ç¢ºä¿

---

### **å•é¡Œ4: æ¶ˆã—ã‚´ãƒ æœªå‹•ä½œ**

#### æ ¹æœ¬åŸå› 
```javascript
// brush-core.js - _applyEraserMask()
if (!this.maskAvailable || !this.glMaskLayer) {
  // Fallbackã«ç§»è¡Œï¼ˆã‚¢ãƒ«ãƒ•ã‚¡å€¤æ¸›ç®—ã®ã¿ï¼‰
  await this._applyEraserMaskFallback(activeLayer, bounds);
  return;
}

// gl-mask-layer.jsã®åˆæœŸåŒ–ç¢ºèª
this.maskAvailable = !!(this.glMaskLayer && this.glMaskLayer.initialized);
```

#### å•é¡Œç‚¹
1. **GLMaskLayerã®åˆæœŸåŒ–ã‚¿ã‚¤ãƒŸãƒ³ã‚°** - BrushCoreåˆæœŸåŒ–æ™‚ã«æœªå®Œäº†
2. **ãƒã‚¹ã‚¯é©ç”¨ãƒ­ã‚¸ãƒƒã‚¯ã®è¤‡é›‘ã•** - è¤‡æ•°ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã¸ã®åå¾©å‡¦ç†
3. **Fallbackã®ä¸å®Œå…¨æ€§** - å˜ç´”ãªã‚¢ãƒ«ãƒ•ã‚¡æ¸›ç®—ã§ã¯ä¸ååˆ†

#### ä¿®æ­£æ–¹é‡
- gl-mask-layer.jsã®åˆæœŸåŒ–ã‚’ç¢ºå®Ÿã«
- ãƒã‚¹ã‚¯é©ç”¨ã‚’ã‚·ãƒ³ãƒ—ãƒ«åŒ–ï¼ˆå…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸€æ‹¬å‡¦ç†ï¼‰
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒã‚¹ã‚¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¿½åŠ 

---

## ğŸ”§ æ®µéšçš„æ”¹ä¿®è¨ˆç”»

### **Phase 1: åº§æ¨™ä¸ä¸€è‡´ã®ä¿®æ­£ï¼ˆæœ€å„ªå…ˆï¼‰**

#### Step 1.1: boundsè¨ˆç®—ã®æ­£è¦åŒ–
```javascript
// gl-stroke-processor.js - ä¿®æ­£
createPolygonVertexBuffer(points, baseSize = 10) {
  const bounds = this._calculateBoundsFromPoints(processedPoints, baseSize);
  
  // âŒ å‰Šé™¤: ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
  // const offsetX = bounds.minX;
  // const offsetY = bounds.minY;
  
  // âœ… ä¿®æ­£: Localåº§æ¨™ã‚’ãã®ã¾ã¾ä½¿ç”¨
  const flat = [];
  for (let i = 0; i < outlinePoints.length; i++) {
    flat.push(
      outlinePoints[i][0],  // ã‚ªãƒ•ã‚»ãƒƒãƒˆæ¸›ç®—ãªã—
      outlinePoints[i][1]
    );
  }
  
  return { buffer, vertexCount, bounds };
}
```

#### Step 1.2: renderPassã®Uniformå‰Šé™¤
```javascript
// gl-msdf-pipeline.js - ä¿®æ­£
_drawStroke(program, vbo, vertexCount, bounds, resolution) {
  // âŒ å‰Šé™¤: uOffset uniform
  // const uOffset = gl.getUniformLocation(program, 'uOffset');
  // gl.uniform2f(uOffset, bounds.minX, bounds.minY);
  
  // Vertex Shaderã‚‚ä¿®æ­£ï¼ˆuOffsetãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‰Šé™¤ï¼‰
}

// Vertex Shaderä¿®æ­£
const vertexShader = `#version 300 es
precision highp float;

layout(location = 0) in vec2 aPosition;    // Localåº§æ¨™ãã®ã¾ã¾
layout(location = 1) in vec2 aTexCoord;
layout(location = 2) in vec3 aReserved;

uniform vec2 uResolution;
// âŒ å‰Šé™¤: uniform vec2 uOffset;

out vec2 vTexCoord;

void main() {
  // âœ… ä¿®æ­£: ã‚ªãƒ•ã‚»ãƒƒãƒˆãªã—ã§NDCå¤‰æ›
  vec2 clipSpace = (aPosition / uResolution) * 2.0 - 1.0;
  clipSpace.y = -clipSpace.y;
  
  gl_Position = vec4(clipSpace, 0.0, 1.0);
  vTexCoord = aTexCoord;
}
`;
```

#### Step 1.3: Spriteé…ç½®ã®ç¢ºèª
```javascript
// brush-core.js - ç¢ºèª
const sprite = await this.textureBridge.createSpriteFromGLTexture(...);

// âœ… ç¢ºèª: bounds.minX/minYã¯æ­£ã—ã„Localåº§æ¨™ã‹ï¼Ÿ
sprite.x = bounds.minX;
sprite.y = bounds.minY;

// ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
console.log('[Stroke] bounds:', bounds);
console.log('[Stroke] sprite pos:', sprite.x, sprite.y);
```

---

### **Phase 2: ãƒ•ãƒªãƒƒã‚«ãƒ¼è§£æ¶ˆ**

#### Step 2.1: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°é »åº¦ã®æœ€é©åŒ–
```javascript
// brush-core.js - ä¿®æ­£
constructor() {
  this.previewThrottle = 100;  // 16ms â†’ 100msï¼ˆ10fpsç›¸å½“ï¼‰
}

async renderPreview() {
  const now = Date.now();
  if (now - this.lastPreviewTime < this.previewThrottle) {
    return;  // ã‚¹ã‚­ãƒƒãƒ—
  }
  this.lastPreviewTime = now;
  
  // ãƒã‚¤ãƒ³ãƒˆæ•°ãƒã‚§ãƒƒã‚¯è¿½åŠ 
  const points = this.strokeRecorder.getRawPoints();
  if (points.length < 3) return;  // æœ€ä½3ç‚¹å¿…è¦
  
  await this._updatePreview(points);
}
```

#### Step 2.2: ãƒ†ã‚¯ã‚¹ãƒãƒ£å†åˆ©ç”¨ï¼ˆFBO poolingï¼‰
```javascript
// brush-core.js - æ–°è¦è¿½åŠ 
constructor() {
  this.previewFBO = null;  // å†åˆ©ç”¨FBO
  this.previewTexture = null;
}

async _updatePreview(points) {
  // âœ… æ—¢å­˜FBOã‚’å†åˆ©ç”¨
  if (!this.previewFBO) {
    this.previewFBO = window.WebGL2DrawingLayer.createFBO(512, 512);
  }
  
  // âŒ å‰Šé™¤: æ¯å›ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆç ´æ£„
  // if (this.previewSprite) {
  //   this.previewSprite.destroy({ children: true });
  // }
  
  // âœ… ä¿®æ­£: æ—¢å­˜ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ãƒ†ã‚¯ã‚¹ãƒãƒ£æ›´æ–°
  if (!this.previewSprite) {
    this.previewSprite = new PIXI.Sprite();
    this.previewContainer.addChild(this.previewSprite);
  }
  
  // FBOã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  const msdfResult = await this.glMSDFPipeline.generateMSDFToFBO(
    this.previewFBO,
    edgeBuffer,
    bounds,
    settings
  );
  
  // ãƒ†ã‚¯ã‚¹ãƒãƒ£æ›´æ–°ï¼ˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã¯ç ´æ£„ã—ãªã„ï¼‰
  const newTexture = PIXI.Texture.from(this.previewFBO.canvas);
  this.previewSprite.texture = newTexture;
  this.previewSprite.x = bounds.minX;
  this.previewSprite.y = bounds.minY;
}
```

---

### **Phase 3: ã‚¸ãƒ£ã‚®ãƒ¼è§£æ¶ˆï¼ˆå‹•çš„è§£åƒåº¦ï¼‰**

#### Step 3.1: å‹•çš„ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºè¨ˆç®—
```javascript
// gl-msdf-pipeline.js - ä¿®æ­£
_calculateOptimalTextureSize(bounds) {
  const width = Math.ceil(bounds.width);
  const height = Math.ceil(bounds.height);
  
  // æœ€å°512ã€æœ€å¤§2048ã€2ã®ã¹ãä¹—ã«åˆ‡ã‚Šä¸Šã’
  const minSize = 512;
  const maxSize = 2048;
  
  const size = Math.max(width, height);
  let textureSize = minSize;
  
  while (textureSize < size && textureSize < maxSize) {
    textureSize *= 2;
  }
  
  return Math.min(textureSize, maxSize);
}

async generateMSDF(...args) {
  // âŒ å‰Šé™¤: å›ºå®šã‚µã‚¤ã‚º
  // const width = this.textureSize;  // 512å›ºå®š
  // const height = this.textureSize;
  
  // âœ… ä¿®æ­£: å‹•çš„ã‚µã‚¤ã‚º
  const textureSize = this._calculateOptimalTextureSize(bounds);
  const width = textureSize;
  const height = textureSize;
  
  // ä»¥ä¸‹åŒæ§˜
}
```

#### Step 3.2: Paddingèª¿æ•´
```javascript
// gl-stroke-processor.js - ä¿®æ­£
_calculateBoundsFromPoints(points, margin = 20) {
  // âŒ å›ºå®šmargin: 20
  // âœ… ã‚µã‚¤ã‚ºã«å¿œã˜ãŸå‹•çš„margin
  const avgSize = points.reduce((sum, p) => sum + (p.pressure || 0.5), 0) / points.length;
  const dynamicMargin = Math.max(20, avgSize * 2);
  
  return {
    minX: minX - dynamicMargin,
    minY: minY - dynamicMargin,
    maxX: maxX + dynamicMargin,
    maxY: maxY + dynamicMargin,
    width: (maxX - minX) + dynamicMargin * 2,
    height: (maxY - minY) + dynamicMargin * 2
  };
}
```

---

### **Phase 4: æ¶ˆã—ã‚´ãƒ æ©Ÿèƒ½ä¿®æ­£**

#### Step 4.1: GLMaskLayeråˆæœŸåŒ–ç¢ºèª
```javascript
// core-initializer.jsï¼ˆã¾ãŸã¯åˆæœŸåŒ–ã‚³ãƒ¼ãƒ‰ï¼‰- è¿½åŠ 
async initWebGL2Systems() {
  // ... ä»–ã®åˆæœŸåŒ–
  
  // GLMaskLayeråˆæœŸåŒ–ã‚’æ˜ç¤ºçš„ã«è¿½åŠ 
  if (window.GLMaskLayer) {
    const gl = window.WebGL2DrawingLayer.getGL();
    await window.GLMaskLayer.initialize(gl);
    console.log('[Init] GLMaskLayer initialized');
  }
  
  // BrushCoreåˆæœŸåŒ–ï¼ˆGLMaskLayerå¾Œï¼‰
  await window.BrushCore.initialize();
}
```

#### Step 4.2: ãƒã‚¹ã‚¯é©ç”¨ã®ã‚·ãƒ³ãƒ—ãƒ«åŒ–
```javascript
// brush-core.js - ä¿®æ­£
async _applyEraserMask(activeLayer, points, bounds) {
  if (!this.maskAvailable) {
    console.warn('[BrushCore] Mask layer unavailable');
    return;
  }
  
  try {
    // 1. ãƒã‚¹ã‚¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆ
    this.glMaskLayer.clearMask();
    const maskTexture = this.glMaskLayer.renderStrokeMask(points, this.currentSettings.size);
    
    // 2. ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¨ä½“ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆå–å¾—
    const layerSnapshot = this._captureLayerSnapshot(activeLayer);
    
    // 3. GPUåˆæˆï¼ˆ1å›ã®draw callã§å®Œäº†ï¼‰
    const maskedTexture = this.glMaskLayer.applyMaskBatch(
      layerSnapshot,
      maskTexture,
      bounds
    );
    
    // 4. çµæœã‚’ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«åæ˜ 
    this._updateLayerFromTexture(activeLayer, maskedTexture);
    
  } catch (error) {
    console.error('[BrushCore] Eraser mask failed:', error);
  }
}
```

---

## ğŸ¯ å„ªå…ˆé †ä½ä»˜ã‘

### **ç·Šæ€¥ï¼ˆ1é€±é–“ä»¥å†…ï¼‰**
1. âœ… **Phase 1: åº§æ¨™ä¸ä¸€è‡´ä¿®æ­£** - ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ã«ç›´çµ
2. âœ… **Phase 2: ãƒ•ãƒªãƒƒã‚«ãƒ¼è§£æ¶ˆ** - UXæ”¹å–„

### **é‡è¦ï¼ˆ2é€±é–“ä»¥å†…ï¼‰**
3. âœ… **Phase 3: ã‚¸ãƒ£ã‚®ãƒ¼è§£æ¶ˆ** - å“è³ªå‘ä¸Š

### **é€šå¸¸ï¼ˆ1ãƒ¶æœˆä»¥å†…ï¼‰**
4. âœ… **Phase 4: æ¶ˆã—ã‚´ãƒ æ©Ÿèƒ½** - æ©Ÿèƒ½å®Œæˆåº¦

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆé …ç›®

### **åº§æ¨™ç²¾åº¦ãƒ†ã‚¹ãƒˆ**
```javascript
// ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§å®Ÿè¡Œ
window.TegakiDebug.coord.testFullPipeline(100, 100);
// âœ… Error < 0.1px ãªã‚‰åˆæ ¼
```

### **ãƒ•ãƒªãƒƒã‚«ãƒ¼ãƒ†ã‚¹ãƒˆ**
- é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æç”»æ™‚ã®è¦–èªç¢ºèª
- DevTools Performance â†’ FPS dropsç¢ºèª

### **è§£åƒåº¦ãƒ†ã‚¹ãƒˆ**
```javascript
// å°ã•ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼ˆ100x100ï¼‰
// å¤§ãã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼ˆ1000x1000ï¼‰
// â†’ ã©ã¡ã‚‰ã‚‚æ»‘ã‚‰ã‹ãªã‚¨ãƒƒã‚¸ã‹ç¢ºèª
```

### **æ¶ˆã—ã‚´ãƒ ãƒ†ã‚¹ãƒˆ**
- ãƒšãƒ³ â†’ æ¶ˆã—ã‚´ãƒ  â†’ ãƒšãƒ³ ã®åˆ‡ã‚Šæ›¿ãˆãƒ•ãƒ­ãƒ¼
- éƒ¨åˆ†æ¶ˆå»ã®ç²¾åº¦ç¢ºèª

---

## ğŸ“ å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Phase 1
- [ ] gl-stroke-processor.js - offsetX/Yå‰Šé™¤
- [ ] gl-msdf-pipeline.js - uOffset uniformå‰Šé™¤
- [ ] Vertex Shaderä¿®æ­£
- [ ] åº§æ¨™ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
- [ ] ãƒ†ã‚¹ãƒˆå®Ÿè¡Œãƒ»æ¤œè¨¼

### Phase 2
- [ ] previewThrottle 100mså»¶é•·
- [ ] FBO poolingå®Ÿè£…
- [ ] ãƒ†ã‚¯ã‚¹ãƒãƒ£å†åˆ©ç”¨ãƒ­ã‚¸ãƒƒã‚¯
- [ ] ä¸è¦ãªdestroy()å‰Šé™¤
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬

### Phase 3
- [ ] _calculateOptimalTextureSize()å®Ÿè£…
- [ ] å‹•çš„marginè¨ˆç®—
- [ ] textureSizeå›ºå®šå€¤å‰Šé™¤
- [ ] è§£åƒåº¦åˆ¥ãƒ†ã‚¹ãƒˆ

### Phase 4
- [ ] GLMaskLayeråˆæœŸåŒ–é †åºä¿®æ­£
- [ ] _captureLayerSnapshot()å®Ÿè£…
- [ ] applyMaskBatch()å®Ÿè£…
- [ ] æ¶ˆã—ã‚´ãƒ å‹•ä½œç¢ºèª

---

## ğŸš€ æœŸå¾…ã•ã‚Œã‚‹æ”¹å–„åŠ¹æœ

| å•é¡Œ | æ”¹å–„å‰ | æ”¹å–„å¾Œ |
|-----|--------|--------|
| åº§æ¨™ç²¾åº¦ | Â±50px ã‚ºãƒ¬ | Â±0.1px ä»¥å†… |
| ãƒ•ãƒªãƒƒã‚«ãƒ¼ | 60fpsç ´æ£„ãƒ»å†ç”Ÿæˆ | 10fpsæ›´æ–°ï¼ˆå†åˆ©ç”¨ï¼‰ |
| è§£åƒåº¦ | 512pxå›ºå®š | 512-2048pxå‹•çš„ |
| æ¶ˆã—ã‚´ãƒ  | å‹•ä½œã›ãš | å®Œå…¨å‹•ä½œ |

---

## ğŸ“š å‚è€ƒãƒªã‚½ãƒ¼ã‚¹

- [PerfectFreehandä»•æ§˜](https://github.com/steveruizok/perfect-freehand)
- [Jump Flooding Algorithmè«–æ–‡](https://www.comp.nus.edu.sg/~tants/jfa.html)
- [PixiJS v8ç§»è¡Œã‚¬ã‚¤ãƒ‰](https://pixijs.com/8.x/guides/migrations/v8)
- [WebGL2ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](https://webgl2fundamentals.org/)

---

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—**: Phase 1ã®å®Ÿè£…ã‹ã‚‰é–‹å§‹ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚åº§æ¨™ä¸ä¸€è‡´ãŒè§£æ¶ˆã•ã‚Œã‚Œã°ã€ä»–ã®å•é¡Œã®åˆ‡ã‚Šåˆ†ã‘ãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ã€‚