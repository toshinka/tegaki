ペン関連シンボル辞典 - P/E+ドラッグ機能の完全マップ
=================================================================

概要
----
P/E+ドラッグ機能におけるサイズ・不透明度変更が反映されない問題を
調査するため、全ペン関連のメソッド、プロパティ、イベントを網羅的に
記録した辞典。


凡例
----
[C] = クラス
[M] = メソッド
[P] = プロパティ
[E] = EventBusイベント
[G] = グローバル変数/オブジェクト
→   = 参照・依存関係
★   = P/E+ドラッグ機能に直接関連


=================================================================
1. BrushSettings (system/drawing/brush-settings.js)
=================================================================

[C] BrushSettings
    ├─ constructor(config, eventBus)
    │   ├─ config: 初期設定オブジェクト
    │   └─ eventBus: イベントバス参照
    │
    ├─[P] size: number              ★ ブラシサイズ (初期: 8)
    ├─[P] color: number             ★ ブラシ色 (0xRRGGBB)
    ├─[P] opacity: number           ★ 不透明度 (0.0-1.0)
    ├─[P] thinning: number            線の細り具合 (0.95)
    ├─[P] smoothing: number           スムージング (0.5)
    ├─[P] streamline: number          ストリームライン (0.5)
    ├─[P] simulatePressure: boolean   筆圧シミュレーション
    ├─[P] taperStart: number          開始テーパー
    ├─[P] taperEnd: number            終了テーパー
    ├─[P] capStart: boolean           開始キャップ
    ├─[P] capEnd: boolean             終了キャップ
    ├─[P] minSize: number             最小サイズ (0.1)
    ├─[P] pressureCorrection: number  筆圧補正 (1.0)
    ├─[P] pressureCurve: string       筆圧カーブ ('linear')
    ├─[P] simplifyTolerance: number   簡略化許容値 (1.0)
    ├─[P] simplifyEnabled: boolean    簡略化有効
    ├─[P] smoothingMode: string       スムージングモード
    ├─[P] splineTension: number       スプライン張力 (0.5)
    └─[P] splineSegments: number      スプラインセグメント (8)
    
    ├─[M] getBrushSize() → number    ★ サイズ取得
    ├─[M] setBrushSize(size)         ★ サイズ設定
    │   └─[E] emit('brushSizeChanged', {size})
    │
    ├─[M] getBrushColor() → number   ★ 色取得
    ├─[M] setBrushColor(color)       ★ 色設定
    │   └─[E] emit('brushColorChanged', {color})
    │
    ├─[M] getBrushOpacity() → number ★ 不透明度取得
    ├─[M] setBrushOpacity(opacity)   ★ 不透明度設定
    │   └─[E] emit('brushOpacityChanged', {opacity})
    │
    ├─[M] getStrokeOptions(isFirst, isLast) → Object
    │   返り値: {size, thinning, smoothing, streamline, ...}
    │
    ├─[M] getCurrentSettings() → Object
    │   返り値: 全設定の集約オブジェクト
    │
    └─[M] subscribeToSettingsChanges()
        購読イベント:
        ├─[E] 'settings:pressure-correction'
        ├─[E] 'settings:smoothing'
        ├─[E] 'settings:pressure-curve'
        ├─[E] 'settings:simplify-tolerance'
        ├─[E] 'settings:simplify-enabled'
        ├─[E] 'settings:smoothing-mode'
        ├─[E] 'settings:spline-tension'
        ├─[E] 'settings:spline-segments'
        └─[E] 'settings:min-size'

登録先:
    ├─ window.TegakiDrawing.BrushSettings
    ├─ window.BrushSettings
    └─ globalThis.BrushSettings


=================================================================
2. DrawingEngine (system/tool-size-manager.js)
   ※ファイル名とクラス名が不一致
=================================================================

[C] DrawingEngine
    ├─ constructor(cameraSystem, layerManager, eventBus, config)
    │
    ├─[P] settings: BrushSettings    ★ BrushSettingsインスタンス
    ├─[P] recorder: StrokeRecorder      ストローク記録
    ├─[P] renderer: StrokeRenderer      ストローク描画
    ├─[P] pressureHandler: PressureHandler 筆圧処理
    ├─[P] transformer: StrokeTransformer   変形処理
    ├─[P] isDrawing: boolean            描画中フラグ
    ├─[P] currentTool: string        ★ 'pen' | 'eraser'
    ├─[P] currentPath: Object           現在のパス
    └─[P] lastPoint: Object             最後の点
    
    ├─[M] _initializeBrushSettings()
    │   ├─ window.TegakiDrawing.BrushSettings → 取得
    │   ├─ window.BrushSettings → フォールバック
    │   ├─ new BrushSettings(config, eventBus)
    │   └─[E] emit('brush:initialized', {settings})
    │
    ├─[M] subscribeToSettings()
    │   購読イベント:
    │   ├─[E] 'tool:size:changed'           ★ サイズ変更
    │   │   └─ settings.setBrushSize(size)  ★
    │   │
    │   ├─[E] 'tool:size-opacity-changed'   ★ サイズ・不透明度変更
    │   │   ├─ settings.setBrushSize(size)     ★
    │   │   └─ settings.setBrushOpacity(opacity) ★
    │   │
    │   ├─[E] 'settings:pressure-correction'
    │   ├─[E] 'settings:smoothing'
    │   ├─[E] 'settings:pressure-curve'
    │   ├─[E] 'settings:simplify-tolerance'
    │   ├─[E] 'settings:simplify-enabled'
    │   ├─[E] 'settings:smoothing-mode'
    │   ├─[E] 'settings:spline-tension'
    │   ├─[E] 'settings:spline-segments'
    │   ├─[E] 'settings:filter-enabled'
    │   └─[E] 'settings:filter-settings'
    │
    ├─[M] startDrawing(screenX, screenY, pressureOrEvent)
    │   ├─ cameraSystem.screenToCanvas(x, y)
    │   ├─ pressureHandler.getFilteredPressure()
    │   ├─ settings.getStrokeOptions()
    │   ├─ renderer.getScaledSize(size, scale)
    │   └─ recorder.startNewPath()
    │
    ├─[M] continueDrawing(screenX, screenY, pressureOrEvent)
    │   ├─ recorder.addPoint()
    │   └─ renderer.renderStroke()
    │
    ├─[M] stopDrawing()
    │   ├─ transformer.preprocessStroke()
    │   ├─ recorder.finalizePath()
    │   ├─ renderer.renderStroke()
    │   ├─ layerManager.addPathToActiveLayer()
    │   └─ window.History.push()
    │
    ├─[M] setTool(tool)              ★ ツール切替
    │   └─[E] emit('toolChanged', {tool})
    │
    ├─[M] setBrushSize(size)         ★ サイズ設定
    │   └─ settings.setBrushSize(size)
    │
    ├─[M] setBrushColor(color)       ★ 色設定
    │   └─ settings.setBrushColor(color)
    │
    ├─[M] setBrushOpacity(opacity)   ★ 不透明度設定
    │   └─ settings.setBrushOpacity(opacity)
    │
    ├─[M] getCurrentTool() → string  ★
    ├─[M] getIsDrawing() → boolean
    └─[M] getDebugInfo() → Object

登録先:
    └─ window.TegakiDrawing.DrawingEngine


=================================================================
3. KeyboardHandler (ui/keyboard-handler.js)
=================================================================

[G] window.KeyboardHandler = IIFE()

    ├─[P] dragState: Object          ★ ドラッグ状態管理
    │   ├─ pKeyPressed: boolean      ★ Pキー押下中
    │   ├─ eKeyPressed: boolean      ★ Eキー押下中
    │   ├─ isDragging: boolean       ★ ドラッグ中
    │   ├─ dragStartX: number        ★ 開始X座標
    │   ├─ dragStartY: number        ★ 開始Y座標
    │   └─ activeTool: string        ★ 'pen' | 'eraser' | null
    │
    ├─[M] handleKeyDown(e)           ★ キー押下処理
    │   ├─ if (KeyP) → dragState.pKeyPressed = true
    │   │   └─ CoreRuntime.api.setTool('pen')
    │   │
    │   └─ if (KeyE) → dragState.eKeyPressed = true
    │       └─ CoreRuntime.api.setTool('eraser')
    │
    ├─[M] handleKeyUp(e)             ★ キー解放処理
    │   ├─ if (KeyP) → endDrag() if isDragging
    │   │   └─ dragState.pKeyPressed = false
    │   │
    │   └─ if (KeyE) → endDrag() if isDragging
    │       └─ dragState.eKeyPressed = false
    │
    ├─[M] handleMouseDown(e)         ★ マウス押下処理
    │   ├─ if (pKeyPressed || eKeyPressed)
    │   │   ├─ e.preventDefault()
    │   │   ├─ dragState.dragStartX/Y = e.clientX/Y
    │   │   ├─ brushSettings.getBrushSize()    ★
    │   │   ├─ brushSettings.getBrushOpacity() ★
    │   │   ├─[E] emit('tool:drag-size-start', {tool, startSize, startOpacity})
    │   │   └─ dragState.isDragging = true
    │   └─ 描画防止: e.stopImmediatePropagation()
    │
    ├─[M] handleMouseMove(e)         ★ マウス移動処理
    │   ├─ if (isDragging)
    │   │   ├─ e.preventDefault()
    │   │   ├─ deltaX = e.clientX - dragStartX ★ 累積差分
    │   │   ├─ deltaY = e.clientY - dragStartY ★ 累積差分
    │   │   └─[E] emit('tool:drag-size-update', {tool, deltaX, deltaY})
    │   └─ 描画防止: e.stopImmediatePropagation()
    │
    ├─[M] handleMouseUp(e)           ★ マウス解放処理
    │   ├─ if (isDragging)
    │   │   ├─ e.preventDefault()
    │   │   └─ endDrag()
    │   └─ 描画防止: e.stopImmediatePropagation()
    │
    ├─[M] endDrag()                  ★ ドラッグ終了
    │   ├─ dragState.isDragging = false
    │   └─[E] emit('tool:drag-size-end')
    │
    ├─[M] handlePointerDown(e)       ★ PointerEvent対応
    ├─[M] handlePointerMove(e)       ★ PointerEvent対応
    ├─[M] handlePointerUp(e)         ★ PointerEvent対応
    │
    ├─[M] getBrushSettings() → BrushSettings | null
    │   検索順序:
    │   1. coreEngine.drawingEngine.settings      ★
    │   2. coreEngine.drawingEngine.brushSettings
    │   3. drawingApp.drawingEngine.settings
    │   4. drawingApp.drawingEngine.brushSettings
    │   5. CoreEngine.drawingEngine.settings
    │   6. drawingEngine.settings
    │
    ├─[M] init()                     ★ 初期化
    │   イベントリスナー登録:
    │   ├─ keydown (capture: true)
    │   ├─ keyup (capture: true)
    │   ├─ mousedown (capture: true, passive: false)  ★
    │   ├─ mousemove (capture: true, passive: false)  ★
    │   ├─ mouseup (capture: true, passive: false)    ★
    │   ├─ pointerdown (capture: true, passive: false) ★
    │   ├─ pointermove (capture: true, passive: false) ★
    │   └─ pointerup (capture: true, passive: false)   ★
    │
    ├─[M] getDebugState() → Object   ★ デバッグ情報
    └─[M] getShortcutList() → Array

イベントリスナー優先度:
    capture: true → PixiJS EventSystemより先に処理
    passive: false → preventDefault()を有効化


=================================================================
4. DragVisualFeedback (ui/drag-visual-feedback.js)
=================================================================

[C] DragVisualFeedback
    ├─ constructor(config, eventBus)
    │
    ├─[P] container: HTMLDivElement     フィードバックコンテナ
    ├─[P] circle: HTMLDivElement        サイズ表示円
    ├─[P] textContainer: HTMLDivElement テキスト表示
    ├─[P] isActive: boolean             ★ アクティブ状態
    ├─[P] currentTool: string           ★ 現在のツール
    ├─[P] currentX: number              マウスX座標
    └─[P] currentY: number              マウスY座標
    
    ├─[M] _setupEventListeners()
    │   購読イベント:
    │   ├─[E] 'tool:drag-size-start'        ★ ドラッグ開始
    │   │   └─ _handleDragStart({tool, startSize, startOpacity})
    │   │
    │   ├─[E] 'tool:size-opacity-changed'   ★ 値変更
    │   │   └─ _handleDragUpdate({size, opacity})
    │   │
    │   └─[E] 'tool:drag-size-end'          ★ ドラッグ終了
    │       └─ _handleDragEnd()
    │
    ├─[M] _handleDragStart(data)     ★
    │   ├─ isActive = true
    │   ├─ currentTool = data.tool
    │   ├─ container.display = 'block'
    │   └─ _updateVisuals(startSize, startOpacity)
    │
    ├─[M] _handleDragUpdate(data)    ★
    │   └─ _updateVisuals(size, opacity)
    │
    ├─[M] _handleDragEnd()           ★
    │   ├─ isActive = false
    │   └─ container.opacity = 0 (アニメーション)
    │
    ├─[M] _updatePosition()          ★
    │   ├─ container.left = currentX
    │   └─ container.top = currentY
    │
    └─[M] _updateVisuals(size, opacity) ★
        ├─ circle.width/height = size * 2
        ├─ circle.opacity = max(0.3, opacity)
        └─ textContainer.innerHTML (サイズ/不透明度表示)

登録先:
    └─ window.DragVisualFeedback


=================================================================
5. ToolSizeManager (未実装？)
=================================================================

※ tool-size-manager.js は DrawingEngine の内容になっている
※ 本来の ToolSizeManager クラスは存在しない可能性


=================================================================
6. EventBus (system/event-bus.js)
=================================================================

[C] TegakiEventBusClass
    ├─[P] _events: Map<string, Function[]>
    ├─[P] _debugMode: boolean
    │
    ├─[M] on(eventName, callback)
    ├─[M] off(eventName, callback)
    ├─[M] once(eventName, callback)
    ├─[M] emit(eventName, data)      ★ イベント発火
    ├─[M] removeAllListeners(eventName)
    ├─[M] getEventNames() → Array
    ├─[M] getListenerCount(eventName) → number
    ├─[M] getDebugInfo() → Object
    └─[M] setDebugMode(enabled)

グローバルインスタンス:
    └─ window.TegakiEventBus


=================================================================
7. P/E+ドラッグ関連のイベントフロー ★
=================================================================

[ユーザー操作]
    │
    ├─ P キー押下
    │   └─ KeyboardHandler.handleKeyDown()
    │       ├─ dragState.pKeyPressed = true
    │       ├─ dragState.activeTool = 'pen'
    │       └─ CoreRuntime.api.setTool('pen')
    │           └─ DrawingEngine.setTool('pen')
    │               ├─ currentTool = 'pen'
    │               └─[E] emit('toolChanged', {tool: 'pen'})
    │
    ├─ マウス押下 (P キー押下中)
    │   └─ KeyboardHandler.handleMouseDown()
    │       ├─ e.preventDefault()
    │       ├─ dragState.dragStartX = e.clientX
    │       ├─ dragState.dragStartY = e.clientY
    │       ├─ getBrushSettings() → BrushSettings
    │       │   ├─ startSize = settings.getBrushSize()     ★
    │       │   └─ startOpacity = settings.getBrushOpacity() ★
    │       ├─[E] emit('tool:drag-size-start', {
    │       │        tool: 'pen',
    │       │        startSize: 10,
    │       │        startOpacity: 0.85
    │       │    })
    │       │   └─→ DragVisualFeedback._handleDragStart()
    │       │       ├─ isActive = true
    │       │       ├─ currentTool = 'pen'
    │       │       └─ _updateVisuals(10, 0.85)
    │       └─ dragState.isDragging = true
    │
    ├─ マウス移動 (ドラッグ中)
    │   └─ KeyboardHandler.handleMouseMove()
    │       ├─ e.preventDefault()
    │       ├─ deltaX = e.clientX - dragStartX  ★ 累積差分
    │       ├─ deltaY = e.clientY - dragStartY  ★ 累積差分
    │       └─[E] emit('tool:drag-size-update', {
    │                tool: 'pen',
    │                deltaX: 50,
    │                deltaY: -20
    │            })
    │           └─→ ❌ リスナーなし！
    │
    ├─ マウス解放
    │   └─ KeyboardHandler.handleMouseUp()
    │       ├─ e.preventDefault()
    │       └─ endDrag()
    │           ├─ dragState.isDragging = false
    │           └─[E] emit('tool:drag-size-end')
    │               └─→ DragVisualFeedback._handleDragEnd()
    │                   ├─ isActive = false
    │                   └─ container.opacity = 0
    │
    └─ P キー解放
        └─ KeyboardHandler.handleKeyUp()
            └─ dragState.pKeyPressed = false


=================================================================
8. 問題の核心 ★★★
=================================================================

【発見した問題】

1. tool:drag-size-update イベントのリスナー不在
   ------------------------------------------------
   KeyboardHandler が emit する tool:drag-size-update イベントを
   受け取るリスナーが存在しない。
   
   ├─ 発火側: KeyboardHandler.handleMouseMove()
   │   └─[E] emit('tool:drag-size-update', {tool, deltaX, deltaY})
   │
   └─ 受信側: ❌ 存在しない
   
   → deltaX/deltaY を実際のサイズ・不透明度に変換して
      tool:size-opacity-changed を発火する中間処理が必要


2. tool:size-opacity-changed イベントの発火不在
   ------------------------------------------------
   DragVisualFeedback と DrawingEngine は
   tool:size-opacity-changed イベントを購読しているが、
   このイベントを発火する箇所が存在しない。
   
   ├─ 購読側:
   │   ├─ DragVisualFeedback._setupEventListeners()
   │   │   └─[E] on('tool:size-opacity-changed')
   │   │
   │   └─ DrawingEngine.subscribeToSettings()
   │       └─[E] on('tool:size-opacity-changed')
   │
   └─ 発火側: ❌ 存在しない
   
   → tool:drag-size-update を受けて、サイズ・不透明度を
      計算し、tool:size-opacity-changed を発火する
      中間処理が必要


3. ToolSizeManager の不在
   ------------------------------------------------
   tool-size-manager.js ファイルは存在するが、
   中身は DrawingEngine になっている。
   本来の ToolSizeManager クラスが実装されていない。
   
   期待される役割:
   ├─ tool:drag-size-update を購読
   ├─ deltaX/deltaY から新しいサイズ・不透明度を計算
   ├─ 各ツール(pen/eraser)の現在値を保持
   ├─ config.dragAdjustment.size.sensitivity を適用
   ├─ config.dragAdjustment.opacity.sensitivity を適用
   └─ tool:size-opacity-changed を発火


=================================================================
9. 必要な修正 ★★★
=================================================================

【Option A: ToolSizeManager を実装】
---------------------------------
新しく ToolSizeManager クラスを作成し、
tool:drag-size-update → tool:size-opacity-changed の
変換処理を実装する。

class ToolSizeManager {
  constructor(config, eventBus) {
    this.config = config;
    this.eventBus = eventBus;
    this.currentTool = null;
    this.startSize = 0;
    this.startOpacity = 0;
    
    this.eventBus.on('tool:drag-size-start', (data) => {
      this.currentTool = data.tool;
      this.startSize = data.startSize;
      this.startOpacity = data.startOpacity;
    });
    
    this.eventBus.on('tool:drag-size-update', (data) => {
      const sizeSensitivity = this.config.dragAdjustment.size.sensitivity;
      const opacitySensitivity = this.config.dragAdjustment.opacity.sensitivity;
      
      const newSize = this.clamp(
        this.startSize + data.deltaX * sizeSensitivity,
        this.config.dragAdjustment.size.min,
        this.config.dragAdjustment.size.max
      );
      
      const newOpacity = this.clamp(
        this.startOpacity - data.deltaY * opacitySensitivity,
        this.config.dragAdjustment.opacity.min,
        this.config.dragAdjustment.opacity.max
      );
      
      this.eventBus.emit('tool:size-opacity-changed', {
        tool: data.tool,
        size: newSize,
        opacity: newOpacity
      });
    });
  }
  
  clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
}


【Option B: KeyboardHandler 内で直接処理】
-----------------------------------------
KeyboardHandler.handleMouseMove() 内で
tool:size-opacity-changed を直接発火する。

handleMouseMove(e) {
  if (!dragState.isDragging) return;
  
  e.preventDefault();
  const deltaX = e.clientX - dragState.dragStartX;
  const deltaY = e.clientY - dragState.dragStartY;
  
  // 🆕 直接計算
  const brushSettings = getBrushSettings();
  if (!brushSettings) return;
  
  const sizeSensitivity = window.TEGAKI_CONFIG.dragAdjustment.size.sensitivity;
  const opacitySensitivity = window.TEGAKI_CONFIG.dragAdjustment.opacity.sensitivity;
  
  const startSize = /* 保存された開始サイズ */;
  const startOpacity = /* 保存された開始不透明度 */;
  
  const newSize = clamp(
    startSize + deltaX * sizeSensitivity,
    window.TEGAKI_CONFIG.dragAdjustment.size.min,
    window.TEGAKI_CONFIG.dragAdjustment.size.max
  );
  
  const newOpacity = clamp(
    startOpacity - deltaY * opacitySensitivity,
    window.TEGAKI_CONFIG.dragAdjustment.opacity.min,
    window.TEGAKI_CONFIG.dragAdjustment.opacity.max
  );
  
  // tool:size-opacity-changed を発火
  window.TegakiEventBus.emit('tool:size-opacity-changed', {
    tool: dragState.activeTool,
    size: newSize,
    opacity: newOpacity
  });
}


=================================================================
10. 設定値の参照パス (config.js)
=================================================================

[G] window.TEGAKI_CONFIG
    │
    ├─ canvas: {width, height}
    │
    ├─ pen: {
    │   ├─ size: 10           ★ ペン初期サイズ
    │   ├─ opacity: 0.85      ★ ペン初期不透明度
    │   └─ color: 0x800000
    │   }
    │
    ├─ eraser: {
    │   ├─ size: 20           ★ 消しゴム初期サイズ
    │   └─ opacity: 1.0       ★ 消しゴム初期不透明度
    │   }
    │
    ├─ tools: {
    │   ├─ pen: {
    │   │   ├─ defaultSize: 10      ★
    │   │   └─ defaultOpacity: 0.85 ★
    │   │   }
    │   └─ eraser: {
    │       ├─ defaultSize: 20      ★
    │       └─ defaultOpacity: 1.0  ★
    │       }
    │   }
    │
    ├─ sizeSlots: {
    │   ├─ pen: [2,4,6,8,12,16,24,36,50]
    │   └─ eraser: [10,15,20,30,40,50,60,80,100]
    │   }
    │
    └─ dragAdjustment: {           ★★★ ドラッグ調整設定
        ├─ size: {
        │   ├─ sensitivity: 0.1    ★ サイズ感度 (px/pixel)
        │   ├─ min: 0.1            ★ 最小サイズ
        │   └─ max: 100            ★ 最大サイズ
        │   }
        ├─ opacity: {
        │   ├─ sensitivity: 0.005  ★ 不透明度感度 (/pixel)
        │   ├─ min: 0.0            ★ 最小不透明度
        │   └─ max: 1.0            ★ 最大不透明度
        │   }
        └─ visual: {
            ├─ textColor: '#ffffff'
            ├─ fontSize: 12
            ├─ showValues: true
            └─ animationDuration: 150
            }
        }


=================================================================
11. StrokeRenderer (system/drawing/stroke-renderer.js)
=================================================================

[C] StrokeRenderer
    ├─ constructor(config, renderer)
    │
    ├─[P] meshPool: Array              Meshプール
    ├─[P] graphicsPool: Array          Graphicsプール
    ├─[P] baseMinWidth: number         最小線幅 (1.0)
    ├─[P] pressureToSizeMultiplier: number 筆圧サイズ係数
    │
    ├─[M] getMinPhysicalWidth() → number
    │   └─ devicePixelRatio対応の最小表示幅
    │
    ├─[M] getPressureAdjustedWidth(pressure, baseSize) → number
    │   ├─ 筆圧ベースの線幅計算
    │   └─ 極小圧力の保護処理
    │
    ├─[M] getScaledSize(baseSize, scale) → number ★
    │   └─ baseSize / scale (カメラスケール補正)
    │
    ├─[M] renderStroke(points, strokeOptions, container, incremental) → {mesh, meshVertices}
    │   ├─ perfect-freehand 呼び出し
    │   ├─ getStroke(pfInput, pfOptions)
    │   └─ createMeshFromOutline()
    │
    ├─[M] createMeshFromOutline(outline, color, alpha) → {mesh, meshVertices}
    │   ├─ PIXI.Geometry 生成
    │   ├─ PIXI.Shader 生成
    │   └─ PIXI.Mesh 生成
    │
    ├─[M] renderStrokeWithCircles(points, strokeOptions, container)
    │   └─ フォールバック: PIXI.Graphics で円描画
    │
    ├─[M] rebuildMeshFromData(meshVertices, container) → PIXI.Mesh
    │   └─ History用の再構築
    │
    └─[M] rebuildPathGraphics(pathData, container)
        └─ Undo/Redo用の再構築

登録先:
    └─ window.TegakiDrawing.StrokeRenderer


=================================================================
12. StrokeRecorder (system/drawing/stroke-recorder.js)
=================================================================

[C] StrokeRecorder
    ├─ constructor()
    │
    ├─[P] pathIdCounter: number
    ├─[P] simplifyTolerance: number (1.0)
    ├─[P] simplifyHighQuality: boolean (true)
    ├─[P] enableSimplify: boolean (true)
    ├─[P] minDistance: number (0.5)
    ├─[P] maxPoints: number (10000)
    ├─[P] clickDistanceThreshold: number (2.0)
    ├─[P] clickSampleThreshold: number (2)
    │
    ├─[M] startNewPath(initialPoint, color, size, opacity, tool, strokeOptions) → pathData
    │   返り値: {
    │     id, points, color, size, opacity, tool,
    │     isComplete, strokeOptions, graphics,
    │     originalSize, scaleAtDrawTime,
    │     isSinglePoint, totalDistance
    │   }
    │
    ├─[M] addPoint(pathData, point)
    │   ├─ 最小距離チェック (1.0px)
    │   └─ totalDistance 更新
    │
    ├─[M] finalizePath(pathData)
    │   ├─ detectSinglePoint() → クリック判定
    │   ├─ simplify() 適用 (Simplify.js)
    │   └─ interpolatePressure()
    │
    ├─[M] detectSinglePoint(pathData) → boolean
    │   ├─ サンプル数チェック
    │   └─ 総移動距離チェック
    │
    ├─[M] getDistance(p1, p2) → number
    │   └─ √(dx² + dy²)
    │
    └─[M] clonePathData(pathData) → pathData

登録先:
    └─ window.TegakiDrawing.StrokeRecorder


=================================================================
13. PressureHandler (system/drawing/pressure-handler.js)
=================================================================

[C] PressureHandler
    ├─ constructor()
    │
    ├─[P] lastPressure: number
    ├─[P] pressureHistory: Array
    ├─[P] maxHistorySize: number (5)
    ├─[P] tiltX: number
    ├─[P] tiltY: number
    ├─[P] twist: number
    ├─[P] pressureCorrection: number (1.0)
    ├─[P] baseline: number (0.0)             ★ ベースライン
    ├─[P] baselineSamples: Array             ★ キャリブレーション用
    ├─[P] baselineSampleCount: number (5)    ★ サンプル数
    ├─[P] isCalibrating: boolean             ★ キャリブレーション中
    ├─[P] isFirstTouch: boolean              初回接触フラグ
    ├─[P] touchStartTimestamp: number
    ├─[P] initialTouchThreshold: number (0.05)
    ├─[P] initialTouchMultiplier: number (0.01)
    ├─[P] ultraLowPressurePower: number (8)
    │
    ├─[M] startStroke()                      ★ ストローク開始
    │   ├─ 履歴リセット
    │   └─ ベースラインキャリブレーション開始
    │
    ├─[M] calibratePressure(rawPressure) → number ★
    │   ├─ N=5サンプル収集
    │   ├─ baseline = min(samples)
    │   └─ 実圧力 = (raw - baseline) / (1 - baseline)
    │
    ├─[M] getPressure(event) → number (0.0-1.0)
    │   ├─ nativeEvent.pressure 取得
    │   ├─ calibratePressure() 適用
    │   ├─ 初回接触の特別処理
    │   └─ 重み付き移動平均
    │
    ├─[M] getCorrectedPressure(event) → number
    │   ├─ getPressure()
    │   ├─ applyUltraFeatherCurve()
    │   └─ × pressureCorrection
    │
    ├─[M] applyUltraFeatherCurve(rawPressure) → number
    │   3段階カーブ処理:
    │   ├─ 0.0-0.1: x^8 * 0.01
    │   ├─ 0.1-0.3: x^4 補間
    │   └─ 0.3-1.0: x^2 補間
    │
    ├─[M] getTilt(event) → {tiltX, tiltY}
    ├─[M] getTwist(event) → number
    ├─[M] getAllPointerData(event) → Object
    ├─[M] estimatePressureFromVelocity(x, y, timestamp) → number
    ├─[M] reset()                            ★ リセット
    └─[M] getDebugInfo() → Object

登録先:
    └─ window.TegakiDrawing.PressureHandler


=================================================================
14. グローバル参照パス整理
=================================================================

DrawingEngine へのアクセスパス:
    ├─ window.coreEngine.drawingEngine
    ├─ window.drawingApp.drawingEngine
    ├─ window.CoreEngine.drawingEngine
    └─ window.drawingEngine

BrushSettings へのアクセスパス:
    ├─ coreEngine.drawingEngine.settings         ★ 推奨
    ├─ coreEngine.drawingEngine.brushSettings
    ├─ drawingApp.drawingEngine.settings
    ├─ drawingApp.drawingEngine.brushSettings
    ├─ window.TegakiDrawing.BrushSettings (クラス)
    ├─ window.BrushSettings (クラス)
    └─ globalThis.BrushSettings (クラス)

EventBus:
    └─ window.TegakiEventBus                     ★ シングルトン

Config:
    ├─ window.TEGAKI_CONFIG
    ├─ window.TEGAKI_KEYMAP
    ├─ window.TEGAKI_KEYCONFIG
    └─ window.TEGAKI_COLORS

CoreRuntime API:
    └─ window.CoreRuntime.api.setTool(tool)


=================================================================
15. イベント一覧 (P/E+ドラッグ関連)
=================================================================

【発火されるイベント】
    ├─[E] 'tool:drag-size-start'           ★ KeyboardHandler
    │      {tool, startSize, startOpacity}
    │
    ├─[E] 'tool:drag-size-update'          ★ KeyboardHandler
    │      {tool, deltaX, deltaY}          ❌ リスナーなし
    │
    ├─[E] 'tool:drag-size-end'             ★ KeyboardHandler
    │      (データなし)
    │
    ├─[E] 'toolChanged'                    DrawingEngine
    │      {tool}
    │
    ├─[E] 'brushSizeChanged'               BrushSettings
    │      {size}
    │
    ├─[E] 'brushOpacityChanged'            BrushSettings
    │      {opacity}
    │
    └─[E] 'brushColorChanged'              BrushSettings
         {color}

【購読されるイベント (発火されないもの)】
    ├─[E] 'tool:size:changed'              ★ DrawingEngine購読
    │      {tool, size}                    ❌ 発火なし
    │
    └─[E] 'tool:size-opacity-changed'      ★ DrawingEngine購読
           {tool, size, opacity}           ★ DragVisualFeedback購読
                                           ❌ 発火なし


=================================================================
16. データフロー図 (理想状態)
=================================================================

[ユーザー] P+ドラッグ
    │
    ▼
[KeyboardHandler]
    ├─ handleMouseDown()
    │   └─ emit('tool:drag-size-start')
    │       └─→ [DragVisualFeedback] 表示開始
    │
    ├─ handleMouseMove()
    │   └─ emit('tool:drag-size-update', {deltaX, deltaY})
    │       │
    │       ▼
    │   ❌ [ToolSizeManager] ← 存在しない！
    │       ├─ サイズ計算: startSize + deltaX * sensitivity
    │       ├─ 不透明度計算: startOpacity - deltaY * sensitivity
    │       └─ emit('tool:size-opacity-changed', {size, opacity})
    │           │
    │           ├─→ [DragVisualFeedback] ビジュアル更新
    │           └─→ [DrawingEngine]
    │               └─ settings.setBrushSize(size)
    │                   settings.setBrushOpacity(opacity)
    │
    └─ handleMouseUp()
        └─ emit('tool:drag-size-end')
            └─→ [DragVisualFeedback] 非表示


=================================================================
17. 修正方針の決定
=================================================================

【推奨: Option A - ToolSizeManager 実装】

理由:
1. 責務分離の原則 (SOLID)
   - KeyboardHandler: 入力検知のみ
   - ToolSizeManager: サイズ・不透明度計算
   - BrushSettings: 設定値の保持
   - DrawingEngine: 描画処理

2. 設定の一元管理
   - ツールごとの現在値を保持
   - dragAdjustment 設定の適用
   - min/max のクランプ処理

3. 拡張性
   - 将来的にスライダーUIとの連携
   - ツールプリセット機能
   - サイズスロット機能

4. デバッグ容易性
   - 計算ロジックが一箇所に集約
   - 現在の状態を getDebugInfo() で確認可能


【実装すべき ToolSizeManager の仕様】

class ToolSizeManager {
  constructor(config, eventBus)
  
  // 状態管理
  currentTool: 'pen' | 'eraser' | null
  toolStates: {
    pen: {size, opacity, startSize, startOpacity},
    eraser: {size, opacity, startSize, startOpacity}
  }
  
  // イベント購読
  on('tool:drag-size-start')  → 開始値を保存
  on('tool:drag-size-update') → サイズ・不透明度計算
  on('toolChanged')           → currentTool 更新
  
  // イベント発火
  emit('tool:size-opacity-changed', {tool, size, opacity})
  
  // メソッド
  calculateNewSize(deltaX): number
  calculateNewOpacity(deltaY): number
  clamp(value, min, max): number
  getToolState(tool): {size, opacity}
  setToolState(tool, size, opacity): void
  resetToDefault(tool): void
  getDebugInfo(): Object
}


=================================================================
18. 既存コードとの整合性チェック
=================================================================

✅ BrushSettings
   - size, opacity プロパティ存在
   - setBrushSize(), setBrushOpacity() メソッド存在
   - イベント発火機能あり

✅ DrawingEngine
   - tool:size-opacity-changed イベント購読済み
   - settings.setBrushSize() 呼び出し可能
   - settings.setBrushOpacity() 呼び出し可能

✅ DragVisualFeedback
   - tool:size-opacity-changed イベント購読済み
   - _updateVisuals(size, opacity) 実装済み

✅ KeyboardHandler
   - tool:drag-size-start 発火済み
   - tool:drag-size-update 発火済み
   - tool:drag-size-end 発火済み
   - getBrushSettings() で参照取得可能

✅ config.js
   - dragAdjustment 設定存在
   - tools.pen/eraser デフォルト値存在
   - sensitivity 設定存在

❌ ToolSizeManager
   - 実装されていない
   - tool:drag-size-update → tool:size-opacity-changed 変換なし


=================================================================
19. 最終結論
=================================================================

【問題の原因】
tool:drag-size-update イベントを受けて
tool:size-opacity-changed イベントを発火する
中間処理 (ToolSizeManager) が実装されていない。

【影響範囲】
- P/E+ドラッグでのサイズ・不透明度変更が反映されない
- DragVisualFeedback は開始値のまま表示
- DrawingEngine の settings は更新されない
- 実際の描画には一切影響なし

【必要な対応】
新規ファイル作成: system/tool-size-manager.js
- ToolSizeManager クラスの実装
- tool:drag-size-update → tool:size-opacity-changed 変換
- ツールごとの状態管理
- config.dragAdjustment 設定の適用

【改修優先度】
★★★★★ 最優先
P/E+ドラッグ機能の根幹に関わる欠落


=================================================================
EOF
=================================================================