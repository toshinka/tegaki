座標系統合・完全修正計画書 v2
================================

【根本原因の確定】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. CameraSystem.screenClientToWorld() が未実装
2. drawing-engine.js が offsetX/offsetY を直接使用
3. resizeCanvas() でストローク座標が変換されない
4. layer-transform.js がイベント未発火
5. サムネイルが camera:transform-changed 未購読

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 1: CameraSystem への座標変換API実装【緊急・必須】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 改修ファイル
  system/camera-system.js

■ 処理位置
  座標変換の唯一の統一入口

■ 追加メソッド
  screenClientToWorld(app, clientX, clientY)
  worldToScreen(app, worldX, worldY)

■ 実装手順
  1. app.view.getBoundingClientRect() で DOM矩形取得
  2. clientX/Y - rect.left/top = canvasX/Y (CSS相対)
  3. pixelScaleX = app.renderer.width / rect.width
  4. pixelScaleY = app.renderer.height / rect.height
  5. rendererX = canvasX * pixelScaleX
  6. rendererY = canvasY * pixelScaleY
  7. worldContainer.transform.worldTransform の逆行列取得
  8. 逆行列.apply({x: rendererX, y: rendererY})
  9. {x, y} 返却

■ 重要事項
  - offsetX/offsetY 使用厳禁
  - worldContainer 未初期化時は renderer座標をそのまま返す
  - DPI/CSS拡大を正確に補正

■ 参考
  coordinate-system.js の screenToWorld() ロジック（但し pixelScale 計算追加必要）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 2: drawing-engine の座標変換完全置換【緊急・必須】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 改修ファイル
  system/drawing/drawing-engine.js

■ 処理位置
  _getLocalPoint(e) メソッド
  handlePointerDown/Move/Up 内の座標取得

■ 参照ファイル
  system/camera-system.js (Phase1で追加)

■ 修正内容
  旧コード:
    const container = this.worldContainer || this.app.stage;
    return container.toLocal(new PIXI.Point(e.offsetX, e.offsetY));

  新コード:
    const camera = this.coreEngine.getCameraSystem();
    const world = camera.screenClientToWorld(this.app, e.clientX, e.clientY);
    const container = this.worldContainer || this.app.stage;
    return container.toLocal(new PIXI.Point(world.x, world.y));

■ 重要事項
  - 全 pointer イベントで統一
  - e.clientX/clientY を使用（offsetX/offsetY 禁止）
  - coreEngine 参照が必須

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 3: CameraSystem.resizeCanvas の厳密実装【緊急・必須】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 改修ファイル
  system/camera-system.js

■ 処理位置
  resizeCanvas(width, height, options) メソッド

■ 参照ファイル
  config.js (TEGAKI_CONFIG)

■ 実装手順
  1. TEGAKI_CONFIG.canvas.width/height 更新
  2. app.renderer.resize(width, height)
  3. worldContainer.pivot.set(0, 0)
  4. worldContainer.position.set(0, 0)
  5. options.horizontal/vertical から offset 計算
     horizontal: 'left' → 0, 'center' → -width/2, 'right' → -width
     vertical: 'top' → 0, 'center' → -height/2, 'bottom' → -height
  6. worldContainer.position.x += offsetX
  7. worldContainer.position.y += offsetY
  8. this.eventBus.emit('camera:transform-changed')

■ 削除対象
  - 既存の alignX/alignY 個別処理
  - layer 個別の position 調整

■ 注意
  - renderer.resize() 失敗時はエラー throw（フォールバック禁止）
  - イベント発火必須

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 4: resize-popup のロジック削減【高優先・必須】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 改修ファイル
  ui/resize-popup.js

■ 処理位置
  適用ボタンクリック時の処理

■ 参照ファイル
  system/camera-system.js (Phase3)

■ 修正内容
  1. CameraSystem.resizeCanvas(w, h, {horizontal, vertical}) 呼び出しに統一
  2. layer.position 個別調整ループを完全削除
  3. animSystem.regenerateAllThumbnails() の setTimeout 削除
  4. camera:transform-changed 購読で自動更新を待つ

■ 削除対象
  - layers.forEach(layer => layer.position...) ループ
  - 手動 offset 計算
  - setTimeout による非同期再生成

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 5: layer-transform へのイベント発火追加【高優先・必須】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 改修ファイル
  system/layer-transform.js

■ 処理位置
  レイヤー移動完了時（position 更新後）

■ 参照ファイル
  system/event-bus.js

■ 追加内容
  layer.position 更新直後に:
    this.eventBus.emit('layer:transform-updated', { layerId: layer.id });

■ 購読側（drawing-engine）
  this.eventBus.on('layer:transform-updated', (data) => {
    if (data.layerId === this.activeLayerId) {
      // 次回描画時に座標系を再計算（キャッシュクリア等）
    }
  });

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 6: サムネイル同期の完全実装【中優先・推奨】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 改修ファイル
  ui/timeline-thumbnail-utils.js
  ui/layer-panel-renderer.js

■ 処理位置
  初期化時にイベント購読登録

■ 参照ファイル
  system/camera-system.js (イベント発行元)
  system/animation-system.js (再生成API)

■ 実装内容
  初期化時に一度だけ:
    eventBus.on('camera:transform-changed', () => {
      animSystem.regenerateAllThumbnails();
    });

■ 追加確認
  - regenerateAllThumbnails() が TEGAKI_CONFIG.canvas を正しく参照
  - renderer 解像度との整合性確認

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 7: Vモードポップアップ修正【中優先・UI品質】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 改修ファイル
  ui/keyboard-handler.js
  system/popup-manager.js
  styles/main.css

■ 問題の特定
  1. PopupManager に Vモードポップアップが未登録の可能性
  2. スライダー CSS が青系（resize-popup-compact クラス）

■ 確認手順
  1. keyboard-handler.js で 'v' キー押下時に PopupManager.show() 呼び出し確認
  2. PopupManager.register() に該当ポップアップが登録されているか確認
  3. core-initializer.js の初期化順序確認

■ CSS修正
  styles/main.css 内:
    .resize-popup-compact .slider .track {
      background: #8b0000; /* maroon */
    }
    .resize-popup-compact .slider .thumb {
      background: #a52a2a; /* darker maroon */
    }

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 8: coordinate-system.js の役割限定【低優先・整理】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 改修ファイル
  coordinate-system.js

■ 方針
  診断専用ユーティリティとして保持、本番コードからの参照削除

■ 実装内容
  ファイル冒頭にコメント追加:
    // 【診断専用】本番コードは camera-system.js を使用すること

  オプション: screenToWorld() を CameraSystem.screenClientToWorld() へのラッパーに変更

■ 削除対象
  - 本番描画パスからの直接呼び出し
  - 重複する変換ロジック

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 9: 統合テストとクリーンアップ【最終・必須】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ テスト項目
  □ 初期描画でペン位置と描画位置が一致
  □ リサイズ（center/left/right/top/bottom）後も描画位置一致
  □ Vモードでレイヤー移動後の描画位置一致
  □ 高DPI環境（devicePixelRatio > 1）での座標一致
  □ CSS拡大（Ctrl + +）での座標一致
  □ レイヤーサムネイル即時更新
  □ タイムラインサムネイル内容・位置正常表示
  □ Vキーでポップアップ表示
  □ スライダー色が maroon 系

■ クリーンアップ対象
  プロジェクト全体で検索・削除:
    - "offsetX" "offsetY" の使用箇所
    - layer.position の個別調整ループ
    - 手動の offset 計算
    - setTimeout によるサムネイル再生成

■ 最終確認
  - CameraSystem.screenClientToWorld が唯一の入口
  - 全 pointer イベントが統一API使用
  - renderer.resize() が必ず実行
  - camera:transform-changed が正常発火
  - layer:transform-updated が正常発火

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【SDF/MSDF実装への準備】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

本改修完了後のアーキテクチャ:

  Screen (clientX/Y)
    ↓ CameraSystem.screenClientToWorld()
  World (カメラ補正済み)
    ↓ container.toLocal()
  Local (レイヤー相対座標)
    ↓ ストローク記録・SDF生成

利点:
- 全座標変換が一元化され SDF/MSDF 生成時の座標ズレなし
- レイヤー transform 変更時のイベント通知で SDF 再生成可能
- worldContainer の transform を SDF シェーダに渡すだけで正確な描画
- リサイズ・ズーム時も座標系が一貫

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【実装順序】
Phase 1 → Phase 2 → Phase 3 → Phase 4 → Phase 5 → Phase 6 → Phase 7 → Phase 8 → Phase 9

Phase 1-4 完了で基本的な座標ズレ解消
Phase 5 完了で Vモードズレ解消
Phase 6 完了でサムネイル同期
Phase 7 で UI品質向上
Phase 8-9 で最終整理

各Phase完了後は個別に動作確認推奨。