================================================================================
Tegaki v8.13 - サムネイル問題 段階的改修計画書 v2.0
================================================================================
作成日: 2025年
対象バージョン: v8.13_Drawing_70以降
改修方針: 非破壊レンダリング・ThumbnailSystem統一・イベント駆動化


================================================================================
【問題の全体像】
================================================================================

■ 症状
1. レイヤーサムネイル: 回転・スケール変更が反映されない
2. 非アクティブレイヤー: サイズ変更すら反映されない
3. タイムラインサムネイル: 初回生成遅延（Vモード操作まで沈黙）
4. Vモード中: 反転ボタン・ショートカット(H/Shift+H)が効かない

■ 根本原因
1. layer-system.js が ThumbnailSystem を無視して独自実装
   → updateThumbnail() が破壊的操作（レイヤーを親から切り離し）
   
2. イベントフロー断絶
   → layer-system.js が layer:transform-updated を購読していない
   → Transform変更がサムネイル更新に伝播しない
   
3. サムネイル生成の二重実装
   → thumbnail-system.js: _renderLayerThumbnail() (クローン方式・失敗)
   → layer-system.js: updateThumbnail() (一時移動方式・破壊的)
   
4. 座標系破壊
   → レイヤーを親から切り離す→座標系の親チェーンが断絶
   → Transform一時リセット→元に戻す際にズレ発生


================================================================================
【アーキテクチャ理解】
================================================================================

■ 座標系の5層構造
Screen座標 (clientX/Y) 
  → [DPI補正] → Canvas座標 (canvasX/Y)
  → [worldContainer逆行列] → World座標 (worldX/Y)
  → [親チェーン遡査] → Local座標 (localX/Y)
  → [RenderTexture] → Texture座標

■ ファイル責務マップ
【座標系】
- coordinate-system.js: 全座標変換の統一API

【サムネイル生成】
- thumbnail-system.js: サムネイル生成の中核
  - generateLayerThumbnail(): レイヤーサムネイル
  - generateFrameThumbnail(): フレームサムネイル
  - _renderLayerThumbnail(): ❌問題箇所（Phase 2で修正）

【レイヤー管理】
- layer-system.js: レイヤー操作・ライフサイクル
  - updateThumbnail(): ❌独自実装（Phase 3で削除）
  - flipActiveLayer(): 反転機能

【Transform制御】
- layer-transform.js: Transform適用・GSAP統合
  - applyTransform(): GSAP delayedCall経由で適用
  - flipLayer(): 反転処理
  - _emitTransformUpdated(): イベント発火（throttle付き）

【UI層】
- layer-panel-renderer.js: レイヤーパネルUI
  - _generateAndDisplayThumbnail(): ThumbnailSystem呼び出し（正常）
  
- timeline-thumbnail-utils.js: タイムラインサムネイル
  - generateThumbnail(): ThumbnailSystem呼び出し
  - layer:transform-updated 購読済み（正常）

■ イベントフロー（現状）
layer-transform.js
  → gsap.delayedCall(0.016秒) 
  → layer:transform-updated 発火
  
timeline-thumbnail-utils.js → ✅ 購読中
layer-panel-renderer.js → ✅ 購読中
layer-system.js → ❌ 購読なし（これが問題）


================================================================================
【メソッド・イベント・シンボル辞典】
================================================================================

■ ThumbnailSystem (thumbnail-system.js)
メソッド                                戻り値           用途
generateLayerThumbnail(layer, w, h)     Promise<Canvas>  レイヤーサムネイル
generateFrameThumbnail(frame, w, h)     Promise<Canvas>  フレームサムネイル
_renderLayerThumbnail(layer, w, h)      Promise<Canvas>  ❌修正対象
_invalidateLayerCacheByLayerId(id)      void             キャッシュクリア
canvasToDataURL(canvas)                 string           DataURL変換

■ LayerSystem (layer-system.js)
メソッド                                戻り値           用途
updateThumbnail(layerIndex)             void             ❌削除対象
requestThumbnailUpdate(layerIndex)      void             修正対象
flipActiveLayer(direction)              void             反転（Vモード時に問題）

■ LayerTransform (layer-transform.js)
メソッド                                戻り値           用途
applyTransform(layer, transform, c)     void             Transform適用
flipLayer(layer, direction)             void             反転処理
_emitTransformUpdated(layerId, layer)   void             イベント発火

■ 主要イベント
イベント名                  発火元              データ                      用途
layer:transform-updated     layer-transform.js  {layerIndex,layerId,trans}  Transform更新通知
thumbnail:layer-updated     複数                {layerIndex,layerId,imm}    サムネイル更新要求
keyboard:vkey-pressed       keyboard-handler    -                           Vモード開始
keyboard:vkey-released      keyboard-handler    -                           Vモード終了

■ グローバルオブジェクト
window.ThumbnailSystem      サムネイル生成システム
window.layerManager         レイヤー管理システム
window.TegakiEventBus       イベントバス
window.CoordinateSystem     座標変換システム
window.cameraSystem         カメラ・ズーム制御


================================================================================
【改修フロー全体】
================================================================================

Phase 1: 準備・診断
  ↓
Phase 2: thumbnail-system.js 修正（非破壊レンダリング実装）
  ↓
Phase 3: layer-system.js 修正（独自実装削除・イベント購読）
  ↓
Phase 4: イベント統合・UI連携確認
  ↓
Phase 5: 最終検証・デバッグコマンド整備


================================================================================
Phase 1: 準備・診断
================================================================================

【目的】
- 現状の動作確認
- 依存関係の検証
- バックアップ作成

【対象ファイル】
- なし（診断のみ）

【バックアップ対象】
- system/drawing/thumbnail-system.js
- system/layer-system.js
- system/layer-transform.js
- ui/layer-panel-renderer.js
- ui/timeline-thumbnail-utils.js

【診断コマンド】
コンソールで以下を実行:

```javascript
// 依存関係確認
console.log('ThumbnailSystem:', typeof window.ThumbnailSystem);
console.log('EventBus:', typeof window.TegakiEventBus);
console.log('LayerManager:', typeof window.layerManager);
console.log('CoordinateSystem:', typeof window.CoordinateSystem);
console.log('GSAP:', typeof gsap);

// イベントリスナー確認
const events = window.TegakiEventBus?.events || {};
console.log('layer:transform-updated listeners:', 
  events['layer:transform-updated']?.length || 0);
console.log('thumbnail:layer-updated listeners:', 
  events['thumbnail:layer-updated']?.length || 0);
```

【検証項目】
[  ] 全ての依存オブジェクトが "object" または "function" を返す
[  ] layer:transform-updated に1個以上のリスナーがある
[  ] thumbnail:layer-updated に1個以上のリスナーがある


================================================================================
Phase 2: thumbnail-system.js 修正（非破壊レンダリング実装）
================================================================================

【目的】
レイヤーを親から切り離さない非破壊レンダリング方式に変更

【対象ファイル】
- system/drawing/thumbnail-system.js（修正）

【参照ファイル】
- coordinate-system.js: 座標系理解
- system/layer-system.js: レイヤー構造確認
- config.js: canvas.width/height 取得

【修正方針】
❌ 削除: クローン方式（Graphics.clone()が不完全）
✅ 採用: 非破壊レンダリング（兄弟を一時非表示）

【修正内容】

■ 2-1. _renderLayerThumbnail() メソッド完全書き換え

修正前の問題:
- レイヤーをクローン→Graphics.clone()が不完全
- レイヤーを一時移動→座標系破壊

修正後の方式:
1. 背景レイヤーは専用処理（_generateBackgroundThumbnail()）
2. フレームコンテナ（親）を取得
3. キャンバス全体サイズでRenderTexture作成
4. 兄弟レイヤーの可視性を一時保存
5. 対象レイヤー以外を非表示化（visible = false）
6. フレームコンテナ全体をレンダリング（レイヤーは元の位置のまま）
7. 可視性を復元
8. サムネイルサイズにリサイズ

実装キーポイント:
```javascript
// Step 1: 親コンテナ取得
const frameContainer = layer.parent;

// Step 2: キャンバスサイズでRenderTexture作成
const canvasWidth = this.config?.canvas?.width || 800;
const canvasHeight = this.config?.canvas?.height || 600;
const frameRT = PIXI.RenderTexture.create({
    width: canvasWidth,
    height: canvasHeight,
    resolution: 1
});

// Step 3: 兄弟レイヤーの可視性を一時保存
const siblingVisibility = new Map();
frameContainer.children.forEach(sibling => {
    if (sibling !== layer) {
        siblingVisibility.set(sibling, sibling.visible);
        sibling.visible = false;
    }
});

const originalVisibility = layer.visible;
layer.visible = true;

// Step 4: レンダリング（レイヤーは元の位置のまま）
this.app.renderer.render({
    container: frameContainer,
    target: frameRT,
    clear: true
});

// Step 5: 可視性を復元
layer.visible = originalVisibility;
siblingVisibility.forEach((vis, sibling) => {
    sibling.visible = vis;
});

// Step 6: サムネイルサイズにリサイズ
const canvas = await this._resizeRenderTextureToCanvas(frameRT, width, height);

// クリーンアップ
frameRT.destroy(true);
```

エラー時の可視性復元も必須（try-catch-finally）

■ 2-2. _generateBackgroundThumbnail() 実装

背景レイヤー専用:
- config.background.color から色取得
- Canvas2D で単色塗りつぶし（軽量化）

■ 2-3. 不要メソッド削除

削除対象:
- _cloneLayerForThumbnail()
- _cloneDisplayObject()

理由: 非破壊レンダリングでは不要

【検証コマンド】

```javascript
window.TegakiDebug = window.TegakiDebug || {};
window.TegakiDebug.thumbnail = {
  testLayer: async function(layerIndex) {
    const layers = window.layerManager.getLayers();
    const layer = layers[layerIndex];
    console.log('Layer:', layer.layerData?.name);
    console.log('Transform:', {
      pos: layer.position,
      scale: layer.scale,
      rot: (layer.rotation * 180 / Math.PI).toFixed(1) + '°'
    });
    
    const canvas = await window.ThumbnailSystem.generateLayerThumbnail(
      layer, 128, 128
    );
    
    if (canvas) {
      const img = new Image();
      img.src = canvas.toDataURL();
      img.style.border = '2px solid red';
      document.body.appendChild(img);
      console.log('✅ Thumbnail appended (red border)');
    } else {
      console.error('❌ Failed');
    }
  }
};
```

【検証手順】
1. レイヤーに描画
2. Vモードでレイヤーを回転・スケール
3. `window.TegakiDebug.thumbnail.testLayer(1)` 実行
4. 画面にサムネイル表示されることを確認
5. サムネイルが回転・スケールを反映しているか確認


================================================================================
Phase 3: layer-system.js 修正（独自実装削除・イベント購読）
================================================================================

【目的】
- 独自サムネイル実装の削除
- ThumbnailSystem統一呼び出しに変更
- layer:transform-updated イベント購読追加

【対象ファイル】
- system/layer-system.js（修正）

【参照ファイル】
- system/drawing/thumbnail-system.js: 呼び出し先
- system/event-bus.js: イベント仕様
- ui/layer-panel-renderer.js: UIレンダリング方法

【修正内容】

■ 3-1. updateThumbnail() メソッド削除

削除対象: updateThumbnail(layerIndex) メソッド全体（約60行）
理由: ThumbnailSystemと重複・破壊的操作を含む

■ 3-2. requestThumbnailUpdate() メソッド修正

修正前: 独自のキュー管理・setTimeout実装

修正後:
```javascript
requestThumbnailUpdate(layerIndex) {
    const layers = this.getLayers();
    if (layerIndex < 0 || layerIndex >= layers.length) return;
    
    const layer = layers[layerIndex];
    const layerId = layer.layerData?.id;
    
    if (!layerId) return;
    
    // ThumbnailSystemのキャッシュをクリア
    if (window.ThumbnailSystem) {
        window.ThumbnailSystem._invalidateLayerCacheByLayerId(layerId);
    }
    
    // イベント発火（layer-panel-renderer.js が購読）
    if (this.eventBus) {
        this.eventBus.emit('thumbnail:layer-updated', {
            component: 'layer-system',
            action: 'thumbnail-requested',
            data: { layerIndex, layerId, immediate: false }
        });
    }
}
```

■ 3-3. processThumbnailUpdates() メソッド削除

削除理由: イベント駆動に変更したため不要

■ 3-4. _startThumbnailUpdateProcess() メソッド削除

削除理由: ポーリング不要（イベント駆動）

■ 3-5. init() メソッド修正

削除する行:
```javascript
this._startThumbnailUpdateProcess(); // ❌
```

追加する行:
```javascript
this._setupThumbnailEventListeners(); // ✅
```

■ 3-6. _setupThumbnailEventListeners() メソッド新規追加

追加位置: _setupAnimationSystemIntegration() の直後

```javascript
_setupThumbnailEventListeners() {
    if (!this.eventBus) return;
    
    // layer:transform-updated イベント購読
    this.eventBus.on('layer:transform-updated', ({ data }) => {
        const { layerIndex, layerId } = data || {};
        
        if (layerIndex === undefined && !layerId) return;
        
        // layerId から layerIndex を解決
        let targetLayerIndex = layerIndex;
        
        if (targetLayerIndex === undefined && layerId) {
            const layers = this.getLayers();
            targetLayerIndex = layers.findIndex(
              l => l.layerData?.id === layerId
            );
        }
        
        if (targetLayerIndex < 0) return;
        
        // ThumbnailSystem のキャッシュをクリア
        if (window.ThumbnailSystem && layerId) {
            window.ThumbnailSystem._invalidateLayerCacheByLayerId(layerId);
        }
        
        // UI更新イベント発火
        this.eventBus.emit('thumbnail:layer-updated', {
            component: 'layer-system',
            action: 'transform-updated-relay',
            data: { 
                layerIndex: targetLayerIndex, 
                layerId, 
                immediate: false 
            }
        });
        
        console.log(`[LayerSystem] Transform updated: layer ${targetLayerIndex}`);
    });
    
    console.log('[LayerSystem] Thumbnail event listeners configured');
}
```

■ 3-7. 不要なプロパティ削除

constructor() から削除:
```javascript
this.thumbnailUpdateQueue = new Set(); // ❌
this.thumbnailUpdateTimer = null;      // ❌
```

【検証コマンド】

```javascript
window.TegakiDebug.thumbnail.testEventFlow = function() {
    console.log('\n=== イベントフローテスト ===');
    
    const eventBus = window.TegakiEventBus;
    const events = eventBus?.events || {};
    
    console.log('layer:transform-updated listeners:', 
        events['layer:transform-updated']?.length || 0);
    console.log('thumbnail:layer-updated listeners:', 
        events['thumbnail:layer-updated']?.length || 0);
    
    // テストイベント発火
    eventBus.emit('layer:transform-updated', {
        data: { layerIndex: 1, layerId: 'test_id' }
    });
    
    console.log('✅ Test event emitted');
};
```

【検証手順】
1. `window.TegakiDebug.thumbnail.testEventFlow()` 実行
2. リスナー数が両方とも 1以上であることを確認
3. エラーが出ないことを確認


================================================================================
Phase 4: イベント統合・UI連携確認
================================================================================

【目的】
- Phase 2・3の統合動作確認
- UI層との連携確認
- Vモード反転機能の動作確認

【対象ファイル】
- なし（統合テストのみ）

【参照ファイル】
- ui/layer-panel-renderer.js: サムネイル表示
- ui/timeline-thumbnail-utils.js: タイムラインサムネイル
- ui/keyboard-handler.js: Vモードキー処理
- system/layer-transform.js: 反転処理

【確認項目】

■ 4-1. レイヤーパネル連携確認

確認内容:
- layer-panel-renderer.js が thumbnail:layer-updated を購読しているか
- _generateAndDisplayThumbnail() が ThumbnailSystem を呼び出しているか

確認コマンド:
```javascript
const events = window.TegakiEventBus?.events || {};
console.log('thumbnail:layer-updated listeners:', 
  events['thumbnail:layer-updated']?.length);
```

期待値: 1以上

■ 4-2. タイムライン連携確認

確認内容:
- timeline-thumbnail-utils.js が layer:transform-updated を購読しているか

確認コマンド:
```javascript
const events = window.TegakiEventBus?.events || {};
console.log('layer:transform-updated listeners (timeline):', 
  events['layer:transform-updated']?.length);
```

期待値: 2以上（layer-system + timeline-thumbnail-utils）

■ 4-3. Vモード反転機能確認

問題: Vモード中に反転ボタン・ショートカットが効かない

確認箇所:
- keyboard-handler.js: Vモード中のH/Shift+H処理
- layer-system.js: flipActiveLayer() 実装
- layer-transform.js: flipLayer() 実装

確認方法:
1. Vモード開始（Vキー押下）
2. H キー押下→水平反転されるか
3. Shift+H 押下→垂直反転されるか
4. レイヤーパネルのサムネイルが更新されるか

もし動作しない場合:
- keyboard-handler.js で Vモード中のキー処理を確認
- flipLayer() 後に _emitTransformUpdated() が呼ばれているか確認

【統合テストシナリオ】

テスト1: 基本Transform反映
1. レイヤーに描画
2. Vモードでレイヤー回転（45度）
3. レイヤーパネルのサムネイルが更新されることを確認
4. タイムラインのサムネイルが更新されることを確認

テスト2: 非アクティブレイヤー
1. レイヤー2つ作成
2. レイヤー1をアクティブに
3. レイヤー2をVモードで変形
4. レイヤー2のサムネイルが更新されることを確認

テスト3: 反転機能
1. Vモード開始
2. H キーで水平反転
3. Shift+H で垂直反転
4. サムネイルが即座に更新されることを確認

テスト4: タイムライン初回生成
1. フレーム作成
2. 描画直後にタイムラインを確認
3. サムネイルが即座に生成されることを確認


================================================================================
Phase 5: 最終検証・デバッグコマンド整備
================================================================================

【目的】
- 全症状の解決確認
- パフォーマンス確認
- デバッグコマンドの完全実装

【最終チェックリスト】

[  ] 1. レイヤーサムネイルが回転・スケールを反映する
[  ] 2. 非アクティブレイヤーもサイズ変更が反映される
[  ] 3. タイムラインサムネイルが初回から正しく生成される
[  ] 4. Vモード中の反転ボタンが動作する
[  ] 5. Vモード中の反転ショートカット(H/Shift+H)が動作する
[  ] 6. サムネイル生成時にフリーズしない
[  ] 7. メモリリークが発生していない

【デバッグコマンド完全実装】

■ 5-1. 全体診断コマンド

```javascript
window.TegakiDebug.thumbnail.diagnose = function() {
    console.log('\n=== サムネイルシステム診断 ===\n');
    
    // システム初期化
    console.log('🔍 システム:');
    console.log('  ThumbnailSystem:', !!window.ThumbnailSystem);
    console.log('  LayerManager:', !!window.layerManager);
    console.log('  EventBus:', !!window.TegakiEventBus);
    
    // キャッシュ状態
    if (window.ThumbnailSystem) {
        const info = window.ThumbnailSystem.getDebugInfo?.() || {};
        console.log('\n💾 キャッシュ:');
        console.log('  Layer cache:', info.layerCacheSize || 'N/A');
        console.log('  Frame cache:', info.frameCacheSize || 'N/A');
    }
    
    // イベントリスナー
    const events = window.TegakiEventBus?.events || {};
    console.log('\n📡 イベントリスナー:');
    console.log('  layer:transform-updated:', 
        events['layer:transform-updated']?.length || 0);
    console.log('  thumbnail:layer-updated:', 
        events['thumbnail:layer-updated']?.length || 0);
    
    // レイヤー状態
    if (window.layerManager) {
        const layers = window.layerManager.getLayers();
        console.log('\n🎨 レイヤー:');
        console.log('  Total:', layers.length);
        console.log('  Active:', window.layerManager.activeLayerIndex);
    }
    
    console.log('\n✅ 診断完了\n');
};
```

■ 5-2. リアルタイム監視コマンド

```javascript
window.TegakiDebug.thumbnail.monitor = function(duration = 10000) {
    console.log(`\n=== 監視開始（${duration/1000}秒） ===\n`);
    
    const eventBus = window.TegakiEventBus;
    let count = 0;
    
    const listener = ({ data }) => {
        count++;
        console.log(`[${count}] layer:transform-updated`, data);
    };
    
    eventBus.on('layer:transform-updated', listener);
    
    setTimeout(() => {
        eventBus.off('layer:transform-updated', listener);
        console.log(`\n✅ 監視終了（${count}個のイベント）\n`);
    }, duration);
};
```

■ 5-3. パフォーマンス計測

```javascript
window.TegakiDebug.thumbnail.measurePerf = async function() {
    console.log('\n=== パフォーマンス計測 ===\n');
    
    const layers = window.layerManager.getLayers();
    const layer = layers[1];
    
    if (!layer) {
        console.error('❌ Layer not found');
        return;
    }
    
    const times = [];
    
    for (let i = 0; i < 10; i++) {
        window.ThumbnailSystem._invalidateLayerCacheByLayerId(
            layer.layerData.id
        );
        
        const start = performance.now();
        await window.ThumbnailSystem.generateLayerThumbnail(layer, 64, 64);
        const end = performance.now();
        
        times.push(end - start);
    }
    
    const avg = times.reduce((a, b) => a + b, 0) / times.length;
    const min = Math.min(...times);
    const max = Math.max(...times);
    
    console.log('サムネイル生成時間:');
    console.log('  平均:', avg.toFixed(2), 'ms');
    console.log('  最小:', min.toFixed(2), 'ms');
    console.log('  最大:', max.toFixed(2), 'ms');
    console.log('\n✅ 計測完了\n');
};
```

【パフォーマンス目標】
- サムネイル生成: 平均 50ms以下
- Vモードドラッグ: 60FPS維持
- メモリ使用量: 改修前と同等


================================================================================
【トラブルシューティング】
================================================================================

■ 問題: サムネイルが真っ黒/真っ白

原因:
- RenderTexture サイズが0
- レイヤーが完全に非表示
- frameContainer が null

確認:
```javascript
const layer = window.layerManager.getLayers()[1];
console.log('Parent:', layer.parent);
console.log('Visible:', layer.visible);
console.log('Children:', layer.children.length);
```

■ 問題: サムネイルが更新されない

原因:
- イベントリスナーが登録されていない
- キャッシュがクリアされていない

確認:
```javascript
const events = window.TegakiEventBus?.events || {};
console.log('Listeners:', events['layer:transform-updated']?.length);
```

■ 問題: Vモード中に反転が効かない

原因:
- keyboard-handler.js で Vモード中のキー処理がブロックされている
- flipLayer() 後に _emitTransformUpdated() が呼ばれていない

確認:
```javascript
// keyboard-handler.js で Vモード中の処理を確認
// layer-transform.js の flipLayer() を確認
```

■ 問題: メモリリーク

原因:
- RenderTexture の destroy() 漏れ
- イベントリスナーの off() 漏れ

確認:
```javascript
// Chrome DevTools > Memory > Take Heap Snapshot
// RenderTexture が残っていないか確認
```


================================================================================
【改修完了の判定基準】
================================================================================

以下の全てが満たされた場合、改修完了とする:

1. レイヤーサムネイル
   - Vモードでの回転・スケール変更が即座に反映される
   - 非アクティブレイヤーの変更も反映される

2. タイムラインサムネイル
   - フレーム作成直後から正しく表示される
   - Vモード操作を待たずに生成される

3. 反転機能
   - Vモード中の反転ボタンが動作する
   - Vモード中のショートカット(H/Shift+H)が動作する
   - 反転後、サムネイルが即座に更新される

4. パフォーマンス
   - サムネイル生成が 50ms以下
   - Vモードドラッグが 60FPS維持
   - メモリリークが発生していない

5. コード品質
   - 二重実装が削除されている
   - イベント駆動に統一されている
   - 破壊的操作が排除されている


================================================================================
【改修後のアーキテクチャ】
================================================================================

■ サムネイル生成フロー（改修後）

Transform変更
  ↓
layer-transform.js: _emitTransformUpdated()
  ↓
layer:transform-updated イベント発火
  ↓
  ├→ layer-system.js: _setupThumbnailEventListeners()
  │   → ThumbnailSystem._invalidateLayerCacheByLayerId()
  │   → thumbnail:layer-updated イベント発火
  │   → layer-panel-renderer.js: サムネイル更新
  │
  └→ timeline-thumbnail-utils.js: サムネイル更新

■ 統一ルール

1. サムネイル生成は ThumbnailSystem のみ
2. Transform変更は layer:transform-updated イベント経由
3. UI更新は thumbnail:layer-updated イベント経由
4. 座標系破壊は厳禁（レイヤーを親から切り離さない）


================================================================================
【付録: 重要なコードパターン】
================================================================================

■ 非破壊レンダリングパターン

```javascript
// 兄弟を一時非表示
const siblingVisibility = new Map();
frameContainer.children.forEach(sibling => {
    if (sibling !== layer) {
        siblingVisibility.set(sibling, sibling.visible);
        sibling.visible = false;
    }
});

// レンダリング
this.app.renderer.render({
    container: frameContainer,
    target: renderTexture,
    clear: true
});

// 可視性を復元
siblingVisibility.forEach((vis, sibling) => {
    sibling.visible = vis;
});
```

■ イベント購読パターン

```javascript
this.eventBus.on('layer:transform-updated', ({ data }) => {
    const { layerIndex, layerId } = data || {};
    
    // 処理
    if (window.ThumbnailSystem && layerId) {
        window.ThumbnailSystem._invalidateLayerCacheByLayerId(layerId);
    }
    
    // 次のイベントを発火
    this.eventBus.emit('thumbnail:layer-updated', {
        component: 'layer-system',
        action: 'transform-updated-relay',
        data: { layerIndex, layerId, immediate: false }
    });
});
```

■ キャッシュクリアパターン

```javascript
requestThumbnailUpdate(layerIndex) {
    const layers = this.getLayers();
    const layer = layers[layerIndex];
    const layerId = layer.layerData?.id;
    
    if (window.ThumbnailSystem && layerId) {
        window.ThumbnailSystem._invalidateLayerCacheByLayerId(layerId);
    }
    
    // イベント発火
    this.eventBus.emit('thumbnail:layer-updated', {
        data: { layerIndex, layerId }
    });
}
```


================================================================================
【改修実施時の注意事項】
================================================================================

1. Phase順に実施すること
   - Phase 1を飛ばさない（診断が重要）
   - Phase 2→3の順序を守る（依存関係）

2. 各Phase完了後に検証すること
   - 検証コマンドを必ず実行
   - 問題があれば次のPhaseに進まない

3. バックアップを必ず取ること
   - 改修前のファイルを .bak で保存
   - 問題があれば即座にロールバック

4. コンソールログを確認すること
   - エラーが出ていないか
   - イベントが発火しているか
   - リスナーが登録されているか

5. 既存の動作を壊さないこと
   - 描画機能は改修対象外
   - カメラ・ズームは改修対象外
   - アニメーションは改修対象外


================================================================================
以上
================================================================================