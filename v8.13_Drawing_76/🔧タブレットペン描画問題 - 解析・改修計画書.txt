# タブレットペン描画問題 - 解析・改修計画書

## 1. 問題の本質（Critical Issues）

### 1-A: PointerEvent二重登録
**症状**: マウスは描画できるがタブレットペンでは描画できない

**原因**:
- `core-runtime.js`: PIXIのstageに直接pointerイベント登録
- `drawing-engine.js`: canvasに対してPointerHandler経由でイベント登録
- 両方が同じpointerIdを受け取り、setPointerCaptureが競合

**影響範囲**:
- ポインター管理が分裂し、タブレットペンでactivePointers登録に失敗
- レイヤーパネルのドラッグも同様の理由で失敗

---

### 1-B: pointerType誤認
**症状**: Windows等の環境でタブレットペンがpointerType='mouse'と報告される

**原因**:
- `pointer-handler.js`の`normalizeEvent()`が生のpointerTypeをそのまま返す
- 筆圧・傾き情報があってもmouseとして扱われる

**影響**:
- タブレットペン使用時にmouseとして処理され、pressureが正しく取得できない可能性

---

## 2. 座標系フロー（正常時）

```
PointerEvent.clientX/Y
  ↓
CoordinateSystem.screenClientToCanvas()  [DPI補正]
  ↓ {canvasX, canvasY}
CoordinateSystem.canvasToWorld()  [worldContainer逆行列]
  ↓ {worldX, worldY}
CoordinateSystem.worldToLocal()  [親チェーン遡査]
  ↓ {localX, localY}
StrokeRecorder.addPoint()  [Local座標を直接記録]
```

**現状確認**:
- coordinate-system.js: 座標変換は正常実装
- drawing-engine.js: _screenToLocal()で正しくパイプライン実行
- stroke-recorder.js: 二重変換を避ける設計で正常

---

## 3. メソッド/シンボル辞典

### pointer-handler.js
```
PointerHandler.attach(element, handlers, options)
  → handlers: {down, move, up, cancel}
  → activePointers: Map<pointerId, info>
  → normalizeEvent(e)  [要修正]
```

### drawing-engine.js
```
_handlePointerDown(info, e)
  → activePointers.set(pointerId, info)
  → _screenToLocal(clientX, clientY)
  → brushCore.startStroke(localX, localY, pressure, pointerId)

_screenToLocal(clientX, clientY)
  → coordSystem.screenClientToCanvas()
  → coordSystem.canvasToWorld()
  → coordSystem.worldToLocal(layer)
  → return {localX, localY}
```

### core-runtime.js
```
setupPointerEvents()  [要削除]
  → stage.on('pointerdown', handlePointerDown)
  → drawingEngine.startDrawing(0, 0, nativeEvent)  [Legacy API]

extractNativeEvent(pixiEvent)  [不要]
  → clientX/Yを抽出するフォールバック処理
```

### coordinate-system.js
```
screenClientToCanvas(clientX, clientY)
  → rect = canvas.getBoundingClientRect()
  → DPI補正 → {canvasX, canvasY}

canvasToWorld(canvasX, canvasY)
  → worldContainer.worldTransform.invert()
  → {worldX, worldY}

worldToLocal(worldX, worldY, container)
  → 親チェーン遡査（手動逆算）
  → {localX, localY}
```

### stroke-recorder.js
```
startStroke(localX, localY, pressure)
  → isRecording = true
  → addPoint(localX, localY, pressure)

addPoint(localX, localY, pressure)
  → points.push({x: localX, y: localY, pressure, ...})
  → 座標変換なし（既にLocal座標）
```

### brush-core.js
```
startStroke(localX, localY, pressure, pointerId)
  → strokeRecorder.startStroke(localX, localY, pressure)
  → _initPreviewContainer(layer)

addPoint(localX, localY, pressure, pointerId)
  → strokeRecorder.addPoint(localX, localY, pressure)
  → _updatePreview()

endStroke(pointerId)
  → strokeData = strokeRecorder.endStroke()
  → _renderStroke(layer, strokeData)  [非同期]
```

---

## 4. 改修計画（Phase別）

### Phase 1: PointerEvent一本化（最優先）

**対象ファイル**: 
- `core-runtime.js`
- `drawing-engine.js`

**修正内容**:

#### core-runtime.js
```javascript
// setupPointerEvents() 全体をコメントアウト or 削除
// handlePointerDown/Move/Up を削除
// extractNativeEvent() を削除

// レガシーAPI互換用の空関数のみ残す（警告付き）
handlePointerDown(event) {
    console.warn('[CoreRuntime] Legacy pointer handling - ignored');
}
```

#### drawing-engine.js
- 変更不要（既にPointerHandler使用）

**検証方法**:
- タブレットペンで描画テスト
- console.logでactivePointers.size確認（1であること）
- マウス・タッチ・ペンそれぞれで正常動作確認

---

### Phase 2: pointerType補正ヒューリスティック

**対象ファイル**:
- `pointer-handler.js`

**修正内容**:

```javascript
function normalizeEvent(e) {
    let pType = e.pointerType;
    
    // ヒューリスティック: mouseでも筆圧・傾きがあればペン扱い
    if (pType === 'mouse') {
        const hasPressure = typeof e.pressure === 'number' && e.pressure > 0.01;
        const hasTilt = typeof e.tiltX === 'number' && 
                       (e.tiltX !== 0 || e.tiltY !== 0);
        
        if (hasPressure || hasTilt) {
            pType = 'pen';
        }
    }
    
    return {
        pointerId: e.pointerId,
        pointerType: pType,  // 補正後
        clientX: e.clientX,
        clientY: e.clientY,
        pressure: e.pressure ?? 0.5,
        tiltX: e.tiltX ?? 0,
        tiltY: e.tiltY ?? 0,
        twist: e.twist ?? 0,
        button: e.button,
        buttons: e.buttons,
        originalEvent: e
    };
}
```

**参考**: drawing-engine.js の _handlePointerDown() でpointerTypeをログ出力している箇所があるため、修正後の動作確認が容易

---

### Phase 3: レイヤーパネルドラッグ修正（優先度：中）

**対象ファイル**:
- `ui/layer-panel-renderer.js`（該当ファイル未取得のため推定）

**修正方針**:
- Sortable/DnD実装をPointerHandler.attach()で置き換え
- mouse/touch/penすべてで統一的にドラッグ処理

**詳細**:
```javascript
// initializeSortable()内で
const detach = window.PointerHandler.attach(layerListElement, {
    down: (info, ev) => onDragStart(info, ev),
    move: (info, ev) => onDragMove(info, ev),
    up: (info, ev) => onDragEnd(info, ev)
}, { capture: true, preventDefault: false });

// クリーンアップ時に detach() を呼ぶ
```

---

## 5. 実装時の注意事項

### DRY/SOLID原則チェック
- ✅ 座標変換は CoordinateSystem に集約済み
- ✅ ストローク記録は StrokeRecorder に集約済み
- ❌ ポインター処理が core-runtime と drawing-engine で二重実装 → Phase 1で解消

### 過剰なログの削除
- core-runtime.js: `console.log('✅ xxx loaded')` は維持（初期化確認用）
- drawing-engine.js: `_handlePointerDown()` のログは開発中は有用だが、本番では削除推奨
- coordinate-system.js: デバッグコマンド `TegakiDebug.coord.*` は維持

### 循環依存チェック
- pointer-handler.js: 依存なし（独立モジュール）
- drawing-engine.js: PointerHandler, CoordinateSystem, BrushCore に依存
- core-runtime.js: すべてに依存（統合レイヤー）
- 循環なし ✅

---

## 6. 検証手順

### Phase 1実施後
1. Chrome DevTools で以下を実行:
```javascript
// タブレットペンでキャンバスをタップ
// Console で確認:
window.drawingEngine.activePointers.size  // 1 であること
```

2. 複数デバイスでテスト:
- マウス: クリック＆ドラッグで描画
- タブレットペン: タップ＆ドラッグで描画
- タッチ: シングルタッチで描画

3. 座標系テスト:
```javascript
TegakiDebug.coord.testFullPipeline(100, 100);
// ✅ 座標変換: 正常 が出力されること
```

### Phase 2実施後
1. Windows環境でテスト（pointerType='mouse'になる環境）
2. Console で pointerType が補正されているか確認:
```javascript
// drawing-engine.js の _handlePointerDown() ログで
// PointerDown: { type: 'pen', ... } となっていること
```

---

## 7. その他の問題（低優先度）

### 7-A: レイヤーナンバリング
- 対象: `system/layer-system.js`
- 修正: `this.nextLayerNumber` カウンタ導入
- 詳細: createLayer() で `レイヤー ${this.nextLayerNumber++}` を使用

### 7-B: 背景レイヤー初期化
- 対象: `system/layer-system.js`
- 修正: 背景レイヤー作成時に `#f0e0d6` で fillRect
- 詳細: isBackground=true の場合、graphics.beginFill(0xf0e0d6)

### 7-C: 消しゴム問題
- 対象: `system/drawing/stroke-renderer.js`（未取得）
- 修正: `graphics.blendMode = PIXI.BLEND_MODES.DST_OUT`
- 詳細: 消しゴム時はレイヤー内アルファのみ削除

### 7-D: サムネイル更新
- 対象: `ui/resize-popup.js`, `system/layer-system.js`
- 修正: リサイズ後に `eventBus.emit('ui:canvas-resized')`
- 詳細: layer-system でイベント受信して requestThumbnailUpdateAll()

---

## 8. 改修後のフロー（期待動作）

```
[ユーザー] タブレットペンでキャンバスをタッチ
  ↓
[canvas] pointerdown イベント発火
  ↓
[PointerHandler] setPointerCapture(pointerId)
  ↓
[normalizeEvent] pointerType='mouse'でも筆圧あり → 'pen' に補正
  ↓
[drawing-engine._handlePointerDown]
  ├→ activePointers.set(pointerId, {type:'pen'})
  ├→ _screenToLocal(clientX, clientY)
  └→ brushCore.startStroke(localX, localY, pressure)
      ↓
[StrokeRecorder] Local座標を直接記録（二重変換なし）
  ↓
[pointermove] 連続発火
  ↓
[drawing-engine._handlePointerMove]
  └→ brushCore.addPoint(localX, localY, pressure)
      ↓
[StrokeRecorder] points.push({x:localX, y:localY, pressure})
  ↓
[BrushCore._updatePreview] プレビュー描画更新
  ↓
[pointerup] 発火
  ↓
[drawing-engine._handlePointerUp]
  └→ brushCore.endStroke()
      ↓
[StrokeRecorder.endStroke] → strokeData返却
  ↓
[BrushCore._renderStroke] WebGPU/SDF描画（非同期）
  ↓
[layer.addChild(strokeGraphics)] 確定描画
  ↓
[History.push] Undo/Redo記録
  ↓
✅ 描画完了
```

---

## 9. 完了チェックリスト

- [ ] Phase 1: core-runtime.js の二重登録を削除
- [ ] Phase 2: pointer-handler.js にヒューリスティック追加
- [ ] 検証: マウス・タッチ・ペンすべてで描画確認
- [ ] 検証: activePointers.size が正しく管理されているか確認
- [ ] 検証: Console にエラーログがないか確認
- [ ] Phase 3: レイヤーパネルドラッグを PointerHandler 化
- [ ] 低優先: レイヤーナンバリング・背景レイヤー・消しゴム・サムネイル修正

---

## 10. 参考情報

### 座標変換パイプライン設計方針
- Screen → Canvas → World → Local の一方向変換
- 各座標系をパラメータ名で明示 (localX, worldX, canvasX, clientX)
- 二重変換の徹底排除（座標変換は drawing-engine で完結）

### WebGPU/SDF描画
- brush-core.js は既に非同期対応（async/await）
- stroke-renderer.js が WebGPU自動選択
- タブレットペン問題とは独立（Phase 1/2で解決後も動作）

### イベントバス設計
- `window.TegakiEventBus` 経由で疎結合
- 'component:action' 形式の命名規則
- ポインター処理とは独立（直接影響なし）

---

END