# Drawing System Refactoring Plan
ベクター消しゴム実装とツール拡張性確保のための段階的改修計画

## 改修方針
- ベクター消しゴム（真の削除・分割）実装
- ツールプラグイン機構の確立
- データ所有権とAPI境界の明確化
- DRY/SOLID原則に基づく責務分離

---

## Phase 1: ツール基盤の構築

### 目的
ツール切り替え機構とデータ管理の一元化

### 新規作成ファイル

**system/drawing/tools/tool-base.js**
- 役割: 全ツール共通の抽象基底クラス
- 必須メソッド: onPointerDown/Move/Up(worldPos, pressure)
- オプショナル: onActivate/Deactivate(), getCursor()
- EventBus連携: なし（派生クラスで使用）
- 参考: なし（新規設計）

**system/drawing/tools/tool-manager.js**
- 役割: ツール状態管理・切り替え・ライフサイクル制御
- プロパティ: currentTool, toolRegistry (Map)
- メソッド:
  - registerTool(name, ToolClass)
  - switchTool(name)
  - getCurrentTool()
- EventBus発行: 'tool:changed' { from, to }
- 参考: system/state-manager.js（状態管理パターン）

**system/drawing/core/stroke-data-manager.js**
- 役割: ストロークデータのCRUD・空間検索
- プロパティ: strokes (Map<id, strokeData>), spatialIndex
- メソッド:
  - addStroke(strokeData) -> id
  - removeStroke(id) -> boolean
  - updateStroke(id, strokeData)
  - findStrokesInBounds(bounds) -> id[]
  - findStrokesInRadius(center, radius) -> id[]
  - getAllStrokes() -> strokeData[]
- EventBus発行: 'stroke:added/removed/updated' { id, strokeData }
- 空間検索: 簡易実装（総当たり）→将来QuadTree化
- 参考: system/layer-system.js（データ管理パターン）

### 改修ファイル

**system/drawing/drawing-engine.js**
- 変更内容:
  - ToolManagerインスタンス追加
  - StrokeDataManagerインスタンス追加
  - ツール処理を currentTool に委譲（onPointerDown/Move/Up内）
  - 座標変換のみ drawing-engine が担当（ワールド座標を渡す）
- 削除する責務: 直接的なストローク描画ロジック
- 保持する責務: 初期化、座標変換、イベント受付、レンダリング制御
- 参考フロー: pointer event → 座標変換 → toolManager.currentTool.onPointerMove(worldPos)
- EventBus購読: 'stroke:added/removed/updated'（再描画トリガー）

**system/drawing/stroke-recorder.js**
- 変更内容:
  - StrokeDataManager と連携
  - 記録完了時に dataManager.addStroke() 呼び出し
  - 座標系をワールド座標基準に統一
- 保持する責務: ポイント記録、スムージング、strokeData組み立て
- 参考: 既存実装を維持しつつデータ追加先を変更

### 検証項目
- [ ] ツール切り替えが正常動作
- [ ] ストロークデータの追加・削除がEventBus経由で通知
- [ ] 既存ペン描画が正常動作（リグレッションなし）

---

## Phase 2: ペンツールの抽象化

### 目的
既存描画ロジックをToolBaseに準拠させる

### 新規作成ファイル

**system/drawing/tools/pen-tool.js**
- 役割: ペン描画ツール実装
- 継承: ToolBase
- 依存:
  - StrokeRecorder（ポイント記録）
  - BrushSettings（ブラシ設定参照）
  - PressureHandler（筆圧処理）
- メソッド実装:
  - onPointerDown: StrokeRecorder.startStroke()
  - onPointerMove: StrokeRecorder.addPoint() + 仮描画
  - onPointerUp: StrokeRecorder.finishStroke() → dataManager.addStroke()
  - getCursor: 'crosshair'
- 仮描画: PixiJS Graphics一時オブジェクト使用
- 参考: drawing-engine.js の既存ペン処理を移植

### 改修ファイル

**system/drawing/drawing-engine.js**
- 変更内容:
  - PenTool を toolManager に登録
  - デフォルトツールとして 'pen' を設定
  - 旧ペン描画コードを削除
- ツール登録例: toolManager.registerTool('pen', PenTool)

**system/drawing/stroke-renderer.js**
- 変更内容:
  - StrokeDataManager から全ストローク取得
  - レンダリングのみに特化（データ操作なし）
- メソッド:
  - renderAllStrokes(dataManager)
  - renderStroke(strokeData)
- 参考: 既存実装を維持、データ取得先を変更

### 検証項目
- [ ] PenTool で描画可能
- [ ] 描画結果が StrokeDataManager に保存
- [ ] 既存の筆圧・スムージング機能が正常動作

---

## Phase 3: ベクター演算基盤

### 目的
消しゴム実装に必要なベクター演算機能の提供

### 新規作成ファイル

**system/drawing/processing/vector-operations.js**
- 役割: ベクター幾何演算ユーティリティ
- メソッド:
  - getStrokeBounds(strokeData) -> { x, y, width, height }
  - testPointInStroke(point, strokeData, threshold) -> boolean
  - testCircleStrokeIntersection(center, radius, strokeData) -> boolean
  - splitStrokeByCircle(strokeData, center, radius) -> strokeData[]
    - 戻り値: 交差していない部分のストローク配列
    - アルゴリズム: 各セグメント毎に円との交差判定、交差区間を除外
  - calculateStrokeLength(strokeData) -> number
- 座標系: 全てワールド座標
- 参考: なし（新規実装）

### 検証項目
- [ ] testCircleStrokeIntersection が正確
- [ ] splitStrokeByCircle が正しく分割
- [ ] 性能テスト（100ストローク程度で遅延なし）

---

## Phase 4: 消しゴムツール実装

### 目的
ベクターベースの真の消しゴム機能

### 新規作成ファイル

**system/drawing/tools/eraser-tool.js**
- 役割: ベクター消しゴムツール
- 継承: ToolBase
- 依存:
  - StrokeDataManager
  - VectorOperations
  - BrushSettings（サイズ取得）
- メソッド実装:
  - onPointerDown: 消去開始、lastEraserPos記録
  - onPointerMove:
    1. 現在位置と前回位置の中間点でサンプリング（連続性確保）
    2. dataManager.findStrokesInRadius() で対象取得
    3. 各ストロークに VectorOperations.splitStrokeByCircle() 適用
    4. 元ストローク削除、分割後セグメント追加（長さ閾値以上のみ）
    5. lastEraserPos更新
  - onPointerUp: 処理完了、history登録
  - getCursor: 'none'（カスタムカーソル表示推奨）
- 最適化: 前回位置からの移動距離が小さい場合はスキップ
- 履歴: 消去前の全ストロークIDを記録
- 参考: なし（新規実装）

### 改修ファイル

**system/drawing/drawing-engine.js**
- 変更内容:
  - EraserTool を toolManager に登録
  - ツール切り替えショートカット追加（例: 'E'キー）
- 登録例: toolManager.registerTool('eraser', EraserTool)

**ui/keyboard-handler.js**
- 変更内容:
  - 消しゴム切り替えショートカット追加
  - EventBus.emit('tool:switch', { tool: 'eraser' })
- 参考: 既存ツール切り替え実装

### 検証項目
- [ ] 消しゴムでストロークが削除される
- [ ] 部分削除時に正しく分割される
- [ ] undo/redo が正常動作
- [ ] 高速移動時も途切れなく消去

---

## Phase 5: レンダリングパイプラインの整理

### 目的
将来のMSDF実装に備えたレンダラー抽象化

### 新規作成ファイル

**system/drawing/renderers/vector-stroke-renderer.js**
- 役割: 現在の Graphics ベースレンダリング
- 既存 stroke-renderer.js の機能を移植
- メソッド:
  - render(strokeData, graphics)
  - clear(graphics)
- 参考: stroke-renderer.js を改名・整理

**system/drawing/renderers/renderer-factory.js**
- 役割: レンダラー選択・生成
- メソッド:
  - createRenderer(type) -> IRenderer
  - type: 'vector', 'msdf'（将来）
- デフォルト: 'vector'
- 参考: なし（新規設計）

**system/drawing/core/render-pipeline.js**
- 役割: レンダリング制御・最適化
- 機能:
  - ダーティフラグ管理
  - レンダリングスケジューリング
  - 部分再描画（将来）
- メソッド:
  - markDirty()
  - requestRender()
  - render(dataManager, renderer)
- EventBus購読: 'stroke:added/removed/updated'
- 参考: なし（新規設計）

### 改修ファイル

**system/drawing/drawing-engine.js**
- 変更内容:
  - RenderPipeline 使用
  - レンダリングロジックを pipeline.render() に委譲
  - 直接的な Graphics 操作を削除
- 簡素化: 描画タイミング制御を RenderPipeline に任せる

**system/drawing/stroke-renderer.js**
- 対応: renderers/vector-stroke-renderer.js に移行後、削除

### 検証項目
- [ ] レンダリングが正常動作
- [ ] 性能低下なし
- [ ] レンダラー切り替え機構が動作

---

## Phase 6: 統合・最適化

### 目的
EventBus統合の完全性確保と性能最適化

### 改修ファイル

**system/drawing/core/stroke-data-manager.js**
- 最適化:
  - 空間検索をQuadTreeに置き換え（ストローク数>100の場合）
  - バッチ操作API追加: batchRemove(ids[]), batchAdd(strokeData[])
- EventBus最適化: バッチ操作時は単一イベント発行

**system/drawing/tools/eraser-tool.js**
- 最適化:
  - 連続消去時のバッチ削除/追加
  - サンプリング間隔の調整（筆圧対応）
- UX改善: 消しゴムプレビュー円表示

**system/history.js**
- 変更内容:
  - ツール操作の履歴対応
  - ストロークバッチ操作の記録
- コマンドパターン:
  - AddStrokeCommand
  - RemoveStrokeCommand
  - BatchStrokeCommand（消しゴム用）
- 参考: 既存履歴機構を拡張

### 新規作成ファイル

**system/drawing/tools/tool-cursor-renderer.js**
- 役割: ツールカーソルのカスタム描画
- 機能: 消しゴム円、ブラシプレビュー
- レイヤー: UI層に描画（ストローク層と分離）
- 参考: なし（新規実装）

### 全体検証
- [ ] 全ツールが正常動作
- [ ] EventBus経由の通信が完全
- [ ] メモリリークなし
- [ ] 設定参照が統一（BrushSettings経由）
- [ ] API命名規則の一貫性
- [ ] 座標系の一貫性（全てワールド座標）

---

## Phase 7: ドキュメント・将来拡張

### ドキュメント作成

**system/drawing/README.md**
- アーキテクチャ概要図
- ファイル責務一覧
- 新規ツール追加手順
- API reference

### 将来実装の準備

**バケツツール (system/drawing/tools/bucket-tool.js)**
- 参考: pen-tool.js の構造
- 必要機能: 境界検出、塗りつぶし領域計算
- 依存: VectorOperations拡張

**エアブラシツール (system/drawing/tools/airbrush-tool.js)**
- 参考: pen-tool.js
- 追加機能: ランダム散布、不透明度制御
- レンダラー: 専用シェーダー検討

**MSDFレンダラー (system/drawing/renderers/msdf-renderer.js)**
- 前提: WebGLシェーダー実装
- 参考: renderer-factory.js
- 統合: render-pipeline.js 経由で切り替え

---

## 改修時の注意事項

### 必須確認事項
- 座標系の一貫性（全てワールド座標で処理）
- データ所有権（StrokeDataManagerのみがストロークデータを保持）
- EventBus経由の通信（直接参照を避ける）
- APIの対称性（add/remove, start/finish など）
- 命名規則の遵守

### 禁止事項
- localStorage使用（メモリ内で完結）
- Canvas2D使用（サムネイル以外）
- 暗黙的な座標変換
- ツール間の直接依存
- 二重実装・重複コード

### 各Phase完了後の確認
1. 既存機能のリグレッションテスト
2. EventBusイベントフローの確認
3. メモリ使用量の確認
4. コンソールエラー・警告の排除
5. コードレビュー（命名・責務・DRY原則）

---

## ファイル依存関係図（Phase 6完了時）

```
drawing-engine.js
├─ ToolManager
│  ├─ PenTool
│  │  ├─ StrokeRecorder
│  │  ├─ BrushSettings
│  │  └─ PressureHandler
│  ├─ EraserTool
│  │  ├─ BrushSettings
│  │  └─ VectorOperations
│  └─ [FutureTools]
├─ StrokeDataManager
│  └─ EventBus
├─ RenderPipeline
│  └─ RendererFactory
│     └─ VectorStrokeRenderer
└─ EventBus
```

### データフロー
1. Pointer Event → drawing-engine（座標変換）
2. drawing-engine → ToolManager.currentTool（ワールド座標）
3. Tool → StrokeDataManager（データ操作）
4. StrokeDataManager → EventBus（変更通知）
5. EventBus → RenderPipeline（再描画）
6. RenderPipeline → VectorStrokeRenderer（描画実行）

---

## 完了条件

### Phase毎の完了定義
- Phase 1: ツール切り替えとデータ管理の動作確認
- Phase 2: PenToolでの描画成功
- Phase 3: ベクター演算の単体テスト通過
- Phase 4: 消しゴムでのストローク削除成功
- Phase 5: レンダリングの正常動作
- Phase 6: 全機能統合、性能要件達成
- Phase 7: ドキュメント完成、拡張性確保

### 最終受け入れ基準
- [ ] ペン・消しゴムが正常動作
- [ ] undo/redoが完全動作
- [ ] 性能：1000ストローク描画でも60fps維持
- [ ] 拡張性：新規ツール追加が50行以内で可能
- [ ] 可読性：Claude Sonnetが全ファイルの責務を理解可能
- [ ] メンテナンス性：1ファイル200行以内（core除く）