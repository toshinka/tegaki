結論（要点）

「アイコンをクリックしてもタイムラインが出ない」原因は概ね Timeline UI が正しく公開／初期化されていない（= 登録されない or DOM 要素が無い） ためです。タイムライン側の init() が早期 return している箇所が確認できます。
GitHub

他に「EventBus の二重実装」「座標系 API の参照統一」「ロード順（DOM とスクリプト順）の不一致」「Layer API の表面化不足（期待されるプロパティが揃っているか）」が見られるため、優先的に統合・整理する必要があります。根拠は core-engine / event-bus / animation-system / coordinate-system の実装です。
GitHub
+3
GitHub
+3
GitHub
+3

以下、詳細 → 優先修正案 → 動作確認手順 をそのまま適用できるように提示します。

1) 問題の技術的根拠（短く）

TimelineUI の init() は最初に DOM 要素を取りに行き、見つからないと return しています。つまりタイムライン用の DOM（例：#timeline-panel / #cuts-container）が存在しないか、Timeline クラス自体がグローバルに公開されていないと初期化がスキップされます。該当箇所：if (!this.timelinePanel || !this.cutsContainer) { console.error('Timeline UI elements not found'); return; }。
GitHub

UI 側（ツールアイコン）は EventBus を emit('ui:toggle-timeline') しています → EventBus 側は window.TegakiEventBus が用意されています。が、Timeline が登録されていないため受け取られません。
GitHub
+1

core-engine 側は AnimationSystem と TimelineUI の存在を見て初期化していますが、TimelineUI のグローバル公開 (window.TegakiTimelineUI) が不足またはスクリプトロード順の問題で未定義の可能性があります（core-engine は if (!window.TegakiTimelineUI) { ... timeline UI disabled } を想定）。
GitHub

さらに core-engine 内に SimpleEventBus 等の類似実装が見られ、EventBus の二重管理になりやすい（設計上の歪み）。
GitHub
+1

2) 優先修正案（リスク低・即効性高） — 必ずこの順でやってください
A. Timeline UI を「グローバルに公開」する（必須）

ui/timeline-ui.js の最後に（IIFE の外へ出すか IIFE の末尾で）必ず以下を追加してください：

// ファイル末尾に追加（または既存の IIFE の末尾に）
window.TegakiTimelineUI = TimelineUI;
console.log('✅ ui/timeline-ui.js loaded (TegakiTimelineUI exported)');


理由：core-engine.initializeAnimationSystem() が new window.TegakiTimelineUI(...) でインスタンス化を試みるため、window.TegakiTimelineUI が定義されている必要があります。現状のファイルで公開代入が見つかりませんでした（未定義の可能性）。
GitHub
+1

B. DOM（タイムライン領域）を index.html に確実に置く（必須）

timeline-ui.js は #timeline-panel と #cuts-container を探しているので、index.html の body に 必ず最小限の DOM を置いてください（スクリプトより先に置く or DOMContentLoaded 前に確実に存在すること）:

<!-- index.html の body 内、他 panel と同じ階層に追加 -->
<div id="timeline-panel" class="timeline-panel" style="display:none; position:fixed; left:10px; bottom:10px; z-index:1500;">
  <div class="timeline-header">
    <button id="close-timeline">×</button>
    <div id="cut-display">CUT1</div>
  </div>
  <div class="timeline-body">
    <div id="cuts-container" class="cuts-container"></div>
  </div>
  <div class="timeline-bottom"></div>
</div>


ポイント：display:none でよい。timeline-ui.js の init() が DOM を探せる位置に必ず置くこと（スクリプト実行より後に DOM を生成する場合は init を遅らせるか、DOMContentLoaded 後に core.initialize() を呼ぶ）。
GitHub

C. スクリプト読み込み順＆初期化（最重要）

index.html の <script> は 下の順序で、かつ DOM 完全構築後に CoreEngine.initialize() を呼ぶ こと：

PixiJS（v8.13 の CDN を 1 度だけ）

system/event-bus.js（window.TegakiEventBus を作る）
GitHub

system/coordinate-system.js（window.CoordinateSystem）
GitHub

system/layer-system.js / system/camera-system.js / system/drawing-clipboard.js

system/animation-system.js（window.TegakiAnimationSystem）
GitHub

ui/timeline-ui.js（ここで window.TegakiTimelineUI を定義） ← 重要

ui/ui-panels.js（アイコンクリックが EventBus を送る側）
GitHub

core-engine.js（CoreEngine）
GitHub

あとで core-runtime.js 等、アプリ起動処理

初期化スニペット（index.html） — DOM 生成済みで確実に呼ぶ：

<script>
document.addEventListener('DOMContentLoaded', () => {
  // PIXI が読み込まれていることを前提
  const app = new PIXI.Application({
    width: window.TEGAKI_CONFIG.canvas.width,
    height: window.TEGAKI_CONFIG.canvas.height,
    backgroundColor: window.TEGAKI_CONFIG.background.color
  });
  document.getElementById('canvas-container').appendChild(app.view);

  // CoreEngine を作成・初期化（animation/timeline は core 内で init 試行）
  const core = new window.TegakiCore.CoreEngine(app);
  core.initialize();
  // 追加：CoordinateSystem に安全参照を渡す（後述）
  if (window.CoordinateSystem) {
    window.CoordinateSystem.setContainers({
      worldContainer: core.cameraSystem?.worldContainer || null,
      canvasContainer: core.cameraSystem?.canvasContainer || null,
      app: app
    });
  }
});
</script>


意図：TimelineUI.init() は DOM 要素を取るので、CoreEngine の初期化が DOM より前に走ると init() が return してしまいます。DOMContentLoaded 後に core.initialize() を呼ぶのが安全です。

D. EventBus の“二重実装”を整理（中〜高優先）

現状、system/event-bus.js で window.TegakiEventBus が定義されていますが、core-engine.js 内でも SimpleEventBus のような同等クラスが存在しています（混乱/断片化の原因）。

方針：system/event-bus.js の window.TegakiEventBus を唯一の公式 EventBus とし、core-engine.js 内の SimpleEventBus 宣言は削除（またはコメントアウト）してください。core-engine.js のすべての this.eventBus = window.TegakiEventBus; 使用箇所はそのままで OK。
GitHub
+1

理由：二重で似た API を持つと「イベントが別のインスタンスに飛んで反応しない」といったバグを誘発します（今回の状況に近い）。

E. CoordinateSystem（座標系）の明示的初期化（推奨）

animation-system / drawingEngine は window.CoordinateSystem を参照しています。CoreEngine.initialize() の中で、CameraSystem の container を CoordinateSystem に渡すコードを必ず追加してください（coordinate-system.js が安全参照を要求しているため）。例：

// core-engine.js の適切な箇所（cameraSystem 初期化後）
if (window.CoordinateSystem) {
  window.CoordinateSystem.setContainers({
    worldContainer: this.cameraSystem.worldContainer,
    canvasContainer: this.cameraSystem.canvasContainer,
    app: this.app
  });
  console.log('CoordinateSystem containers set by CoreEngine');
}


理由：座標 API の安定性を保証するため（createTransformMatrix 等を Core から直接呼べるように）。
GitHub

3) 追加でチェックすべき点（短い箇条書き）

index.html に PixiJS が v8.13 の CDN が 1 回だけ読み込まれているか確認（v7/v8 混在は厳禁）。

ui/timeline-ui.js の最後で window.TegakiTimelineUI が存在するか確認（追加したか）。
GitHub

animation-system が layerSystem.layerTransforms / layerSystem.layersContainer 等のプロパティを使うので、layer-system.js がこれらの API を露出しているか確認。もし API 名が違うなら adapter を実装してやる（例を下に示します）。
GitHub

フォールバック／暗黙修復を入れない（要件通り） — 見つかった不一致は明示的にエラーにして潰す方針で OK。

4) 最短でタイムラインを「見える化」するための最小パッチ（コピペで動作確認できる）

ui/timeline-ui.js の末尾に下を追加（→ Timeline クラスをグローバルに公開）：

// 追記（ファイル末尾）
window.TegakiTimelineUI = TimelineUI;
console.log('✅ TegakiTimelineUI exported');


index.html にタイムライン DOM を追加（body 内）：

<div id="timeline-panel" class="timeline-panel" style="display:none;">
  <div class="timeline-bottom"></div>
  <div id="cuts-container"></div>
  <button id="close-timeline">×</button>
</div>


index.html で Core の初期化を DOMContentLoaded 後に行う（上の「スニペット」をそのまま使う）。

core-engine から SimpleEventBus を削除（またはコメント）して window.TegakiEventBus を唯一参照にする。

これで「アイコン押してイベント送る → EventBus 上で通知 → Timeline が受ける」一連が繋がるはずです。

5) 動作確認コマンド（コンソールで試す：順に）

開発者ツールの Console に以下を貼って実行し、値が true になっているか確認してください。

console.log('TegakiEventBus exists? ', !!window.TegakiEventBus);
console.log('TegakiAnimationSystem exists? ', !!window.TegakiAnimationSystem);
console.log('TegakiTimelineUI exists? ', !!window.TegakiTimelineUI);
console.log('timeline DOM elements: ', document.getElementById('timeline-panel'), document.getElementById('cuts-container'));


期待される結果：

TegakiEventBus → true. 
GitHub

TegakiAnimationSystem → true（animation-system.js を読み込んでいれば）。
GitHub

TegakiTimelineUI → true（上記の export を追加済みなら true）。
GitHub

document.getElementById('timeline-panel') → 要素オブジェクト（null でない）

さらに EventBus の受信テスト（Timeline が存在することが前提）：

// 一時的に listener を増やすテスト
window.TegakiEventBus.on('ui:toggle-timeline', () => console.log('received toggle from test'));
window.TegakiEventBus.emit('ui:toggle-timeline');


もし received toggle from test が出れば EventBus 自体は OK。次に UI のアイコンクリックでタイムラインが表示されるはずです（TimelineUI.show() が呼ばれる）。

6) API 断片化・座標不一致などについて（まとめ）

EventBus: system/event-bus.js を唯一の真の EventBus として統一してください（window.TegakiEventBus）。core-engine 内のローカル SimpleEventBus を残すと二重化します。
GitHub
+1

座標系: window.CoordinateSystem が既に用意されているので、CoreEngine 側で setContainers を呼び安全参照を登録してください。animation/drawing 側は window.CoordinateSystem を参照する想定です（同一 API を使わせること）。
GitHub

Layer API: animation-system.js は layerSystem.layers, layerSystem.layerTransforms, layersContainer 等を期待しています。layer-system にこれらが欠けると断片化バグになります。必要なら アダプタ層 を作って期待インターフェースに合わせてください（例は要望あれば即提供）。
GitHub

バージョン混在: HTML の <script> を点検し、PixiJS は v8.13 の CDN のみを使ってください（混在は重大な不整合を起こします）。