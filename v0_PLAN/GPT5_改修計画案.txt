改修計画書 — PixiJS v8.13 ブラウザお絵かきツール（GIFアニメ/タイムライン改修 + ショートカット/履歴調査）

以下は Claude（改修AI） が直接編集することを前提に、ファイル横断での定義違いを最小化しつつ安全に実装できる順序化された手順と、各ファイルごとの具体的改修指示・チェックリストです。
目的は「最小の変更で既存機能を失わせず、可読性と改修しやすさを高める」ことです。作業は 変更範囲を限定 し、後続AIがミスしないように「何を触るか」「どの関数を期待するか」「入出力（イベント/API）仕様」を明確に示します。

全体方針（絶対遵守）

PixiJS は v8.13 固定。ファイル内に v7/v8 混在記述や互換処理を入れない。もし古い記述があれば その行だけ明確に差し替え。

グローバル変数の乱用禁止。既存の singleton 風オブジェクト（LayerSystem, EventBus, CoordinateSystem 等）を使うか、なければファイル内で明示的に single-export 風オブジェクトを作る。

変更は「最小限の差分」で。UI位置や文言以外は既存の処理フローを壊さない。

コンソールログは最小限。（デバッグ情報は diagnostics.js 経由で出力すること）

フォールバック・暗黙の自動修復は入れない。エラーは明示的に投げる or diagnostics.warn() を使う。

変更の前に必ず該当関数の現在のシグネチャを確認してから差替え。変更点はコメントでマーキング（// CHG: ...）。

優先順位（効率順）

アーキテクチャ整備（短い API 仕様書を作成） — これにより以降の変更で定義違いを防ぐ。

EventBus の検証・統合（発火／受信の命名統一） — タイムライン出現不具合の多くはイベント周り。

タイムライン表示問題の修正（アニメアイコン→タイムライン表示） — UIの基本動作回復。

タイムラインの UI 変更（アイコン差替え・配列変更・配置） — 見た目と配置の定着。

GIF書き出しと+CUT移動（メニュー配置の移動） — UI上の配置変更と機能フック。

CTRL+V 貼付け先変更実装（drawing-clipboard.js / layer-system.js） — レイヤ操作。

ショートカット変更 ALT+Space、キーイベントの衝突チェック — キーバインド整理。

アンドゥ/リドゥ（CTRL+Z / CTRL+Y）確認 & 必要なら実装 — 非破壊の履歴管理を担保。

横断チェック（座標変換API、レイヤAPI断片化、Pixiバージョン記述確認） — 最終レビュー。

各ステップは「実施前チェック → 実装（小さな差分）→ 単体確認 → 次へ」を順守すること。

ファイル別改修項目（詳細・ガイド）

以降「ファイル名：修正ポイント（関数名やイベント）」という形式で列挙します。必ず該当箇所の既存シグネチャを確認してから置き換えること。差し替え時は // CHG コメントを入れてください。

1) system/event-bus.js

役割（期待する API）

// singleton EventBus
EventBus.on(eventName, handler)
EventBus.off(eventName, handler)
EventBus.emit(eventName, payload)


改修内容

既に同様の API があれば命名を上記に統一（小文字 on/off/emit）。

タイムライン表示のトリガー名を明示：'ui:toggle-timeline', 'ui:show-timeline', 'ui:hide-timeline', 'animation:play', 'animation:stop'。

emit は同期で OK（UI即時反応が必要）。ただしエラーは投げるのではなく diagnostics.error()。
チェック

他ファイルで異なるイベント名を使っていないか grep で確認。すべて EventBus に集約する。

2) ui/ui-panels.js / ui/timeline-ui.js

目的

アニメアイコン押下でタイムラインを出す実装修正。

タイムライン UI のアイコン差替え・配置変更。

改修手順（timeline 表示バグ修正）

イベントハンドラ接続

アニメアイコンのクリックハンドラが EventBus.emit('ui:show-timeline') するように統一。

ui-panels.js でアニメアイコンの DOM / PIXI ボタンを生成する箇所を検索（例：buttonAnimation）。そこに button.on('pointertap', () => EventBus.emit('ui:toggle-timeline')) を入れる。

timeline のインジェクトポイント

timeline-ui.js に TimelineUI.show() / TimelineUI.hide() / TimelineUI.toggle() を実装する。内部は単純に container.visible = true/false。

初期化時に EventBus.on('ui:toggle-timeline', TimelineUI.toggle) を登録する。

表示されない場合の典型原因

TimelineUI.container が stage に追加されていない → init() 時 app.stage.addChild(container) を確認。

container.visible = false のまま → toggle() 呼ばれているかログで確認（diagnostics）。

Z-order により背面に回されている → app.stage.addChildAt(container, app.stage.children.length-1)。

UI 変更（ループアイコン）

変更するアイコンはユーザ差替えSVGを渡しているようなので、timeline-ui.js 内で使うアイコン定義を差し替える（SVG → innerHTML か PIXI.Texture.from()で扱う方式に合わせる）。

仕様

アイコン名：repeat-icon（提供 SVG を使用）

ON/OFF 表示：チェックではなく「反転点灯」→ 実装は iconSprite.tint = 0xffffff と iconSprite.tint = 0x800000 の切替（Pixi スプライトの場合）。

位置： ▶️ の左隣りに1マス空けて配置（具体的に x 値を playButton.x - (cellWidth * 2) など）。

ON時は EventBus.emit('animation:loop:set', true)、OFF時は ...false 。

タイムライン内ボタン（サムネ時間）

現状上下配置で重なっている → レイアウトを左右に変更。

ボタンを prevThumbBtn / nextThumbBtn に置き換え、アイコンは ◀ / ▶ （テキストまたは小さなSVG）。

配置はサムネイル領域の左右（left / right）にし、縦重なりを無くす。

DOM/PIXI の配置単位は cellWidth を基準に横配置。

GIF書き出しと +CUT の移動

現在の「ループ」UI の位置（つまりハードコード位置）を探し、その DOM/PIXI ノードを 削除せず移動 する。

GIF書き出しボタンの ID を gif-export-btn と統一し、timeline-ui.js からループの場所へ移動（DOM操作か container の移動）。

+CUT は fpsControl の右隣へ移動。配置変更は UI の初期化順で対応する（順番で決める）。

3) core-runtime.js / core-engine.js

目的

タイムライン起動経路の最終受け口、キーバインド（スペース → ALT+Space変更）、Undo/Redo フック確認。

改修内容

キーイベント管理を一本化：core-runtime.js 側に KeyManager（あるいは既存のキー処理部分）を一本化して onKeyDown を集中させる。

EventBus.emit('input:play-toggle') を飛ばしていた箇所を EventBus 経由で TimelineUI へ伝播させる（ただし新しいショートカットは ALT+Space にする）。

実装例（擬似）：

window.addEventListener('keydown', (e) => {
  if (e.altKey && e.code === 'Space') {
     e.preventDefault();
     EventBus.emit('ui:toggle-timeline-play');
  }
  if (e.ctrlKey && e.code === 'KeyZ') EventBus.emit('history:undo');
  if (e.ctrlKey && e.code === 'KeyY') EventBus.emit('history:redo');
});


注意：Space 単体が他で使われている可能性あり（ツール内／ブラウザ）。e.preventDefault() を使う場合は影響範囲を事前に確認。

4) system/drawing-clipboard.js

目的

CTRL+V の挙動を「新規レイヤーへ貼付け」→「コピー先のアクティブレイヤーに貼付け（元画像を消す）」に変更。

改修手順

API 仕様（期待）

DrawingClipboard.get() → コピーした ImageData / Texture オブジェクトを返す。

DrawingClipboard.pasteTo(layerId) → 指定レイヤーに貼り付け（既存画像を上書き）。

変更点

既存 pasteAsNewLayer() があれば残しつつ、pasteToActiveLayer() を実装。CTRL+V のキーハンドラをこの新関数に接続する。

動作は 破壊的上書き：対象レイヤーの内容を完全に消去（LayerSystem.clear(layerId)）してから LayerSystem.drawTexture(layerId, clipboardTexture)。

安全対策

履歴（undo）に載せること：貼付け前のレイヤー状態を History.push({type:'replace-layer', layerId, previousBitmap}) のように保存。

5) system/layer-system.js

目的

Layer 操作（移動・回転・反転）を一元化し、アニメーションでの利用を容易にする。

改修指示

明確な API を用意（名前と挙動を固定）：

LayerSystem.createLayer({name, width, height})

LayerSystem.deleteLayer(id)

LayerSystem.setActiveLayer(id)

LayerSystem.clearLayer(id)

LayerSystem.drawTexture(layerId, texture, opts)

LayerSystem.applyTransform(layerId, {x,y,rotation,scaleX,scaleY})

座標系：LayerSystem は内部で**ワールド座標系（canvas 原点左上）**を採用し、CoordinateSystem による変換は CoordinateSystem.toWorld() / fromWorld() のみを使う。ファイル間で座標基準が曖昧な箇所があれば // TODO: convert coords via CoordinateSystem コメントを残す。

履歴連携：レイヤー破壊的操作（clear, delete, replace）では必ず EventBus.emit('history:record', { ... }) を呼ぶ。

6) system/diagnostics.js

目的

変更時のログ出力はここ経由で。diagnostics.warn/info/error() を使って問題箇所を明示する。
改修

もし未実装なら diagnostics.enabled フラグを追加して開発時のみ出力する。

7) system/animation-system.js / system/gif-exporter.js

目的

GIF 書き出しトリガーの移動・FPS制御の近接配置、ループフラグの使用場所を明確にする。

改修指示

animation-system は play(), stop(), setLoop(bool), setFPS(n), renderFrame() をエクスポートする。gif-exporter は exportGIF({from, to, fps, loop}) を提供。

UI からは EventBus.emit('animation:export-gif', {range, fps, loop}) を投げる。gif-exporter はこのイベントを on して処理する。

+CUT は EventBus.emit('timeline:add-cut', {time}) のようなイベントを投げ、animation-system が frames を管理。

8) 履歴（Undo/Redo） — 未実装 or 評価必要

確認項目

まず grep で undo / redo / history を検索。実装が既にあれば、非破壊（＝元状態が残る）かを確認する（履歴スタックに以前の bitmap/texture を入れているか）。
実装（必要なら）

軽量で確実な Command パターンを推奨。最小実装：

History.push(command) — command は {undo: fn, redo: fn, meta}

History.undo() → pop latest and call undo()

History.redo() → call redo()

画像データコピーはメモリ高騰の元なので、差分 が無理な場合は ImageBitmap や Canvas を toBlob() で保存しておく（ただしローカル開発で一時的）。

CTRL+Z / CTRL+Y は EventBus.emit('history:undo') / 'history:redo' に変換し、History が処理する。

テストケース（各ステップ後に必ず実施）

タイムライン表示

アニメアイコンをクリック → EventBus に 'ui:toggle-timeline' が emit され、TimelineUI.container.visible が true になる。

もし visible が変わらない場合、diagnostics.warn に呼び出し履歴を出す。

ループアイコン

クリックで animation:loop:set が true/false で発火。animation-system がループフラグを反映する。視覚は iconSprite.tint で変える。

GIF書き出し移動

タイムラインで GIF export ボタンを押すと animation:export-gif が発火し、gif-exporter が受信して動作する。

サムネボタン重なり

左右矢印でサムネを移動できること（Tab順やキーボード操作も確認）。

CTRL+V 貼り付け

CTRL+C でコピー、CTRL+V でアクティブレイヤーが置換される。History にエントリが残る。

Alt+Space 動作

Alt+Space でタイムライン再生/停止がトグル。ブラウザとの衝突がないことを確認。

Undo/Redo

CTRL+Z 後、変化が元に戻る。CTRL+Y でやり直せる。画像置換も元に戻る。

横断チェックリスト（必ず実行）

 Pixi の読み込みタグが v8.13 の CDN になっている（HTML を確認）。

 ファイル中に v7 や PIXI.v7 の文言がないか検索。あれば報告して差し替えのみ行う。

 座標 API の一貫性：CoordinateSystem の toWorld() / fromWorld() が exist するか。無ければ短く実装して各所からそれを使わせる。

 EventBus が複数実装されていないか（重複定義）。重複があれば一つに統合し、古い定義は // DEPR: replaced by EventBus を付けて残す。

 LayerSystem 関数群が断片化していないか。applyTransform 等はここに集中。

 設定参照が複数個所で行われていないか（例：config.loop を core-engine.js と timeline-ui.js 両方で参照している）→ 参照は読み取り専用にし EventBus 経由で変更を配信。

 二重実装（同じ機能が複数ファイルで別々の名前で実装）を発見したら、どちらを残すか明記してから一方を削除。

変更時のドキュメント（必須）

変更差分ごとに短い「変更理由コメント」をコミットメッセージに入れる（例：CHG: make CTRL+V paste to active layer; push history entry）。

各ファイル冒頭に「変更履歴ブロック」を残し、手を入れた関数に // CHG by Claude: yyyy-mm-dd を入れる。

最低限の API 定義ファイル（docs/API.md）を作成し、EventBus / LayerSystem / CoordinateSystem / History / AnimationSystem のシグネチャを記載する（短くても良い）。

実装メモ（コード例：Undo/Redo の核）

必ず既存の形を確認してから統合。もし既に History があればそれを使う。

// system/history.js (新規 or 既存を統合)
const History = (() => {
  const undoStack = [];
  const redoStack = [];
  return {
    push(cmd) { undoStack.push(cmd); redoStack.length = 0; EventBus.emit('history:changed'); },
    undo() {
      const cmd = undoStack.pop(); if (!cmd) return;
      cmd.undo(); redoStack.push(cmd); EventBus.emit('history:changed');
    },
    redo() {
      const cmd = redoStack.pop(); if (!cmd) return;
      cmd.redo(); undoStack.push(cmd); EventBus.emit('history:changed');
    }
  };
})();


使用例（レイヤー置換）：

// copyBefore is ImageBitmap or dataURL or canvas
History.push({
  undo() { LayerSystem.drawBitmap(layerId, copyBefore); },
  redo() { LayerSystem.drawBitmap(layerId, newBitmap); },
});

最後に：納品／検査ポイント（AIへ）

各変更は小さいコミット単位で行う（1つのコミット = 1つの目的）。

変更箇所を必ず // CHG でマーキング。

実装後、上記テストケース全件を手で実行して報告する（成功/失敗とログスニペット）。

もし既存の API と衝突が見つかったら勝手に破壊せず、それを issue にして一覧化してから段階的に修正を行う。

「改修AI がミスしないように」の観点から、イベント名とAPI シグネチャは変更せずに統一して使うこと（一覧化を忘れない）。