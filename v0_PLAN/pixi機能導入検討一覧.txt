1) RenderTexture / offscreen render targets | 評点: 5
要約:
  レイヤー毎・プレビューやエクスポート前の合成などに RenderTexture を用い、GPU上でレイヤ合成・キャッシュを行う。
影響:
  - ラスタ化処理を高速化（CPU→GPU負荷分散）
  - サムネイルやフレーム合成でのメモリコピーを減らせる
実装見積:
  小〜中（2〜3日）：既存 layer-system の draw→ctx.putImageData を RenderTexture 描画に差し替える作業が中心
リスク:
  - WebGL 状態管理ミスで破棄漏れやメモリリークが発生しやすい
  - Canvas2D 依存場所（サムネイル等）との整合を取る必要あり

2) Graphics Path / vector primitives（Graphics APIのベクタ最適化） | 評点: 5
要約:
  Stroke を直接 PIXI.Graphics / Geometry パスとして保持・描画し、毎フレームGPUで描画する方式。
影響:
  - ベクタ主体のツールなら精度・拡張性が高く、高解像度での再レンダリングコストが極端に下がる
  - アニメ／変形（transform）の表現が容易
実装見積:
  中（3〜6日）：stroke-recorder と stroke-renderer を PIXI.Graphics ベースに書き換え。既存ストロークフォーマットの正規化が必要
リスク:
  - 大量のパスは GPUバッチ効率を低下させる可能性（→バッチング戦略が必要）
  - 一部のフィル／ブラシ表現はラスタ化が必要

3) Render Layers / DisplayGroup（レンダリンググループ管理） | 評点: 4
要約:
  レンダリング順・ブレンド・マスク等を明示的な Render Layer 単位で管理し、レンダリングパイプラインを制御。
影響:
  - レイヤー合成・エフェクト適用・部分的再描画制御が容易に
  - export 時のレイヤ選択やレイヤ単位のキャッシュ制御と親和性が高い
実装見積:
  小（1〜2日）：layer-system に RenderLayer 抽象を追加し、core の描画ループに組み込む
リスク:
  - API 設計ミスが既存レイヤ操作と食い違うと大規模修正に

4) Texture GC / automatic texture destroy & pooling | 評点: 4
要約:
  PIXI テクスチャの自動破棄（ガーベジコレクトの補助）と再利用プールを利用してメモリを抑制。
影響:
  - 長時間の作業・大量フレーム生成時のメモリ増大を抑え安定性向上
実装見積:
  小（1日）：export / frame 作成箇所で Texture.from/Texture.destroy のポリシー整備
リスク:
  - 間違ったタイミングで destroy すると表示崩壊。参照カウント管理が必要

5) Culling API（表示領域カリング） | 評点: 3
要約:
  大量オブジェクト（補助線、ガイド、過去フレームサムネイル等）を画面外で自動無描画にするAPI。
影響:
  - レイヤ管理やタイムラインでオブジェクト数が増えた際のフレームレート確保に有効
実装見積:
  小（1〜2日）：描画ループに culling チェックを導入、必要オブジェクトに bounding box を付与
リスク:
  - 境界計算コストが新たな負荷になる場合あり（だが通常は有益）

6) ParticleContainer / sprite-batch（大量点描的オブジェクト最適化） | 評点: 2
要約:
  多数の同種スプライト（同一テクスチャ）を高速バッチで描画する軽量コンテナ。
影響:
  - エフェクトや点描的な装飾を大量に描く時に有効。ストローク表現には直接適合しないが、筆跡を破片化して表現する場合は有利
実装見積:
  小（1日）: 特殊ケースのみ導入
リスク:
  - API制約（transform以外のプロパティ制約）で表現限界がある

7) Improved Text caching & shared TextStyle | 評点: 3
要約:
  TextStyle を共有してテキストテクスチャを再利用することで、UIテキスト描画の負荷を下げる。
影響:
  - タイムライン/ラベル等のUIに効果。高頻度更新UIのパフォーマンス改善
実装見積:
  小（0.5〜1日）：テキスト生成箇所の TextStyle の一元化
リスク:
  - 低。互換性問題は小さい

8) Mask/Scissor improvements（マスク最適化） | 評点: 3
要約:
  高速マスクや scissor 操作の改善で、部分描画・サムネイル更新を効率化。
影響:
  - サムネイル更新や部分更新での無駄描画を削減。Undo時の再描画負荷低下
実装見積:
  小（1〜2日）：サムネイル更新ロジックの rewrite
リスク:
  - WebGL state を直接扱う部分でバグが入りやすい

9) Pointer Events / Interaction improvements（ペン・圧力/傾き対応の強化） | 評点: 4
要約:
  Pointer API と統合された改善で、Stylus（pressure/tilt）等のイベント処理が安定化。
影響:
  - ベクタペン主体のツールでは圧力データ取得・高精度入力が直ちに恩恵を受ける
実装見積:
  中（1〜2日）: pressure-handling 部分の PIXI interaction 経由への移行
リスク:
  - 既存の custom pointer ラッパーと衝突する場合がある。テスト必須

10) Renderer multi-sample / antialias improvements | 評点: 2
要約:
  レンダラのアンチエイリアスやマルチサンプリング設定の改善で線の見栄えが向上。
影響:
  - ストロークの見た目改善（特に太線や斜め線）
実装見積:
  小（0.5日）: Renderer 初期化オプションの調整
リスク:
  - 一部環境でパフォーマンス低下する可能性。オプション化推奨

総評（導入優先度・短縮版）：
- 最優先（強く推奨）：RenderTexture（1）, Graphics Path（2）, Pointer Events 強化（9）
- 優先（導入メリット大）：Render Layers（3）, Texture GC（4）
- 中位（ユースケース依存）：Culling（5）, Text caching（7）, Mask 最適化（8）
- 低優先（特殊用途）：ParticleContainer（6）, MSAA/antialias 設定（10）

補足:
- v8.14 が「安定性改善リリース」であるため、もし早めに v8.14 を取り込めるなら「破棄/再計算」系のバグに起因する不具合は減る可能性が高い。だが新機能は少ないので、上の機能導入は v8.13 ベースで進めても問題ない。
- 実装順は「RenderTexture → Graphics Path → Pointer Events/Pressure」を基本線に。これらを組み合わせると「ベクタ描画をGPU上で効率的に扱い、エクスポートや長時間作業の安定性を確保」できる。
