================================================================================
  Undo/Redo堅牢化・データ所有権明確化 段階的改修計画書
================================================================================

【現状分析】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
■ 確認された問題
1. CTRL+Lで新規レイヤーが作成されない
2. ボタンで新規レイヤー作成するとHistoryに2カウントされる
3. 新規レイヤー作成後CTRL+Z二回で消える
4. 新規レイヤー作成後にペン描画すると最初の一回は履歴が戻るだけ
5. Shift+Nで新規CUT作成できるがCTRL+Zで消えない（連打で時々消える）

■ 根本原因
- 複数箇所から直接History.saveState()を呼んでいる（多重登録）
- Commandパターンが部分的にしか導入されていない
- 操作の境界（トランザクション）が不明確
- index.htmlでUndo/Redo処理が削除されているが、他の箇所が残存
- StateManagerが存在するがデータの唯一の所有者になっていない

■ 設計方針
- GPT5案.txtのB案「History中心への再設計（軽量版）」を採用
- 全操作をCommand経由に統一
- StateManagerを「唯一のデータストア」として強化
- Historyが全Commandを一元管理
- 各サブシステム（layer-system.js等）は表示とロジックに専念


================================================================================
  Phase 1: History統一化とCommand基盤整備
================================================================================

【目的】
全ての操作をCommand経由にし、Historyへの直接pushを排除する

【対象ファイル】
- system/history.js（新規作成 or 大幅改修）
- system/command-base.js（確認・補強）
- system/layer-commands.js（確認・補強）

【実装内容】

┌─────────────────────────────────────────────────────────┐
│ STEP 1-1: history.js の作成/改修                          │
└─────────────────────────────────────────────────────────┘

◆ 責務
- 全Commandの実行・記録を一元管理
- Undo/Redoスタックの管理
- 状態復元時のフラグ管理（二重記録防止）

◆ 主要メソッド
```
class History {
  constructor(stateManager, eventBus)
  
  // Command実行と記録
  executeCommand(command)           // Commandを実行してスタックに追加
  
  // Undo/Redo
  undo()                            // 一つ前に戻す
  redo()                            // 一つ先に進む
  
  // 状態管理
  saveState()                       // 現在状態をスナップショット保存
  restoreState(state)               // 状態を復元
  
  // フラグ
  isExecutingUndoRedo               // Undo/Redo実行中フラグ
  isRecordingState                  // 状態記録中フラグ
  
  // イベント監視
  setupEventListeners()             // 操作イベントを監視して自動記録
}
```

◆ イベント自動監視
以下のイベントを監視してsaveState()を自動実行:
- 'layer:created'              → レイヤー作成完了時
- 'layer:deleted'              → レイヤー削除完了時
- 'drawing:completed'          → 描画完了時
- 'animation:cut-created'      → CUT作成完了時
- 'animation:cut-deleted'      → CUT削除完了時

◆ 二重記録防止メカニズム
```javascript
executeCommand(command) {
  if (this.isExecutingUndoRedo) return; // Undo/Redo中はスキップ
  
  this.isRecordingState = true;
  command.execute();
  this.undoStack.push(command);
  this.redoStack = [];
  this.isRecordingState = false;
  
  this.eventBus.emit('history:changed', {...});
}

undo() {
  this.isExecutingUndoRedo = true;
  // 復元処理
  this.isExecutingUndoRedo = false;
}
```

◆ ファイル構造例
```javascript
(function() {
  'use strict';
  
  class History {
    constructor(stateManager, eventBus) {
      this.stateManager = stateManager;
      this.eventBus = eventBus;
      
      this.undoStack = [];
      this.redoStack = [];
      this.MAX_HISTORY = 50;
      
      this.isExecutingUndoRedo = false;
      this.isRecordingState = false;
      
      this.setupEventListeners();
    }
    
    setupEventListeners() {
      // レイヤー作成完了 → 自動記録
      this.eventBus.on('layer:created', (data) => {
        if (!this.isExecutingUndoRedo && !this.isRecordingState) {
          this.saveState();
        }
      });
      
      // 描画完了 → 自動記録
      this.eventBus.on('drawing:completed', (data) => {
        if (!this.isExecutingUndoRedo && !this.isRecordingState) {
          this.saveState();
        }
      });
      
      // CUT作成 → 自動記録
      this.eventBus.on('animation:cut-created', (data) => {
        if (!this.isExecutingUndoRedo && !this.isRecordingState) {
          this.saveState();
        }
      });
      
      // 以下、他のイベントも同様...
    }
    
    saveState() {
      if (this.isExecutingUndoRedo || this.isRecordingState) return;
      
      this.isRecordingState = true;
      
      const currentState = this.stateManager.getState();
      this.undoStack.push(currentState);
      
      if (this.undoStack.length > this.MAX_HISTORY) {
        this.undoStack.shift();
      }
      
      this.redoStack = [];
      this.isRecordingState = false;
      
      this.eventBus.emit('history:changed', {
        undoCount: this.undoStack.length,
        redoCount: this.redoStack.length
      });
    }
    
    undo() {
      if (this.undoStack.length === 0) return;
      
      this.isExecutingUndoRedo = true;
      
      const currentState = this.stateManager.getState();
      this.redoStack.push(currentState);
      
      const previousState = this.undoStack.pop();
      this.stateManager.setState(previousState, 'history:undo');
      
      this.isExecutingUndoRedo = false;
      
      this.eventBus.emit('history:changed', {
        undoCount: this.undoStack.length,
        redoCount: this.redoStack.length
      });
    }
    
    redo() {
      // 同様の実装...
    }
  }
  
  window.History = new History(
    window.TegakiStateManager, 
    window.TegakiEventBus
  );
})();
```


┌─────────────────────────────────────────────────────────┐
│ STEP 1-2: 各ファイルからの直接History.saveState()削除     │
└─────────────────────────────────────────────────────────┘

◆ 修正対象箇所（検索キーワード: History.saveState）

【layer-system.js】
- createLayer() → History.saveState()削除（'layer:created'イベントで自動記録）
- deleteLayer() → History.saveState()削除（'layer:deleted'イベントで自動記録）

【animation-system.js】
- createNewBlankCut() → History.saveState()削除（既に削除済み）

【core-engine.js】
- stopDrawing() → History.saveState()保持（'drawing:completed'前に必要）
- layer:clear-active → History.saveState()保持（イベント発火前に必要）

◆ 修正パターン例
```javascript
// ❌ 修正前
createLayer(name, isBackground) {
  window.History.saveState(); // 削除
  
  // レイヤー作成処理...
  
  this.eventBus.emit('layer:created', { layerId, name });
}

// ✅ 修正後
createLayer(name, isBackground) {
  // History記録削除（'layer:created'イベントでhistory.jsが自動記録）
  
  // レイヤー作成処理...
  
  this.eventBus.emit('layer:created', { layerId, name });
}
```


┌─────────────────────────────────────────────────────────┐
│ STEP 1-3: index.htmlのUndo/Redoキー処理復活              │
└─────────────────────────────────────────────────────────┘

◆ 現状問題
index.htmlでUndo/Redoキーハンドリングが削除されている
→ CTRL+Zが効かない原因

◆ 修正内容
```javascript
// index.html内 setupUnifiedKeyboardShortcuts()関数

// ✅ 追加: Ctrl+Z (Undo)
if ((e.ctrlKey || e.metaKey) && e.code === 'KeyZ' && !e.shiftKey) {
  if (window.History && typeof window.History.undo === 'function') {
    window.History.undo();
  }
  e.preventDefault();
  return;
}

// ✅ 追加: Ctrl+Y / Ctrl+Shift+Z (Redo)
if ((e.ctrlKey || e.metaKey) && (e.code === 'KeyY' || 
    (e.code === 'KeyZ' && e.shiftKey))) {
  if (window.History && typeof window.History.redo === 'function') {
    window.History.redo();
  }
  e.preventDefault();
  return;
}
```


【Phase 1 完了条件】
✓ history.jsが作成され、全イベントを監視している
✓ layer-system.js等から直接History.saveState()が削除されている
✓ index.htmlでCTRL+Z/Yが動作する
✓ History情報がUI（history-info）に表示される
✓ レイヤー作成時にHistoryが1カウントだけ増える


================================================================================
  Phase 2: StateManagerの強化とデータ所有権明確化
================================================================================

【目的】
StateManagerを「唯一のデータストア」として確立し、
各サブシステムは状態を保持しない

【対象ファイル】
- system/state-manager.js（強化）
- system/layer-system.js（リファクタリング）
- system/animation-system.js（リファクタリング）

【実装内容】

┌─────────────────────────────────────────────────────────┐
│ STEP 2-1: StateManagerの状態構造定義                      │
└─────────────────────────────────────────────────────────┘

◆ 完全な状態構造
```javascript
state = {
  cuts: [
    {
      id: 'cut_xxx',
      name: 'CUT1',
      duration: 0.5,
      layers: [
        {
          id: 'layer_xxx',
          name: 'レイヤー1',
          visible: true,
          opacity: 1.0,
          isBackground: false,
          transform: {
            x: 0, y: 0,
            rotation: 0,
            scaleX: 1, scaleY: 1
          },
          paths: [
            {
              id: 'path_xxx',
              points: [{x, y}, ...],
              color: 0x800000,
              size: 16,
              opacity: 1.0,
              tool: 'pen'
            }
          ]
        }
      ]
    }
  ],
  currentCutIndex: 0,
  currentLayerIndex: 1,
  settings: {
    loop: true,
    animationFPS: 24
  }
}
```

◆ 追加メソッド
```javascript
class StateManager {
  // レイヤー操作
  addLayer(cutIndex, layerData)
  removeLayer(cutIndex, layerIndex)
  updateLayer(cutIndex, layerIndex, updates)
  reorderLayers(cutIndex, fromIndex, toIndex)
  
  // CUT操作
  addCut(cutData, insertIndex = -1)
  removeCut(cutIndex)
  updateCut(cutIndex, updates)
  reorderCuts(fromIndex, toIndex)
  
  // Path操作
  addPath(cutIndex, layerIndex, pathData)
  removePath(cutIndex, layerIndex, pathId)
  
  // アクティブ状態
  setActiveLayer(cutIndex, layerIndex)
  setActiveCut(cutIndex)
}
```


┌─────────────────────────────────────────────────────────┐
│ STEP 2-2: LayerSystemのリファクタリング                   │
└─────────────────────────────────────────────────────────┘

◆ 変更方針
- layerDataを直接持たない（StateManagerから取得）
- レイヤー作成/削除時にStateManagerを経由
- currentCutContainerはPixiJSの描画用のみ（データは持たない）

◆ 主要メソッド変更
```javascript
// ❌ 修正前
createLayer(name, isBackground) {
  const layer = new PIXI.Container();
  layer.layerData = { ... }; // ❌ 直接データ保持
  
  this.currentCutContainer.addChild(layer);
  this.eventBus.emit('layer:created', { ... });
}

// ✅ 修正後
createLayer(name, isBackground) {
  // StateManagerに追加
  const layerData = {
    id: `layer_${Date.now()}`,
    name: name,
    visible: true,
    opacity: 1.0,
    isBackground: isBackground,
    paths: []
  };
  
  this.stateManager.addLayer(
    this.stateManager.getCurrentCutIndex(),
    layerData
  );
  
  // Pixi描画用に同期
  this._syncPixiLayerFromState(layerData);
  
  this.eventBus.emit('layer:created', { layerId: layerData.id });
}

_syncPixiLayerFromState(layerData) {
  // StateManagerのデータからPixi.Containerを再構築
  const layer = new PIXI.Container();
  layer.label = layerData.id;
  
  // pathsを再描画
  layerData.paths.forEach(pathData => {
    const graphics = this._rebuildPathGraphics(pathData);
    layer.addChild(graphics);
  });
  
  this.currentCutContainer.addChild(layer);
}
```


┌─────────────────────────────────────────────────────────┐
│ STEP 2-3: AnimationSystemのリファクタリング               │
└─────────────────────────────────────────────────────────┘

◆ 変更方針
- Cut情報をStateManagerに一元化
- AnimationSystemはPlayback状態とタイミング管理に専念

◆ 主要メソッド変更
```javascript
// ❌ 修正前
class AnimationSystem {
  constructor() {
    this.animationData = { cuts: [...] }; // ❌ 独自データ保持
  }
}

// ✅ 修正後
class AnimationSystem {
  constructor(stateManager) {
    this.stateManager = stateManager;
    this.playback = {
      isPlaying: false,
      startTime: 0
    };
  }
  
  getCurrentCut() {
    return this.stateManager.getCurrentCut();
  }
  
  createNewBlankCut() {
    const cutData = {
      id: `cut_${Date.now()}`,
      name: `CUT${this.stateManager.state.cuts.length + 1}`,
      duration: 0.5,
      layers: [...]
    };
    
    this.stateManager.addCut(cutData);
    this.eventBus.emit('animation:cut-created', { cutId: cutData.id });
  }
}
```


【Phase 2 完了条件】
✓ StateManagerがレイヤー/CUT/Pathの追加/削除メソッドを持つ
✓ LayerSystemはStateManagerからデータを取得する
✓ AnimationSystemはStateManagerからデータを取得する
✓ Pixi.ContainerにはlayerDataを持たない（labelのみ）
✓ 状態変更は必ずStateManager経由


================================================================================
  Phase 3: Commandパターンの完全導入
================================================================================

【目的】
全ての操作をCommandクラスに統一し、
History.executeCommand()経由で実行

【対象ファイル】
- system/command-base.js（確認）
- system/layer-commands.js（拡張）
- system/animation-commands.js（新規作成）

【実装内容】

┌─────────────────────────────────────────────────────────┐
│ STEP 3-1: Commandクラス体系                              │
└─────────────────────────────────────────────────────────┘

◆ CommandBase
```javascript
class CommandBase {
  constructor(stateManager, eventBus) {
    this.stateManager = stateManager;
    this.eventBus = eventBus;
  }
  
  execute() { throw new Error('Must implement execute()'); }
  undo() { throw new Error('Must implement undo()'); }
  redo() { this.execute(); }
}
```

◆ Layer Commands
```javascript
class CreateLayerCommand extends CommandBase {
  constructor(stateManager, eventBus, cutIndex, layerData) {
    super(stateManager, eventBus);
    this.cutIndex = cutIndex;
    this.layerData = layerData;
    this.createdLayerId = null;
  }
  
  execute() {
    this.createdLayerId = this.stateManager.addLayer(
      this.cutIndex, 
      this.layerData
    );
    this.eventBus.emit('layer:created', { layerId: this.createdLayerId });
  }
  
  undo() {
    const layerIndex = this.stateManager.findLayerIndexById(
      this.cutIndex, 
      this.createdLayerId
    );
    this.stateManager.removeLayer(this.cutIndex, layerIndex);
    this.eventBus.emit('layer:deleted', { layerId: this.createdLayerId });
  }
}

class DeleteLayerCommand extends CommandBase { ... }
class ReorderLayersCommand extends CommandBase { ... }
```

◆ Animation Commands
```javascript
class CreateCutCommand extends CommandBase {
  constructor(stateManager, eventBus, cutData) {
    super(stateManager, eventBus);
    this.cutData = cutData;
    this.createdCutId = null;
  }
  
  execute() {
    this.createdCutId = this.stateManager.addCut(this.cutData);
    this.eventBus.emit('animation:cut-created', { cutId: this.createdCutId });
  }
  
  undo() {
    const cutIndex = this.stateManager.findCutIndexById(this.createdCutId);
    this.stateManager.removeCut(cutIndex);
    this.eventBus.emit('animation:cut-deleted', { cutId: this.createdCutId });
  }
}

class DeleteCutCommand extends CommandBase { ... }
```


┌─────────────────────────────────────────────────────────┐
│ STEP 3-2: 操作箇所の書き換え                             │
└─────────────────────────────────────────────────────────┘

◆ LayerSystem
```javascript
// ❌ 修正前
createLayer(name, isBackground) {
  const layerData = { ... };
  this.stateManager.addLayer(...);
  this.eventBus.emit('layer:created', ...);
}

// ✅ 修正後
createLayer(name, isBackground) {
  const layerData = { ... };
  const command = new CreateLayerCommand(
    this.stateManager,
    this.eventBus,
    this.stateManager.getCurrentCutIndex(),
    layerData
  );
  window.History.executeCommand(command);
}
```

◆ AnimationSystem
```javascript
// ✅ 修正後
createNewBlankCut() {
  const cutData = { ... };
  const command = new CreateCutCommand(
    this.stateManager,
    this.eventBus,
    cutData
  );
  window.History.executeCommand(command);
}
```


【Phase 3 完了条件】
✓ 全てのレイヤー操作がCommandクラス経由
✓ 全てのCUT操作がCommandクラス経由
✓ History.executeCommand()で実行される
✓ Undo/Redoが完全に動作する


================================================================================
  Phase 4: 統合テストと最終調整
================================================================================

【目的】
全ての操作でUndo/Redoが正しく動作することを確認

【テスト項目】

1. レイヤー作成
   - Ctrl+L → レイヤー作成 → Historyに1カウント
   - Ctrl+Z → レイヤー削除
   - Ctrl+Y → レイヤー復元

2. ボタンでレイヤー作成
   - ボタンクリック → レイヤー作成 → Historyに1カウント
   - Ctrl+Z → レイヤー削除

3. 新規レイヤーにペン描画
   - レイヤー作成 → ペン描画 → Historyに2カウント（作成+描画）
   - Ctrl+Z → 描画消去
   - Ctrl+Z → レイヤー削除

4. CUT作成
   - Shift+N → CUT作成 → Historyに1カウント
   - Ctrl+Z → CUT削除
   - Ctrl+Y → CUT復元

5. 連続操作
   - レイヤー作成 → ペン描画 → レイヤー作成 → ペン描画
   - Ctrl+Z連打 → 全て正しく戻る

【調整項目】
- Historyのmax count確認
- サムネイル更新タイミング
- UIの反映タイミング


================================================================================
  改修時の注意事項
================================================================================

1. 段階的実装
   - Phase 1完了後に動作確認してからPhase 2へ
   - 各STEPごとに動作確認

2. イベント発火タイミング
   - 操作完了後にイベント発火
   - Undo/Redo中はisExecutingUndoRedoフラグで制御

3. StateManager更新
   - setState()を使ってImmutableに更新
   - リスナーに通知

4. Pixi同期
   - StateManager更新後にPixi.Containerを同期
   - サムネイル更新は遅延実行

5. デバッグ
   - console.logは最小限
   - エラー発生時のみログ出力


================================================================================
  ファイル依存関係図
================================================================================

index.html
  ├── config.js
  ├── coordinate-system.js
  ├── system/event-bus.js
  ├── system/state-manager.js ★改修
  │     └── 唯一のデータストア
  ├── system/history.js ★新規作成/大幅改修
  │     ├── StateManager参照
  │     ├── EventBus監視
  │     └── Undo/Redoスタック管理
  ├── system/command-base.js
  │     └── 全Commandの基底クラス
  ├── system/layer-commands.js ★拡張
  │     ├── CreateLayerCommand
  │     ├── DeleteLayerCommand
  │     └── ReorderLayersCommand
  ├── system/animation-commands.js ★新規作成
  │     ├── CreateCutCommand
  │     └── DeleteCutCommand
  ├── system/layer-system.js ★改修
  │     ├── StateManagerから読み取り専用
  │     ├── Command経由で操作
  │     └── Pixi描画のみ担当
  ├── system/animation-system.js ★改修
  │     ├── StateManagerから読み取り専用
  │     ├── Command経由で操作
  │     └── Playback管理のみ担当
  ├── core-engine.js
  │     └── 各システム統合
  └── core-runtime.js


================================================================================
  改修効果
================================================================================

✅ 全ての操作が正確に1回だけHistoryに記録される
✅ Undo/Redoが確実に動作する
✅ データの所有権が明確（StateManagerが唯一の所有者）
✅ 各サブシステムの責務が明確
✅ 将来の拡張が容易（新しいCommandを追加するだけ）
✅ AIによる改修が容易（アーキテクチャが明確）

【終】