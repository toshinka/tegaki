🧩 全体方針

PixiJS v8 は WebGL2ベースの高速描画ができるので、
app.renderer.extract.canvas() などでキャンバス画像を取得し、
フレームごとにキャプチャ → まとめて書き出す方式が最も一般的です。

🟢 1. APNG出力

PixiJS v8 + apng-js または UPNG.js

🧠 Pixi側でアニメーションループ中に extract.canvas() → toDataURL('image/png')

📦 UPNG.js

軽量で、複数PNGフレームをまとめて APNG に再構成できます。

互換性：Pixi v8でも問題なし（WebGL→Canvas変換の仕様が変わらないため）

✅ おすすめ構成

const pngFrames = frames.map(canvas => {
  const dataURL = canvas.toDataURL("image/png");
  return UPNG.decode(dataURL);
});
const apng = UPNG.encode(pngFrames, width, height, 0);

🟡 2. WEBPアニメ出力

PixiJS v8 + webm-writer または webp-encoder

WEBP動画はブラウザのネイティブAPIで直接作るのは難しく、
JSライブラリでエンコードするのが現実的です。

💡 webp-encoder（@louisremi/webp-encoder）や
webm-writer（失敗時fallback）を利用可。

Pixiで生成した canvas → ImageBitmap → ライブラリ入力。

✅ おすすめ構成

const encoder = new WebPEncoder({quality: 0.9, frameRate: 12});
for (const frame of frames) encoder.addFrame(frame);
const blob = encoder.encode();

🔵 3. MP4出力

PixiJS v8 + MediaRecorder API

🧩 Pixiが動作中の app.view（canvas要素）を MediaRecorder に渡す。

ブラウザ標準で録画 → .webm or .mp4 出力。

Chrome系なら video/webm;codecs=vp9 安定。MP4は一部環境で限定的。

✅ おすすめ構成

const stream = app.view.captureStream(30); // 30fps
const recorder = new MediaRecorder(stream, {mimeType: 'video/webm'});


※後処理で ffmpeg.js を使えば .mp4 に変換可能（Pixiとの相性も良い）。

🔴 4. PDF出力

PixiJS v8 + jsPDF または pdf-lib

PixiはPDF出力機能を持たないが、Canvas → 画像変換 → PDF埋め込みが可能。

app.renderer.extract.canvas() → toDataURL('image/png') → jsPDF.addImage()

高解像度レンダリングを行えば綺麗に出力可能。

✅ おすすめ構成

const pdf = new jsPDF();
pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, w, h);
pdf.save('output.pdf');

🧠 まとめ（Pixi v8と相性の良い出力系ライブラリ）
出力形式	推奨ライブラリ	Pixi v8互換性	備考
APNG	UPNG.js	◎	軽量・シンプル
WEBP	webp-encoder / webm-writer	◎	圧縮率高・ブラウザ依存注意
MP4	MediaRecorder / ffmpeg.js	◎	実装簡単・後処理でMP4
PDF	jsPDF / pdf-lib	◎	画像埋め込み式出力
💡補足：Pixi v8 で注意すべき点

app.renderer.extract は非同期ではなく、GPU→CPU転送が入るため パフォーマンス負荷 がある。

高FPSキャプチャ時はフレームバッファを圧縮 or 非同期バッチ化推奨。

PixiJS v8 は OffscreenCanvas対応 なので、録画処理をWorkerで分離可能。

----


改訂版：PixiJS v8.13 出力統合モジュール構成計画

🧭 改訂版：PixiJS v8.13 出力統合モジュール構成計画（file://対応）
🎯 目的

PixiJS の描画結果を APNG / WebP / MP4 / PDF として出力できるようにする。
すべての処理は ブラウザ単体（file://実行）で完結。
サーバ通信なし・モジュールimportなし・PixiJSのRenderer機能のみで実現。

⚙️ 環境条件と設計への影響
項目	制約	設計への影響
実行環境	Chrome 最新（file://）	fetch / import は使えない。<script> にCDN読み込みで完結
モジュール	ESModules禁止	すべてグローバル名前空間 or 即時関数で定義
PixiJS	v8.13 CDN利用	PIXI グローバルAPIのみ使用。Renderer抽出に extract.canvas()
Canvas2D	禁止（例外：サムネイル）	描画処理はPixiJS内部で完結。出力のみ toDataURL() 許可
外部ライブラリ	CDNスクリプト限定	必要なら <script src="..."></script> で静的参照
🧩 ファイル構成（簡易構成）
/v8.13_export_demo/
├─ index.html
├─ export-manager.js
├─ export-apng.js
├─ export-webp.js
├─ export-mp4.js
├─ export-pdf.js
└─ libs/
    ├─ upng.min.js       ← APNG用
    ├─ webp-encoder.min.js ← WebP用
    └─ jspdf.umd.min.js  ← PDF用


※ ffmpeg.js はfile://環境ではWeb Worker動作に難ありなので除外。
MP4は MediaRecorder ベースで webm/mp4互換出力 のみ。

🧠 コア設計
export-manager.js（中核）
// ==================================================
// export-manager.js - 非ESM版 (PixiJS v8.13対応)
// ==================================================
window.ExportManager = {
  export: async function(format, input, options = {}) {
    switch (format) {
      case 'apng': return window.ExportAPNG.run(input, options);
      case 'webp': return window.ExportWEBP.run(input, options);
      case 'mp4':  return window.ExportMP4.run(input, options);
      case 'pdf':  return window.ExportPDF.run(input, options);
      default: alert("Unsupported format: " + format);
    }
  }
};

🖼️ 各フォーマット別設計
🟢 export-apng.js
// ==================================================
// export-apng.js
// ==================================================
window.ExportAPNG = {
  run: async function(frames, options = {}) {
    const width  = options.width  || 512;
    const height = options.height || 512;
    const delay  = options.delay  || 100;
    const rgbaFrames = frames.map(f => {
      const binary = atob(f.split(',')[1]);
      const arr = Uint8Array.from(binary, c => c.charCodeAt(0));
      return arr.buffer;
    });
    const apng = UPNG.encode(rgbaFrames, width, height, 0, Array(frames.length).fill(delay));
    const blob = new Blob([apng], { type: 'image/apng' });
    this._download(blob, 'animation.apng');
  },

  _download: function(blob, name) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    a.click();
  }
};

🟡 export-webp.js
// ==================================================
// export-webp.js
// ==================================================
window.ExportWEBP = {
  run: async function(frames, options = {}) {
    const quality = options.quality || 0.9;
    const encoder = new WebPEncoder({ quality });
    for (const f of frames) {
      const img = await createImageBitmap(await fetch(f).then(r => r.blob()));
      encoder.addFrame(img);
    }
    const blob = encoder.encode();
    this._download(blob, 'animation.webp');
  },

  _download: function(blob, name) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    a.click();
  }
};

🔵 export-mp4.js
// ==================================================
// export-mp4.js
// ==================================================
window.ExportMP4 = {
  run: async function(canvas, options = {}) {
    const fps = options.fps || 30;
    const duration = options.duration || 2000;
    const stream = canvas.captureStream(fps);
    const rec = new MediaRecorder(stream, { mimeType: 'video/webm' });
    const chunks = [];
    rec.ondataavailable = e => chunks.push(e.data);
    rec.start();
    await new Promise(r => setTimeout(r, duration));
    rec.stop();
    await new Promise(r => rec.onstop = r);
    const blob = new Blob(chunks, { type: 'video/webm' });
    this._download(blob, 'animation.webm');
  },

  _download: function(blob, name) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    a.click();
  }
};

🔴 export-pdf.js
// ==================================================
// export-pdf.js
// ==================================================
window.ExportPDF = {
  run: async function(canvas) {
    const pdf = new jspdf.jsPDF({ orientation: 'portrait', unit: 'px' });
    const img = canvas.toDataURL('image/png');
    pdf.addImage(img, 'PNG', 0, 0, canvas.width, canvas.height);
    pdf.save('output.pdf');
  }
};

🧩 index.html（統合テスト例）
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PixiJS v8 Export Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/pixi.min.js"></script>
  <script src="libs/upng.min.js"></script>
  <script src="libs/webp-encoder.min.js"></script>
  <script src="libs/jspdf.umd.min.js"></script>

  <script src="export-apng.js"></script>
  <script src="export-webp.js"></script>
  <script src="export-mp4.js"></script>
  <script src="export-pdf.js"></script>
  <script src="export-manager.js"></script>
</head>
<body>
  <button onclick="ExportManager.export('pdf', app.view)">PDF</button>
  <button onclick="ExportManager.export('mp4', app.view)">MP4</button>
  <button onclick="ExportManager.export('apng', recorder.frames)">APNG</button>
  <button onclick="ExportManager.export('webp', recorder.frames)">WebP</button>
  
  <script>
    const app = new PIXI.Application();
    document.body.appendChild(app.view);
    app.stage.addChild(new PIXI.Graphics().beginFill(0xff0000).drawCircle(100, 100, 50));

    const recorder = {
      frames: [],
      capture: function() {
        const c = app.renderer.extract.canvas();
        this.frames.push(c.toDataURL("image/png"));
      }
    };
  </script>
</body>
</html>

🧱 この構成のメリット
項目	内容
file://対応	import不要、fetchやCORS問題を回避
PixiJS v8準拠	renderer.extract.canvas() のみ使用、互換性安全
拡張性	新しい形式追加は export-manager.js に追記するだけ
AI改修容易	単一責務構造、グローバル名前空間明確化済み
安全性	Canvas2D利用はデータ抽出のみ、描画はPixiのみ