ğŸ§© å…¨ä½“æ–¹é‡

PixiJS v8 ã¯ WebGL2ãƒ™ãƒ¼ã‚¹ã®é«˜é€Ÿæç”»ãŒã§ãã‚‹ã®ã§ã€
app.renderer.extract.canvas() ãªã©ã§ã‚­ãƒ£ãƒ³ãƒã‚¹ç”»åƒã‚’å–å¾—ã—ã€
ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«ã‚­ãƒ£ãƒ—ãƒãƒ£ â†’ ã¾ã¨ã‚ã¦æ›¸ãå‡ºã™æ–¹å¼ãŒæœ€ã‚‚ä¸€èˆ¬çš„ã§ã™ã€‚

ğŸŸ¢ 1. APNGå‡ºåŠ›

PixiJS v8 + apng-js ã¾ãŸã¯ UPNG.js

ğŸ§  Pixiå´ã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ä¸­ã« extract.canvas() â†’ toDataURL('image/png')

ğŸ“¦ UPNG.js

è»½é‡ã§ã€è¤‡æ•°PNGãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ã¾ã¨ã‚ã¦ APNG ã«å†æ§‹æˆã§ãã¾ã™ã€‚

äº’æ›æ€§ï¼šPixi v8ã§ã‚‚å•é¡Œãªã—ï¼ˆWebGLâ†’Canvaså¤‰æ›ã®ä»•æ§˜ãŒå¤‰ã‚ã‚‰ãªã„ãŸã‚ï¼‰

âœ… ãŠã™ã™ã‚æ§‹æˆ

const pngFrames = frames.map(canvas => {
  const dataURL = canvas.toDataURL("image/png");
  return UPNG.decode(dataURL);
});
const apng = UPNG.encode(pngFrames, width, height, 0);

ğŸŸ¡ 2. WEBPã‚¢ãƒ‹ãƒ¡å‡ºåŠ›

PixiJS v8 + webm-writer ã¾ãŸã¯ webp-encoder

WEBPå‹•ç”»ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒã‚¤ãƒ†ã‚£ãƒ–APIã§ç›´æ¥ä½œã‚‹ã®ã¯é›£ã—ãã€
JSãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã®ãŒç¾å®Ÿçš„ã§ã™ã€‚

ğŸ’¡ webp-encoderï¼ˆ@louisremi/webp-encoderï¼‰ã‚„
webm-writerï¼ˆå¤±æ•—æ™‚fallbackï¼‰ã‚’åˆ©ç”¨å¯ã€‚

Pixiã§ç”Ÿæˆã—ãŸ canvas â†’ ImageBitmap â†’ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå…¥åŠ›ã€‚

âœ… ãŠã™ã™ã‚æ§‹æˆ

const encoder = new WebPEncoder({quality: 0.9, frameRate: 12});
for (const frame of frames) encoder.addFrame(frame);
const blob = encoder.encode();

ğŸ”µ 3. MP4å‡ºåŠ›

PixiJS v8 + MediaRecorder API

ğŸ§© PixiãŒå‹•ä½œä¸­ã® app.viewï¼ˆcanvasè¦ç´ ï¼‰ã‚’ MediaRecorder ã«æ¸¡ã™ã€‚

ãƒ–ãƒ©ã‚¦ã‚¶æ¨™æº–ã§éŒ²ç”» â†’ .webm or .mp4 å‡ºåŠ›ã€‚

Chromeç³»ãªã‚‰ video/webm;codecs=vp9 å®‰å®šã€‚MP4ã¯ä¸€éƒ¨ç’°å¢ƒã§é™å®šçš„ã€‚

âœ… ãŠã™ã™ã‚æ§‹æˆ

const stream = app.view.captureStream(30); // 30fps
const recorder = new MediaRecorder(stream, {mimeType: 'video/webm'});


â€»å¾Œå‡¦ç†ã§ ffmpeg.js ã‚’ä½¿ãˆã° .mp4 ã«å¤‰æ›å¯èƒ½ï¼ˆPixiã¨ã®ç›¸æ€§ã‚‚è‰¯ã„ï¼‰ã€‚

ğŸ”´ 4. PDFå‡ºåŠ›

PixiJS v8 + jsPDF ã¾ãŸã¯ pdf-lib

Pixiã¯PDFå‡ºåŠ›æ©Ÿèƒ½ã‚’æŒãŸãªã„ãŒã€Canvas â†’ ç”»åƒå¤‰æ› â†’ PDFåŸ‹ã‚è¾¼ã¿ãŒå¯èƒ½ã€‚

app.renderer.extract.canvas() â†’ toDataURL('image/png') â†’ jsPDF.addImage()

é«˜è§£åƒåº¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’è¡Œãˆã°ç¶ºéº—ã«å‡ºåŠ›å¯èƒ½ã€‚

âœ… ãŠã™ã™ã‚æ§‹æˆ

const pdf = new jsPDF();
pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, w, h);
pdf.save('output.pdf');

ğŸ§  ã¾ã¨ã‚ï¼ˆPixi v8ã¨ç›¸æ€§ã®è‰¯ã„å‡ºåŠ›ç³»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼‰
å‡ºåŠ›å½¢å¼	æ¨å¥¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª	Pixi v8äº’æ›æ€§	å‚™è€ƒ
APNG	UPNG.js	â—	è»½é‡ãƒ»ã‚·ãƒ³ãƒ—ãƒ«
WEBP	webp-encoder / webm-writer	â—	åœ§ç¸®ç‡é«˜ãƒ»ãƒ–ãƒ©ã‚¦ã‚¶ä¾å­˜æ³¨æ„
MP4	MediaRecorder / ffmpeg.js	â—	å®Ÿè£…ç°¡å˜ãƒ»å¾Œå‡¦ç†ã§MP4
PDF	jsPDF / pdf-lib	â—	ç”»åƒåŸ‹ã‚è¾¼ã¿å¼å‡ºåŠ›
ğŸ’¡è£œè¶³ï¼šPixi v8 ã§æ³¨æ„ã™ã¹ãç‚¹

app.renderer.extract ã¯éåŒæœŸã§ã¯ãªãã€GPUâ†’CPUè»¢é€ãŒå…¥ã‚‹ãŸã‚ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è² è· ãŒã‚ã‚‹ã€‚

é«˜FPSã‚­ãƒ£ãƒ—ãƒãƒ£æ™‚ã¯ãƒ•ãƒ¬ãƒ¼ãƒ ãƒãƒƒãƒ•ã‚¡ã‚’åœ§ç¸® or éåŒæœŸãƒãƒƒãƒåŒ–æ¨å¥¨ã€‚

PixiJS v8 ã¯ OffscreenCanvaså¯¾å¿œ ãªã®ã§ã€éŒ²ç”»å‡¦ç†ã‚’Workerã§åˆ†é›¢å¯èƒ½ã€‚

----


æ”¹è¨‚ç‰ˆï¼šPixiJS v8.13 å‡ºåŠ›çµ±åˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æˆè¨ˆç”»

ğŸ§­ æ”¹è¨‚ç‰ˆï¼šPixiJS v8.13 å‡ºåŠ›çµ±åˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æˆè¨ˆç”»ï¼ˆfile://å¯¾å¿œï¼‰
ğŸ¯ ç›®çš„

PixiJS ã®æç”»çµæœã‚’ APNG / WebP / MP4 / PDF ã¨ã—ã¦å‡ºåŠ›ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
ã™ã¹ã¦ã®å‡¦ç†ã¯ ãƒ–ãƒ©ã‚¦ã‚¶å˜ä½“ï¼ˆfile://å®Ÿè¡Œï¼‰ã§å®Œçµã€‚
ã‚µãƒ¼ãƒé€šä¿¡ãªã—ãƒ»ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«importãªã—ãƒ»PixiJSã®Rendereræ©Ÿèƒ½ã®ã¿ã§å®Ÿç¾ã€‚

âš™ï¸ ç’°å¢ƒæ¡ä»¶ã¨è¨­è¨ˆã¸ã®å½±éŸ¿
é …ç›®	åˆ¶ç´„	è¨­è¨ˆã¸ã®å½±éŸ¿
å®Ÿè¡Œç’°å¢ƒ	Chrome æœ€æ–°ï¼ˆfile://ï¼‰	fetch / import ã¯ä½¿ãˆãªã„ã€‚<script> ã«CDNèª­ã¿è¾¼ã¿ã§å®Œçµ
ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«	ESModulesç¦æ­¢	ã™ã¹ã¦ã‚°ãƒ­ãƒ¼ãƒãƒ«åå‰ç©ºé–“ or å³æ™‚é–¢æ•°ã§å®šç¾©
PixiJS	v8.13 CDNåˆ©ç”¨	PIXI ã‚°ãƒ­ãƒ¼ãƒãƒ«APIã®ã¿ä½¿ç”¨ã€‚RendereræŠ½å‡ºã« extract.canvas()
Canvas2D	ç¦æ­¢ï¼ˆä¾‹å¤–ï¼šã‚µãƒ ãƒã‚¤ãƒ«ï¼‰	æç”»å‡¦ç†ã¯PixiJSå†…éƒ¨ã§å®Œçµã€‚å‡ºåŠ›ã®ã¿ toDataURL() è¨±å¯
å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª	CDNã‚¹ã‚¯ãƒªãƒ—ãƒˆé™å®š	å¿…è¦ãªã‚‰ <script src="..."></script> ã§é™çš„å‚ç…§
ğŸ§© ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆï¼ˆç°¡æ˜“æ§‹æˆï¼‰
/v8.13_export_demo/
â”œâ”€ index.html
â”œâ”€ export-manager.js
â”œâ”€ export-apng.js
â”œâ”€ export-webp.js
â”œâ”€ export-mp4.js
â”œâ”€ export-pdf.js
â””â”€ libs/
    â”œâ”€ upng.min.js       â† APNGç”¨
    â”œâ”€ webp-encoder.min.js â† WebPç”¨
    â””â”€ jspdf.umd.min.js  â† PDFç”¨


â€» ffmpeg.js ã¯file://ç’°å¢ƒã§ã¯Web Workerå‹•ä½œã«é›£ã‚ã‚Šãªã®ã§é™¤å¤–ã€‚
MP4ã¯ MediaRecorder ãƒ™ãƒ¼ã‚¹ã§ webm/mp4äº’æ›å‡ºåŠ› ã®ã¿ã€‚

ğŸ§  ã‚³ã‚¢è¨­è¨ˆ
export-manager.jsï¼ˆä¸­æ ¸ï¼‰
// ==================================================
// export-manager.js - éESMç‰ˆ (PixiJS v8.13å¯¾å¿œ)
// ==================================================
window.ExportManager = {
  export: async function(format, input, options = {}) {
    switch (format) {
      case 'apng': return window.ExportAPNG.run(input, options);
      case 'webp': return window.ExportWEBP.run(input, options);
      case 'mp4':  return window.ExportMP4.run(input, options);
      case 'pdf':  return window.ExportPDF.run(input, options);
      default: alert("Unsupported format: " + format);
    }
  }
};

ğŸ–¼ï¸ å„ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆåˆ¥è¨­è¨ˆ
ğŸŸ¢ export-apng.js
// ==================================================
// export-apng.js
// ==================================================
window.ExportAPNG = {
  run: async function(frames, options = {}) {
    const width  = options.width  || 512;
    const height = options.height || 512;
    const delay  = options.delay  || 100;
    const rgbaFrames = frames.map(f => {
      const binary = atob(f.split(',')[1]);
      const arr = Uint8Array.from(binary, c => c.charCodeAt(0));
      return arr.buffer;
    });
    const apng = UPNG.encode(rgbaFrames, width, height, 0, Array(frames.length).fill(delay));
    const blob = new Blob([apng], { type: 'image/apng' });
    this._download(blob, 'animation.apng');
  },

  _download: function(blob, name) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    a.click();
  }
};

ğŸŸ¡ export-webp.js
// ==================================================
// export-webp.js
// ==================================================
window.ExportWEBP = {
  run: async function(frames, options = {}) {
    const quality = options.quality || 0.9;
    const encoder = new WebPEncoder({ quality });
    for (const f of frames) {
      const img = await createImageBitmap(await fetch(f).then(r => r.blob()));
      encoder.addFrame(img);
    }
    const blob = encoder.encode();
    this._download(blob, 'animation.webp');
  },

  _download: function(blob, name) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    a.click();
  }
};

ğŸ”µ export-mp4.js
// ==================================================
// export-mp4.js
// ==================================================
window.ExportMP4 = {
  run: async function(canvas, options = {}) {
    const fps = options.fps || 30;
    const duration = options.duration || 2000;
    const stream = canvas.captureStream(fps);
    const rec = new MediaRecorder(stream, { mimeType: 'video/webm' });
    const chunks = [];
    rec.ondataavailable = e => chunks.push(e.data);
    rec.start();
    await new Promise(r => setTimeout(r, duration));
    rec.stop();
    await new Promise(r => rec.onstop = r);
    const blob = new Blob(chunks, { type: 'video/webm' });
    this._download(blob, 'animation.webm');
  },

  _download: function(blob, name) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    a.click();
  }
};

ğŸ”´ export-pdf.js
// ==================================================
// export-pdf.js
// ==================================================
window.ExportPDF = {
  run: async function(canvas) {
    const pdf = new jspdf.jsPDF({ orientation: 'portrait', unit: 'px' });
    const img = canvas.toDataURL('image/png');
    pdf.addImage(img, 'PNG', 0, 0, canvas.width, canvas.height);
    pdf.save('output.pdf');
  }
};

ğŸ§© index.htmlï¼ˆçµ±åˆãƒ†ã‚¹ãƒˆä¾‹ï¼‰
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PixiJS v8 Export Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/pixi.min.js"></script>
  <script src="libs/upng.min.js"></script>
  <script src="libs/webp-encoder.min.js"></script>
  <script src="libs/jspdf.umd.min.js"></script>

  <script src="export-apng.js"></script>
  <script src="export-webp.js"></script>
  <script src="export-mp4.js"></script>
  <script src="export-pdf.js"></script>
  <script src="export-manager.js"></script>
</head>
<body>
  <button onclick="ExportManager.export('pdf', app.view)">PDF</button>
  <button onclick="ExportManager.export('mp4', app.view)">MP4</button>
  <button onclick="ExportManager.export('apng', recorder.frames)">APNG</button>
  <button onclick="ExportManager.export('webp', recorder.frames)">WebP</button>
  
  <script>
    const app = new PIXI.Application();
    document.body.appendChild(app.view);
    app.stage.addChild(new PIXI.Graphics().beginFill(0xff0000).drawCircle(100, 100, 50));

    const recorder = {
      frames: [],
      capture: function() {
        const c = app.renderer.extract.canvas();
        this.frames.push(c.toDataURL("image/png"));
      }
    };
  </script>
</body>
</html>

ğŸ§± ã“ã®æ§‹æˆã®ãƒ¡ãƒªãƒƒãƒˆ
é …ç›®	å†…å®¹
file://å¯¾å¿œ	importä¸è¦ã€fetchã‚„CORSå•é¡Œã‚’å›é¿
PixiJS v8æº–æ‹ 	renderer.extract.canvas() ã®ã¿ä½¿ç”¨ã€äº’æ›æ€§å®‰å…¨
æ‹¡å¼µæ€§	æ–°ã—ã„å½¢å¼è¿½åŠ ã¯ export-manager.js ã«è¿½è¨˜ã™ã‚‹ã ã‘
AIæ”¹ä¿®å®¹æ˜“	å˜ä¸€è²¬å‹™æ§‹é€ ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«åå‰ç©ºé–“æ˜ç¢ºåŒ–æ¸ˆã¿
å®‰å…¨æ€§	Canvas2Dåˆ©ç”¨ã¯ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºã®ã¿ã€æç”»ã¯Pixiã®ã¿