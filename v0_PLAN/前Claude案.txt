=== tegaki v8.13 緊急改修計画書 (ベーシック版) ===
作成日: 2025-10-05
形式: プレーンテキスト (.txt)
対象: PixiJS v8.13 お絵かきツール

========================================
【1】問題の原因究明
========================================

■ 1-A. getGlobalBounds スタックオーバーフロー
--------------------------------------
原因: CoreRuntime.switchCut() でのコンテナ追加時の循環参照

検出箇所:
  - core-runtime.js:99-111 (switchCut メソッド)
  
具体的問題:
  1) oldCut.container を stage から removeChild する
  2) 直後に newCut.container を stage に addChild する
  3) この時、newCut.container の parent チェーンに自身または
     祖先が含まれている可能性がある
  4) PixiJS v8.13 の getGlobalBounds が parent を辿る際に
     無限ループに陥りスタックオーバーフローが発生

根本原因:
  - addChild 前に parent チェーンの循環参照チェックが無い
  - container.parent === container の自己参照状態が発生


■ 1-B. レイヤーパネル未表示
--------------------------------------
原因: CoreRuntime.init での layerManager 参照が未設定

検出箇所:
  - core-runtime.js:61-77 (init メソッド)
  - layer-system.js:35-55 (コンストラクタ)

具体的問題:
  1) CoreRuntime.init で internal.layerManager に値を代入
  2) しかし LayerSystem のコンストラクタは CoreRuntime.init より
     先に実行されるため、初期化タイミングが不整合
  3) LayerSystem.updateLayerPanelUI() が呼ばれても
     stateManager が null のため処理が中断される
  4) レイヤーパネルの DOM 要素が生成されない


■ 1-C. キー割り当ての誤動作
--------------------------------------
原因: index.html のキーイベントハンドラの条件分岐の誤り

検出箇所:
  - index.html:552-625 (setupUnifiedKeyboardShortcuts 関数)

具体的問題:
  1) CTRL+Z の処理が event.code === 'KeyZ' で正しく分岐
  2) しかし CTRL+Y の処理が event.code === 'KeyY' のみで
     !e.altKey の条件が無い
  3) 方向キー ArrowLeft/ArrowRight の処理に event.ctrlKey の
     条件チェックが無い
  4) 結果として CTRL+Z が別の動作にマップされ、
     方向キーが効かない

根本原因:
  - キーイベント処理の条件分岐が不完全
  - 修飾キー (Ctrl, Shift, Alt) のチェック漏れ


■ 1-D. History (Undo/Redo) の未実装
--------------------------------------
原因: Command パターンの不完全な実装

検出箇所:
  - system/layer-commands.js (CreateLayerCommand など)
  - system/history.js (History.executeCommand)

具体的問題:
  1) CreateLayerCommand の undo メソッドが
     StateManager からレイヤーを削除するだけで
     PixiJS の DisplayObject を削除していない
  2) 新規 CUT 作成の Command が存在しない
  3) ペン描画の Command は動作するが、レイヤー/CUT の
     作成/削除が History に記録されない


========================================
【2】高優先度修正 (必須・即適用)
========================================

■ 2-A. 循環参照チェックの実装
--------------------------------------
目的: getGlobalBounds のスタックオーバーフローを防止

実装箇所: core-runtime.js (新規ユーティリティ関数追加)

追加コード:

```javascript
// core-runtime.js の先頭 (即時関数の中) に追加

function isAncestor(potentialAncestor, child) {
    let cur = potentialAncestor;
    let depth = 0;
    const MAX_DEPTH = 100;
    
    while (cur && depth < MAX_DEPTH) {
        if (cur === child) return true;
        cur = cur.parent;
        depth++;
    }
    
    if (depth >= MAX_DEPTH) {
        console.error('isAncestor: MAX_DEPTH exceeded');
        return true;
    }
    
    return false;
}

function safeAddChild(parent, child) {
    if (!parent || !child) {
        console.error('safeAddChild: invalid arguments');
        return false;
    }
    
    if (parent === child) {
        console.error('safeAddChild: cannot add container to itself');
        return false;
    }
    
    if (isAncestor(child, parent)) {
        console.error('safeAddChild: circular reference detected');
        return false;
    }
    
    parent.addChild(child);
    return true;
}
```

修正箇所: core-runtime.js:99-111 (switchCut メソッド)

変更前:
```javascript
if (this.project.stage) {
    this.project.stage.addChild(newCut.container);
}
```

変更後:
```javascript
if (this.project.stage) {
    safeAddChild(this.project.stage, newCut.container);
}
```


■ 2-B. CoreRuntime 初期化順序の修正
--------------------------------------
目的: layerManager の確実な初期化

実装箇所: index.html:757-791 (initializeApp 関数)

修正内容:
1) CoreRuntime.init 呼び出し前に全てのサブシステムを生成
2) init 成功確認後に UI イベントを発火

変更後のコード:

```javascript
async initialize() {
    // PixiJS アプリ作成
    this.pixiApp = new PIXI.Application();
    await this.pixiApp.init({ /* options */ });
    
    // CoreEngine 初期化
    this.coreEngine = new CoreEngine(this.pixiApp);
    const drawingApp = this.coreEngine.initialize();
    
    // CRITICAL: CoreRuntime.init を確実に実行
    const runtimeSuccess = CoreRuntime.init({
        app: this.pixiApp,
        worldContainer: this.coreEngine.getCameraSystem().worldContainer,
        canvasContainer: this.coreEngine.getCameraSystem().canvasContainer,
        cameraSystem: this.coreEngine.getCameraSystem(),
        layerManager: this.coreEngine.getLayerManager(),
        drawingEngine: this.coreEngine.getDrawingEngine()
    });
    
    if (!runtimeSuccess) {
        console.error('CoreRuntime initialization failed');
        return false;
    }
    
    // システム初期化完了イベント発火
    if (window.TegakiEventBus) {
        window.TegakiEventBus.emit('system:ready');
    }
    
    // UI コントローラ作成
    this.uiController = new UIController(
        this.coreEngine.getDrawingEngine(), 
        this.coreEngine.getLayerManager(), 
        this.pixiApp
    );
    
    return true;
}
```


■ 2-C. キーイベントハンドラの修正
--------------------------------------
目的: Ctrl+Z/Ctrl+Y と方向キーの正しい動作

実装箇所: index.html:552-625 (setupUnifiedKeyboardShortcuts)

修正内容: 全てのキー処理に修飾キーチェックを追加

変更後のコード:

```javascript
document.addEventListener('keydown', (e) => {
    preventBrowserDefaults(e);
    
    const eventBus = window.TegakiEventBus;
    if (!eventBus) return;
    
    // 入力フィールドでは無効化
    const activeElement = document.activeElement;
    if (activeElement && (
        activeElement.tagName === 'INPUT' ||
        activeElement.tagName === 'TEXTAREA' ||
        activeElement.isContentEditable
    )) return;
    
    // UNDO: Ctrl+Z (Shift なし)
    if (e.ctrlKey && e.code === 'KeyZ' && !e.shiftKey && !e.altKey) {
        if (window.History?.undo) window.History.undo();
        e.preventDefault();
        return;
    }
    
    // REDO: Ctrl+Y または Ctrl+Shift+Z
    if (e.ctrlKey && !e.altKey) {
        if (e.code === 'KeyY' && !e.shiftKey) {
            if (window.History?.redo) window.History.redo();
            e.preventDefault();
            return;
        }
        if (e.code === 'KeyZ' && e.shiftKey) {
            if (window.History?.redo) window.History.redo();
            e.preventDefault();
            return;
        }
    }
    
    // 方向キー: 修飾キー無しでのみ動作
    if (!e.ctrlKey && !e.shiftKey && !e.altKey) {
        if (e.code === 'ArrowLeft') {
            eventBus.emit('timeline:move-left');
            e.preventDefault();
            return;
        }
        if (e.code === 'ArrowRight') {
            eventBus.emit('timeline:move-right');
            e.preventDefault();
            return;
        }
        if (e.code === 'ArrowUp') {
            eventBus.emit('layer:move-up');
            e.preventDefault();
            return;
        }
        if (e.code === 'ArrowDown') {
            eventBus.emit('layer:move-down');
            e.preventDefault();
            return;
        }
    }
    
    // 他のショートカット (既存のまま)
});
```


========================================
【3】中期修正 (推奨)
========================================

■ 3-A. History Command の拡張
--------------------------------------
目的: レイヤー/CUT 作成の Undo/Redo 対応

実装箇所:
  - system/layer-commands.js (CreateLayerCommand の修正)
  - system/animation-commands.js (新規 CreateCutCommand 追加)

CreateLayerCommand の修正:

```javascript
class CreateLayerCommand {
    constructor(stateManager, eventBus, cutIndex, layerData) {
        this.stateManager = stateManager;
        this.eventBus = eventBus;
        this.cutIndex = cutIndex;
        this.layerData = layerData;
        this.layerIndex = -1;
        this.pixiLayer = null;
    }
    
    execute() {
        // StateManager にレイヤーを追加
        const result = this.stateManager.addLayer(
            this.cutIndex, 
            this.layerData
        );
        
        if (!result) return false;
        
        this.layerIndex = result.layerIndex;
        
        // PixiJS DisplayObject を生成
        const layerSystem = window.layerSystem;
        if (layerSystem) {
            this.pixiLayer = layerSystem.createPixiLayerFromData(
                this.layerData
            );
            layerSystem.currentCutContainer.addChild(this.pixiLayer);
        }
        
        // UI 更新
        if (this.eventBus) {
            this.eventBus.emit('layer:created', { 
                cutIndex: this.cutIndex,
                layerIndex: this.layerIndex 
            });
        }
        
        return true;
    }
    
    undo() {
        // PixiJS DisplayObject を削除
        if (this.pixiLayer) {
            const layerSystem = window.layerSystem;
            if (layerSystem?.currentCutContainer) {
                layerSystem.currentCutContainer.removeChild(this.pixiLayer);
                this.pixiLayer.destroy({ children: true });
            }
        }
        
        // StateManager からレイヤーを削除
        this.stateManager.removeLayer(this.cutIndex, this.layerIndex);
        
        // UI 更新
        if (this.eventBus) {
            this.eventBus.emit('layer:deleted', { 
                cutIndex: this.cutIndex,
                layerIndex: this.layerIndex 
            });
        }
        
        return true;
    }
    
    redo() {
        return this.execute();
    }
}
```

CreateCutCommand の実装 (新規):

```javascript
// system/animation-commands.js に追加

class CreateCutCommand {
    constructor(animationSystem, cutData) {
        this.animationSystem = animationSystem;
        this.cutData = cutData;
        this.cutIndex = -1;
    }
    
    execute() {
        const result = this.animationSystem.createCutInternal(this.cutData);
        
        if (!result) return false;
        
        this.cutIndex = result.cutIndex;
        
        if (window.TegakiEventBus) {
            window.TegakiEventBus.emit('cut:created', { 
                cutIndex: this.cutIndex 
            });
        }
        
        return true;
    }
    
    undo() {
        this.animationSystem.deleteCutInternal(this.cutIndex);
        
        if (window.TegakiEventBus) {
            window.TegakiEventBus.emit('cut:deleted', { 
                cutIndex: this.cutIndex 
            });
        }
        
        return true;
    }
    
    redo() {
        return this.execute();
    }
}

window.CreateCutCommand = CreateCutCommand;
```


========================================
【4】低優先度 (品質改善)
========================================

■ 4-A. DisplayObject の深さ制限ガード
--------------------------------------
目的: getGlobalBounds の再帰深度制限

実装箇所: coordinate-system.js (デバッグ用)

追加コード:

```javascript
// coordinate-system.js に追加 (デバッグ用)

function checkParentChainDepth(obj, maxDepth = 50) {
    let cur = obj;
    let depth = 0;
    
    while (cur && depth < maxDepth) {
        cur = cur.parent;
        depth++;
    }
    
    if (depth >= maxDepth) {
        console.warn('checkParentChainDepth: MAX_DEPTH exceeded', obj);
        return false;
    }
    
    return true;
}

// getGlobalBounds を呼ぶ前に使用
if (!checkParentChainDepth(displayObject)) {
    console.error('Invalid parent chain detected');
    return null;
}
```


■ 4-B. UI 初期化イベントの整備
--------------------------------------
目的: 依存関係の明確化

実装箇所: layer-system.js, ui-panels.js

修正内容:
1) 'system:ready' イベントを受信してから UI を描画
2) layerManager が null の場合は UI を描画しない

```javascript
// layer-system.js のコンストラクタに追加

if (this.eventBus) {
    this.eventBus.on('system:ready', () => {
        this.updateLayerPanelUI();
        this.updateStatusDisplay();
    });
}
```


========================================
【5】テスト & 検証手順
========================================

■ ステップ 1: DevTools 例外検証
--------------------------------------
1) Chrome DevTools を開く
2) Sources タブで "Pause on exceptions" を有効化
3) アプリを起動
4) 例外発生時に call stack を確認
5) parent チェーンを追跡 (console で printParentChain 実行)


■ ステップ 2: safeAddChild の動作確認
--------------------------------------
1) safeAddChild を実装
2) CUT 切替操作を実行
3) console に循環参照エラーが出ないことを確認
4) getGlobalBounds エラーが消えることを確認


■ ステップ 3: キー操作の検証
--------------------------------------
1) Ctrl+Z を押す → Undo が実行される
2) Ctrl+Y を押す → Redo が実行される
3) ← キーを押す → タイムライン左移動
4) → キーを押す → タイムライン右移動
5) ↑ キーを押す → レイヤー上移動
6) ↓ キーを押す → レイヤー下移動


■ ステップ 4: レイヤーパネルの表示確認
--------------------------------------
1) アプリ起動
2) 右側にレイヤーパネルが表示される
3) 既定レイヤー (L0) が表示される
4) Ctrl+L でレイヤー追加 → パネルに表示される


■ ステップ 5: History の検証
--------------------------------------
1) 新規レイヤー作成
2) Ctrl+Z を押す → レイヤーが消える
3) Ctrl+Y を押す → レイヤーが復元される
4) ペン描画を実行
5) Ctrl+Z を押す → 描画が消える
6) Ctrl+Y を押す → 描画が復元される


========================================
【6】影響範囲とリスク
========================================

■ 影響範囲
--------------------------------------
- core-runtime.js: switchCut メソッドの変更
- index.html: キーイベントハンドラの全面修正
- layer-commands.js: CreateLayerCommand の拡張
- animation-commands.js: CreateCutCommand の新規追加

■ リスク
--------------------------------------
LOW: safeAddChild の導入
  - 既存の循環参照を検出して停止するため、
    意図しない動作が明示的に防止される

MEDIUM: キーイベントハンドラの修正
  - 全てのショートカットの動作が変わる可能性
  - 十分なテストが必要

HIGH: Command パターンの拡張
  - History の動作が変わるため、
    既存の Undo/Redo が影響を受ける
  - 段階的な導入が推奨される


========================================
【7】作業優先順位
========================================

Phase 1 (即時):
  1) safeAddChild の実装と適用
  2) CoreRuntime.init の呼び出し確認
  3) キーイベントハンドラの修正

Phase 2 (短期):
  4) CreateLayerCommand の修正
  5) CreateCutCommand の実装
  6) UI イベント整備

Phase 3 (中期):
  7) テスト自動化
  8) ドキュメント整備


========================================
【8】デバッグ用ユーティリティ
========================================

■ 親チェーン追跡 (console で実行)
--------------------------------------
```javascript
function printParentChain(obj) {
    const seen = new Set();
    let cur = obj;
    let depth = 0;
    
    while (cur && !seen.has(cur) && depth < 100) {
        console.log(`[${depth}]`, cur.label || cur.name || cur);
        seen.add(cur);
        cur = cur.parent;
        depth++;
    }
    
    if (cur && seen.has(cur)) {
        console.warn('Cycle detected at:', cur.label || cur.name || cur);
    }
    
    if (depth >= 100) {
        console.warn('MAX_DEPTH exceeded');
    }
}

// 使用例
printParentChain(window.CoreRuntime.getActiveCut().container);
```


========================================
【9】補足: PixiJS v8.13 での注意点
========================================

■ getGlobalBounds の挙動
--------------------------------------
PixiJS v8.13 では getGlobalBounds が内部で parent チェーンを
辿る際に、循環参照があると無限ループに陥る。
parent を null にするか、parent チェーンを事前に検証する必要がある。

■ Container.addChild の仕様
--------------------------------------
PixiJS v8.13 では addChild 時に自動的な循環参照チェックは
行われない。アプリケーション側で検証する必要がある。

■ RenderTexture の破棄
--------------------------------------
RenderTexture.destroy(true) を呼ぶ際、baseTexture も
同時に破棄される。複数の Sprite で共有している場合は注意。


========================================
【10】最終チェックリスト
========================================

□ safeAddChild を実装した
□ CoreRuntime.init の引数を確認した
□ キーイベントハンドラを修正した
□ Ctrl+Z で Undo が動作する
□ Ctrl+Y で Redo が動作する
□ ← → キーでタイムライン移動できる
□ ↑ ↓ キーでレイヤー移動できる
□ レイヤーパネルが表示される
□ getGlobalBounds エラーが出ない
□ CreateLayerCommand が Undo/Redo できる
□ 新規レイヤー作成が History に記録される

========================================
End of Document
========================================