# SatellitePlan_RuleBook_v9.txt
# Tegaki PixiJS v8.13 統合開発・非破壊化ルールブック（Claude実装最適化版）

## 🎯 基本方針（v9更新）
- **統合HTMLファイルとcore-engine.js + サテライトファイル構成**をコアとし、Claudeがなるべく単一ファイルの修正で済むファイル構成
- **但し、API 境界を明確となった場合は、新たな主星を設けても良い。例えばdrawing-engine.jsとそのサテライトファイルみたいな構成
- **非破壊性担保**：レイヤー変形時も元描画データ（パス/ストローク）を保持
- **Claude可読性最優先**：改修時に触る必要のあるコードは主星ファイルに集約

---

## 📁 現在のファイル構成（Phase1.5統合版）

### 確定構成
```
index.html           # 統合HTMLファイル（UI + CSS + JavaScript統合）
config.js           # 設定値（参照専用）
ui-panels.js        # UI制御（参照専用）  
core-engine.js      # コアエンジン統合（参照専用）
```

### Claude改修ルール
- **index.html内のJavaScript部分のみ修正**でタスク完結させる
- サテライトファイル（config.js, ui-panels.js, core-engine.js）は**値・機能参照のみ**
- 新機能実装時は**統合HTML内のJavaScript部分で完結**する方式
- **機能修正時も統合HTML内で対応**し、サテライトファイルへの影響最小化

### サテライトファイル役割
- **config.js**: 定数・設定値（Canvas サイズ・DPI・ツールデフォルト値）
- **ui-panels.js**: UI操作・パネル制御・ユーザーインタラクション
- **core-engine.js**: 描画エンジン・レイヤー管理・カメラシステムの統合

---

## 🏗 現在の統合アーキテクチャ（Phase1.5版）

### CoreEngine統合構造
```javascript
// core-engine.js内の統合エンジン
class CoreEngine {
  constructor(app) {
    this.app = app;
    this.cameraSystem = null;
    this.layerManager = null;
    this.drawingEngine = null;
    this.clipboardSystem = null;
  }
  
  initialize() {
    // 各システムを内部で初期化・相互連携
    this.cameraSystem = new CameraSystem(this.app);
    this.layerManager = new LayerManager(/*...*/);
    this.drawingEngine = new DrawingEngine(/*...*/);
    this.clipboardSystem = new ClipboardSystem(/*...*/);
  }
  
  // 統合API提供
  switchTool(tool) { /* 統合制御 */ }
  resizeCanvas(width, height) { /* 統合処理 */ }
}
```

### レイヤーデータ構造（非破壊化対応）
```javascript
// 現在実装されているレイヤー構造
layer.layerData = {
  id: 'layer_1',
  name: 'レイヤー1',  
  visible: true,
  opacity: 1.0,
  paths: [                                    // 非破壊パスデータ
    {
      id: 'p123',
      points: [{x, y}, {x, y}, ...],         // 座標点配列
      color: 0x000000,
      size: 16,
      opacity: 0.85,
      isComplete: true,
      graphics: PIXI.Graphics               // 表示用Graphics
    }
  ],
  isBackground: false
};
```

---

## 🔧 非破壊化実装状況と課題

### 現在の問題（緊急対応必要）
1. **レイヤー変形確定時の破壊的処理**: `LayerManager.confirmLayerTransform()` でRenderTextureベイク
2. **コピー&ペースト劣化**: 変形確定後にパスデータが失われ、コピー時に劣化画像をコピー
3. **繰り返し劣化**: コピーのコピーで累積的な画質低下

### 緊急修正対象（core-engine.js内）
```javascript
// 修正必要箇所: LayerManager.confirmLayerTransform()
confirmLayerTransform() {
  // 【現状】破壊的RenderTextureベイク
  const renderTexture = PIXI.RenderTexture.create({...});
  this.app.renderer.render(activeLayer, { renderTexture });
  activeLayer.removeChildren(); // ❌ パスデータ消失
  const sprite = new PIXI.Sprite(renderTexture);
  activeLayer.addChild(sprite); // ❌ 劣化開始
  
  // 【修正後】非破壊的論理確定
  // 1) パスデータに変形適用
  this.applyTransformToPaths(activeLayer, transform);
  // 2) 表示transformリセット
  activeLayer.position.set(0, 0);
  activeLayer.rotation = 0;
  activeLayer.scale.set(1, 1);
  // 3) パスから再描画
  this.rebuildLayerFromPaths(activeLayer);
}
```

---

## 🚀 段階的改修計画（Claude作業最適化）

### Phase1: 緊急非破壊化（即時実装）
**目的**: 現在のコピー&ペースト劣化を停止

**実装対象**: 統合HTMLファイル内JavaScript部分で`core-engine.js`の機能を上書き
```javascript
// index.html内のJavaScript部分に追加
window.addEventListener('DOMContentLoaded', async () => {
  // CoreEngineの非破壊化パッチ適用
  const originalConfirmTransform = window.TegakiCore.CoreEngine.prototype.confirmLayerTransform;
  window.TegakiCore.CoreEngine.prototype.confirmLayerTransform = function() {
    // 非破壊的確定処理の実装
  };
});
```

**変更ファイル**: index.htmlのみ（JavaScript部分）
**変更規模**: 約50行追加

### Phase2: パスデータ完全保持
**目的**: コピー&ペースト時もパスデータを確実に継承

**実装内容**:
- コピー処理の完全非破壊化
- パスデータ第一優先のクリップボード管理
- 変形状態を考慮したパスデータ仮想適用

**変更ファイル**: index.htmlのみ（JavaScript部分）
**変更規模**: 約100行追加

### Phase3: レンダリングパイプライン分離
**目的**: 表示とデータの完全分離

**実装内容**:
- パス → Graphics再構築システム
- キャッシュシステム（再生成可能）
- サムネイル更新最適化

**変更ファイル**: index.htmlのみ（JavaScript部分）
**変更規模**: 約150行追加

---

## 🎬 GIFアニメーション機能実装計画

### 基本方針（A案：シンプル絵コンテ）
- **CUT = レイヤー合成スナップショット**: 各CUTで全レイヤー状態を保存
- **DOM + PixiJS連携**: タイムラインはHTML/CSS、サムネイルはPixiJS RenderTexture
- **統合HTML内実装**: GIF機能も統合HTML内のJavaScript部分で完結

### データ構造
```javascript
// 統合HTML内に追加するアニメーションデータ
const animationData = {
  cuts: [
    {
      id: 'cut_1',
      name: 'CUT1', 
      duration: 0.2,              // 表示時間（秒）
      layerStates: [              // 全レイヤーの状態保存
        {
          layerId: 'layer_0',
          visible: true,
          opacity: 1.0,
          transform: { x: 0, y: 0, scale: 1, rotation: 0 }
        }
      ],
      thumbnail: null             // RenderTexture（遅延生成）
    }
  ],
  fps: 12,
  loop: true,
  currentCutIndex: 0
};
```

### UI追加（統合HTML内）
```html
<!-- サイドバーにアニメボタン追加 -->
<div class="tool-button" id="animation-tool" title="GIFアニメーション">
  <!-- アニメーションアイコン -->
</div>

<!-- タイムラインパネル追加 -->
<div class="timeline-panel" id="timeline-panel">
  <!-- CUT管理UI -->
</div>
```

---

##⚠️ Claude実装時の禁止事項（厳格）

### 🚫 ファイル構成
- **統合HTMLファイル分割への回帰禁止** - 必ず統合HTML + サテライト構成維持
- **サテライトファイル内でのロジック実装禁止** - 参照用のみ
- **相談なしの構造変更・短縮・冗長化禁止**

### 🚫 技術制約
- PixiJS v7/v8混在対応禁止
- Canvas2D/TypeScript/ESM/bundler導入禁止
- localStorage/sessionStorage使用禁止（Claude環境制約）

### 🚫 実装制約
- **フォールバック・フェイルセーフ処理絶対禁止** - 曖昧動作・暗黙修復禁止
- 過度なユーザー向けエラー演出禁止 - 開発中なので不要
- 二重実装・冗長化禁止
- 座標計算の直接実装禁止（toLocal/toGlobal必須）

---

## 🔄 Claude改修フロー（最適化版）

### 基本改修手順
1. **要求分析**: 機能追加・修正内容の特定
2. **影響範囲確定**: 統合HTML内JavaScript部分の該当箇所特定
3. **サテライトファイル確認**: 必要な設定値・機能の参照先確認
4. **統合HTML内実装**: JavaScript部分のみで改修完結
5. **動作検証**: 該当機能の動作確認

### 修正パターン
```javascript
// パターン1: サテライトファイルの機能拡張
// ❌ サテライトファイル修正（禁止）
// ✅ 統合HTML内で機能拡張
const expandedFunction = (originalFunction) => {
  return function(...args) {
    // 拡張処理
    return originalFunction.apply(this, args);
  };
};

// パターン2: 新機能追加
// ✅ 統合HTML内で完結
class NewFeature {
  constructor() {
    // 統合HTML内で実装
  }
}
```

---

## 📋 実装チェックリスト（Claude用）

### 非破壊化確認
- [ ] `confirmLayerTransform()` が非破壊的論理確定を実行
- [ ] パスデータが変形確定後も保持される
- [ ] コピー&ペースト時にパスデータが継承される
- [ ] 繰り返しコピーでも画質劣化しない

### 統合HTML実装確認
- [ ] JavaScript部分のみで機能が完結している
- [ ] サテライトファイルを参照のみで使用している
- [ ] 新機能が統合HTML内で実装されている
- [ ] 既存機能との整合性が保たれている

### パフォーマンス確認
- [ ] 60fps維持でUI応答性確保
- [ ] メモリリーク未発生
- [ ] サムネイル生成が最適化されている
- [ ] キャッシュシステムが適切に動作

### GIF機能準備確認（将来実装）
- [ ] CUT管理データ構造が準備済み
- [ ] タイムラインUI要素が追加済み
- [ ] レイヤー状態キャプチャ機能が実装済み
- [ ] RenderTexture生成機能が準備済み

---

## 🎯 将来拡張ロードマップ

### ステージ1: 非破壊化完成（優先度：最高）
- [x] 統合HTML + サテライト構成確立
- [ ] 緊急非破壊化実装
- [ ] コピー&ペースト品質保証
- [ ] レンダリングパイプライン分離

### ステージ2: GIFアニメ機能（優先度：高）
- [ ] CUT管理システム実装
- [ ] タイムライン UI実装
- [ ] 再生制御機能実装
- [ ] GIFエクスポート機能実装

### ステージ3: 高度なアニメ機能（優先度：中）
- [ ] フレーム間補間
- [ ] オニオンスキン表示
- [ ] 詳細タイムライン編集
- [ ] 高解像度出力対応

### ステージ4: 外部連携（優先度：低）
- [ ] 2窓連携機能
- [ ] JSON データ共有
- [ ] LIVE2D/SPINE準備
- [ ] クラウド連携検討

---

## 📚 重要APIリファレンス（Claude参照用）

### 現在利用可能なAPI（サテライトファイル）
```javascript
// config.js
window.TEGAKI_CONFIG = {
  canvas: { width: 400, height: 400 },
  pen: { size: 16, color: 0x000000, opacity: 0.85 },
  // ...
};

// ui-panels.js
window.TegakiUI = {
  UIController: class UIController { /* ... */ }
};

// core-engine.js  
window.TegakiCore = {
  CoreEngine: class CoreEngine { /* ... */ }
};
```

### PixiJS v8.13 必須API
```javascript
// Container transform
container.position.set(x, y);
container.rotation = radians;
container.scale.set(scaleX, scaleY);

// RenderTexture（高解像度対応）
PIXI.RenderTexture.create({width, height, resolution});
app.renderer.render(object, {renderTexture});

// 座標変換（必須）
container.toLocal(globalPoint);
container.toGlobal(localPoint);

// Graphics v8.13
graphics.moveTo(x, y);
graphics.lineTo(x, y);
graphics.circle(x, y, radius);
graphics.fill({color, alpha});
```

---

## 🔚 Claude実装時の重要ポイント

### 最優先事項
1. **統合HTML内のJavaScript部分のみ修正**
2. **非破壊化の緊急実装**（コピー&ペースト劣化停止）
3. **サテライトファイルは参照のみ**

### 実装時の注意
1. **段階的実装**: 一度に大きな変更をせず、段階的に機能追加
2. **既存機能保持**: 新機能追加時も既存機能が動作することを確認
3. **パフォーマンス配慮**: 60fps維持とメモリ管理の徹底

### 品質保証
1. **動作テスト**: 各機能の基本動作確認
2. **回帰テスト**: 既存機能への影響がないことを確認
3. **パフォーマンステスト**: レスポンス性能の維持確認

---

このルールブックv9は、Phase1.5統合版の完成を踏まえ、Claude改修効率を最大化しつつ、非破壊化とGIF機能実装を段階的に実現するためのガイドラインです。統合HTMLファイル中心の改修により、作業効率と品質の両立を目指します。