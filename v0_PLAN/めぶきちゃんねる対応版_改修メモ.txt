改修計画書（簡潔版）

目的：既存の ブラウザお絵かきツール(v8.13_History38) を、画像掲示板（CSP等セキュリティ有り）にそのまま投稿添付できる形 に改修し、ブックマークレット／ローダー経由で掲示板に注入できるようにする。PIXIの巨大さは敢えて無視し、機能/インターフェースとデータ取扱いに重点を置く。

前提（要点）

実行環境：Chrome 最新、file://ローカルテスト可能。

技術スタック：PixiJS v8.13（既存想定）、ES2023（モジュール無し）、fetch利用可。

禁止：Canvas2D（サムネイル以外）, TypeScript, bundler, ESM, Vite, Babel。

ベクターペン主体：内部での記録は ベクタ（ストローク）形式 を原則。ただしエクスポート時にラスタ化してAPNG/GIF等を生成する。

セキュリティ要件：外部CDN依存を最小化し単一の統合ファイル（ローカル/自身のGitHubPagesホスト）で動作させる方針（CSP対策含む）。（アニメ版計画書の流用方針を採用）。

結論（結論的提案）

単一統合ビルドを作る（libs と core を build.js で結合し dist/tegaki_bundle.js を作成）。

Pixi はそのまま統合（今回はサイズを無視）。IIFEラップで window.PIXI を提供。

描画はベクタ（stroke）で内部保存。Undo/Redo, 履歴はストローク単位で保持（ImageDataはエクスポート時のみ作成）。

エクスポート処理は build-in ライブラリ（UPNG, pako, gif.js 等）を統合して行う（Worker は Base64→Blob URL 化でインライン化）。

**ローダー（bookmarklet）**は掲示板で動く最小JSを配置し、読み込んだ後に window.TegakiStart() を呼ぶ形式にする。CSPが厳しければ統合ファイルのホストを同一オリジンか許可済みにする。

（上記は「アニメ版開発計画書.txt」の方針を踏襲しています）。

リスクと注意点（短く）

ベクタ記録の漏洩：ストロークデータは表現力が高く、個人特定につながる可能性がある。掲示板に自動送信する際はユーザー確認・明示（UI/ショートカットで最終合意）を必須にする。

座標系の不整合：coordinate-system.js と Pixi 座標の取り扱いを厳格化（座標変換 API を一本化すること）。

メモリ/CPU：大きなフレーム数や大量のベクタを長時間保持するとブラウザ負荷が上がる。履歴上限を明示（例：最大履歴深さ N=100）する。

CSP/Worker：gif.worker や外部スクリプトは ビルド時にインライン化 する（Base64→Blob URL）ことで回避。

変更対象（最小限のファイル群／優先度順）

core-runtime.js / core-engine.js — 全体エントリのIIFE統合点（高）

system/（drawing/, history.js, layer-system.js, coordinate-system.js）— データモデル・API標準化（高）

export-manager.js と system/exporters/* — 統合エクスポートパイプライン（高）

ui/*（timeline, export-popup 等）— 最小UIで投稿フローに接続（中）

loader/bookmarklet 設計（新規）— 掲示板への注入ロジック（高）

（上記は提供リンク群に照らして必要な箇所を抽出）

API・命名規約（必須）

（AIが改修する前提で厳格に）

全体名前空間：window.TEGAKI （小規模な公開APIをここに集約）

主要API：

TEGAKI.init(containerEl, options) → 初期化（戻り値: instance）

instance.exportAs(type, opts) → Promise<Blob> （type: 'apng'|'gif'|'png'|'webp'|'mp4'）

instance.getState() → シリアライズ済オブジェクト（ストローク配列など）

instance.loadState(obj) → 復元

instance.attachToBoard(formSelector) → 掲示板のフォームにBlobを注入（内部確認ダイアログは呼ばない）

ストロークデータ構造（必須一意）:

{
  id: string,           // uuid-like
  tool: 'pen'|'eraser',
  color: '#rrggbb',
  width: number,
  points: [ [x,y,t], ... ], // x,y は normalized 0..1 (キャンバス比依存を排除)
  timestamp: 1670000000000
}


points の座標は ノーマライズ（0..1） で保存すること。これで解像度/表示スケールによる不整合回避。

履歴API: history.push(stroke), history.undo(), history.redo() — 履歴はストローク単位で扱う。

データ所有と座標系（重要）

保存/送信されるデータは「最終エクスポートのビットマップ（Blob）」のみ。ストロークログはユーザー同意なしには外部送信しない。

coordinate-system.js を中心に、以下方針を徹底：

入出力座標は常に normalized (0..1)。キャンバス描画時にピクセル変換するユーティリティを用意。

UI/サムネイル用の縮小変換は ui/thumbnail-utils.js で一元管理。

ビルド方針（簡潔）

作業ファイルを src/ に集約。libs（UPNG, pako, gif.js, pixi.min.js）を libs/ に配置。

build.js（Node.js スクリプト）で順次読み込んで一つの dist/tegaki_bundle.js を生成。

gif.worker.js は Base64 にして IIFE 内で URL.createObjectURL(new Blob([atob(base64)])) を作る（アニメ版計画書の手順を踏襲）。

Pixi のグローバルは window.PIXI = PIXI として公開。TEGAKIは window.TEGAKI = {...} を追加。

最終成果物を GitHub Pages にデプロイ or 掲示板が許すホストに置く（CSP考慮）。

エクスポート＆掲示板注入フロー（最短シーケンス）

ユーザーがショートカットで「投稿」コマンドを発動。

instance.exportAs('apng') を呼ぶ（内部でストロークをラスタ化して UPNG.encode を使う）。

Blob が生成されたら instance.attachToBoard(formSelector) を呼び、該当 <input type="file"> に DataTransfer を使ってファイルを注入する（下記サンプル）。

ユーザーに最終確認を促す（アラートではなく小さなモーダルか toast）。

ユーザーが投稿ボタンを押す（自動送信はしない）。

最小サンプル（実装指示＋コード断片、極小）

build.js の要点（pseudo）：

// build.js - pseudo
// 1) concat libs: pixi.min.js, upng.js, pako.min.js, gif.js
// 2) inline gif.worker.js as base64 and create Blob URL in runtime
// 3) append core-runtime.js + other src files
// 4) wrap whole in IIFE and expose window.TEGAKI, window.PIXI


Worker inline（runtime）（概念コード最小）：

(function(){
  const workerBase64 = '...'; // build が埋める
  const code = atob(workerBase64);
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  if(window.GIF && window.GIF.prototype) {
    window.GIF.prototype.options = window.GIF.prototype.options || {};
    window.GIF.prototype.options.workerScript = url;
  }
})();


掲示板へ Blob 注入（最小）：

async function injectBlobToInput(fileBlob, inputSelector, filename){
  const file = new File([fileBlob], filename, { type: fileBlob.type });
  const dt = new DataTransfer();
  dt.items.add(file);
  const input = document.querySelector(inputSelector);
  input.files = dt.files;
  // do not auto-submit
}

テスト項目（短く）

単体：TEGAKI.init() → 描画→undo/redo（ストローク）→ exportAs('apng') が Blob を返す

統合：dist/tegaki_bundle.js をローダー経由で掲示板上に読み込み、injectBlobToInput() で <input type=file> に添付されるか確認

CSP：掲示板でブックマークレット実行 → external script 読み込みが拒否される場合の対応（同一オリジンへ置く）

性能：大きめ（複数レイヤ・多数ストローク）でのメモリ・エクスポート時間測定

マイルストーン（短く）

build.js 作成 + libs 集約（1日）

ストローク単位の履歴実装・API 公開（1〜2日）

exporters の統合（UPNG/GIF）と Worker インライン化（1日）

loader/bookmarklet と inject 実装（0.5日）

テスト＆ドキュメント（0.5日）

※所要日数は開発者の習熟度に依存。

最後に（実務メモ）

「ベクターペン主体」なので、履歴・保存はストローク形式を第一義とする。ラスタは最低限、サムネイルと最終エクスポートでのみ生成すること。

すべての公開APIは window.TEGAKI に集約。AIが直接パッチを当てやすいよう、各ファイルのエクスポート関数名とデータモデルは上で示した通り厳格に揃えること。

実装手順・Workerインライン化・ビルド方針は「アニメ版開発計画書.txt」をほぼ踏襲しているため、ビルドスクリプトの雛形とWorker埋め込みコードはそのまま転用可能。

やるべき次アクション（推奨）：

build.js のスケルトンを1つ作成してlibsを統合（私が作ることも可能です）。

TEGAKI 名前空間の簡易APIとストロークデータモデルをソースに埋める。

export→inject のエンドツーエンドテストをローカル（file://）で実施。

---

追記：ビルド前テスト発火 index.html 構成計画
目的

各 .js ファイル（core, system, ui 等）を順に読み込み、PixiJS連携と初期化フローを検証する。

統合ビルド前の段階でバグを早期検出。Pixiバージョンや依存関係の衝突を明示化する。

他AIが修正を提案しやすい構成（HTML＋スクリプトタグ列＋簡易UI構造）。

ファイル構成（例）
/project-root
│
├─ libs/
│   ├─ pixi.min.js
│   ├─ upng.min.js
│   ├─ gif.js
│   ├─ pako.min.js
│
├─ system/
│   ├─ event-bus.js
│   ├─ state-manager.js
│   ├─ drawing/
│   │   ├─ stroke-renderer.js
│   │   ├─ stroke-recorder.js
│   │   ├─ brush-settings.js
│   │   └─ drawing-engine.js
│   ├─ export-manager.js
│   ├─ exporters/
│   │   ├─ png-exporter.js
│   │   ├─ gif-exporter.js
│   │   ├─ apng-exporter.js
│   │   └─ webp-exporter.js
│   └─ ...
│
├─ ui/
│   ├─ export-popup.js
│   ├─ timeline-ui.js
│   └─ ...
│
├─ core-runtime.js
├─ core-engine.js
├─ config.js
├─ coordinate-system.js
│
└─ index.html   ← ★テスト発火用（今回追記の中心）

index.html 設計要件

すべてのJSを逐次 <script> タグで読み込む。

依存順は libs → core → system → ui。

async/defer は使用しない。読み込み順序を保証する。

ローカル動作（file://）を前提にするため、CORSヘッダ不要。

PixiJS起動とTEGAKI初期化を即時テストする。

読み込み完了後に window.onload または DOMContentLoaded で
TEGAKI.init(document.getElementById('canvas-area')) を呼ぶ。

UIは最小限。

<canvas> 要素1枚と、ログ用 <div>（id="status-log"）のみ。

描画／Undo／Redo／Exportをキーボードショートカットで操作。

ログ出力をAIが解析しやすい形式に統一。

console.logは "TEST:" プレフィックスを付ける（例：TEST:init complete）。

エラー時は "ERR:" プレフィックスで出力。

index.html サンプル構成（プレーン構文）
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>TEGAKI Test Launcher</title>
<style>
  body { background:#222; color:#eee; font-family:monospace; }
  #canvas-area { width:800px; height:600px; margin:20px auto; display:block; }
  #status-log { margin:10px; white-space:pre; }
</style>
</head>
<body>
  <canvas id="canvas-area"></canvas>
  <div id="status-log">[Log start]</div>

  <!-- ==== LIBS ==== -->
  <script src="libs/pixi.min.js"></script>
  <script src="libs/upng.min.js"></script>
  <script src="libs/pako.min.js"></script>
  <script src="libs/gif.js"></script>

  <!-- ==== CORE ==== -->
  <script src="config.js"></script>
  <script src="coordinate-system.js"></script>
  <script src="core-engine.js"></script>
  <script src="core-runtime.js"></script>

  <!-- ==== SYSTEM ==== -->
  <script src="system/event-bus.js"></script>
  <script src="system/state-manager.js"></script>
  <script src="system/history.js"></script>
  <script src="system/layer-system.js"></script>
  <script src="system/drawing/drawing-engine.js"></script>
  <script src="system/drawing/brush-settings.js"></script>
  <script src="system/drawing/stroke-renderer.js"></script>
  <script src="system/drawing/stroke-recorder.js"></script>
  <script src="system/export-manager.js"></script>

  <!-- ==== UI ==== -->
  <script src="ui/export-popup.js"></script>
  <script src="ui/timeline-ui.js"></script>

  <!-- ==== TEST LAUNCH ==== -->
  <script>
  window.addEventListener('DOMContentLoaded', () => {
    try {
      if (!window.PIXI) throw new Error("PixiJS not loaded");
      const canvas = document.getElementById('canvas-area');
      const tegaki = window.TEGAKI?.init ? window.TEGAKI.init(canvas, {}) : null;
      if (!tegaki) throw new Error("TEGAKI.init missing");
      console.log("TEST: init complete");
      document.getElementById('status-log').textContent += "\nOK: Init success";
    } catch(e) {
      console.error("ERR:", e);
      document.getElementById('status-log').textContent += "\nERR: " + e.message;
    }
  });
  </script>
</body>
</html>

テストindex.htmlの運用手順

/project-root/index.html をブラウザで直接開く（file://〜）。

コンソールに TEST: init complete が表示されれば、
PixiJS → Core → System → UI までの依存が正しく解決していることを意味する。

ペンツール・履歴・エクスポートなどを単体で検証し、
各 .js ファイルを改修後、逐次再読込して確認。

修正が安定した段階で build.js に結合順を反映し、
最終的に dist/tegaki_bundle.js に統合して本番（ブックマークレット版）へ移行。

付記：AI向け開発支援ルール

AIモデルがテストログを解析できるよう、TEST: / ERR: の接頭辞を統一的に使用。

index.html の <script> 群は、ファイル名＝ロード順 を意図的に一致させる（依存解析が容易）。

index.html の更新は build スクリプトに影響を与えない。ビルド工程は build.js が別途管理する。

追記後のマイルストーン更新
手順	作業	目安
1	libs, system, ui 等ファイルを手動順序で index.html に登録	半日
2	テスト発火：Pixi＋TEGAKI.init 成功確認	半日
3	各サブモジュールの動作確認（描画→履歴→エクスポート）	1日
4	build.js に同順序を反映し結合テスト	1日
5	掲示板ブックマークレット統合・投稿添付確認	1日
まとめ

PixiJSのサイズ問題は無視可。性能的影響なし。

ビルド前テストindex.html により、AIや開発者が段階的に改修検証可能。

index.html の設計は「他AIエージェントが理解・発火できる最小構成」を満たす。

安定後は build.js に同一順序で結合し、最終的に CSP安全な単一ファイルに統合。

---

🧩 1. ファイルサイズとロード時間の関係

PixiJS（v8.x）の minified 版はおおよそ 1.8〜2.2MB 程度あります。
HTTP/2＋Gzip/Brotli 圧縮を有効にした場合、転送量は 400〜600KB 程度 まで減ります。

単一ファイル構成（あなたの方式）：

1リクエストで完結するため、HTTP遅延が最小化されます。

キャッシュも 1 ファイル単位で効くため、再訪時は瞬時。

複数ファイル構成（CDN複数読み込み）：

各ライブラリごとにリクエストが発生（DNS、TLS、TCP handshake 含む）。

特に CSP 制約のある環境では外部CDNアクセスが無駄になる。

📊 結論：
2MB であっても、HTTP/2＋圧縮環境ならロード時間は 1 秒以下。
複数CDN分割よりも、単一ファイル化のほうが速い傾向 です。

🧠 2. メモリ展開コスト

JavaScriptの実行時は、minify後のテキストサイズではなく「AST（構文木）」や「関数オブジェクト」に展開されます。
ただし、2MBクラスのライブラリをロードしても、
PixiJS自体が利用するメモリは概ね 50〜100MB 以下 に収まります。

PixiJSはWebGLのレンダラであり、CPUよりもGPUメモリを消費します。
このため メモリ使用量はファイルサイズより描画解像度に強く依存 します。

📌 重要な点：

2MBのPixi本体は「一度読み込んで初期化」されるだけ。

その後のフレームレンダリングではサイズの影響は皆無。

ImageやTextureを大量に扱わない限り、常駐コストは軽微。

⚙️ 3. 実際の最適化指針

もし少しでも軽量化したい場合、PixiJSには以下の選択肢があります。

方法	効果	解説
pixi.js → pixi.min.js	高	不要コメント・改行を削除
PixiJSカスタムビルド	中	使わないモジュール（filter, spine等）を除外
IIFEラップ＋lazy init	低	必要時に new PIXI.Application() する
コード分離 (deferred eval)	低	loader内で eval(pixiCode) するなど段階的展開

📌 あなたの開発方針（bundler禁止・ESM禁止・CSP対応）では、
「pixi.min.js を直接結合」がベストバランスです。

⚡ 4. 実測値目安（PixiJS v8.13）
項目	内容
pixi.min.js サイズ	約 1.9 MB
Brotli圧縮転送サイズ	約 470 KB
読み込み＋初期化時間（Chrome 140, i9）	約 150ms〜250ms
メモリ使用量（空canvas時）	約 70 MB
FPS安定性	60 FPS（描画が重くなければ固定）

PixiはGPU処理主体なので、描画開始後の負荷はファイルサイズに無関係です。

🧮 5. まとめ
観点	評価	備考
初回ロード速度	◎	単一ファイル＋圧縮で最速
メモリ使用量	○	ファイルサイズに比例しない
実行パフォーマンス	◎	GPU処理主体
保守性	◎	CSP制約下で安定
再利用・キャッシュ	◎	一度キャッシュされれば即時起動
✅ 結論

PixiJSを含めて2MBの単一ビルドにしても、性能的問題はほぼありません。
逆にHTTPリクエスト分散やCSP回避の観点からも、統合が正解です。
特に「掲示板投稿ツール」のように起動回数が少ないツールでは、
ロードコストは完全に許容範囲です。

---


