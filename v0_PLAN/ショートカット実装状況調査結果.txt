ショートカット実装状況調査結果
1. config.js に集約されているショートカット
javascriptshortcuts: {
    undo: 'ctrl+z',
    redo: 'ctrl+y',
    // ... 一部のみ定義
}
2. 分散実装されているショートカット
ui/timeline-ui.js (約575行目～)
javascriptsetupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        if (!this.isVisible) return;
        
        if (e.code === 'Space' && e.shiftKey && !e.ctrlKey && !e.altKey) {
            this.togglePlayStop();  // Shift+Space: 再生/停止
        } else if (e.code === 'KeyR' && !e.ctrlKey && !e.altKey) {
            this.toggleRepeat();  // R: リピート切替
        } else if (e.code === 'ArrowLeft') {
            this.goToPreviousCutSafe();  // ←: 前のカット
        } else if (e.code === 'ArrowRight') {
            this.goToNextCutSafe();  // →: 次のカット
        } else if (e.code === 'Equal' && e.altKey) {
            this.animationSystem.createNewEmptyCut();  // Alt+=: CUT追加
        }
    });
}
core-engine.js (約185行目～)
javascriptsetupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        const shortcuts = this.config.shortcuts;
        
        // Ctrl+Z: Undo (config.js参照)
        // Ctrl+Y: Redo (config.js参照)
        // ... 他のショートカットも一部config.js参照
        
        // ただし、以下は直接実装:
        if (e.key === 'b' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
            // B: ブラシツール
        }
        if (e.key === 'e' && !e.ctrlKey && !e.altKey && !e.shiftKey) {
            // E: 消しゴムツール
        }
        // ... その他多数
    });
}
system/layer-system.js (レイヤー関連)
javascript// Ctrl+Shift+N: 新規レイヤー
// Delete: レイヤー削除
// など、直接実装されている可能性

改修計画書
目的

すべてのショートカット定義を config.js に集約
保守性・カスタマイズ性の向上
ショートカット競合の検出機能追加

Phase 1: config.js の拡張
config.js に追加する設定
javascriptshortcuts: {
    // 既存
    undo: 'ctrl+z',
    redo: 'ctrl+y',
    
    // ツール切替
    brushTool: 'b',
    eraserTool: 'e',
    handTool: 'h',
    
    // レイヤー操作
    newLayer: 'ctrl+shift+n',
    deleteLayer: 'delete',
    duplicateLayer: 'ctrl+j',
    mergeDown: 'ctrl+e',
    
    // アニメーション/タイムライン
    playPause: 'shift+space',
    toggleRepeat: 'r',
    previousCut: 'arrowleft',
    nextCut: 'arrowright',
    addCut: 'alt+equal',
    copyCut: 'shift+c',
    
    // 表示切替
    toggleTimeline: 'ctrl+t',
    toggleLayerPanel: 'ctrl+l',
    
    // カメラ
    resetZoom: 'ctrl+0',
    zoomIn: 'ctrl+plus',
    zoomOut: 'ctrl+minus',
}
Phase 2: ショートカット管理クラスの作成
新規ファイル: system/shortcut-manager.js
javascriptclass ShortcutManager {
    constructor(config) {
        this.shortcuts = config.shortcuts;
        this.listeners = new Map();
        this.conflictCheck();
    }
    
    // ショートカット登録
    register(action, callback, context = null) {
        const key = this.shortcuts[action];
        if (!key) {
            console.warn(`Shortcut "${action}" not defined in config`);
            return;
        }
        
        this.listeners.set(action, { callback, context, key });
    }
    
    // 競合検出
    conflictCheck() {
        const used = new Set();
        for (const [action, key] of Object.entries(this.shortcuts)) {
            if (used.has(key)) {
                console.warn(`Shortcut conflict: "${key}" is used multiple times`);
            }
            used.add(key);
        }
    }
    
    // キーイベント処理
    handleKeyEvent(e) {
        const pressedKey = this.normalizeKey(e);
        
        for (const [action, listener] of this.listeners) {
            if (listener.key === pressedKey) {
                e.preventDefault();
                listener.callback.call(listener.context, e);
                break;
            }
        }
    }
    
    // キー正規化
    normalizeKey(e) {
        const parts = [];
        if (e.ctrlKey) parts.push('ctrl');
        if (e.shiftKey) parts.push('shift');
        if (e.altKey) parts.push('alt');
        parts.push(e.code.toLowerCase());
        return parts.join('+');
    }
}
Phase 3: 各ファイルの修正
timeline-ui.js の修正
javascript// Before
setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && e.shiftKey) { ... }
    });
}

// After
setupKeyboardShortcuts() {
    const sm = window.TegakiShortcutManager;
    
    sm.register('playPause', () => this.togglePlayStop(), this);
    sm.register('toggleRepeat', () => this.toggleRepeat(), this);
    sm.register('previousCut', () => this.goToPreviousCutSafe(), this);
    sm.register('nextCut', () => this.goToNextCutSafe(), this);
    sm.register('addCut', () => this.animationSystem.createNewEmptyCut(), this);
}
core-engine.js の修正
javascript// すべてのショートカットをShortcutManager経由に変更
setupKeyboardShortcuts() {
    const sm = window.TegakiShortcutManager;
    
    sm.register('undo', () => this.history.undo());
    sm.register('redo', () => this.history.redo());
    sm.register('brushTool', () => this.setTool('brush'));
    sm.register('eraserTool', () => this.setTool('eraser'));
    // ... すべて集約
}
Phase 4: 実装優先順位

高優先度

config.js にすべてのショートカット定義を追加
ShortcutManager クラスの作成
タイムライン関連ショートカットの移行


中優先度

ツール切替ショートカットの移行
レイヤー操作ショートカットの移行


低優先度

ショートカットカスタマイズUI（将来的に）
競合検出の視覚化



Phase 5: テスト項目

 すべてのショートカットが config.js から読み込まれる
 既存の動作が保持される
 タイムライン非表示時はタイムライン関連ショートカットが無効
 ショートカット競合が検出される
 複数修飾キーの組み合わせが正しく動作

実装上の注意点

コンテキスト依存の処理

タイムライン表示時のみ有効なショートカット
ツール選択時のみ有効なショートカット
→ register() に条件関数を追加


後方互換性

段階的移行を可能にする
旧実装と新実装の並行稼働期間を設ける


デバッグ支援

ShortcutManager.debug() でアクティブなショートカット一覧表示
競合警告をコンソールに出力



この計画に従って実装すれば、ショートカット管理が一元化され、保守性が大幅に向上します。