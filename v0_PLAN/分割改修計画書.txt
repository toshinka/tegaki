core-engine.js 分割改修計画書
1. 概要と目的
core-engine.js（現在約2000行）を以下の3つのシステムファイルに分割：

camera-system.js - カメラ操作（パン・ズーム・座標変換）
layer-system.js - レイヤー管理（作成・削除・変形・並べ替え）
drawing-clipboard.js - クリップボード機能（コピー・ペースト・選択範囲）

制約: index.htmlのscript読み込み順を変更せず、既存の動作を100%維持する。
2. フォルダ構造
/
├── index.html
├── config.js
├── coordinate-system.js
├── core-runtime.js
├── ui-panels.js
├── core-engine.js        ← 改修対象
└── systems/              ← 新規作成
 　     ├── camera-system.js
   　   ├── layer-system.js
   　   └── drawing-clipboard.js
3. グローバル登録契約
3.1 登録メカニズム
javascript// core-engine.js 冒頭に追加
window.TegakiSystems = {
  _registry: {},
  _pending: [],
  Register: function(name, impl) {
    this._registry[name] = impl;
    if (this._onRegister) this._onRegister(name, impl);
  },
  get: function(name) { 
    return this._registry[name]; 
  },
  waitFor: function(names, callback) {
    const check = () => {
      if (names.every(n => this._registry[n])) {
        callback();
      } else {
        setTimeout(check, 10);
      }
    };
    check();
  }
};
3.2 動的ロード（core-engine.js内）
javascript// initTegaki() の最初に追加
function loadSystems(callback) {
  const scripts = [
    'js/systems/camera-system.js',
    'js/systems/layer-system.js', 
    'js/systems/drawing-clipboard.js'
  ];
  
  let loaded = 0;
  scripts.forEach(src => {
    const script = document.createElement('script');
    script.src = src;
    script.onload = () => {
      loaded++;
      if (loaded === scripts.length) callback();
    };
    document.head.appendChild(script);
  });
}

// 初期化フロー
loadSystems(() => {
  TegakiSystems.waitFor(['CameraSystem', 'LayerSystem', 'ClipboardSystem'], () => {
    // 既存のinitTegaki処理を継続
  });
});
4. 座標変換API統一仕様
4.1 命名規則（厳格）
javascriptwindow.Tegaki.Coords = {
  // DOM座標 → ワールド座標
  screenToWorld: function(point) { },
  
  // ワールド座標 → DOM座標
  worldToScreen: function(point) { },
  
  // ワールド座標 → ローカル座標
  worldToLocal: function(container, point) { },
  
  // ローカル座標 → ワールド座標
  localToWorld: function(container, point) { }
};
4.2 実装（PixiJS v8.13準拠）
javascript// camera-system.js内で実装
screenToWorld: function(screenPoint) {
  const bounds = app.canvas.getBoundingClientRect();
  const x = (screenPoint.x - bounds.left) * (app.canvas.width / bounds.width);
  const y = (screenPoint.y - bounds.top) * (app.canvas.height / bounds.height);
  
  // PixiJS v8.13: toLocal(point, from, result)
  return app.stage.toLocal({x, y}, app.renderer.events.rootBoundary);
}
5. EventBus統一仕様
5.1 実装（core-engine.js）
javascriptwindow.Tegaki.EventBus = {
  _handlers: {},
  
  on: function(event, handler) {
    if (!this._handlers[event]) this._handlers[event] = [];
    this._handlers[event].push(handler);
  },
  
  emit: function(event, data) {
    const handlers = this._handlers[event];
    if (handlers) handlers.forEach(h => h(data));
  },
  
  off: function(event, handler) {
    const handlers = this._handlers[event];
    if (handlers) {
      const idx = handlers.indexOf(handler);
      if (idx >= 0) handlers.splice(idx, 1);
    }
  }
};
5.2 イベント命名規則

layer.created - レイヤー作成時
layer.removed - レイヤー削除時
layer.transformed - 変形時
layer.reordered - 順序変更時
camera.moved - カメラ移動時
clipboard.copied - コピー時
clipboard.pasted - ペースト時

6. 各システムAPI仕様
6.1 CameraSystem
javascriptconst CameraSystem = {
  init: function(app, stage) { },
  
  // 基本操作
  panTo: function(x, y) { },
  zoomTo: function(scale, centerPoint) { },
  resetView: function() { },
  
  // 状態取得
  getTransform: function() { return {x, y, scale}; },
  
  // 座標変換（Tegaki.Coordsに委譲）
  screenToWorld: function(point) { },
  worldToScreen: function(point) { }
};
6.2 LayerSystem
javascriptconst LayerSystem = {
  init: function(app, rootContainer) { },
  
  // レイヤー操作
  createLayer: function(id, options) { },
  removeLayer: function(id) { },
  getLayer: function(id) { },
  getAllLayers: function() { },
  
  // 順序管理
  moveLayer: function(id, newIndex) { },
  swapLayers: function(id1, id2) { },
  
  // アクティブレイヤー
  setActiveLayer: function(id) { },
  getActiveLayer: function() { },
  
  // 変形（アニメツール対応）
  transformLayer: function(id, transform) {
    // transform = {x, y, rotation, scaleX, scaleY, flipX, flipY}
  },
  
  // シリアライズ
  serialize: function() { },
  deserialize: function(data) { }
};
6.3 ClipboardSystem
javascriptconst ClipboardSystem = {
  init: function(app, layerSystem) { },
  
  // 基本操作
  copy: function(bounds) { },
  cut: function(bounds) { },
  paste: function(position) { },
  
  // 状態管理
  hasContent: function() { },
  clear: function() { },
  
  // シリアライズ
  serialize: function() { },
  deserialize: function(data) { }
};
7. 移行手順（段階的実行）
Phase 1: 準備（30分）

js/systems/フォルダ作成
3つの空システムファイル作成（Register呼び出しのみ）
core-engine.jsにローダー追加

Phase 2: CameraSystem移行（1時間）

カメラ関連関数を抽出
座標変換APIを統一
グローバル参照をinit経由に変更

Phase 3: LayerSystem移行（2時間）

レイヤー管理関数を抽出
Container操作をPixiJS v8.13準拠に
EventBus経由のイベント発火

Phase 4: ClipboardSystem移行（1時間）

クリップボード関数を抽出
LayerSystemとの連携確立

Phase 5: 統合テスト（30分）

全機能動作確認
後方互換性確認

8. PixiJS v8.13固有の注意点
8.1 Container操作
javascript// 正しい: v8.13のaddChildAt
container.addChildAt(child, index);

// 間違い: 古いsetChildIndex
// container.setChildIndex(child, index); // v8では削除
8.2 座標変換
javascript// v8.13: toLocal/toGlobalの引数順
point.toLocal(from, to, result);

// 間違い: v7の引数順
// container.toLocal(point); // v8では引数が違う
8.3 イベントシステム
javascript// v8.13: EventSystemを使用
app.renderer.events.domElement;

// 間違い: InteractionManagerは削除
// app.renderer.plugins.interaction; // v8には存在しない
9. 後方互換性保証
9.1 ラッパー関数（core-engine.js内）
javascript// 既存のグローバル関数を維持
window.panCamera = function(x, y) {
  TegakiSystems.get('CameraSystem').panTo(x, y);
};

window.createLayer = function(options) {
  return TegakiSystems.get('LayerSystem').createLayer(options);
};
9.2 既存変数の維持
javascript// 既存のグローバル変数は維持
window.App = app;
window.Tegaki.stage = stage;
window.Tegaki.renderer = renderer;
10. 検証チェックリスト

 file://でエラーなし
 描画・消しゴム動作
 レイヤー追加/削除/並べ替え
 コピー&ペースト
 カメラパン/ズーム
 座標変換の正確性
 保存/読み込み
 キーボードショートカット
 UI応答性

11. 禁止事項の確認

❌ フォールバック処理なし
❌ エラー隠蔽なし
❌ ユーザー向けエラー演出なし
❌ 二重実装なし
❌ console.logは最小限

12. 実装優先順位

必須: グローバル登録メカニズム
必須: 座標変換API統一
重要: EventBus実装
重要: LayerSystem（アニメツール準備）
標準: CameraSystem
標準: ClipboardSystem

この計画書に従って実装することで、既存機能を100%維持しながら、AIにとって可読性が高く、将来のアニメーション機能拡張に対応できる構造になります。

1) 改修方針（要約）

目的：core-engine.js の機能を camera-system.js / layer-system.js / drawing-clipboard.js に分割して責務を明確化。既存の動作（分割前）と完全互換を維持する。

制約：index.html の <script> 順は変更しない。モジュールは使わない。新ファイルは core-engine.js 側で 動的に読み込む（既存の global 名前空間を壊さない）。

互換性の鍵：グローバル登録契約（registration handshake） を設ける。新ファイルは window.TegakiSystems に自身を登録し、core-engine.js はそれを待って初期化する。

イベント連携：EventBus（シンプルな publish/subscribe シングルトン）を全システムで使う。名前空間付きイベント（例: layer.changed）を運用する。

座標系：画面（スクリーン）⇄ワールド⇄ローカル の変換 API を厳密に定義。Pixi の toGlobal() / toLocal() を基本にする。
pixijs.com

2) 推奨フォルダ構成

（プロジェクトルートの例）

├── index.html
├── config.js
├── coordinate-system.js
├── core-runtime.js
├── ui-panels.js
├── core-engine.js        ← 改修対象
└── systems/              ← 新規作成
 　     ├── camera-system.js
   　   ├── layer-system.js
   　   └── drawing-clipboard.js


理由：機能ごとに /js/systems に集約。AIが読む時に責務が明確で、差分・PR 管理も楽。

3) グローバル契約（必須） — 仕様（短）

グローバル名前空間

window.TegakiSystems = window.TegakiSystems || {}

各 system ファイルは起動時に window.TegakiSystems.Register(name, implementation) を呼ぶ。

core-engine 側の期待

core-engine.js は TegakiSystems の ready() を待ち、init フローで CameraSystem.init(app, deps) 等を呼ぶ。

既存の public API（例： window.App や window.Tegaki.*）は引き続き同じ名前で提供する（後方互換）。

4) EventBus API（全体で共通）

実装（シンプル）

// EventBus: simple pub/sub
window.Tegaki = window.Tegaki || {};
window.Tegaki.EventBus = (function(){
  const handlers = {};
  return {
    on: (evt, fn)=> { (handlers[evt]||(handlers[evt]=[])).push(fn); },
    off: (evt, fn)=> { if(!handlers[evt]) return; handlers[evt]=handlers[evt].filter(f=>f!==fn); },
    emit: (evt, data)=> { (handlers[evt]||[]).slice().forEach(f=>{ try{ f(data); }catch(e){console.warn(e);} }); }
  };
})();


命名例：layer.created, layer.reordered, camera.panned, clipboard.paste など。

5) 座標変換 API（厳格に定義：重要）

提供するトップレベル関数（core-engine または coordinate-system.js に委譲）

Tegaki.Coords = {
  screenToWorld: function(pointScreen){ /* {x,y} in DOM pixels -> world coordinates */ },
  worldToScreen: function(pointWorld){ /* inverse */ },
  toLocal: function(targetDisplayObject, pointWorld){ /* point in world -> local of target */ },
  toGlobal: function(displayObject, pointLocal){ /* point in local -> world */ }
};


実装ノート：

基本は Pixi の displayObject.toLocal() / displayObject.toGlobal() を使う。Pixi v8 の API に従うこと。
pixijs.com
+1

screenToWorld は <canvas> DOM の boundingClientRect とアプリの resolution / renderer.view のスケールを使ってキャンバス内ピクセルを求め、app.stage.toLocal() でワールドに変換する（例コードは下方に記載）。

6) LayerSystem 公開 API（必読）

LayerSystem は Pixi Container をラップし、レイヤーごとの metadata と transform を持つシステムにします。命名を厳格に。

Public methods:

LayerSystem.init({app, rootContainer}) — 初期化

LayerSystem.createLayer(id, {name, zIndex, visible=true}) -> layer — layer は object {id, name, container: PIXI.Container, meta: {...}}

LayerSystem.getLayer(id) -> layer

LayerSystem.removeLayer(id)

LayerSystem.moveLayer(id, newIndex) — z-order を変える（内部は container.addChildAt などを使用）。

LayerSystem.setActiveLayer(id)

LayerSystem.transformLayer(id, {x,y,rotation,scaleX,scaleY,flipX,flipY}) — flip は scaleX *= -1 の代替として管理。flipX/flipY をメタとして保つ。

LayerSystem.exportLayerTexture(id) -> Promise<HTMLCanvasElement | PIXI.Texture>

LayerSystem.serialize() / LayerSystem.deserialize(data) — 保存/復元用

Events emitted via EventBus: layer.created, layer.removed, layer.reordered, layer.updated, layer.activeChanged.

内部ルール：

各レイヤーの container は必ず layer.container.sortableChildren = true（必要に応じて）にするか、rootContainer の子として順序管理する（Pixi の標準メソッドを使用）。
pixijs.com

レイヤーの transform 操作は全て LayerSystem.transformLayer を経由する。UI / キーボード操作はここを叩くのみ。

7) Drawing Clipboard API（公開）

用途：選択領域のコピー/ペースト（bitmap / vector 兼用）、および一時保存。

Public methods:

Clipboard.init({app, layerSystem})

Clipboard.copySelection(bounds, options) -> Promise<clipboardId> — 現在アクティブレイヤーから矩形領域を切り取り or コピー（copy only）

Clipboard.pasteAt(clipboardId, x, y, options) -> returnedObject — 新しいオブジェクトをレイヤーへ追加

Clipboard.clear()

Clipboard.list() — 保持している項目一覧

Clipboard.serialize() / Clipboard.deserialize() — プロジェクト保存

実装ノート：

実体は Pixi RenderTexture を使う（app.renderer.generateTexture(container, options)）か Canvas へ描画し保存。静的な画像クリップは renderTexture を推奨（パフォーマンスと互換性）。
pixijs.download

8) core-engine.js に加える変更（要点＋コード雛形）

方針：最小限の追加で新ファイルを動的読み込みし、登録完了後に初期化する。

1. loader helper（core-engine.js に追加）

(function(){
  window.TegakiSystems = window.TegakiSystems || {
    _registry: {},
    Register: function(name, impl){ this._registry[name]=impl; if(this._onRegister) this._onRegister(name, impl); },
    get: function(name){ return this._registry[name]; },
    readyWhen: function(namesArray, cb){
      const missing = namesArray.filter(n=>!this._registry[n]);
      if(missing.length===0) return cb();
      // set up a watcher
      this._onRegister = (name, impl)=>{
        const stillMissing = namesArray.filter(n=>!this._registry[n]);
        if(stillMissing.length===0){ this._onRegister=null; cb(); }
      };
    }
  };

  function loadScriptOnce(url, cb){
    if(document.querySelector('script[src="'+url+'"]')) return cb && cb();
    const s = document.createElement('script'); s.src = url; s.onload = ()=>cb && cb(); s.onerror = ()=>{ console.error('script load fail',url); cb && cb(new Error('load fail')); }; document.head.appendChild(s);
  }

  // call from core init
  window.TegakiSystems.Loader = { loadSystemFiles: function(list, done){
    let remain = list.length;
    if(remain===0) return done();
    list.forEach(u=> loadScriptOnce(u, ()=>{ remain--; if(remain===0) done(); }));
  }};

})();


2. core-engine の init に組み込む

起動フロー先頭で TegakiSystems.Loader.loadSystemFiles(['/js/systems/camera-system.js', '/js/systems/layer-system.js', '/js/systems/drawing-clipboard.js'], ()=> { TegakiSystems.readyWhen(['CameraSystem','LayerSystem','Clipboard'], ()=>{ /* now call init of each */ }); });

既存の window.App API（もし存在しているなら）を init の引数で渡す。

注意：file:// 環境なら相対パスで <script> を差し込むのが最も確実。fetch+eval より安全で同一起源問題も起きにくい。

9) 新規 system ファイルのテンプレ（短縮版）

/js/systems/camera-system.js

(function(){
  const CameraSystem = {
    name: 'CameraSystem',
    init: function(opts){
      this.app = opts.app;
      this.stage = opts.stage;
      // camera root container and camera state
      this.camera = new PIXI.Container();
      this.stage.addChild(this.camera);
      this.state = {x:0,y:0,zoom:1};
    },
    panTo: function(x,y){ /* perform pan, set transforms */ },
    zoomTo: function(z, center){ /* perform zoom */ },
    getWorldPosition: function(){ return {...this.state}; }
  };

  window.TegakiSystems.Register('CameraSystem', CameraSystem);
})();


/js/systems/layer-system.js と drawing-clipboard.js も同様の形で Register('LayerSystem', ...) Register('Clipboard', ...) を行う。

10) 具体的移行手順（ステップバイステップ）

作業ブランチを作る（git があれば）。

プロジェクトに /js/systems/ フォルダを作成。

camera-system.js, layer-system.js, drawing-clipboard.js の骨格ファイルを追加（上のテンプレを使用）。各ファイルは Register を呼ぶだけの自己完結型にする。

core-engine.js の冒頭に TegakiSystems loader helper（上記）を追加。既存 init の呼び出し前に Loader.loadSystemFiles([...], () => { TegakiSystems.readyWhen([...], ()=>{ /* existing init continues */ }); }); を挿入。

既存の core-engine の大きな関数群は触らず、初期化フローの先頭で読み出し・登録を行う。

Layer/Camera/Clipboard のロジックを一つずつ core-engine.js から新ファイルへ抜き出す。抜き出す際は：

グローバル変数参照は opts で受け渡す（例：app、renderer、rootContainer）。直接 window.* を参照しないようにして可搬性を高める。

既存の関数名は public API に合わせて LayerSystem.createLayer 等に変更。古い呼び出し場所が残る場合はラッパー関数を core-engine.js に残し後方互換を提供する（推奨）。

unit/regression テスト：新旧と同じ操作（描画、レイヤー移動、コピー&ペースト、カメラ操作）を行い、挙動が同一であることを検証。

console.log を減らす（warn / error のみ残す） — AI での検索性を優先。

11) 検証チェックリスト（必ず全部確認）

 ページを file:// で開いて、エラーが出ない（console の uncaught errors がゼロ）

 既存の描画ツールで「描画」「消しゴム」「レイヤー追加/削除/並べ替え」「選択範囲のコピー＆ペースト」が動作する

 カメラ（パン/ズーム）で座標のズレが発生しない（座標変換関数を使って確認）

 console.warn が発生していない（除外している最小ログ以外）

 TegakiSystems に CameraSystem, LayerSystem, Clipboard が登録されている（console.log(Object.keys(window.TegakiSystems._registry)) で確認）

 レイヤー移動（moveLayer）で swapChildren 依存のバグが出ない（zIndex / addChildAt を利用）

 保存→ロード（serialize/deserialize）で描画内容・レイヤー状態が復元される

12) Pixi v8 に関する注意点（参考）

座標変換は Pixi の toLocal() / toGlobal() を信頼して使う（正しく使えばローカル⇄グローバルの変換はこれらが担当する）。実装は docs の例に従うこと。
pixijs.com

レイヤーの順序変更は Container.addChildAt() / swapChildren() を使うとよい。cacheAsTexture で静的なレイヤーを最適化できるが、頻繁に更新するレイヤーは使わない方が良い。
pixijs.com

Pixi v8.13 系は活発にアップデートが入るため、将来的な小バージョンの API 変化に注意（8.13.x が安定）。公式のバージョンページ・リリースノートを参照する。
pixijs.com
+1

13) 具体コード：screenToWorld の実装サンプル（必須）
// assume app is PIXI.Application instance
Tegaki.Coords = Tegaki.Coords || {};
Tegaki.Coords.screenToWorld = function(screenPoint){
  const canvas = app.view;
  const rect = canvas.getBoundingClientRect();
  const x = (screenPoint.x - rect.left) * (canvas.width / rect.width);
  const y = (screenPoint.y - rect.top)  * (canvas.height / rect.height);
  // Stage is assumed to be app.stage or camera container depending on architecture
  // If you keep a camera container as root for world, use app.stage or cameraRoot accordingly:
  return app.stage.toLocal(new PIXI.Point(x, y)); // returns a PIXI.Point in world coords
};


備考：上の canvas.width / rect.width は HiDPI (devicePixelRatio) 対応のために必要。

14) 小さなコーディングスタイル規約（AI向け）

全て camelCase。例：createLayer, moveLayer, screenToWorld。関数の先頭は動詞。

グローバル変数は window.Tegaki* にまとめる（例：window.Tegaki.EventBus、window.Tegaki.Coords）。

ファイル内の top-level は IIFE で囲み、グローバル汚染を最小化。各システムは Register で露出。

コンソール出力は console.error と console.warn のみ最小限に。console.log は原則禁止。

ドキュメントは各ファイル冒頭に JSDoc 風の短い説明（3行以内）を入れる。

15) リスク／デバッグのポイント

script の相対パス誤り（file:// だと相対ルートが異なる場合がある） → core-engine.js の loader は new URL('./systems/camera-system.js', document.currentScript.src).href のようにして相対解決すると安全。

動的ロードで race condition が起きる場合は TegakiSystems.readyWhen() を用いて待つ（上記パターン）。

座標のズレはまず screenToWorld の devicePixelRatio と canvas の CSS サイズ確認から。StackOverflowの多くの例が参考になる（古い例もあるが基本は同じ）。
Stack Overflow
+1

16) 最後に：作業優先度（短いロードマップ）

systems フォルダ作成 + 3つの骨格ファイルを追加（2時間）。

core-engine.js に loader を差し込み、空の Register 呼び出しを待つ形で起動（1時間）。

LayerSystem の最小機能（create/get/move/setActive）を core-engine から切り出し（2〜3時間）。

CameraSystem と Clipboard を順に切り出し、テスト（各2時間程度）。

総合リグレッションテスト（1時間）。ログやエラーハンドリング調整（1時間）。

（上記は所要時間の目安で、あなたは「実行時間見積り」を求めていないため詳述は控えめにしました。）