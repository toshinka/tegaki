🎨 レイヤー変形システム改修計画書 Phase2a
座標系統一・編集モード初期化安全化対応
📋 現状問題の詳細分析
🚨 Critical Issue 1: 編集モード開始時の座標飛び
症状: V押下時にレイヤーが左上(0,0付近)に移動
根本原因:
javascript// 問題のあるコード（core-engine.js:L1089-1111）
updateActiveLayerTransform(property, value) {
    switch(property) {
        case 'x':
            transform.x = value;
            activeLayer.position.set(centerX + value, centerY + transform.y); // ❌問題
            break;
        case 'rotation':
            transform.rotation = value;
            activeLayer.pivot.set(centerX, centerY);  // ❌ 毎回pivot再設定
            activeLayer.position.set(centerX + transform.x, centerY + transform.y);
            activeLayer.rotation = value;
            break;
    }
}
原因分析:

enterLayerMoveMode() 時に既存のposition状態をtransform dataに反映していない
pivot設定が変形種別によって不整合
座標系の基準点が処理によって異なる

🚨 Critical Issue 2: XY移動後の回転軸ズレ
症状: XY移動後の回転軸が絵の中心になる（期待：カメラフレーム中央）
根本原因:
javascript// 問題のあるコード（core-engine.js:L1393-1420）
if (e.shiftKey) {
    // 基準点をカメラ中央に設定
    activeLayer.pivot.set(centerX, centerY);
    activeLayer.position.set(centerX + transform.x, centerY + transform.y);
    // ❌ transform.x, transform.y が累積されているため、実際の回転軸がズレる
}
🎯 設計原則・統一ルール定義
Coordinate System Rules (座標系統一ルール)
javascript/**
 * 座標系統一定義:
 * 
 * 1. CAMERA_CENTER: カメラフレーム中央座標 (CONFIG.canvas.width/2, CONFIG.canvas.height/2)
 *    - 全ての変形の基準点
 *    - pivot設定の固定基準
 * 
 * 2. TRANSFORM_DATA: 変形データ座標系
 *    - カメラ中央基準の相対座標 (-∞ to +∞)
 *    - 編集用の論理座標
 *    - 形式: { x: number, y: number, rotation: radian, scaleX: number, scaleY: number }
 * 
 * 3. DISPLAY_COORDINATES: 表示座標系
 *    - PixiJS実座標 (position/pivot/rotation/scale)
 *    - 計算式: position = CAMERA_CENTER + TRANSFORM_DATA.offset
 *    - pivot = CAMERA_CENTER (固定)
 * 
 * 4. INVARIANT_RULES (不変条件):
 *    - pivot は常に CAMERA_CENTER
 *    - 回転軸は常に CAMERA_CENTER
 *    - position = CAMERA_CENTER + transform offset
 */
Transform State Management (変形状態管理)
javascript/**
 * 変形状態の定義:
 * 
 * EDIT_MODE: 編集中状態
 *   - transform data: 編集中の累積値
 *   - display state: リアルタイム表示
 *   - 基準: スライダー値 = transform data
 * 
 * CONFIRMED_MODE: 確定済み状態  
 *   - transform data: 確定済み累積値
 *   - display state: 確定済み表示
 *   - 基準: 表示状態 = transform data
 * 
 * STATE_TRANSITION: 状態遷移
 *   CONFIRMED → EDIT: normalize → apply unified transform
 *   EDIT → CONFIRMED: preserve display state → update transform data
 */
🏗️ API設計・メソッド定義
Core Methods (コアメソッド定義)
1. 座標正規化メソッド
javascript/**
 * 現在の表示状態を変形データに正規化
 * @param {PIXI.Container} layer - 対象レイヤー
 * @returns {TransformData} 正規化された変形データ
 */
normalizeTransformFromDisplayState(layer) {
    const centerX = CONFIG.canvas.width / 2;
    const centerY = CONFIG.canvas.height / 2;
    
    return {
        x: layer.position.x - centerX,
        y: layer.position.y - centerY,
        rotation: layer.rotation,
        scaleX: layer.scale.x,
        scaleY: layer.scale.y
    };
}
2. 統一変形適用メソッド
javascript/**
 * 変形データを表示状態に統一適用
 * @param {PIXI.Container} layer - 対象レイヤー
 * @param {TransformData} transform - 変形データ
 * @param {boolean} preserveRotationCenter - 回転中心保持フラグ
 */
applyUnifiedTransform(layer, transform, preserveRotationCenter = true) {
    const centerX = CONFIG.canvas.width / 2;
    const centerY = CONFIG.canvas.height / 2;
    
    if (preserveRotationCenter) {
        // pivot を常にカメラ中央固定（回転軸統一）
        layer.pivot.set(centerX, centerY);
    }
    
    // position = 中央 + 変形オフセット
    layer.position.set(centerX + transform.x, centerY + transform.y);
    
    // rotation/scale 直接適用
    layer.rotation = transform.rotation;
    layer.scale.set(transform.scaleX, transform.scaleY);
}
3. 安全な編集モード初期化
javascript/**
 * 編集モード安全初期化（座標飛び防止）
 */
enterLayerMoveModeSafe() {
    if (this.isLayerMoveMode) return;
    
    const activeLayer = this.getActiveLayer();
    if (!activeLayer) return;
    
    // Step 1: 現在の表示状態を正規化
    const normalizedTransform = this.normalizeTransformFromDisplayState(activeLayer);
    
    // Step 2: 正規化データを保存
    this.layerTransforms.set(activeLayer.layerData.id, normalizedTransform);
    
    // Step 3: 統一変形を適用（座標系統一）
    this.applyUnifiedTransform(activeLayer, normalizedTransform);
    
    // Step 4: UI状態更新
    this.isLayerMoveMode = true;
    this.vKeyPressed = true;
    this.cameraSystem.setVKeyPressed(true);
    
    // Step 5: パネル・ガイドライン表示
    if (this.layerTransformPanel) {
        this.layerTransformPanel.classList.add('show');
        this.updateLayerTransformPanelValues();
    }
    this.cameraSystem.showGuideLines();
    this.updateCursor();
}
Data Flow Definition (データフロー定義)
mermaidgraph TD
    A[Display State] -->|normalizeTransformFromDisplayState| B[Transform Data]
    B -->|applyUnifiedTransform| C[Unified Display State]
    C -->|User Interaction| D[Modified Transform Data]
    D -->|Real-time Update| E[Live Display]
    E -->|Confirm V Key| F[Preserved Display State]
    F -->|Next Edit Mode| A
🔧 修正対象ファイル・メソッド
core-engine.js 修正箇所
1. LayerManager Class
修正メソッド:

enterLayerMoveMode() → enterLayerMoveModeSafe()
updateActiveLayerTransform() → 統一座標系対応
confirmLayerTransform() → 既存preserve機能維持

追加メソッド:

normalizeTransformFromDisplayState(layer)
applyUnifiedTransform(layer, transform, preserveRotationCenter)
getCanvasCenter() - DRY原則

2. 影響範囲
Direct Impact:

Line 1050-1200: LayerManager.updateActiveLayerTransform()
Line 1250-1300: LayerManager.enterLayerMoveMode()
Line 800-850: LayerManager.updateLayerTransformPanelValues()

Indirect Impact:

ClipboardSystem.getEffectiveTransform() - 座標系統一対応
Thumbnail生成 - pivot/position状態変更対応

🧪 テスト項目・検証ポイント
Regression Tests (リグレッションテスト)

非破壊編集: 回転→確定→再編集で状態維持
履歴機能: アンドゥ・リドゥの正常動作
コピー&ペースト: 変形状態の正確なコピー
サムネイル: レイヤー変形の正確な反映

New Feature Tests (新機能テスト)

座標飛び防止: V押下時の初期位置維持
回転軸統一: XY移動後もカメラ中央軸回転
スライダー整合性: 表示状態とUI値の一致

🎯 実装優先順位・Phase分け
Phase 2a-1: Critical Fix (緊急修正)
期間: 即座
内容:

座標飛び防止 (enterLayerMoveModeSafe())
基本座標系統一メソッド追加

Phase 2a-2: Rotation Center Fix (回転軸修正)
期間: Phase 2a-1完了後
内容:

回転軸カメラ中央固定化
applyUnifiedTransform() 完全統一

Phase 2a-3: Code Cleanup (コード整理)
期間: Phase 2a-2完了後
内容:

重複コード除去
統一API使用への置き換え

🚨 リスク要因・対策
High Risk

pivot変更によるサムネイル描画影響

対策: サムネイル生成時の一時的state保存・復元


既存レイヤーの座標系不整合

対策: 開始時の自動正規化処理



Medium Risk

パフォーマンス影響（正規化処理増加）

対策: 必要時のみ実行・キャッシュ活用



💡 改修アプローチ推奨
段階的修正 + 後方互換性維持を推奨
理由:

既存機能（非破壊編集・履歴）の安定稼働
個別検証・テストの実施可能性
問題発生時の切り分け・ロールバック容易性
Claude改修時の作業範囲明確化