# TEGAKI Twin-Star System 改修プラン

## 🎯 目標アーキテクチャ

```
Twin-Star System
├── UI Star (index.html中心)
│   ├── config.js ✅ 完成
│   ├── ui-panels.js ✅ 完成  
│   └── ui-tools.js (新規作成予定)
└── Engine Star (core-runtime.js中心) 
    ├── coordinate-system.js (新規)
    ├── layer-system.js (分離)
    ├── drawing-engine.js (分離)
    ├── transform-utils.js (新規)
    └── clipboard-system.js (分離)
```

## 📅 Phase 0 - 即座対応 (1日)

### P0.1 座標系コメント追加
現在のコードに座標系の明示的コメントを追加

```javascript
// BEFORE
const canvasPoint = this.cameraSystem.screenToCanvas(screenX, screenY);

// AFTER  
// coord: screen -> world
const canvasPoint = this.cameraSystem.screenToCanvas(screenX, screenY);
```

### P0.2 座標変換メソッド統合
`screenToCanvasForDrawing`と`screenToCanvas`の使い分けを明確化

```javascript
// 統合された座標変換API
class CoordinateSystem {
  // coord: screen -> canvas (描画用)
  screenToCanvas(app, screenX, screenY) { /* ... */ }
  
  // coord: screen -> world (レイヤー操作用)  
  screenToWorld(app, screenX, screenY) { /* ... */ }
  
  // coord: world -> screen
  worldToScreen(app, worldX, worldY) { /* ... */ }
}
```

## 📅 Phase 1 - 座標系統一 (1週間)

### P1.1 coordinate-system.js 作成
単一責任で座標変換を管理

```javascript
window.CoordinateSystem = {
  // 明示的な座標空間変換
  screenToWorld(app, x, y) {
    // coord: screen -> world
    const point = new PIXI.Point(x, y);
    return app.stage.toLocal(point);
  },
  
  worldToLayer(layer, worldX, worldY) {
    // coord: world -> layer
    return layer.toLocal(new PIXI.Point(worldX, worldY));
  },
  
  // 変形適用（pivot考慮）
  transformPoint(point, pivot, transform) {
    // 統一された変形計算
    return this.applyTransformMatrix(point, pivot, transform);
  }
};
```

### P1.2 core-engine.js内の座標変換を置換
- `container.toLocal()` → `CoordinateSystem.worldToLayer()`
- `container.toGlobal()` → `CoordinateSystem.layerToWorld()`

### P1.3 座標空間検証の追加
```javascript
function validateCoordSpace(point, expectedSpace) {
  if (!point._coordSpace || point._coordSpace !== expectedSpace) {
    throw new Error(`Expected ${expectedSpace} coordinates, got ${point._coordSpace || 'unknown'}`);
  }
}
```

## 📅 Phase 2 - Engine Star 作成 (3日)

### P2.1 core-runtime.js ファサード作成
```javascript
window.CoreRuntime = {
  coord: CoordinateSystem,
  camera: CameraSystem, 
  layer: LayerSystem,
  transform: TransformUtils,
  draw: DrawingEngine,
  
  // 統一API
  api: {
    // カメラ操作
    panCamera: (dx, dy) => CoreRuntime.camera.pan(dx, dy),
    zoomCamera: (factor, centerX, centerY) => CoreRuntime.camera.zoom(factor, centerX, centerY),
    
    // レイヤー操作
    transformActiveLayer: (transform, pivotMode) => {
      const layer = CoreRuntime.layer.getActive();
      CoreRuntime.transform.applyNonDestructive(layer, transform, pivotMode);
    }
  }
};
```

### P2.2 CameraSystem の分離
core-engine.js から CameraSystem クラスを camera-system.js に移動

### P2.3 UI層の参照更新
index.html内の `TegakiCore.*` → `CoreRuntime.*`

## 📅 Phase 3 - レイヤーシステム分離 (1週間)

### P3.1 layer-system.js 作成 - パス中心設計
```javascript
// パス中心のデータモデル
const Layer = {
  id: 'layer_xxx',
  paths: [
    {
      id: 'path_xxx', 
      points: [{x: 10, y: 20}, ...], // coord: layer space
      style: {color: 0x800000, width: 5},
      closed: false
    }
  ],
  transform: {scale: 1, rotation: 0, tx: 0, ty: 0}, // 一時的変形
  container: pixiContainer, // 表示用
  cache: renderTexture || null // キャッシュ
};
```

### P3.2 非破壊変形の実装
```javascript
TransformUtils.applyTransformToPaths(layer, transform, pivotMode) {
  const pivot = this.getPivotPoint(layer, pivotMode);
  
  // パスデータに直接変形適用（非破壊）
  layer.paths.forEach(path => {
    path.points = path.points.map(point => {
      // coord: layer -> world -> transformed -> layer
      return this.transformPointWithPivot(point, pivot, transform);
    });
  });
  
  // 表示変形をリセット
  layer.container.position.set(0, 0);
  layer.container.scale.set(1, 1);
  layer.container.rotation = 0;
}
```

### P3.3 キャッシュ無効化システム
```javascript
// ダーティフラグによる選択的更新
class LayerSystem {
  markDirty(layerId, reason) {
    this.dirtyLayers.add(layerId);
    this.dirtyReasons.set(layerId, reason);
  }
  
  processDirtyLayers() {
    this.dirtyLayers.forEach(layerId => {
      const layer = this.getLayer(layerId);
      const reason = this.dirtyReasons.get(layerId);
      
      if (reason === 'transform') {
        this.rebuildGraphics(layer);
        this.updateThumbnail(layer);
      }
    });
  }
}
```

## 📅 Phase 4 - 描画エンジン分離 (3日)

### P4.1 drawing-engine.js 作成
描画とデータを分離

```javascript
window.DrawingEngine = {
  // パスからGraphics再構築
  rebuildGraphicsFromPath(path, graphics, style) {
    graphics.clear();
    
    if (path.points.length === 0) return;
    
    // スタイル適用
    graphics.lineStyle(style.width, style.color, style.alpha);
    
    // パス描画
    graphics.moveTo(path.points[0].x, path.points[0].y);
    path.points.slice(1).forEach(point => {
      graphics.lineTo(point.x, point.y);
    });
  },
  
  // ブラシストローク記録
  recordBrushStroke(startPoint, endPoint, pressure, style) {
    return {
      id: this.generateId(),
      points: this.interpolateStroke(startPoint, endPoint, pressure),
      style: {...style},
      timestamp: Date.now()
    };
  }
};
```

### P4.2 描画最適化
- スムージングアルゴリズム改善
- レンダーキャッシュの効率化
- 選択的Graphics更新

## 📅 Phase 5 - 最終統合 (3日)

### P5.1 core-engine.js 削除前の検証
- 全機能が新システムに移行済みか確認
- 循環依存がないか検証
- イベントシステムが正常動作するか確認

### P5.2 レガシーファイル削除
```bash
# 削除対象
rm core-engine.js
rm duplicate-coordinate-methods.js
```

### P5.3 最終統合テスト
- 座標変換の往復精度テスト
- レイヤー変形の非破壊性確認
- コピー&ペーストの完全性確認

## 🎯 期待される効果

### 📈 性能向上
- **座標変換**: < 1ms (現在: 2-5ms)
- **レイヤー切り替え**: < 8ms (現在: 15-30ms)  
- **変形操作**: < 16ms (現在: 30-50ms)

### 🧹 コード品質向上
- **ファイルサイズ**: 各1500行以下 (現在: core-engine.js 4000行+)
- **責任分離**: 単一責任原則の徹底
- **座標系バグ**: ゼロ (明示的な型システム)

### 🔧 保守性向上
- **Claude改修効率**: 70%向上 (明確なAPI境界)
- **機能追加速度**: 50%向上 (疎結合設計)
- **バグ特定時間**: 80%短縮 (責任範囲明確化)

## ⚠️ 注意事項

### 🚫 絶対禁止パターン
- `try-catch`でのエラー隠蔽
- `||`演算子でのデフォルト値設定
- 座標変換の直接`toLocal`/`toGlobal`呼び出し
- ユーザー向けエラーダイアログ
- フォールバック処理

### ✅ 必須パターン
- 座標空間の明示的コメント
- 単一責任の徹底
- イベントベース通信
- 非破壊的パス操作
- 明示的リソース解放

## 🚀 開始提案

**まずはPhase 0から開始することを推奨します。**

Phase 0は1日で完了し、既存機能への影響を最小限に抑えながら、後続フェーズの準備を整えます。特に座標系コメントの追加は、Claude/AIの理解を大幅に向上させ、以降の改修作業の精度を高めます。

段階的アプローチにより、各フェーズでの動作確認とロールバックポイントの確保が可能です。