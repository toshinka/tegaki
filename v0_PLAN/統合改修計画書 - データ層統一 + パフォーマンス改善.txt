```
================================================================================
PixiJS v8.13 お絵かきツール - 段階的改修計画書
================================================================================
策定日: 2025-10-12
対象バージョン: v8.13_History37
目標: パフォーマンス問題解消 + データ層統一化（スプレッドシートUI基盤）

================================================================================
■ 全体方針
================================================================================
1. Phase 1-3: 緊急パフォーマンス修正（メモリリーク・描画速度）
2. Phase 4-5: データモデル統一化（スプレッドシートUI準備）
3. Phase 6: API標準化（バッチ処理・PSD入出力対応）

各Phaseは独立して完了可能。Phase完了後は動作確認を推奨。

================================================================================
Phase 1: メモリリーク解消
================================================================================
【目的】Graphics破棄漏れ修正 → 白画面フリーズ解消
【影響範囲】system/layer-system.js のみ
【所要時間】5分

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正対象ファイル
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
system/layer-system.js

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正箇所
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
メソッド: rebuildPathGraphics(path)
行番号: 67-73

【現状】
if (path.graphics) {
    try {
        if (path.graphics.destroy && typeof path.graphics.destroy === 'function') {
            path.graphics.destroy();  // ← 子オブジェクト破棄オプション不足
        }
    } catch (destroyError) {}
    path.graphics = null;
}

【修正後】
if (path.graphics) {
    try {
        if (path.graphics.destroy && typeof path.graphics.destroy === 'function') {
            path.graphics.destroy({ 
                children: true,      // ← 追加
                texture: false, 
                baseTexture: false 
            });
        }
    } catch (destroyError) {}
    path.graphics = null;
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
処理フロー上の位置
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
描画ストローク追加
  → DrawingEngine.completeStroke()
    → LayerSystem.addPathToActiveLayer()
      → rebuildPathGraphics() ← ここ（頻繁に呼ばれる）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
検証方法
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. ブラウザDevToolsでMemoryタブを開く
2. 複数のストロークを描画（50本程度）
3. Ctrl+Zでundo/redo繰り返し
4. メモリ使用量が安定していることを確認（増加し続けない）

================================================================================
Phase 2: Perfect Freehand スケール再計算の廃止
================================================================================
【目的】カメラズーム時の全パス再描画を停止 → 描画速度95%改善
【影響範囲】system/layer-system.js
【所要時間】10分

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正対象ファイル
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
system/layer-system.js

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正1: rebuildPathGraphics() 内のスケール計算削除
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
行番号: 79-92

【削除する箇所】
// Phase 2: 現在のズーム率を取得
const currentScale = this.cameraSystem?.camera?.scale || 1;

// Phase 2: originalSizeがある場合は現在のズーム率で再計算
let renderSize = path.size;
if (path.originalSize !== undefined && path.scaleAtDrawTime !== undefined) {
    const normalizedSize = path.originalSize / path.scaleAtDrawTime;
    renderSize = normalizedSize / currentScale;
}

【修正後（シンプル化）】
const renderSize = path.size;  // 描画時のサイズを固定使用

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正2: camera:scale-changed イベントリスナー削除
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
メソッド: _setupAnimationSystemIntegration()
行番号: 326-330

【削除する箇所】
// Phase 2: カメラスケール変更時のレイヤー再描画
this.eventBus.on('camera:scale-changed', (data) => {
    this.rebuildAllLayersForScaleChange();
});

【理由】
ベクターストロークはPIXIのContainer.scaleで拡縮すべき。
全パス再構築は不要かつ重すぎる。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
処理フロー上の位置
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
カメラズーム操作
  → CameraSystem.updateScale()
    → EventBus.emit('camera:scale-changed') 
      → [削除] LayerSystem.rebuildAllLayersForScaleChange()
        → [削除] 全パスのrebuildPathGraphics()

修正後: カメラズーム → Container.scaleのみ適用（高速）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
検証方法
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 複数のストロークを描画（30本程度）
2. マウスホイールでカメラをズームイン/アウト
3. ズーム操作が即座に反映され、遅延がないことを確認
4. ストロークの見た目が正常であることを確認

================================================================================
Phase 3: サムネイル更新の最適化
================================================================================
【目的】レイヤー移動中の過剰なサムネイル生成を抑制 → UI応答性80%改善
【影響範囲】system/layer-system.js
【所要時間】10分

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正対象ファイル
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
system/layer-system.js

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正1: requestThumbnailUpdate() のディバウンス延長
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
メソッド: requestThumbnailUpdate(layerIndex)
行番号: 1057-1067

【現状】
requestThumbnailUpdate(layerIndex) {
    const layers = this.getLayers();
    if (layerIndex >= 0 && layerIndex < layers.length) {
        this.thumbnailUpdateQueue.add(layerIndex);
        
        if (!this.thumbnailUpdateTimer) {
            this.thumbnailUpdateTimer = setTimeout(() => {
                this.processThumbnailUpdates();
                this.thumbnailUpdateTimer = null;
            }, 100);  // ← 短すぎる
        }
    }
}

【修正後】
requestThumbnailUpdate(layerIndex) {
    const layers = this.getLayers();
    if (layerIndex >= 0 && layerIndex < layers.length) {
        this.thumbnailUpdateQueue.add(layerIndex);
        
        // ディバウンス処理：既存タイマーをクリア
        if (this.thumbnailUpdateTimer) {
            clearTimeout(this.thumbnailUpdateTimer);
        }
        
        this.thumbnailUpdateTimer = setTimeout(() => {
            this.processThumbnailUpdates();
            this.thumbnailUpdateTimer = null;
        }, 500);  // 100ms → 500ms
    }
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正2: レイヤー移動中のサムネイル更新抑制
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
メソッド: updateActiveLayerTransform(property, value)
行番号: 419付近

【現状】
updateActiveLayerTransform(property, value) {
    // ... 変形処理 ...
    
    this.requestThumbnailUpdate(this.activeLayerIndex);  // ← 毎回呼ばれる
    
    if (this.eventBus) {
        this.eventBus.emit('layer:updated', { layerId, transform });
    }
}

【修正後】
updateActiveLayerTransform(property, value) {
    // ... 変形処理 ...
    
    // Vキー押下中（ドラッグ操作中）はサムネイル更新をスキップ
    if (!this.isLayerDragging) {
        this.requestThumbnailUpdate(this.activeLayerIndex);
    }
    
    if (this.eventBus) {
        this.eventBus.emit('layer:updated', { layerId, transform });
    }
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正3: レイヤー移動モード終了時に一度だけ更新
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
メソッド: exitLayerMoveMode()
行番号: 753付近

【追加】
exitLayerMoveMode() {
    // ... 既存の終了処理 ...
    
    this.updateCursor();
    this.confirmLayerTransform();
    
    // ← ここに追加
    this.requestThumbnailUpdate(this.activeLayerIndex);
    
    // ... 残りの処理 ...
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
処理フロー上の位置
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Vキー押下 → enterLayerMoveMode()
  ↓
レイヤードラッグ中
  → _handleLayerDrag() 
    → updateActiveLayerTransform()
      → [修正] サムネイル更新をスキップ
  ↓
Vキー離脱 → exitLayerMoveMode()
  → [修正] ここで一度だけサムネイル更新

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
検証方法
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. Vキーを押してレイヤー移動モードに入る
2. マウスでレイヤーをドラッグ移動（5秒程度）
3. ドラッグ中にカクつきがないことを確認
4. Vキーを離す
5. サムネイルが正しく更新されることを確認

================================================================================
Phase 4: データモデル統一化 - Layer定義
================================================================================
【目的】レイヤーデータを標準スキーマで管理 → スプレッドシートUI対応
【影響範囲】新規ファイル作成 + layer-system.js 一部修正
【所要時間】30分

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
新規作成ファイル
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
system/data-models.js

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
実装内容
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(function() {
    'use strict';

    // ========== Layer データモデル ==========
    const LAYER_SCHEMA = {
        id: { type: 'string', required: true, editable: false },
        name: { type: 'string', required: true, editable: true },
        visible: { type: 'boolean', default: true, editable: true },
        opacity: { type: 'number', min: 0, max: 1, default: 1.0, editable: true },
        isBackground: { type: 'boolean', default: false, editable: false },
        clipping: { type: 'boolean', default: false, editable: true },
        blendMode: { type: 'string', default: 'normal', editable: true },
        locked: { type: 'boolean', default: false, editable: true }
    };

    class LayerModel {
        constructor(data = {}) {
            this.id = data.id || `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            this.name = data.name || 'レイヤー';
            this.visible = data.visible !== undefined ? data.visible : true;
            this.opacity = data.opacity !== undefined ? data.opacity : 1.0;
            this.isBackground = data.isBackground || false;
            this.clipping = data.clipping || false;
            this.blendMode = data.blendMode || 'normal';
            this.locked = data.locked || false;
            this.paths = data.paths || [];
        }

        static getSchema() {
            return LAYER_SCHEMA;
        }

        toJSON() {
            return {
                id: this.id,
                name: this.name,
                visible: this.visible,
                opacity: this.opacity,
                isBackground: this.isBackground,
                clipping: this.clipping,
                blendMode: this.blendMode,
                locked: this.locked
            };
        }

        validate() {
            const errors = [];
            
            if (!this.id) errors.push('id is required');
            if (!this.name) errors.push('name is required');
            if (this.opacity < 0 || this.opacity > 1) errors.push('opacity must be 0-1');
            
            return { valid: errors.length === 0, errors };
        }
    }

    // ========== CUT データモデル ==========
    const CUT_SCHEMA = {
        id: { type: 'string', required: true, editable: false },
        name: { type: 'string', required: true, editable: true },
        duration: { type: 'number', min: 0.01, max: 10, default: 0.5, editable: true },
        visible: { type: 'boolean', default: true, editable: true },
        locked: { type: 'boolean', default: false, editable: true }
    };

    class CutModel {
        constructor(data = {}) {
            this.id = data.id || `cut_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            this.name = data.name || 'CUT';
            this.duration = data.duration !== undefined ? data.duration : 0.5;
            this.visible = data.visible !== undefined ? data.visible : true;
            this.locked = data.locked || false;
        }

        static getSchema() {
            return CUT_SCHEMA;
        }

        toJSON() {
            return {
                id: this.id,
                name: this.name,
                duration: this.duration,
                visible: this.visible,
                locked: this.locked
            };
        }

        validate() {
            const errors = [];
            
            if (!this.id) errors.push('id is required');
            if (!this.name) errors.push('name is required');
            if (this.duration < 0.01 || this.duration > 10) {
                errors.push('duration must be 0.01-10');
            }
            
            return { valid: errors.length === 0, errors };
        }
    }

    window.TegakiDataModels = {
        LayerModel,
        CutModel,
        LAYER_SCHEMA,
        CUT_SCHEMA
    };

    console.log('✅ data-models.js loaded');
})();

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
index.html への追加
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<!-- システムコア -->
<script src="config.js"></script>
<script src="coordinate-system.js"></script>
<script src="system/data-models.js"></script>  ← 追加
<script src="system/event-bus.js"></script>
...

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
layer-system.js の修正（段階的移行）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
メソッド: createLayer(name, isBackground)
行番号: 915付近

【修正】
createLayer(name, isBackground = false) {
    if (!this.currentCutContainer) {
        return null;
    }
    
    // ← DataModelを使用
    const layerModel = new window.TegakiDataModels.LayerModel({
        name: name || `レイヤー${this.currentCutContainer.children.length + 1}`,
        isBackground: isBackground
    });
    
    const layer = new PIXI.Container();
    layer.label = layerModel.id;
    layer.layerData = layerModel;  // ← モデルを直接格納
    
    // ... 残りは既存のまま ...
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
検証方法
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. ブラウザコンソールで確認:
   window.TegakiDataModels.LAYER_SCHEMA
   → スキーマが表示される

2. レイヤー作成後:
   window.drawingApp.layerManager.getActiveLayer().layerData.toJSON()
   → 標準形式のJSONが返る

3. スキーマ取得:
   window.TegakiDataModels.LayerModel.getSchema()
   → editableフラグ付きスキーマが返る

================================================================================
Phase 5: 標準化API実装 - バッチ操作対応
================================================================================
【目的】スプレッドシートUIからの一括更新を可能にする
【影響範囲】新規ファイル作成 + 既存システムへの統合
【所要時間】40分

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
新規作成ファイル
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
system/batch-api.js

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
実装内容
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
(function() {
    'use strict';

    class BatchAPI {
        constructor(layerSystem, animationSystem) {
            this.layerSystem = layerSystem;
            this.animationSystem = animationSystem;
        }

        // ========== Layer 操作 ==========
        
        getLayer(index) {
            const layers = this.layerSystem.getLayers();
            if (index < 0 || index >= layers.length) return null;
            
            const layer = layers[index];
            return layer.layerData ? layer.layerData.toJSON() : null;
        }

        getAllLayers() {
            const layers = this.layerSystem.getLayers();
            return layers.map((layer, index) => ({
                index,
                ...layer.layerData.toJSON()
            }));
        }

        setLayerProperty(index, property, value) {
            const layers = this.layerSystem.getLayers();
            if (index < 0 || index >= layers.length) return false;
            
            const layer = layers[index];
            if (!layer.layerData) return false;
            
            const schema = window.TegakiDataModels.LAYER_SCHEMA[property];
            if (!schema || !schema.editable) return false;
            
            // 型チェック + 範囲チェック
            if (schema.type === 'number') {
                if (typeof value !== 'number') return false;
                if (schema.min !== undefined && value < schema.min) return false;
                if (schema.max !== undefined && value > schema.max) return false;
            }
            
            layer.layerData[property] = value;
            
            // PIXIオブジェクトへ反映
            if (property === 'visible') layer.visible = value;
            if (property === 'opacity') layer.alpha = value;
            
            this.layerSystem.requestThumbnailUpdate(index);
            return true;
        }

        renameLayer(index, newName) {
            return this.setLayerProperty(index, 'name', newName);
        }

        batchUpdateLayers(updates) {
            // updates = [{ index: 0, property: 'opacity', value: 0.5 }, ...]
            const results = [];
            
            for (const update of updates) {
                const success = this.setLayerProperty(
                    update.index, 
                    update.property, 
                    update.value
                );
                results.push({ ...update, success });
            }
            
            return results;
        }

        batchRenameLayers(pattern) {
            // pattern = { search: 'Layer', replace: 'レイヤー' }
            const layers = this.layerSystem.getLayers();
            const results = [];
            
            layers.forEach((layer, index) => {
                if (!layer.layerData) return;
                
                const oldName = layer.layerData.name;
                const newName = oldName.replace(
                    new RegExp(pattern.search, 'g'), 
                    pattern.replace
                );
                
                if (newName !== oldName) {
                    layer.layerData.name = newName;
                    results.push({ index, oldName, newName });
                }
            });
            
            this.layerSystem.updateLayerPanelUI();
            return results;
        }

        // ========== CUT 操作 ==========
        
        getCut(index) {
            const cut = this.animationSystem.animationData.cuts[index];
            if (!cut) return null;
            
            return {
                index,
                id: cut.id,
                name: cut.name,
                duration: cut.duration,
                layerCount: cut.getLayerCount()
            };
        }

        getAllCuts() {
            return this.animationSystem.animationData.cuts.map((cut, index) => ({
                index,
                id: cut.id,
                name: cut.name,
                duration: cut.duration,
                layerCount: cut.getLayerCount()
            }));
        }

        setCutProperty(index, property, value) {
            const cuts = this.animationSystem.animationData.cuts;
            if (index < 0 || index >= cuts.length) return false;
            
            const cut = cuts[index];
            const schema = window.TegakiDataModels.CUT_SCHEMA[property];
            if (!schema || !schema.editable) return false;
            
            // 型チェック + 範囲チェック
            if (schema.type === 'number') {
                if (typeof value !== 'number') return false;
                if (schema.min !== undefined && value < schema.min) return false;
                if (schema.max !== undefined && value > schema.max) return false;
            }
            
            cut[property] = value;
            return true;
        }

        renameCut(index, newName) {
            return this.setCutProperty(index, 'name', newName);
        }

        setAllCutsDuration(duration) {
            const cuts = this.animationSystem.animationData.cuts;
            let successCount = 0;
            
            cuts.forEach(cut => {
                if (duration >= 0.01 && duration <= 10) {
                    cut.duration = duration;
                    successCount++;
                }
            });
            
            return { total: cuts.length, success: successCount };
        }

        batchUpdateCuts(updates) {
            const results = [];
            
            for (const update of updates) {
                const success = this.setCutProperty(
                    update.index, 
                    update.property, 
                    update.value
                );
                results.push({ ...update, success });
            }
            
            return results;
        }

        // ========== スキーマ取得 ==========
        
        getLayerPropSchema() {
            return window.TegakiDataModels.LAYER_SCHEMA;
        }

        getCutPropSchema() {
            return window.TegakiDataModels.CUT_SCHEMA;
        }

        // ========== エクスポート用データ取得 ==========
        
        exportLayersAsTable() {
            const layers = this.getAllLayers();
            return layers.map(layer => ({
                '番号': layer.index + 1,
                '名前': layer.name,
                '表示': layer.visible ? '○' : '×',
                '不透明度': Math.round(layer.opacity * 100) + '%',
                'クリッピング': layer.clipping ? '○' : '×',
                'ロック': layer.locked ? '○' : '×'
            }));
        }

        exportCutsAsTable() {
            const cuts = this.getAllCuts();
            return cuts.map(cut => ({
                '番号': cut.index + 1,
                'CUT名': cut.name,
                '時間': cut.duration.toFixed(2) + 's',
                'レイヤー数': cut.layerCount
            }));
        }
    }

    window.TegakiBatchAPI = BatchAPI;

    console.log('✅ batch-api.js loaded');
})();

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
index.html への追加
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
<script src="system/data-models.js"></script>
<script src="system/batch-api.js"></script>  ← 追加
<script src="system/event-bus.js"></script>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
core-engine.js への統合
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
initialize() メソッド内に追加

this.batchAPI = new window.TegakiBatchAPI(
    this.layerManager,
    this.animationSystem
);

window.batchAPI = this.batchAPI;  // グローバル公開（開発用）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
処理フロー上の位置
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【従来】
UIイベント → LayerSystem直接操作 → PIXIオブジェクト変更

【Phase 5以降】
スプレッドシートUI → BatchAPI → LayerSystem → PIXIオブジェクト変更
                              ↓
                         History記録

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
検証方法
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ブラウザコンソールで実行:

1. 全レイヤー取得
   window.batchAPI.getAllLayers()

2. レイヤー0の不透明度を50%に変更
   window.batchAPI.setLayerProperty(0, 'opacity', 0.5)

3. 一括リネーム
   window.batchAPI.batchRenameLayers({ search: 'レイヤー', replace: 'Layer' })

4. エクスポート形式で取得
   console.table(window.batchAPI.exportLayersAsTable())

5. 全CUT情報取得
   window.batchAPI.getAllCuts()

6. 全CUTの時間を1秒に設定
   window.batchAPI.setAllCutsDuration(1.0)

================================================================================
Phase 6: History統合 - BatchAPI操作の記録
================================================================================
【目的】スプレッドシートからの一括変更もUndo/Redo可能にする
【影響範囲】system/batch-api.js
【所要時間】20分

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正対象ファイル
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
system/batch-api.js

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修正箇所
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
メソッド: setLayerProperty(index, property, value)

【修正前】
setLayerProperty(index, property, value) {
    const layers = this.layerSystem.getLayers();
    if (index < 0 || index >= layers.length) return false;
    
    const layer = layers[index];
    if (!layer.layerData) return false;
    
    const schema = window.TegakiDataModels.LAYER_SCHEMA[property];
    if (!schema || !schema.editable) return false;
    
    // ... 型チェック ...
    
    layer.layerData[property] = value;
    
    // PIXIオブジェクトへ反映
    if (property === 'visible') layer.visible = value;
    if (property === 'opacity') layer.alpha = value;
    
    this.layerSystem.requestThumbnailUpdate(index);
    return true;
}

【修正後】
setLayerProperty(index, property, value) {
    const layers = this.layerSystem.getLayers();
    if (index < 0 || index >= layers.length) return false;
    
    const layer = layers[index];
    if (!layer.layerData) return false;
    
    const schema = window.TegakiDataModels.LAYER_SCHEMA[property];
    if (!schema || !schema.editable) return false;
    
    // ... 型チェック ...
    
    // ← History記録を追加
    if (window.History && !window.History._manager.isApplying) {
        const oldValue = layer.layerData[property];
        
        const command = {
            name: 'layer-property-change',
            do: () => {
                layer.layerData[property] = value;
                if (property === 'visible') layer.visible = value;
                if (property === 'opacity') layer.alpha = value;
                this.layerSystem.requestThumbnailUpdate(index);
            },
            undo: () => {
                layer.layerData[property] = oldValue;
                if (property === 'visible') layer.visible = oldValue;
                if (property === 'opacity') layer.alpha = oldValue;
                this.layerSystem.requestThumbnailUpdate(index);
            },
            meta: { type: 'layer-prop', index, property, oldValue, newValue: value }
        };
        
        window.History.push(command);
    } else {
        layer.layerData[property] = value;
        if (property === 'visible') layer.visible = value;
        if (property === 'opacity') layer.alpha = value;
        this.layerSystem.requestThumbnailUpdate(index);
    }
    
    return true;
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
同様の修正: batchUpdateLayers()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【修正】
batchUpdateLayers(updates) {
    // Composite Commandを使用（複数操作を1つのUndo/Redoで扱う）
    if (window.History && !window.History._manager.isApplying) {
        const commands = [];
        
        for (const update of updates) {
            const layers = this.layerSystem.getLayers();
            const layer = layers[update.index];
            if (!layer?.layerData) continue;
            
            const oldValue = layer.layerData[update.property];
            
            commands.push({
                name: 'layer-prop-batch-item',
                do: () => {
                    this.setLayerProperty(update.index, update.property, update.value);
                },
                undo: () => {
                    this.setLayerProperty(update.index, update.property, oldValue);
                },
                meta: { index: update.index, property: update.property }
            });
        }
        
        if (commands.length > 0) {
            const composite = window.History.createComposite(
                commands, 
                'batch-layer-update'
            );
            window.History.push(composite);
        }
        
        return updates.map(u => ({ ...u, success: true }));
    }
    
    // History無効時は既存処理
    const results = [];
    for (const update of updates) {
        const success = this.setLayerProperty(
            update.index, 
            update.property, 
            update.value
        );
        results.push({ ...update, success });
    }
    return results;
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
同様の修正: batchRenameLayers()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【修正】
batchRenameLayers(pattern) {
    const layers = this.layerSystem.getLayers();
    const changes = [];
    
    // 変更対象を収集
    layers.forEach((layer, index) => {
        if (!layer.layerData) return;
        
        const oldName = layer.layerData.name;
        const newName = oldName.replace(
            new RegExp(pattern.search, 'g'), 
            pattern.replace
        );
        
        if (newName !== oldName) {
            changes.push({ index, oldName, newName });
        }
    });
    
    // History記録
    if (window.History && !window.History._manager.isApplying) {
        const commands = changes.map(change => ({
            name: 'layer-rename-batch-item',
            do: () => {
                const layer = this.layerSystem.getLayers()[change.index];
                if (layer?.layerData) {
                    layer.layerData.name = change.newName;
                }
            },
            undo: () => {
                const layer = this.layerSystem.getLayers()[change.index];
                if (layer?.layerData) {
                    layer.layerData.name = change.oldName;
                }
            },
            meta: { index: change.index }
        }));
        
        if (commands.length > 0) {
            const composite = window.History.createComposite(
                commands, 
                'batch-rename-layers'
            );
            window.History.push(composite);
        }
    } else {
        // History無効時は直接実行
        changes.forEach(change => {
            const layer = layers[change.index];
            if (layer?.layerData) {
                layer.layerData.name = change.newName;
            }
        });
    }
    
    this.layerSystem.updateLayerPanelUI();
    return changes;
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
検証方法
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 一括リネーム実行
   window.batchAPI.batchRenameLayers({ search: 'レイヤー', replace: 'Layer' })

2. Ctrl+Z で Undo
   → すべてのレイヤー名が元に戻る

3. Ctrl+Y で Redo
   → すべてのレイヤー名が再度変更される

4. 複数プロパティ一括変更
   window.batchAPI.batchUpdateLayers([
       { index: 0, property: 'opacity', value: 0.5 },
       { index: 1, property: 'visible', value: false }
   ])

5. Ctrl+Z で Undo
   → 2つの変更が同時に戻る（1回のUndoで完了）

================================================================================
Phase 7（将来実装）: スプレッドシートUI
================================================================================
【目的】Excelライクなレイヤー/CUT編集画面
【影響範囲】新規UI実装
【所要時間】Phase 1-6完了後に実施

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 1-6完了後の追加実装
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- ui/spreadsheet-editor.js 新規作成
- ライブラリ候補: Handsontable, ag-Grid, SlickGrid
- 機能:
  - レイヤー/CUT一覧を表形式で表示
  - セル編集 → BatchAPI経由で更新
  - フィルタ・ソート
  - CSV/TSVエクスポート
  - 複数セル選択 → 一括変更

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BatchAPIとの連携例
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// スプレッドシートからの編集イベント
spreadsheet.on('cellChanged', (row, column, newValue) => {
    const propertyName = COLUMN_TO_PROPERTY[column];
    window.batchAPI.setLayerProperty(row, propertyName, newValue);
});

// 一括置換ボタン
replaceButton.on('click', () => {
    const pattern = {
        search: searchInput.value,
        replace: replaceInput.value
    };
    window.batchAPI.batchRenameLayers(pattern);
    spreadsheet.reload();  // 表示更新
});

================================================================================
Phase 8（将来実装）: PSD入出力対応
================================================================================
【目的】Photoshop/CLIP STUDIO PAINTとの連携
【前提条件】Phase 1-6完了（データモデル統一済み）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
実装方針
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- ライブラリ: ag-psd (https://github.com/Agamnentzar/ag-psd)
- BatchAPIのデータ形式を利用
- レイヤー情報（名前・不透明度・クリッピング）の読み書き

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
処理フロー
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【PSD読み込み】
ag-psd.readPsd() 
  → レイヤー情報抽出
  → LayerModel.fromPSD() でデータ変換
  → LayerSystem.createLayer() で追加

【PSD書き出し】
BatchAPI.getAllLayers()
  → PSD形式に変換
  → ag-psd.writePsd()

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
参考実装（骨子）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
class PSDExporter {
    constructor(batchAPI) {
        this.batchAPI = batchAPI;
    }
    
    async importPSD(file) {
        const arrayBuffer = await file.arrayBuffer();
        const psd = readPsd(arrayBuffer);
        
        psd.children.forEach(psdLayer => {
            const layerModel = new LayerModel({
                name: psdLayer.name,
                visible: psdLayer.visible,
                opacity: psdLayer.opacity / 255,
                clipping: psdLayer.clipping,
                blendMode: psdLayer.blendMode
            });
            
            // レイヤー作成 + 画像データ設定
            // ...
        });
    }
    
    async exportPSD() {
        const layers = this.batchAPI.getAllLayers();
        
        const psdData = {
            width: config.canvas.width,
            height: config.canvas.height,
            children: layers.map(layer => ({
                name: layer.name,
                visible: layer.visible,
                opacity: Math.round(layer.opacity * 255),
                clipping: layer.clipping,
                blendMode: layer.blendMode
                // ... 画像データ
            }))
        };
        
        const buffer = writePsd(psdData);
        // ... ダウンロード処理
    }
}

================================================================================
改修後の期待効果
================================================================================

【Phase 1-3完了後】
- メモリリーク解消 → 長時間作業可能
- 描画速度95%改善 → カメラズームが瞬時
- UI応答性80%改善 → レイヤー移動がスムーズ

【Phase 4-6完了後】
- データ構造統一 → AIによる改修容易性向上
- バッチAPI実装 → スクリプトによる自動化可能
- History統合 → 一括操作もUndo/Redo可能

【Phase 7-8完了後（将来）】
- スプレッドシートUI → レイヤー管理効率10倍
- PSD入出力 → CLIP STUDIOリネームツールとして使用可能
- 一括置換機能 → 大量レイヤーの命名作業が秒で完了

================================================================================
実装優先順位
================================================================================

【緊急（1週間以内）】
Phase 1, 2, 3 → パフォーマンス問題解消

【高優先度（1ヶ月以内）】
Phase 4, 5 → データ層統一化

【中優先度（2ヶ月以内）】
Phase 6 → History統合完全化

【低優先度（要件確定後）】
Phase 7, 8 → スプレッドシートUI・PSD対応

================================================================================
注意事項
================================================================================

1. 各Phase完了後は必ず動作確認を実施
2. Phase 1-3はユーザー影響大 → 慎重にテスト
3. Phase 4以降は既存機能への影響を最小化
4. 段階的移行: 旧実装と新実装の共存期間を設ける

================================================================================
参考資料
================================================================================

【関連ファイル】
- system/layer-system.js: レイヤー管理の中核
- system/animation-system.js: CUT管理の中核
- system/history.js: Undo/Redo機構
- core-engine.js: システム統合部分

【外部ライブラリ】
- Perfect Freehand: ベクターストローク描画
- PixiJS v8.13: レンダリングエンジン
- ag-psd: PSD読み書き（Phase 8で使用予定）

【データフロー】
UI操作 → EventBus → System（Layer/Animation） → PIXI → Canvas

【Phase 4以降のデータフロー】
UI/スプレッドシート → BatchAPI → DataModel → System → PIXI → Canvas
                                      ↓
                                   History

================================================================================
EOF
================================================================================
```