# 📋 LayerSystem 再分割改修計画書 v2

## 🔴 現状の問題点

### phase2eで発生した不具合の根本原因
1. **階層移動API（moveLayer, reparent等）が未実装**
   - layer-utils.jsに座標変換関数のみで、階層構造操作関数が無い
   - GPT5案.txtで要求されていた`findLayerById`, `reparentLayer`, `syncDisplayOrder`が無い
2. **LayerSystemとAnimationSystemの分離設計ミス**
   - LayerSystem.layers配列とAnimationSystemのCUT構造が二重管理
   - 同期タイミングのズレで不整合が発生
3. **EventBus通知の欠如**
   - UI操作後の`layers.changed`イベントが発火していない
   - パネル再描画が動作していない

---

## 🎯 改修方針

### 設計原則
- **AnimationSystemがレイヤーデータの単一真実**（Single Source of Truth）
- LayerSystemは**表示層の同期役**に徹する
- レイヤー階層操作はAnimationSystem経由で行う
- layer-utils.jsは**純粋なユーティリティ関数群**のみ（状態を持たない）

### phase1f4からの最小変更で安定化
- phase1f4の動作を維持しつつ、ユーティリティ関数を外部化
- 階層操作はphase1f4の実装を継承
- 新規機能（CUT切替対応）はAnimationSystem側に寄せる

---

## 📁 分割方針（改訂版）

### layer-system.js（改修版）
**責務**: CUT表示層の管理・レイヤー操作の実行・Transform制御

**保持する機能**:
- レイヤーContainer管理（`layersContainer`, `layers`配列）
- AnimationSystem同期（`_syncLayersContainerFromAnimationSystem`）
- レイヤー作成/削除/可視性切替
- Transform制御（移動/回転/拡縮/反転）
- サムネイル生成・更新
- キーボード操作ハンドリング
- ドラッグによるレイヤー移動

**削除する機能**:
- 座標変換ロジック → LayerUtils
- Path操作の詳細ロジック → 保持（AnimationSystemとの整合性優先）

---

### layer-utils.js（改訂版）
**責務**: レイヤー操作の純粋関数群

**実装する機能**:
1. **座標系変換** ← phase2eから継承
   - `toLocalCoordinates(layer, globalX, globalY)`
   - `toGlobalCoordinates(layer, localX, localY)`
   - `screenToLayerCoordinates(layer, screenX, screenY, renderer)`

2. **レイヤー階層操作** ← GPT5案から追加
   - `findLayerById(layers, id)` - レイヤー検索
   - `findLayerByIndex(layers, index)` - インデックス検索
   - `moveLayerInArray(layers, fromIndex, toIndex)` - 配列内移動

3. **Transform補助** ← phase2eから継承
   - `getLayerTransform(layer)`
   - `applyTransform(layer, transform, centerX, centerY)`
   - `resetLayerTransform(layer)`
   - `createTransformMatrix(transform, centerX, centerY)`

4. **レイヤー制御** ← phase2eから継承
   - `setLayerVisibility(layer, visible)`
   - `setLayerOpacity(layer, alpha)`
   - `clearLayer(layer)` - 描画オブジェクト削除

5. **検索・取得** ← phase2eから継承
   - `findLayerByLabel(container, label)`
   - `getAllDrawableLayers(container)`
   - `getLayerAtIndex(container, index)`

**削除する機能**:
- `reparentLayer` - 複雑すぎるため削除（LayerSystemで代替）
- `syncDisplayOrder` - LayerSystemの責務として移管

**注意**: **状態を持たない純粋関数のみ**。EventBus操作やAnimationSystem操作は含まない。

---

## 🔄 動作フロー（改訂版）

### 初期化フロー
```
1. index.html → <script src="system/layer-utils.js"></script> 読み込み
2. LayerUtils グローバル登録 (window.LayerUtils)
3. LayerSystem 初期化
   └─ LayerUtils.applyTransform() など利用
```

### レイヤー階層移動フロー（改訂版）
```
1. ユーザー操作: レイヤーパネルで上下移動ボタンクリック
   ↓
2. LayerSystem.moveActiveLayerHierarchy('up'/'down')
   ↓
3. LayerUtils.moveLayerInArray(layers, fromIndex, toIndex)
   └─ layers配列の要素を入れ替え
   ↓
4. LayerSystem.layersContainer の子要素順序を同期
   └─ layersContainer.setChildIndex(layer, newIndex)
   ↓
5. AnimationSystem.saveCutLayerStates()
   └─ CUT構造に永続化
   ↓
6. EventBus.emit('layers.changed', {layers})
   └─ UIパネル再描画トリガー
```

### CUT切替フロー（維持）
```
1. AnimationSystem.switchToActiveCut(cutIndex)
   ↓
2. EventBus.emit('animation:cut-applied')
   ↓
3. LayerSystem._syncLayersContainerFromAnimationSystem()
   └─ CUT構造からlayersContainer再構築
   ↓
4. LayerSystem.updateLayerPanelUI()
```

---

## 📝 改修内容詳細

### 1. layer-utils.js への追加機能

#### 階層操作関数
```javascript
/**
 * レイヤー配列内で要素を移動
 * @param {Array} layers - レイヤー配列
 * @param {number} fromIndex - 移動元インデックス
 * @param {number} toIndex - 移動先インデックス
 * @returns {boolean} 成功したか
 */
function moveLayerInArray(layers, fromIndex, toIndex) {
    if (!layers || fromIndex < 0 || toIndex < 0 || 
        fromIndex >= layers.length || toIndex >= layers.length) {
        return false;
    }
    const [layer] = layers.splice(fromIndex, 1);
    layers.splice(toIndex, 0, layer);
    return true;
}

/**
 * IDでレイヤーを検索
 * @param {Array} layers - レイヤー配列
 * @param {string} id - レイヤーID
 * @returns {Object|null} {layer, index} または null
 */
function findLayerById(layers, id) {
    if (!layers || !id) return null;
    for (let i = 0; i < layers.length; i++) {
        if (layers[i].layerData?.id === id) {
            return { layer: layers[i], index: i };
        }
    }
    return null;
}
```

#### Transform適用関数（phase1f4互換）
```javascript
/**
 * Transformを適用（CoordinateSystem互換）
 * @param {PIXI.Container} layer - 対象レイヤー
 * @param {Object} transform - Transform情報
 * @param {number} centerX - 回転中心X
 * @param {number} centerY - 回転中心Y
 */
function applyTransform(layer, transform, centerX, centerY) {
    if (!layer || !transform) return;
    
    if (transform.rotation !== 0 || Math.abs(transform.scaleX) !== 1 || 
        Math.abs(transform.scaleY) !== 1) {
        layer.pivot.set(centerX, centerY);
        layer.position.set(centerX + transform.x, centerY + transform.y);
        layer.rotation = transform.rotation;
        layer.scale.set(transform.scaleX, transform.scaleY);
    } else if (transform.x !== 0 || transform.y !== 0) {
        layer.pivot.set(0, 0);
        layer.position.set(transform.x, transform.y);
        layer.rotation = 0;
        layer.scale.set(1, 1);
    } else {
        layer.pivot.set(0, 0);
        layer.position.set(0, 0);
        layer.rotation = 0;
        layer.scale.set(1, 1);
    }
}
```

---

### 2. layer-system.js の改修ポイント

#### 階層移動メソッドの改修
```javascript
moveActiveLayerHierarchy(direction) {
    if (this.layers.length <= 1) return;
    
    const currentIndex = this.activeLayerIndex;
    let newIndex;
    
    if (direction === 'up') {
        newIndex = Math.min(currentIndex + 1, this.layers.length - 1);
    } else if (direction === 'down') {
        newIndex = Math.max(currentIndex - 1, 0);
    } else {
        return;
    }
    
    if (newIndex !== currentIndex) {
        // 配列の順序変更
        window.LayerUtils.moveLayerInArray(this.layers, currentIndex, newIndex);
        
        // Pixi Containerの順序同期
        this.layersContainer.setChildIndex(this.layers[newIndex], newIndex);
        
        // アクティブインデックス更新
        this.activeLayerIndex = newIndex;
        
        // AnimationSystemに永続化
        if (this.animationSystem?.saveCutLayerStates) {
            this.animationSystem.saveCutLayerStates();
        }
        
        // UI更新通知
        if (this.eventBus) {
            this.eventBus.emit('layers.changed', { 
                layers: this.layers,
                activeIndex: newIndex
            });
        }
        
        this.updateLayerPanelUI();
    }
}
```

#### Transform適用の委譲
```javascript
_applyTransformDirect(layer, transform, centerX, centerY) {
    // LayerUtilsに委譲
    window.LayerUtils.applyTransform(layer, transform, centerX, centerY);
}
```

---

## ✅ テスト項目

### 基本動作確認
- [ ] レイヤー作成・削除が正常動作
- [ ] レイヤー可視性切替が反映される
- [ ] アクティブレイヤー切替が機能する
- [ ] サムネイル生成が動作する

### 階層移動確認
- [ ] レイヤーパネルで上下移動ボタン操作
- [ ] Pixi表示順が正しく更新される
- [ ] AnimationSystemのCUT構造に永続化される
- [ ] 描画順序が視覚的に変化する

### Transform確認
- [ ] Vキーでレイヤー移動モード起動
- [ ] ドラッグでレイヤー移動が動作
- [ ] 回転・拡縮スライダーが機能
- [ ] 水平/垂直反転が動作

### CUT切替確認
- [ ] CUT作成・削除が動作
- [ ] CUT切替時にレイヤー表示が正しく更新
- [ ] 各CUTのレイヤー状態が独立して保存される

### EventBus確認
- [ ] `layers.changed`イベントが発火
- [ ] `layer:created`イベントが発火
- [ ] `layer:deleted`イベントが発火
- [ ] `layer:updated`イベントが発火

---

## 📌 実装順序

### Step 1: layer-utils.js 拡張
1. 階層操作関数追加（`moveLayerInArray`, `findLayerById`）
2. Transform適用関数追加（`applyTransform`, `createTransformMatrix`）

### Step 2: layer-system.js 改修
1. `_applyTransformDirect` → LayerUtils委譲
2. `moveActiveLayerHierarchy` → EventBus通知追加
3. `setActiveLayer` → EventBus通知追加（既存維持）

### Step 3: 動作確認
1. DevToolsでEventBus監視
2. レイヤー階層移動テスト
3. Transform操作テスト

---

## 🚨 注意事項

### 既存機能の維持
- phase1f4で動作していた全機能を保持
- AnimationSystem連携を破壊しない
- サムネイル生成ロジックを維持

### 過度な抽象化を避ける
- `reparentLayer`のような複雑な階層操作は実装しない
- 現状の単純な配列操作で十分

### EventBusの適切な使用
- UI更新が必要なタイミングで`layers.changed`を発火
- 過剰な通知は避ける（連続操作時はdebounce検討）

---

## 📊 改修の影響範囲

### 変更ファイル
- ✏️ `system/layer-utils.js` - 関数追加
- ✏️ `system/layer-system.js` - EventBus通知追加、LayerUtils利用

### 影響を受けるファイル
- ✅ `ui/ui-panels.js` - EventBus受信（既存維持）
- ✅ `system/animation-system.js` - LayerSystem連携（既存維持）
- ✅ `coordinate-system.js` - LayerUtils利用（既存維持）

### 影響を受けないファイル
- ✅ `core-engine.js`
- ✅ `core-runtime.js`
- ✅ `system/camera-system.js`
- ✅ `system/history.js`

---

## 🎯 成功基準

1. **階層移動が動作する**
   - レイヤーパネルでの上下移動
   - Pixi表示順の同期
   - AnimationSystemへの永続化

2. **CUT切替が安定動作する**
   - 切替時のレイヤー表示更新
   - 各CUTのレイヤー状態独立性

3. **EventBusが正常動作する**
   - `layers.changed`イベント発火
   - UIパネル自動再描画

4. **Transform操作が維持される**
   - Vキーモードの全機能
   - 座標変換の正確性

---

## 📝 備考

- 本計画書に基づき、段階的に改修を実施
- 各Stepごとに動作確認を行い、不具合があれば即座にロールバック
- phase1f4の安定性を最優先とし、過度な機能追加は避ける