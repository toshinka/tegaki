改修計画書：CUT独立性とサムネイル反映の実装
問題の整理
現状の不具合

・CUT間の独立性が無い：1つのCUTに描いた内容が全CUTに反映される
・サムネイルが反映されない：タイムラインのサムネイルにCUT毎の画像が表示されない
・新規CUT作成時に絵が消える：+CUTボタンで作成すると既存の絵が消失
・新規CUT作成時に自動アクティブ化されない：作成後アクティブ無しになる
・キャンバス比率の反映がリニアでない：CUT追加時のみ反映される

根本原因の診断
既存ファイルを調査した結果：
system/layer-system.js - グローバルなPIXI Containerを全CUTで共有している
core-runtime.js - CUT切替時のstage管理が未実装
ui/timeline-ui.js - サムネイル生成ロジックがactiveCutのみを参照している
core-engine.js - Project構造にCUT毎の独立したcontainerが無い

設計方針
データモデルの再定義（最優先）
javascript// Project構造
Project = {
  canvasSize: {w, h},
  DPR: number,
  renderer: PIXI.Renderer,
  cuts: [Cut, ...],
  activeCutId: string
}

// Cut構造（各CUTは完全に独立）
Cut = {
  id: string,
  name: string,
  width: number,
  height: number,
  container: PIXI.Container, // このCUT専用のルートContainer
  layers: [Layer, ...],
  renderTexture: PIXI.RenderTexture, // サムネイル/エクスポート用
  needsThumbnailUpdate: boolean
}

// Layer構造
Layer = {
  id: string,
  name: string,
  type: 'vector'|'bitmap',
  container: PIXI.Container, // layerの描画内容を保持
  visible: boolean,
  opacity: number,
  transform: {x, y, scale, rotation, flipX, flipY}
}
責務分離の明確化

LayerSystem: Layer単位のデータ管理と描画
CoreRuntime: Project状態管理、CUT切替、レンダーループ
TimelineUI: UI表示のみ（データ操作はCoreRuntime経由）
CameraSystem: キャンバスサイズ統一管理


ファイル別改修内容
① core-runtime.js
目的: Project/CUT/Rendererの中央管理とCUT切替機能
主要API:
javascriptCoreRuntime.init(options)              // 初期化
CoreRuntime.createCut(opts)            // CUT作成
CoreRuntime.switchCut(cutId)           // CUT切替（stage差し替え）
CoreRuntime.getCutById(cutId)          // CUT取得
CoreRuntime.renderCutToTexture(cutId)  // サムネイル生成
CoreRuntime.extractCutDataURL(cutId)   // dataURL取得
CoreRuntime.updateCanvasSize(w,h)      // 全CUTのRenderTexture再生成
重要な実装ポイント:

project.stageには常にactiveCutのcontainerのみを配置
switchCut時は古いcontainerをremoveChildして新containerをaddChild
各Cut.renderTextureはMath.round(w*DPR) x Math.round(h*DPR)で作成
レンダーループ内でneedsThumbnailUpdateをチェックしてサムネイル更新


② system/layer-system.js（大幅改修）
目的: CUT毎に独立したLayerを管理
主要API:
javascriptLayerSystem.init(project, renderer)
LayerSystem.createLayer(cutId, opts)        // 指定CUTにLayer作成
LayerSystem.removeLayer(cutId, layerId)
LayerSystem.getLayer(cutId, layerId)
LayerSystem.drawStroke(cutId, layerId, strokeData)  // 描画
LayerSystem.setLayerTransform(cutId, layerId, transform)
LayerSystem.cloneLayersToNewCut(srcCutId, targetCutId)
変更点:

グローバルなContainer共有を廃止
全てのAPIにcutIdを必須引数として追加
drawStroke後にcut.needsThumbnailUpdate = trueを設定
Layer.containerは各CUTのcut.containerの子として追加


③ ui/timeline-ui.js（改修）
目的: CUT一覧表示とサムネイル更新
主要メソッド:
javascriptTimelineUI.init(options)
TimelineUI.createCutElement(cut)      // CUT要素をDOM追加
TimelineUI.refreshThumbnail(cutId)    // サムネイル更新
TimelineUI.refreshActiveCutUI()       // アクティブ表示更新
TimelineUI.handleAddCut()             // +CUTボタン処理
+CUTボタンの処理フロー:
javascriptfunction handleAddCut() {
  const newCut = CoreRuntime.createCut({name: `Cut ${n+1}`});
  CoreRuntime.switchCut(newCut.id);  // 即座にアクティブ化
  createCutElement(newCut);
  refreshActiveCutUI();
  refreshThumbnail(newCut.id);       // サムネイル生成
}
サムネイル生成:
javascriptfunction refreshThumbnail(cutId) {
  const dataUrl = CoreRuntime.extractCutDataURL(cutId);
  thumbImg.src = dataUrl;
}

④ core-engine.js（改修）
目的: 既存のcore-engine.jsとcore-runtime.jsを統合調整
変更点:

CoreRuntime.initを呼び出してProject初期化
window.TegakiApp.projectをCoreRuntime.projectに委譲
LayerSystem, TimelineUI等にCoreRuntime.projectを渡す


⑤ system/camera-system.js（改修）
目的: キャンバスサイズ変更時の一貫した反映
主要API:
javascriptCameraSystem.updateCanvasSize(w, h)  // 全CUTのRenderTexture再生成
CameraSystem.applyTransformToContainer(container)
実装:
javascriptfunction updateCanvasSize(w, h) {
  CoreRuntime.project.canvasSize = {width: w, height: h};
  
  // 全CUTのrenderTextureを再作成
  CoreRuntime.project.cuts.forEach(cut => {
    cut.renderTexture = PIXI.RenderTexture.create({
      width: Math.round(w * CoreRuntime.project.DPR),
      height: Math.round(h * CoreRuntime.project.DPR)
    });
    cut.needsThumbnailUpdate = true;
  });
  
  // EventBus経由で通知
  eventBus.emit('camera:resized', {width: w, height: h});
}

⑥ system/drawing-clipboard.js（軽微改修）
変更点:

描画時にLayerSystem.drawStroke(activeCutId, activeLayerId, stroke)を呼ぶ
activeCutIdはCoreRuntime.project.activeCutIdから取得


⑦ system/gif-exporter.js（改修）
目的: 各CUTのrenderTextureを使ってGIF生成
実装:
javascriptfunction exportSequence(cutIds, options) {
  cutIds.forEach(cutId => {
    const rt = CoreRuntime.renderCutToTexture(cutId);
    const canvas = renderer.extract.canvas(rt);
    gifEncoder.addFrame(canvas);
  });
}

動作フロー
アプリ起動

CoreRuntime.init() → renderer, stage, Project初期化
デフォルトでCut[0]を作成、activeCutId = cuts[0].id
LayerSystem.init(project, renderer)
TimelineUI.init() → 既存CUTをDOMに描画
レンダーループ開始

描画時

ユーザーがブラシで描画
DrawingClipboard → LayerSystem.drawStroke(activeCutId, activeLayerId, strokeData)
cut.needsThumbnailUpdate = true
次のフレームでレンダーループがTimelineUI.refreshThumbnail(cutId)を自動呼出

CUT切替時

TimelineUIでCUT要素クリック
CoreRuntime.switchCut(cutId) → stage.removeChild(oldCut.container), stage.addChild(newCut.container)
activeCutId更新
refreshActiveCutUI()でUI反映

+CUT作成時

TimelineUI.handleAddCut()
CoreRuntime.createCut() → 新Cut作成、renderTexture初期化
CoreRuntime.switchCut(newCut.id) → 即座にアクティブ化
createCutElement(newCut) → DOM追加
refreshThumbnail(newCut.id) → サムネイル生成

キャンバスサイズ変更時

UI操作 → CameraSystem.updateCanvasSize(w, h)
全CUTのrenderTexture再生成
eventBus.emit('camera:resized')
TimelineUIが全サムネイル更新


実装優先順位

core-runtime.js 新規作成 → Project/CUT管理とswitchCut実装
layer-system.js 改修 → cutId引数追加、グローバル共有廃止
timeline-ui.js 改修 → +CUT自動アクティブ化、サムネイル生成修正
core-engine.js 調整 → CoreRuntime統合
camera-system.js 改修 → updateCanvasSize実装
gif-exporter.js 改修 → renderTexture利用


注意点（落とし穴チェック）

RenderTexture破棄: 古いRenderTextureはdestroy(true)で解放
DPR計算: 必ずMath.round(w*DPR)で整数化
座標系: LayerのtransformはCut.container基準
Graphics複製: cloneLayersToNewCutはgeometry複製を使用（v8対応）
file://対応: renderer.extractはfile://でも動作（クロスオリジン注意不要）


API辞典（各ファイルの主要メソッド）
CoreRuntime

init(options) - 初期化
createCut(opts) - CUT作成
switchCut(cutId) - CUT切替
getCutById(cutId) - CUT取得
renderCutToTexture(cutId) - RenderTextureにレンダリング
extractCutDataURL(cutId) - dataURL取得
updateCanvasSize(w,h) - サイズ変更

LayerSystem

init(project, renderer) - 初期化
createLayer(cutId, opts) - Layer作成
removeLayer(cutId, layerId) - Layer削除
getLayer(cutId, layerId) - Layer取得
drawStroke(cutId, layerId, strokeData) - 描画
setLayerTransform(cutId, layerId, transform) - 変形
cloneLayersToNewCut(srcId, dstId) - 複製

TimelineUI

init(options) - 初期化
createCutElement(cut) - DOM要素作成
refreshThumbnail(cutId) - サムネイル更新
refreshActiveCutUI() - アクティブ表示更新
handleAddCut() - +CUT処理

CameraSystem

init(project, renderer) - 初期化
updateCanvasSize(w, h) - サイズ変更
applyTransformToContainer(container) - 変形適用

GifExporter

exportSequence(cutIds, options) - GIF生成


テストケース

✅ CUT1に描画 → CUT2作成 → CUT1に戻る → 絵が独立していること
✅ +CUT押下 → 新CUTが即アクティブになること
✅ 描画後 → サムネイルが即更新されること
✅ キャンバスサイズ変更 → 全CUTのサムネイルがリニアに更新されること
✅ CUT切替 → 表示が切り替わること


