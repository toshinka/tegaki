# GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½å®Ÿè£…è¨ˆç”»æ›¸ v10
## ç¾è¡Œã‚·ã‚¹ãƒ†ãƒ æœ€é©åŒ–ç‰ˆï¼ˆPixiJS v8.13 æº–æ‹ ï¼‰

### ğŸ“‹ ç¾çŠ¶åˆ†æã¨å•é¡Œç‚¹ãƒã‚§ãƒƒã‚¯

#### âœ… è§£æ±ºæ¸ˆã¿ã®é …ç›®
- **åº§æ¨™å¤‰æ›API**: CoordinateSystemã§çµ±ä¸€æ¸ˆã¿ï¼ˆcoordinate-system.jsï¼‰
- **ãƒ¬ã‚¤ãƒ¤ãƒ¼API**: LayerSystemã§é›†ç´„æ¸ˆã¿ï¼ˆsystem/layer-system.jsï¼‰  
- **EventBusçµ±åˆ**: å„ã‚·ã‚¹ãƒ†ãƒ ã§å®Ÿè£…æ¸ˆã¿
- **è¨­å®šå‚ç…§**: TEGAKI_CONFIGã§çµ±ä¸€æ¸ˆã¿
- **PixiJS v8.13**: æ­£ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’CDNã§èª­ã¿è¾¼ã¿æ¸ˆã¿

#### âš ï¸ ç¢ºèªã•ã‚ŒãŸå•é¡Œç‚¹
- **ES importæ–‡**: ä½¿ç”¨ã—ã¦ã„ãªã„ï¼ˆwindowçµŒç”±ã§æ­£ã—ãå®Ÿè£…ï¼‰
- **APIå¢ƒç•Œ**: CoreRuntimeã§çµ±ä¸€ã•ã‚Œã¦ã„ã‚‹ãŒã€GIFæ©Ÿèƒ½è¿½åŠ æ™‚ã«æ•´åˆæ€§ç¶­æŒãŒå¿…è¦

---

## ğŸ¯ å®Ÿè£…æ–¹é‡ï¼ˆç¾çŠ¶ã‚·ã‚¹ãƒ†ãƒ ã«æœ€é©åŒ–ï¼‰

### åŸºæœ¬æˆ¦ç•¥
1. **æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ã‚’ç¶­æŒ**: ç¾åœ¨ã®åˆ†å‰²æ§‹é€ ã‚’æ´»ã‹ã™
2. **CoreRuntimeçµŒç”±ã§ã®APIæä¾›**: UIå±¤ã‹ã‚‰ã®çµ±ä¸€ã‚¢ã‚¯ã‚»ã‚¹ç¶­æŒ
3. **LayerSystemã‚’æ‹¡å¼µ**: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã‚’LayerSystemã«çµ±åˆ
4. **gif.jsãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ´»ç”¨**: GIFç”Ÿæˆã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å§”è­²

### ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé¸å®šï¼ˆPixiJS v8.13ã¨ã®ç›¸æ€§è€ƒæ…®ï¼‰
```html
<!-- æ—¢å­˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆç¶­æŒï¼‰ -->
<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

<!-- GIFæ©Ÿèƒ½ç”¨è¿½åŠ  -->
<script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.min.js"></script>
```

---

## ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆï¼ˆç¾çŠ¶ç¶­æŒï¼‹æ‹¡å¼µï¼‰

### æ–°è¦è¿½åŠ ãƒ•ã‚¡ã‚¤ãƒ«
```
system/
â”œâ”€â”€ animation-system.js    # GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ï¼ˆæ–°è¦ï¼‰
â””â”€â”€ gif-exporter.js       # GIFæ›¸ãå‡ºã—å‡¦ç†ï¼ˆæ–°è¦ï¼‰

ui/
â””â”€â”€ timeline-ui.js        # ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³UIï¼ˆæ–°è¦ï¼‰
```

### æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ä¿®æ­£ç®‡æ‰€
- `index.html`: ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³UIè¦ç´ è¿½åŠ ã€æ–°è¦ã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿
- `core-runtime.js`: AnimationSystem APIã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆè¿½åŠ 
- `core-engine.js`: AnimationSystemåˆæœŸåŒ–è¿½åŠ 
- `config.js`: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šè¿½åŠ 

---

## ğŸ— ãƒ‡ãƒ¼ã‚¿æ§‹é€ è¨­è¨ˆï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰

### ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
```javascript
// TEGAKI_CONFIG ã«è¿½åŠ 
window.TEGAKI_CONFIG.animation = {
    defaultFPS: 12,
    maxCuts: 50,
    defaultCutDuration: 0.5, // ç§’
    exportSettings: {
        maxWidth: 800,
        maxHeight: 800,
        quality: 10, // 1-30 (å°ã•ã„ã»ã©é«˜å“è³ª)
        workers: 2
    }
};

// AnimationSystemå†…ã§ç®¡ç†
const animationData = {
    cuts: [
        {
            id: 'cut_' + Date.now(),
            name: 'CUT1',
            duration: 0.5, // ç§’
            layerSnapshots: [
                {
                    layerId: 'layer_0',
                    visible: true,
                    opacity: 1.0,
                    transform: { 
                        x: 0, y: 0, 
                        rotation: 0,
                        scaleX: 1, scaleY: 1
                    },
                    pathsData: [] // ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼
                }
            ],
            thumbnailTexture: null // PIXI.RenderTexture
        }
    ],
    settings: {
        fps: 12,
        loop: true
    },
    playback: {
        isPlaying: false,
        currentCutIndex: 0,
        startTime: 0
    }
};
```

### 4. HTMLã‚¹ã‚¿ã‚¤ãƒ«è¿½åŠ ï¼ˆindex.htmlå†…ï¼‰

```css
/* ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ‘ãƒãƒ« */
.timeline-panel {
    position: fixed;
    bottom: 20px;
    left: 70px;
    right: 220px;
    background: var(--futaba-cream);
    border: 2px solid var(--futaba-maroon);
    border-radius: 12px;
    padding: 16px;
    z-index: 1500;
    max-height: 280px;
    display: none;
    box-shadow: 0 8px 24px rgba(128, 0, 0, 0.15);
}

.timeline-panel.show {
    display: block;
    animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
    from { opacity: 0; transform: translateY(20px); }
    to   { opacity: 1; transform: translateY(0); }
}

.timeline-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--futaba-light-medium);
}

.timeline-controls {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

.timeline-controls button {
    padding: 6px 12px;
    background: var(--futaba-background);
    border: 1px solid var(--futaba-medium);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.timeline-controls button:hover {
    background: var(--futaba-medium);
    border-color: var(--futaba-maroon);
}

.cuts-container {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    padding: 8px 0;
    margin-bottom: 12px;
    max-height: 120px;
}

.cut-item {
    min-width: 80px;
    background: var(--futaba-background);
    border: 2px solid var(--futaba-light-medium);
    border-radius: 8px;
    padding: 4px;
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
}

.cut-item:hover {
    border-color: var(--futaba-medium);
    transform: scale(1.05);
}

.cut-item.active {
    border-color: var(--futaba-maroon);
    background: var(--futaba-light-medium);
}

.cut-thumbnail {
    width: 72px;
    height: 54px;
    background: var(--futaba-background);
    border: 1px solid var(--futaba-light-medium);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 4px;
}

.cut-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.cut-thumbnail-placeholder {
    width: 100%;
    height: 100%;
    background: var(--futaba-light-medium);
}

.cut-info {
    text-align: center;
}

.cut-name {
    font-size: 10px;
    color: var(--text-primary);
    margin-bottom: 2px;
}

.cut-duration {
    width: 100%;
    font-size: 10px;
    text-align: center;
    border: 1px solid var(--futaba-light-medium);
    border-radius: 3px;
    padding: 2px;
}

.delete-cut-btn {
    position: absolute;
    top: 2px;
    right: 2px;
    width: 16px;
    height: 16px;
    background: rgba(128, 0, 0, 0.1);
    border: 1px solid var(--futaba-maroon);
    border-radius: 50%;
    color: var(--futaba-maroon);
    font-size: 10px;
    line-height: 1;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.cut-item:hover .delete-cut-btn {
    opacity: 1;
}

.timeline-settings {
    display: flex;
    gap: 16px;
    font-size: 12px;
    padding-top: 8px;
    border-top: 1px solid var(--futaba-light-medium);
}

.timeline-settings label {
    display: flex;
    align-items: center;
    gap: 4px;
}

.timeline-settings input[type="number"] {
    width: 50px;
    padding: 2px 4px;
    border: 1px solid var(--futaba-light-medium);
    border-radius: 3px;
}

.export-progress {
    margin-top: 12px;
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: var(--futaba-light-medium);
    border-radius: 4px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: var(--futaba-maroon);
    width: 0%;
    transition: width 0.3s ease;
}
```

---

## ğŸ”§ å®Ÿè£…è©³ç´°

### 1. AnimationSystem ã‚¯ãƒ©ã‚¹ï¼ˆsystem/animation-system.jsï¼‰

```javascript
(function() {
    'use strict';
    
    class AnimationSystem {
        constructor() {
            this.animationData = this.createDefaultAnimation();
            this.layerSystem = null;
            this.cameraSystem = null;
            this.app = null;
            this.eventBus = null;
            this.playbackTimer = null;
            this.isAnimationMode = false;
        }
        
        init(layerSystem, cameraSystem, app, eventBus) {
            this.layerSystem = layerSystem;
            this.cameraSystem = cameraSystem;
            this.app = app;
            this.eventBus = eventBus;
            
            console.log('âœ… AnimationSystem initialized');
        }
        
        createDefaultAnimation() {
            return {
                cuts: [],
                settings: {
                    fps: window.TEGAKI_CONFIG.animation.defaultFPS,
                    loop: true
                },
                playback: {
                    isPlaying: false,
                    currentCutIndex: 0,
                    startTime: 0
                }
            };
        }
        
        // CUTä½œæˆï¼ˆç¾åœ¨ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ï¼‰
        createCutFromCurrentState() {
            const cut = {
                id: 'cut_' + Date.now(),
                name: `CUT${this.animationData.cuts.length + 1}`,
                duration: window.TEGAKI_CONFIG.animation.defaultCutDuration,
                layerSnapshots: this.captureAllLayerStates(),
                thumbnailTexture: null
            };
            
            this.animationData.cuts.push(cut);
            this.generateCutThumbnail(this.animationData.cuts.length - 1);
            
            this.eventBus.emit('animation:cut-created', { cutId: cut.id });
            return cut;
        }
        
        // å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
        captureAllLayerStates() {
            const snapshots = [];
            
            this.layerSystem.layers.forEach(layer => {
                const layerId = layer.layerData.id;
                const transform = this.layerSystem.layerTransforms.get(layerId) || {
                    x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1
                };
                
                // ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ï¼ˆéç ´å£Šä¿å­˜ï¼‰
                const pathsData = layer.layerData.paths.map(path => ({
                    ...path,
                    points: [...path.points],
                    graphics: null // Graphicsã¯å†ç”Ÿæˆã™ã‚‹ã®ã§ä¿å­˜ã—ãªã„
                }));
                
                snapshots.push({
                    layerId: layerId,
                    visible: layer.layerData.visible,
                    opacity: layer.layerData.opacity,
                    transform: { ...transform },
                    pathsData: pathsData
                });
            });
            
            return snapshots;
        }
        
        // CUTã‚’é©ç”¨ï¼ˆãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹ã‚’å¾©å…ƒï¼‰
        applyCutToLayers(cutIndex) {
            const cut = this.animationData.cuts[cutIndex];
            if (!cut) return;
            
            // ä¸€æ™‚çš„ã«ã‚¤ãƒ™ãƒ³ãƒˆæŠ‘åˆ¶
            const originalEmit = this.eventBus.emit;
            this.eventBus.emit = () => {};
            
            cut.layerSnapshots.forEach(snapshot => {
                const layer = this.layerSystem.layers.find(
                    l => l.layerData.id === snapshot.layerId
                );
                
                if (!layer) return;
                
                // å¯è¦–æ€§ãƒ»é€æ˜åº¦é©ç”¨
                layer.layerData.visible = snapshot.visible;
                layer.visible = snapshot.visible;
                layer.layerData.opacity = snapshot.opacity;
                layer.alpha = snapshot.opacity;
                
                // å¤‰å½¢é©ç”¨
                this.layerSystem.layerTransforms.set(
                    snapshot.layerId, 
                    { ...snapshot.transform }
                );
                
                // ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿å¾©å…ƒï¼ˆéç ´å£Šï¼‰
                this.restoreLayerPaths(layer, snapshot.pathsData);
                
                // è¡¨ç¤ºä½ç½®æ›´æ–°
                const centerX = window.TEGAKI_CONFIG.canvas.width / 2;
                const centerY = window.TEGAKI_CONFIG.canvas.height / 2;
                layer.position.set(
                    centerX + snapshot.transform.x,
                    centerY + snapshot.transform.y
                );
                layer.rotation = snapshot.transform.rotation;
                layer.scale.set(
                    snapshot.transform.scaleX,
                    snapshot.transform.scaleY
                );
            });
            
            // ã‚¤ãƒ™ãƒ³ãƒˆå¾©å…ƒ
            this.eventBus.emit = originalEmit;
            
            // UIæ›´æ–°
            this.layerSystem.updateLayerPanelUI();
            this.eventBus.emit('animation:cut-applied', { cutIndex });
        }
        
        // ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æç”»ã‚’å¾©å…ƒ
        restoreLayerPaths(layer, pathsData) {
            // æ—¢å­˜ã®Graphicsã‚’ã‚¯ãƒªã‚¢
            layer.children.forEach(child => {
                if (child !== layer.layerData.backgroundGraphics) {
                    layer.removeChild(child);
                    if (child.destroy) child.destroy();
                }
            });
            
            // ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰Graphicsã‚’å†ç”Ÿæˆ
            layer.layerData.paths = pathsData.map(pathData => {
                const graphics = new PIXI.Graphics();
                
                // ãƒ‘ã‚¹æç”»
                pathData.points.forEach(point => {
                    graphics.circle(point.x, point.y, pathData.size / 2);
                    graphics.fill({
                        color: pathData.color,
                        alpha: pathData.opacity
                    });
                });
                
                layer.addChild(graphics);
                
                return {
                    ...pathData,
                    graphics: graphics
                };
            });
        }
        
        // ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆï¼ˆé…å»¶å‡¦ç†ï¼‰
        async generateCutThumbnail(cutIndex) {
            const cut = this.animationData.cuts[cutIndex];
            if (!cut) return;
            
            // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
            const backupSnapshots = this.captureAllLayerStates();
            
            // CUTçŠ¶æ…‹ã‚’é©ç”¨
            this.applyCutToLayers(cutIndex);
            
            // RenderTextureä½œæˆï¼ˆå°ã‚µã‚¤ã‚ºï¼‰
            const renderTexture = PIXI.RenderTexture.create({
                width: 80,
                height: 60,
                resolution: 1
            });
            
            // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
            this.app.renderer.render(
                this.layerSystem.layersContainer,
                { renderTexture }
            );
            
            cut.thumbnailTexture = renderTexture;
            
            // å…ƒã®çŠ¶æ…‹ã«æˆ»ã™ï¼ˆç°¡æ˜“ç‰ˆï¼‰
            // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ backupSnapshots ã‚’ä½¿ã£ã¦å®Œå…¨å¾©å…ƒ
            
            this.eventBus.emit('animation:thumbnail-generated', { cutIndex });
        }
        
        // å†ç”Ÿåˆ¶å¾¡
        play() {
            if (this.animationData.cuts.length === 0) return;
            
            this.animationData.playback.isPlaying = true;
            this.animationData.playback.startTime = Date.now();
            
            this.startPlaybackLoop();
            this.eventBus.emit('animation:playback-started');
        }
        
        pause() {
            this.animationData.playback.isPlaying = false;
            this.stopPlaybackLoop();
            this.eventBus.emit('animation:playback-paused');
        }
        
        stop() {
            this.animationData.playback.isPlaying = false;
            this.animationData.playback.currentCutIndex = 0;
            this.stopPlaybackLoop();
            this.applyCutToLayers(0);
            this.eventBus.emit('animation:playback-stopped');
        }
        
        startPlaybackLoop() {
            const fps = this.animationData.settings.fps;
            const frameTime = 1000 / fps;
            
            this.playbackTimer = setInterval(() => {
                this.updatePlayback();
            }, frameTime);
        }
        
        stopPlaybackLoop() {
            if (this.playbackTimer) {
                clearInterval(this.playbackTimer);
                this.playbackTimer = null;
            }
        }
        
        updatePlayback() {
            const currentCut = this.animationData.cuts[
                this.animationData.playback.currentCutIndex
            ];
            
            if (!currentCut) return;
            
            const elapsed = (Date.now() - this.animationData.playback.startTime) / 1000;
            
            if (elapsed >= currentCut.duration) {
                // æ¬¡ã®CUTã¸
                this.animationData.playback.currentCutIndex++;
                
                if (this.animationData.playback.currentCutIndex >= 
                    this.animationData.cuts.length) {
                    if (this.animationData.settings.loop) {
                        this.animationData.playback.currentCutIndex = 0;
                    } else {
                        this.stop();
                        return;
                    }
                }
                
                this.animationData.playback.startTime = Date.now();
                this.applyCutToLayers(this.animationData.playback.currentCutIndex);
            }
        }
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        toggleAnimationMode() {
            this.isAnimationMode = !this.isAnimationMode;
            
            if (this.isAnimationMode) {
                this.eventBus.emit('animation:mode-entered');
            } else {
                this.eventBus.emit('animation:mode-exited');
            }
            
            return this.isAnimationMode;
        }
    }
    
    window.TegakiAnimationSystem = AnimationSystem;
    console.log('âœ… animation-system.js loaded');
})();
```

### 2. GIFæ›¸ãå‡ºã—å‡¦ç†ï¼ˆsystem/gif-exporter.jsï¼‰

```javascript
(function() {
    'use strict';
    
    class GIFExporter {
        constructor(animationSystem, app) {
            this.animationSystem = animationSystem;
            this.app = app;
            this.isExporting = false;
        }
        
        async exportGIF(options = {}) {
            if (this.isExporting) {
                console.warn('GIF export already in progress');
                return;
            }
            
            const settings = {
                width: options.width || window.TEGAKI_CONFIG.canvas.width,
                height: options.height || window.TEGAKI_CONFIG.canvas.height,
                quality: options.quality || 
                    window.TEGAKI_CONFIG.animation.exportSettings.quality,
                workers: window.TEGAKI_CONFIG.animation.exportSettings.workers
            };
            
            // æœ€å¤§ã‚µã‚¤ã‚ºåˆ¶é™
            const maxSize = window.TEGAKI_CONFIG.animation.exportSettings;
            if (settings.width > maxSize.maxWidth) {
                const ratio = maxSize.maxWidth / settings.width;
                settings.width = maxSize.maxWidth;
                settings.height = Math.round(settings.height * ratio);
            }
            if (settings.height > maxSize.maxHeight) {
                const ratio = maxSize.maxHeight / settings.height;
                settings.height = maxSize.maxHeight;
                settings.width = Math.round(settings.width * ratio);
            }
            
            this.isExporting = true;
            
            try {
                // gif.js åˆæœŸåŒ–
                const gif = new GIF({
                    workers: settings.workers,
                    quality: settings.quality,
                    width: settings.width,
                    height: settings.height,
                    workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.min.js'
                });
                
                // é€²æ—ã‚¤ãƒ™ãƒ³ãƒˆ
                gif.on('progress', (progress) => {
                    window.TegakiEventBus.emit('gif:export-progress', { 
                        progress: Math.round(progress * 100) 
                    });
                });
                
                // å„CUTã‚’ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ã—ã¦è¿½åŠ 
                for (let i = 0; i < this.animationSystem.animationData.cuts.length; i++) {
                    const cut = this.animationSystem.animationData.cuts[i];
                    
                    // CUTé©ç”¨
                    this.animationSystem.applyCutToLayers(i);
                    
                    // é«˜è§£åƒåº¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                    const renderTexture = PIXI.RenderTexture.create({
                        width: settings.width,
                        height: settings.height,
                        resolution: 2 // é«˜è§£åƒåº¦ã§ç”Ÿæˆ
                    });
                    
                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ãƒŠã®ä¸­å¤®åŒ–èª¿æ•´
                    const tempContainer = new PIXI.Container();
                    const offsetX = (settings.width - window.TEGAKI_CONFIG.canvas.width) / 2;
                    const offsetY = (settings.height - window.TEGAKI_CONFIG.canvas.height) / 2;
                    
                    // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚³ãƒ”ãƒ¼é…ç½®
                    tempContainer.addChild(this.animationSystem.layerSystem.layersContainer);
                    tempContainer.position.set(offsetX, offsetY);
                    
                    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                    this.app.renderer.render(tempContainer, { renderTexture });
                    
                    // Canvaså–å¾—
                    const canvas = this.app.renderer.extract.canvas(renderTexture);
                    
                    // ãƒ•ãƒ¬ãƒ¼ãƒ è¿½åŠ ï¼ˆduration ã¯ãƒŸãƒªç§’ï¼‰
                    gif.addFrame(canvas, { 
                        delay: cut.duration * 1000 
                    });
                    
                    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    renderTexture.destroy();
                    tempContainer.removeChild(this.animationSystem.layerSystem.layersContainer);
                    this.animationSystem.layerSystem.layersContainer.position.set(0, 0);
                    
                    // é€²æ—æ›´æ–°
                    window.TegakiEventBus.emit('gif:frame-rendered', { 
                        frame: i + 1, 
                        total: this.animationSystem.animationData.cuts.length 
                    });
                }
                
                // GIFç”Ÿæˆå®Œäº†æ™‚
                gif.on('finished', (blob) => {
                    this.downloadGIF(blob);
                    this.isExporting = false;
                    window.TegakiEventBus.emit('gif:export-completed');
                });
                
                // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹
                gif.render();
                
            } catch (error) {
                console.error('GIF export failed:', error);
                this.isExporting = false;
                window.TegakiEventBus.emit('gif:export-failed', { error });
            }
        }
        
        downloadGIF(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `animation_${Date.now()}.gif`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    }
    
    window.TegakiGIFExporter = GIFExporter;
    console.log('âœ… gif-exporter.js loaded');
})();
```

### 3. ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³UIï¼ˆui/timeline-ui.jsï¼‰

```javascript
(function() {
    'use strict';
    
    class TimelineUI {
        constructor(animationSystem) {
            this.animationSystem = animationSystem;
            this.timelinePanel = null;
            this.cutsContainer = null;
            this.sortable = null;
            this.isVisible = false;
        }
        
        init() {
            this.createTimelinePanel();
            this.setupEventListeners();
            this.setupKeyboardShortcuts();
            console.log('âœ… TimelineUI initialized');
        }
        
        createTimelinePanel() {
            // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ‘ãƒãƒ«HTMLä½œæˆ
            const panel = document.createElement('div');
            panel.className = 'timeline-panel';
            panel.id = 'timeline-panel';
            panel.innerHTML = `
                <div class="timeline-header">
                    <h3>GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</h3>
                    <button class="close-btn" id="close-timeline">Ã—</button>
                </div>
                
                <div class="timeline-controls">
                    <button id="play-btn" title="å†ç”Ÿ (Space)">â–¶</button>
                    <button id="pause-btn" title="ä¸€æ™‚åœæ­¢">â¸</button>
                    <button id="stop-btn" title="åœæ­¢">â¹</button>
                    <button id="add-cut-btn" title="CUTè¿½åŠ  (Alt+Plus)">+ CUT</button>
                    <button id="export-gif-btn" title="GIFæ›¸ãå‡ºã—">GIFå‡ºåŠ›</button>
                </div>
                
                <div class="cuts-container" id="cuts-container">
                    <!-- CUTã‚¢ã‚¤ãƒ†ãƒ ãŒå‹•çš„ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                </div>
                
                <div class="timeline-settings">
                    <label>FPS: 
                        <input type="number" id="fps-input" 
                               min="1" max="60" value="12">
                    </label>
                    <label>
                        <input type="checkbox" id="loop-checkbox" checked>
                        ãƒ«ãƒ¼ãƒ—å†ç”Ÿ
                    </label>
                </div>
                
                <div class="export-progress" id="export-progress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <span id="progress-text">0%</span>
                </div>
            `;
            
            document.body.appendChild(panel);
            this.timelinePanel = panel;
            this.cutsContainer = document.getElementById('cuts-container');
        }
        
        setupEventListeners() {
            // å†ç”Ÿåˆ¶å¾¡
            document.getElementById('play-btn').addEventListener('click', () => {
                this.animationSystem.play();
            });
            
            document.getElementById('pause-btn').addEventListener('click', () => {
                this.animationSystem.pause();
            });
            
            document.getElementById('stop-btn').addEventListener('click', () => {
                this.animationSystem.stop();
            });
            
            // CUTè¿½åŠ 
            document.getElementById('add-cut-btn').addEventListener('click', () => {
                this.animationSystem.createCutFromCurrentState();
                this.updateCutsList();
            });
            
            // GIFæ›¸ãå‡ºã—
            document.getElementById('export-gif-btn').addEventListener('click', () => {
                this.exportGIF();
            });
            
            // ãƒ‘ãƒãƒ«é–‰ã˜ã‚‹
            document.getElementById('close-timeline').addEventListener('click', () => {
                this.hide();
            });
            
            // è¨­å®šå¤‰æ›´
            document.getElementById('fps-input').addEventListener('change', (e) => {
                this.animationSystem.animationData.settings.fps = 
                    parseInt(e.target.value);
            });
            
            document.getElementById('loop-checkbox').addEventListener('change', (e) => {
                this.animationSystem.animationData.settings.loop = e.target.checked;
            });
            
            // EventBusé€£æº
            window.TegakiEventBus.on('animation:cut-created', () => {
                this.updateCutsList();
            });
            
            window.TegakiEventBus.on('gif:export-progress', (data) => {
                this.updateExportProgress(data.progress);
            });
            
            window.TegakiEventBus.on('gif:export-completed', () => {
                this.hideExportProgress();
            });
        }
        
        setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Alt + A: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒãƒ«è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
                if (e.altKey && e.key === 'a') {
                    this.toggle();
                    e.preventDefault();
                }
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿
                if (this.isVisible) {
                    // Space: å†ç”Ÿ/ä¸€æ™‚åœæ­¢
                    if (e.key === ' ' && !e.ctrlKey && !e.altKey) {
                        if (this.animationSystem.animationData.playback.isPlaying) {
                            this.animationSystem.pause();
                        } else {
                            this.animationSystem.play();
                        }
                        e.preventDefault();
                    }
                    
                    // Alt + Plus: CUTè¿½åŠ 
                    if (e.altKey && e.key === '+') {
                        this.animationSystem.createCutFromCurrentState();
                        this.updateCutsList();
                        e.preventDefault();
                    }
                }
            });
        }
        
        updateCutsList() {
            this.cutsContainer.innerHTML = '';
            
            this.animationSystem.animationData.cuts.forEach((cut, index) => {
                const cutItem = document.createElement('div');
                cutItem.className = 'cut-item';
                cutItem.dataset.cutIndex = index;
                
                // ã‚µãƒ ãƒã‚¤ãƒ«è¡¨ç¤º
                let thumbnailHtml = '<div class="cut-thumbnail-placeholder"></div>';
                if (cut.thumbnailTexture) {
                    const canvas = this.animationSystem.app.renderer
                        .extract.canvas(cut.thumbnailTexture);
                    thumbnailHtml = `<img src="${canvas.toDataURL()}" />`;
                }
                
                cutItem.innerHTML = `
                    <div class="cut-thumbnail">${thumbnailHtml}</div>
                    <div class="cut-info">
                        <div class="cut-name">${cut.name}</div>
                        <input type="number" class="cut-duration" 
                               value="${cut.duration}" 
                               min="0.1" max="10" step="0.1">
                    </div>
                    <button class="delete-cut-btn" data-index="${index}">Ã—</button>
                `;
                
                // CUTé¸æŠ
                cutItem.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('delete-cut-btn') &&
                        !e.target.classList.contains('cut-duration')) {
                        this.animationSystem.applyCutToLayers(index);
                        this.setActiveCut(index);
                    }
                });
                
                // CUTå‰Šé™¤
                cutItem.querySelector('.delete-cut-btn')
                    .addEventListener('click', (e) => {
                        this.deleteCut(index);
                        e.stopPropagation();
                    });
                
                // æ™‚é–“å¤‰æ›´
                cutItem.querySelector('.cut-duration')
                    .addEventListener('change', (e) => {
                        cut.duration = parseFloat(e.target.value);
                    });
                
                this.cutsContainer.appendChild(cutItem);
            });
            
            // Sortable.js ã§ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—
            if (this.sortable) {
                this.sortable.destroy();
            }
            
            this.sortable = Sortable.create(this.cutsContainer, {
                animation: 150,
                onEnd: (evt) => {
                    this.reorderCuts(evt.oldIndex, evt.newIndex);
                }
            });
        }
        
        setActiveCut(index) {
            document.querySelectorAll('.cut-item').forEach((item, i) => {
                if (i === index) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }
        
        deleteCut(index) {
            this.animationSystem.animationData.cuts.splice(index, 1);
            this.updateCutsList();
        }
        
        reorderCuts(oldIndex, newIndex) {
            const cuts = this.animationSystem.animationData.cuts;
            const [removed] = cuts.splice(oldIndex, 1);
            cuts.splice(newIndex, 0, removed);
        }
        
        async exportGIF() {
            const exporter = new window.TegakiGIFExporter(
                this.animationSystem,
                this.animationSystem.app
            );
            
            this.showExportProgress();
            await exporter.exportGIF();
        }
        
        showExportProgress() {
            document.getElementById('export-progress').style.display = 'block';
        }
        
        updateExportProgress(progress) {
            document.getElementById('progress-fill').style.width = progress + '%';
            document.getElementById('progress-text').textContent = progress + '%';
        }
        
        hideExportProgress() {
            document.getElementById('export-progress').style.display = 'none';
        }
        
        show() {
            this.timelinePanel.classList.add('show');
            this.isVisible = true;
            this.animationSystem.toggleAnimationMode();
            this.updateCutsList();
        }
        
        hide() {
            this.timelinePanel.classList.remove('show');
            this.isVisible = false;
            if (this.animationSystem.isAnimationMode) {
                this.animationSystem.toggleAnimationMode();
            }
        }
        
        toggle() {
            if (this.isVisible) {
                this.hide();
            } else {
                this.show();
            }
        }
    }
    
    window.TegakiTimelineUI = TimelineUI;
    console.log('âœ… timeline-ui.js loaded');
})();