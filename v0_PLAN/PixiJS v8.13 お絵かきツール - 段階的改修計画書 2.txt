================================================================================
PixiJS v8.13 お絵かきツール - 段階的改修計画書 2/2
================================================================================
作成日: 2025-10-12
対象バージョン: v8.13_History37
スコープ: API層の統一とHistory統合（Phase 5-6）
前提条件: 計画書 1/2 の Phase 1-4 が完全に実装・検証済みであること

【重要】
計画書 2/2 は計画書 1/2 の Phase 1-4 のすべてが完了した状態から開始すること。
計画書 1/2 の Phase 1-4 が未完了の場合、エラーが多発する可能性があります。

================================================================================
改修の原則（計画書 1/2 から継続）
================================================================================

【SOLID原則とDRY原則】
- 単一責任: 各オブジェクトは1つの責任のみ保持
- 依存性逆転: 具体実装ではなく抽象（インターフェース）に依存
- DRY: データ定義は1箇所に集約

【グローバル化の統一ルール】
window 配下に公開されるもの:
- window.TegakiDataModels (LayerModel, CutModel の定義)
- window.TegakiBatchAPI (BatchAPI クラス定義)
- window.batchAPI (BatchAPI インスタンス ← Phase 5 で初期化)
- window.EventBus (状態変化の伝播)
- window.StateManager (状態照会)
- window.drawingApp (アプリケーション本体)

【依存関係の方向】
UI層 ← EventBus ← BatchAPI ← StateManager
                   ↓
            LayerSystem/AnimationSystem
                   ↓
                DataModel
                   ↓
            PIXI Objects / Canvas

【計画書 1/2 との異なる点】
計画書 1: 基本システムの改修（ユーザー目線での改善）
計画書 2: API層の統一（開発者目線での統一）

================================================================================
Phase 5: 標準化API実装 - BatchAPI
================================================================================

【目的と効果】
スプレッドシートUIからの一括操作を可能にする（History統合の準備）
所要時間: 40分
影響範囲: 2ファイル（新規 batch-api.js + core-engine.js 修正）
ユーザー実感: なし（内部API層の追加）

【修正対象ファイル】
system/batch-api.js（新規作成）
core-engine.js（初期化コード追加）

【参考ファイル】
system/data-models.js（LAYER_SCHEMA, CUT_SCHEMA 参照用）
system/layer-system.js（getLayers, requestThumbnailUpdate 参照用）
system/animation-system.js（animationData.cuts 参照用）

【処理フロー上の位置】

現状（計画書 1/2 完了後）:
UI → LayerSystem直接操作 → PIXI更新

改修後（Phase 5 以降）:
スプレッドシート/UI/コンソール
  → BatchAPI （データ検証 + 型チェック）
    → LayerSystem/StateManager （状態変更）
      → PIXI更新
    → EventBus （状態通知）
      → UI更新

【実装内容】

Step 1: system/batch-api.js を新規作成

ファイル名: system/batch-api.js

内容:
```javascript
(function() {
    'use strict';

    class BatchAPI {
        constructor(layerSystem, animationSystem) {
            this.layerSystem = layerSystem;
            this.animationSystem = animationSystem;
        }

        // ========== Layer 操作 ==========
        
        getLayer(index) {
            const layers = this.layerSystem.getLayers();
            if (index < 0 || index >= layers.length) return null;
            
            const layer = layers[index];
            return layer.layerData ? layer.layerData.toJSON() : null;
        }

        getAllLayers() {
            const layers = this.layerSystem.getLayers();
            return layers.map((layer, index) => ({
                index,
                ...layer.layerData.toJSON()
            }));
        }

        setLayerProperty(index, property, value) {
            const layers = this.layerSystem.getLayers();
            if (index < 0 || index >= layers.length) return false;
            
            const layer = layers[index];
            if (!layer.layerData) return false;
            
            const schema = window.TegakiDataModels.LAYER_SCHEMA[property];
            if (!schema || !schema.editable) return false;
            
            // 型チェック
            if (schema.type === 'number') {
                if (typeof value !== 'number') return false;
                if (schema.min !== undefined && value < schema.min) return false;
                if (schema.max !== undefined && value > schema.max) return false;
            }
            
            layer.layerData[property] = value;
            
            // PIXI オブジェクトへ反映
            if (property === 'visible') layer.visible = value;
            if (property === 'opacity') layer.alpha = value;
            
            this.layerSystem.requestThumbnailUpdate(index);
            return true;
        }

        renameLayer(index, newName) {
            return this.setLayerProperty(index, 'name', newName);
        }

        batchUpdateLayers(updates) {
            // updates = [{ index: 0, property: 'opacity', value: 0.5 }, ...]
            const results = [];
            
            for (const update of updates) {
                const success = this.setLayerProperty(
                    update.index, 
                    update.property, 
                    update.value
                );
                results.push({ ...update, success });
            }
            
            return results;
        }

        batchRenameLayers(pattern) {
            // pattern = { search: 'Layer', replace: 'レイヤー' }
            const layers = this.layerSystem.getLayers();
            const results = [];
            
            layers.forEach((layer, index) => {
                if (!layer.layerData) return;
                
                const oldName = layer.layerData.name;
                const newName = oldName.replace(
                    new RegExp(pattern.search, 'g'), 
                    pattern.replace
                );
                
                if (newName !== oldName) {
                    layer.layerData.name = newName;
                    results.push({ index, oldName, newName });
                }
            });
            
            this.layerSystem.updateLayerPanelUI();
            return results;
        }

        // ========== CUT 操作 ==========
        
        getCut(index) {
            const cut = this.animationSystem.animationData.cuts[index];
            if (!cut) return null;
            
            return {
                index,
                id: cut.id,
                name: cut.name,
                duration: cut.duration,
                layerCount: cut.getLayerCount ? cut.getLayerCount() : 0
            };
        }

        getAllCuts() {
            return this.animationSystem.animationData.cuts.map((cut, index) => ({
                index,
                id: cut.id,
                name: cut.name,
                duration: cut.duration,
                layerCount: cut.getLayerCount ? cut.getLayerCount() : 0
            }));
        }

        setCutProperty(index, property, value) {
            const cuts = this.animationSystem.animationData.cuts;
            if (index < 0 || index >= cuts.length) return false;
            
            const cut = cuts[index];
            const schema = window.TegakiDataModels.CUT_SCHEMA[property];
            if (!schema || !schema.editable) return false;
            
            // 型チェック + 範囲チェック
            if (schema.type === 'number') {
                if (typeof value !== 'number') return false;
                if (schema.min !== undefined && value < schema.min) return false;
                if (schema.max !== undefined && value > schema.max) return false;
            }
            
            cut[property] = value;
            return true;
        }

        renameCut(index, newName) {
            return this.setCutProperty(index, 'name', newName);
        }

        setAllCutsDuration(duration) {
            const cuts = this.animationSystem.animationData.cuts;
            let successCount = 0;
            
            cuts.forEach(cut => {
                if (duration >= 0.01 && duration <= 10) {
                    cut.duration = duration;
                    successCount++;
                }
            });
            
            return { total: cuts.length, success: successCount };
        }

        batchUpdateCuts(updates) {
            const results = [];
            
            for (const update of updates) {
                const success = this.setCutProperty(
                    update.index, 
                    update.property, 
                    update.value
                );
                results.push({ ...update, success });
            }
            
            return results;
        }

        // ========== スキーマ取得 ==========
        
        getLayerPropSchema() {
            return window.TegakiDataModels.LAYER_SCHEMA;
        }

        getCutPropSchema() {
            return window.TegakiDataModels.CUT_SCHEMA;
        }

        // ========== エクスポート用データ取得 ==========
        
        exportLayersAsTable() {
            const layers = this.getAllayers();
            return layers.map(layer => ({
                '番号': layer.index + 1,
                '名前': layer.name,
                '表示': layer.visible ? '○' : '×',
                '不透明度': Math.round(layer.opacity * 100) + '%',
                'クリッピング': layer.clipping ? '○' : '×',
                'ロック': layer.locked ? '○' : '×'
            }));
        }

        exportCutsAsTable() {
            const cuts = this.getAllCuts();
            return cuts.map(cut => ({
                '番号': cut.index + 1,
                'CUT名': cut.name,
                '時間': cut.duration.toFixed(2) + 's',
                'レイヤー数': cut.layerCount
            }));
        }
    }

    window.TegakiBatchAPI = BatchAPI;

    console.log('✅ batch-api.js loaded');
})();
```

Step 2: index.html で batch-api.js を読み込み

現状:
```html
<script src="system/data-models.js"></script>
<script src="system/event-bus.js"></script>
...
```

修正後（batch-api.js を追加、data-models.js の後）:
```html
<script src="system/data-models.js"></script>
<script src="system/batch-api.js"></script>
<script src="system/event-bus.js"></script>
...
```

Step 3: core-engine.js で BatchAPI インスタンスを初期化

ファイル: core-engine.js
メソッド: initialize()

現状コード例:
```javascript
initialize() {
    // ... 既存初期化コード ...
    
    this.layerManager = new window.LayerSystem(this.app, this.eventBus);
    this.animationSystem = new window.AnimationSystem(this.eventBus);
    this.history = new window.History(this.eventBus);
    
    // ... 残りの初期化 ...
}
```

修正後コード:
```javascript
initialize() {
    // ... 既存初期化コード ...
    
    this.layerManager = new window.LayerSystem(this.app, this.eventBus);
    this.animationSystem = new window.AnimationSystem(this.eventBus);
    this.history = new window.History(this.eventBus);
    
    // ← ここに追加
    this.batchAPI = new window.TegakiBatchAPI(
        this.layerManager,
        this.animationSystem
    );
    
    // グローバル公開（開発用）
    window.batchAPI = this.batchAPI;
    
    // ... 残りの初期化 ...
}
```

【検証ポイント】

ブラウザコンソールで以下を実行:

1. BatchAPI が定義されているか確認
```javascript
window.batchAPI
// → BatchAPI インスタンスが返される
```

2. 全レイヤーを取得
```javascript
window.batchAPI.getAllLayers()
// → [ { index: 0, id: "layer_...", name: "...", ... }, ... ]
```

3. レイヤープロパティを変更
```javascript
window.batchAPI.setLayerProperty(0, 'opacity', 0.5)
// → true が返される
```

4. スキーマを取得
```javascript
window.batchAPI.getLayerPropSchema()
// → LAYER_SCHEMA が返される
```

5. 全CUTを取得
```javascript
window.batchAPI.getAllCuts()
// → [ { index: 0, id: "cut_...", name: "CUT", ... }, ... ]
```

【エラー検証タイミング（重要）】

Phase 5 修正直後に以下を確認:

1. index.html の読み込み順確認
   data-models.js → batch-api.js → 他のシステム の順
   そうしないと TegakiBatchAPI が未定義でエラー

2. core-engine.js で BatchAPI が初期化されているか
   アプリ起動直後にコンソールで:
   ```javascript
   window.drawingApp.batchAPI
   // → undefined でなく BatchAPI インスタンスが返される
   ```

3. 既存のUIが壊れていないか確認
   通常のストロークが描画できる
   レイヤー操作ができる

【よくあるエラー】

エラー: "TegakiBatchAPI is not defined"
原因: index.html で batch-api.js が読み込まれていない、または読み込み順が間違っている
解決: index.html の script タグを確認して、batch-api.js が data-models.js の後に読まれることを確認

エラー: "this.layerManager is undefined"
原因: core-engine.js で BatchAPI 初期化時に this.layerManager が未設定
解決: initialize() メソッド内で LayerSystem の初期化が BatchAPI より前にあることを確認

【進行チェックリスト】
□ 計画書 1/2 の Phase 1-4 がすべて完了していることを確認
□ system/batch-api.js を新規作成
□ index.html の script タグに batch-api.js を追加
□ core-engine.js の initialize() で BatchAPI を初期化
□ window.batchAPI が定義されていることをコンソールで確認
□ window.batchAPI.getAllLayers() でレイヤー情報が返されることを確認
→ 完了後、Phase 6 へ進む

================================================================================
Phase 6: History統合 - BatchAPI操作の記録
================================================================================

【目的と効果】
スプレッドシート/API経由の操作も Undo/Redo 対象にする
所要時間: 20分
影響範囲: 2ファイル（batch-api.js 修正 + history.js 確認）
ユーザー実感: 中（APIでの一括操作も Undo/Redo 可能に）

【修正対象ファイル】
system/batch-api.js（Phase 5 で作成）

【参考ファイル】
system/history.js（History クラスの API 確認用）

【処理フロー上の位置】

現状（Phase 5 完了後）:
BatchAPI.setLayerProperty()
  → LayerSystem 更新
  → PIXI 更新

改修後（Phase 6 以降）:
BatchAPI.setLayerProperty()
  → History.push() ← ★ 追加
    → do/undo コマンド登録
  → LayerSystem 更新
  → PIXI 更新
  → UI 更新

【具体的な修正内容】

Step 1: BatchAPI.setLayerProperty に History 統合

ファイル: system/batch-api.js
メソッド: setLayerProperty(index, property, value)

現状コード:
```javascript
setLayerProperty(index, property, value) {
    const layers = this.layerSystem.getLayers();
    if (index < 0 || index >= layers.length) return false;
    
    const layer = layers[index];
    if (!layer.layerData) return false;
    
    const schema = window.TegakiDataModels.LAYER_SCHEMA[property];
    if (!schema || !schema.editable) return false;
    
    // 型チェック
    if (schema.type === 'number') {
        if (typeof value !== 'number') return false;
        if (schema.min !== undefined && value < schema.min) return false;
        if (schema.max !== undefined && value > schema.max) return false;
    }
    
    layer.layerData[property] = value;
    
    // PIXI オブジェクトへ反映
    if (property === 'visible') layer.visible = value;
    if (property === 'opacity') layer.alpha = value;
    
    this.layerSystem.requestThumbnailUpdate(index);
    return true;
}
```

修正後コード:
```javascript
setLayerProperty(index, property, value) {
    const layers = this.layerSystem.getLayers();
    if (index < 0 || index >= layers.length) return false;
    
    const layer = layers[index];
    if (!layer.layerData) return false;
    
    const schema = window.TegakiDataModels.LAYER_SCHEMA[property];
    if (!schema || !schema.editable) return false;
    
    // 型チェック
    if (schema.type === 'number') {
        if (typeof value !== 'number') return false;
        if (schema.min !== undefined && value < schema.min) return false;
        if (schema.max !== undefined && value > schema.max) return false;
    }
    
    // ← History 統合（Undo/Redo対応）
    if (window.History && !window.History._manager.isApplying) {
        const oldValue = layer.layerData[property];
        
        const command = {
            name: 'layer-property-change',
            do: () => {
                layer.layerData[property] = value;
                if (property === 'visible') layer.visible = value;
                if (property === 'opacity') layer.alpha = value;
                this.layerSystem.requestThumbnailUpdate(index);
            },
            undo: () => {
                layer.layerData[property] = oldValue;
                if (property === 'visible') layer.visible = oldValue;
                if (property === 'opacity') layer.alpha = oldValue;
                this.layerSystem.requestThumbnailUpdate(index);
            },
            meta: { 
                type: 'layer-prop', 
                index, 
                property, 
                oldValue, 
                newValue: value 
            }
        };
        
        window.History.push(command);
    } else {
        // History が無効な場合は直接実行
        layer.layerData[property] = value;
        if (property === 'visible') layer.visible = value;
        if (property === 'opacity') layer.alpha = value;
        this.layerSystem.requestThumbnailUpdate(index);
    }
    
    return true;
}
```

修正理由:
window.History が存在し、かつ History が現在「Undo/Redo適用中」でない場合は、
do/undo コマンドを登録する。これにより、API経由での操作も Undo/Redo の対象になる。
window.History._manager.isApplying フラグは、Undo/Redo実行中に
「二重記録」を防ぐための保護機構。

Step 2: batchUpdateLayers に History 統合

ファイル: system/batch-api.js
メソッド: batchUpdateLayers(updates)

現状コード:
```javascript
batchUpdateLayers(updates) {
    // updates = [{ index: 0, property: 'opacity', value: 0.5 }, ...]
    const results = [];
    
    for (const update of updates) {
        const success = this.setLayerProperty(
            update.index, 
            update.property, 
            update.value
        );
        results.push({ ...update, success });
    }
    
    return results;
}
```

修正後コード:
```javascript
batchUpdateLayers(updates) {
    // Composite コマンドを使用（複数操作を1つの Undo/Redo で扱う）
    if (window.History && !window.History._manager.isApplying) {
        const commands = [];
        
        for (const update of updates) {
            const layers = this.layerSystem.getLayers();
            const layer = layers[update.index];
            if (!layer?.layerData) continue;
            
            const oldValue = layer.layerData[update.property];
            
            commands.push({
                name: 'layer-prop-batch-item',
                do: () => {
                    this.setLayerProperty(update.index, update.property, update.value);
                },
                undo: () => {
                    this.setLayerProperty(update.index, update.property, oldValue);
                },
                meta: { index: update.index, property: update.property }
            });
        }
        
        if (commands.length > 0) {
            // 複数のコマンドをまとめて1つの Undo/Redo にする
            const composite = window.History.createComposite(
                commands, 
                'batch-layer-update'
            );
            window.History.push(composite);
        }
        
        return updates.map(u => ({ ...u, success: true }));
    }
    
    // History が無効な場合は通常実行
    const results = [];
    for (const update of updates) {
        const success = this.setLayerProperty(
            update.index, 
            update.property, 
            update.value
        );
        results.push({ ...update, success });
    }
    return results;
}
```

修正理由:
複数の Layer 更新を一度に行う場合、1つ1つ History に記録すると
Undo を複数回実行する必要がある。
createComposite() メソッドで複数のコマンドをまとめることで、
1回の Undo/Redo で全ての操作を巻き戻す/やり直すことができる。

Step 3: batchRenameLayers に History 統合

ファイル: system/batch-api.js
メソッド: batchRenameLayers(pattern)

現状コード:
```javascript
batchRenameLayers(pattern) {
    // pattern = { search: 'Layer', replace: 'レイヤー' }
    const layers = this.layerSystem.getLayers();
    const results = [];
    
    layers.forEach((layer, index) => {
        if (!layer.layerData) return;
        
        const oldName = layer.layerData.name;
        const newName = oldName.replace(
            new RegExp(pattern.search, 'g'), 
            pattern.replace
        );
        
        if (newName !== oldName) {
            layer.layerData.name = newName;
            results.push({ index, oldName, newName });
        }
    });
    
    this.layerSystem.updateLayerPanelUI();
    return results;
}
```

修正後コード:
```javascript
batchRenameLayers(pattern) {
    const layers = this.layerSystem.getLayers();
    const changes = [];
    
    // 変更対象を事前に集計
    layers.forEach((layer, index) => {
        if (!layer.layerData) return;
        
        const oldName = layer.layerData.name;
        const newName = oldName.replace(
            new RegExp(pattern.search, 'g'), 
            pattern.replace
        );
        
        if (newName !== oldName) {
            changes.push({ index, oldName, newName });
        }
    });
    
    // History 記録
    if (window.History && !window.History._manager.isApplying) {
        const commands = changes.map(change => ({
            name: 'layer-rename-batch-item',
            do: () => {
                const layer = this.layerSystem.getLayers()[change.index];
                if (layer?.layerData) {
                    layer.layerData.name = change.newName;
                }
            },
            undo: () => {
                const layer = this.layerSystem.getLayers()[change.index];
                if (layer?.layerData) {
                    layer.layerData.name = change.oldName;
                }
            },
            meta: { index: change.index }
        }));
        
        if (commands.length > 0) {
            const composite = window.History.createComposite(
                commands, 
                'batch-rename-layers'
            );
            window.History.push(composite);
        }
    } else {
        // History が無効な場合は直接実行
        changes.forEach(change => {
            const layer = layers[change.index];
            if (layer?.layerData) {
                layer.layerData.name = change.newName;
            }
        });
    }
    
    this.layerSystem.updateLayerPanelUI();
    return changes;
}
```

修正理由:
複数のレイヤー名を一度に変更する場合、1回の Undo/Redo で
全てのレイヤー名が巻き戻る/やり直されるように Composite コマンドを使用。

Step 4: CUT 操作にも History 統合を追加（オプション）

ファイル: system/batch-api.js
メソッド: setCutProperty(index, property, value)

現状コード:
```javascript
setCutProperty(index, property, value) {
    const cuts = this.animationSystem.animationData.cuts;
    if (index < 0 || index >= cuts.length) return false;
    
    const cut = cuts[index];
    const schema = window.TegakiDataModels.CUT_SCHEMA[property];
    if (!schema || !schema.editable) return false;
    
    // 型チェック + 範囲チェック
    if (schema.type === 'number') {
        if (typeof value !== 'number') return false;
        if (schema.min !== undefined && value < schema.min) return false;
        if (schema.max !== undefined && value > schema.max) return false;
    }
    
    cut[property] = value;
    return true;
}
```

修正後コード:
```javascript
setCutProperty(index, property, value) {
    const cuts = this.animationSystem.animationData.cuts;
    if (index < 0 || index >= cuts.length) return false;
    
    const cut = cuts[index];
    const schema = window.TegakiDataModels.CUT_SCHEMA[property];
    if (!schema || !schema.editable) return false;
    
    // 型チェック + 範囲チェック
    if (schema.type === 'number') {
        if (typeof value !== 'number') return false;
        if (schema.min !== undefined && value < schema.min) return false;
        if (schema.max !== undefined && value > schema.max) return false;
    }
    
    // ← History 統合（同じパターンで実装）
    if (window.History && !window.History._manager.isApplying) {
        const oldValue = cut[property];
        
        const command = {
            name: 'cut-property-change',
            do: () => {
                cut[property] = value;
            },
            undo: () => {
                cut[property] = oldValue;
            },
            meta: { type: 'cut-prop', index, property, oldValue, newValue: value }
        };
        
        window.History.push(command);
    } else {
        cut[property] = value;
    }
    
    return true;
}
```

【検証ポイント】

ブラウザコンソールで以下を実行:

1. 単一レイヤーのプロパティ変更と Undo/Redo
```javascript
window.batchAPI.setLayerProperty(0, 'opacity', 0.5)
// 画面上で opacity が変更される
window.drawingApp.undo()  // Ctrl+Z
// opacity が元の値に戻る
window.drawingApp.redo()  // Ctrl+Y
// opacity が再度 0.5 に戻る
```

2. 一括レイヤー更新と Undo/Redo
```javascript
window.batchAPI.batchUpdateLayers([
    { index: 0, property: 'opacity', value: 0.5 },
    { index: 1, property: 'visible', value: false }
])
// 2つのレイヤーが更新される
window.drawingApp.undo()  // Ctrl+Z
// 2つの変更が同時に巻き戻る（1回の Undo で完了）
```

3. 一括リネームと Undo/Redo
```javascript
window.batchAPI.batchRenameLayers({ search: 'レイヤー', replace: 'Layer' })
// 全てのレイヤー名が置換される
window.drawingApp.undo()  // Ctrl+Z
// 全てのレイヤー名が元に戻る（1回の Undo で完了）
```

4. ブラウザコンソールでエラーなし
```javascript
console.clear()
// エラーが出ていないことを確認
```

【エラー検証タイミング（重要）】

Phase 6 修正直後に以下を確認:

1. History が有効になっているか
   アプリ起動直後にコンソールで:
   ```javascript
   window.History
   // → History クラスが返される
   ```

2. BatchAPI 操作が History に記録されているか
   ```javascript
   window.batchAPI.setLayerProperty(0, 'opacity', 0.5)
   window.drawingApp.undo()
   // opacity が元の値に戻ることで確認
   ```

3. Composite コマンドが動作しているか
   ```javascript
   window.batchAPI.batchUpdateLayers([...])
   window.drawingApp.undo()
   // 全ての変更が1回の Undo で巻き戻ることで確認
   ```

【よくあるエラー】

エラー: "window.History is undefined"
原因: history.js が読み込まれていない、または初期化されていない
解決: index.html で history.js が読み込まれていることを確認
     core-engine.js で this.history = new window.History(...) が実行されていることを確認

エラー: History に BatchAPI 操作が記録されていない
原因: window.History._manager.isApplying チェックが機能していない
解決: history.js の History クラスに _manager プロパティと isApplying フラグが
     定義されていることを確認

【進行チェックリスト】
□ Phase 5 が完了していることを確認
□ batch-api.js の setLayerProperty に History コマンド登録を追加
□ batch-api.js の batchUpdateLayers に Composite コマンド登録を追加
□ batch-api.js の batchRenameLayers に Composite コマンド登録を追加
□ batch-api.js の setCutProperty に History コマンド登録を追加（オプション）
□ ブラウザコンソールでエラーなし
□ BatchAPI 操作が Undo/Redo できることを確認
□ Composite コマンドが1回の Undo で複数操作を巻き戻すことを確認
→ 完了後、計画書 1/2 と 2/2 の全 Phase が完了

================================================================================
計画書 1/2 と 2/2 の統合チェックリスト
================================================================================

【全 Phase 完了後の総合検証】

Step 1: 基本機能の動作確認
□ アプリ起動時にエラーなし
□ 複数のストローク描画が可能
□ レイヤー作成/削除/リネームが可能
□ ズーム操作が滑らか（Phase 2 の効果）
□ レイヤー移動時に UI がカクつかない（Phase 3 の効果）

Step 2: DataModel の統合確認
□ 新規レイヤーに layer.layerData が存在
□ layer.layerData.toJSON() が正しい形式のデータを返す
□ LayerModel/CutModel の validate() がエラーチェック可能

Step 3: BatchAPI の統合確認
□ window.batchAPI が定義されている
□ BatchAPI で全レイヤー情報を取得可能
□ BatchAPI でレイヤープロパティを変更可能
□ BatchAPI で一括操作が可能

Step 4: History 統合の確認
□ UI操作（ストローク描画など）が Undo/Redo 可能
□ BatchAPI 操作が Undo/Redo 可能
□ Composite コマンドで複数操作が1回の Undo/Redo で処理される

Step 5: パフォーマンス改善の確認
□ MemoryProfile でメモリリークがないこと（Phase 1）
□ カメラズーム時に fps 低下がないこと（Phase 2）
□ レイヤー移動時に UI がスムーズであること（Phase 3）

【最終動作確認シナリオ】

1. アプリ起動
2. 複数のストロークを描画（10本程度）
3. レイヤー名を変更
4. Ctrl+Z で undo
5. Ctrl+Y で redo
6. V キーでレイヤー移動モード
7. マウスでレイヤーを移動
8. V キーを離す
9. マウスホイールでカメラをズーム
10. コンソールで以下を実行
    ```javascript
    window.batchAPI.setLayerProperty(0, 'opacity', 0.3)
    window.drawingApp.undo()
    ```
11. opacity が元に戻ることで確認
12. ブラウザ DevTools の Memory タブで
    複数の操作後もメモリ使用量が安定していることを確認

【既知の制限事項】

現状（計画書 2/2 完了時点）:
- ペンツール（stroke-recorder, drawing-engine）は未改修
  → 計画書 3/3（予定）で改修予定
- Export 機能は未改修
  → 計画書 3/3（予定）で改修予定
- スプレッドシート UI は実装されていない
  → Phase 7（予定）で実装予定

【次ステップ（計画書 3/3 予定）】

Phase 7: ペンツール統合（別途計画書にて）
- stroke-recorder, drawing-engine の EventBus 対応
- path を LayerModel.paths に統合
- ペン操作を History に記録

Phase 8: Export機能統合（別途計画書にて）
- export-manager, exporters の DataModel 対応
- layer.layerData.paths から paths を取得
- export時のスキーマ検証

================================================================================
終了
================================================================================