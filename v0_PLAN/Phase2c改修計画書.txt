# Phase2c改修計画書（GPT5案準拠）

## 現状問題分析

### 主要問題
1. **座標系の混在**：screen/world/canvas座標の統一API不在
2. **変形確定（transform の焼き込み）の不整合**：confirmLayerTransform実装未完成
3. **レイヤーAPIの断片化**：システム間の結合度低下で機能不全
4. **EventBus統合の不完全性**：レガシー直接参照と新規EventBusの混在
5. **設定参照の混在**：CONFIG参照の不統一

### 具体的症状
- ペン描画が左にズレる（座標変換API不一致）
- レイヤー移動・回転の中心が不正（アンカー計算不正）
- 変形確定後に絵が消える（二重適用・消失）
- レイヤーパネルの階層移動不可（UI統合不完全）
- 新規レイヤー作成不可（API断片化）
- キャンバスサイズ変更不可（システム間連携不良）
- コピー＆ペーストで消失（canonical座標未対応）

## 設計原則（GPT5案準拠）

### 1. 座標系厳密定義
- **screen**: ブラウザのクライアントピクセル（mouse event の clientX/Y）
- **world**: worldContainer 上の座標（Camera の pan/zoom/rotation を含む）
- **canvas (canonical)**: キャンバス内容の論理座標。**path.points は常にこの座標で保存**
- **local**: Layer コンテナのローカル座標（通常 canvas と同義）

### 2. パス保存の統一ルール
- パス（path.points）は**常に canvas（canonical）座標で保持**
- 描画は Camera/Layer の transform を合成してスクリーンへ投影
- Container の transform は表示のためのみ使用

### 3. レイヤー変形管理統一
- LayerSystem が変形を一元管理
- 変形確定（confirm）時は points に焼き込み、Container transform をリセット
- **二重適用・消失を完全排除**

### 4. Clipboard の canonical 化
- Copy/Paste は canonical 座標で実行（変形状態は保存しない）

### 5. EventBus統合
- EventBus（文字列定義されたイベント）で同期実行
- 直接参照の削減（レガシー参照は段階的移行）

## 改修対象範囲

### 対象ファイル（4ファイルのみ）
- `core-engine.js`（中枢制御）
- `systems/camera-system.js`（座標変換API）
- `systems/layer-system.js`（レイヤー管理・変形確定）
- `systems/drawing-clipboard.js`（非破壊コピー&ペースト）

### 非対象ファイル（触らない）
- `ui-panels.js`
- `core-runtime.js`
- `config.js`
- その他既存ファイル

### API追加・拡張
- 必要な public API/イベントは `core-engine.js` に追加
- 外部ファイルとの整合性維持

## フェーズ別改修計画

### フェーズA（最優先・必須）

#### A1. 座標変換API明確化・実装（最重要）
**目的**: ペン描画の左ズレ問題解消

**実装内容**:
```javascript
// CameraSystem 改修
class CameraSystem {
    /**
     * @input screen coordinates
     * @output world coordinates
     */
    screenToWorld({x, y}) {
        const rect = app.view.getBoundingClientRect();
        const screenX = x - rect.left;
        const screenY = y - rect.top;
        return this.worldContainer.toLocal({x: screenX, y: screenY}, app.stage);
    }
    
    /**
     * @input world coordinates  
     * @output canvas (canonical) coordinates
     */
    worldToCanvas({x, y}) {
        return this.canvasContainer.toLocal({x, y}, this.worldContainer);
    }
    
    /**
     * @input screen coordinates
     * @output canvas (canonical) coordinates
     */
    screenToCanvas({x, y}) {
        const world = this.screenToWorld({x, y});
        return this.worldToCanvas(world);
    }
    
    // 逆変換も実装
    canvasToWorld({x, y}) { /* ... */ }
    canvasToScreen({x, y}) { /* ... */ }
}
```

#### A2. DrawingEngine入力ルート統一
**目的**: screen→canvas座標変換の一元化

```javascript
// DrawingEngine 改修
startDrawing(screenX, screenY) {
    // 必ず camera.screenToCanvas() を経由
    const canvasPoint = this.cameraSystem.screenToCanvas({x: screenX, y: screenY});
    // path.points は canonical 座標で保存
    this.currentPath.points.push(canvasPoint);
}
```

#### A3. LayerSystem.confirmLayerTransform() 非破壊正実装
**目的**: 変形確定時の絵の消失問題解消

```javascript
// LayerSystem 改修
confirmLayerTransform(layerId) {
    const transform = this.layerTransforms.get(layerId);
    if (isIdentity(transform)) return;
    
    const layer = this.getLayerById(layerId);
    const matrix = buildTransformMatrix(transform, this.getCanvasCenterAnchor());
    
    // パス座標に変形を焼き込み
    layer.layerData.paths.forEach(path => {
        path.points = path.points.map(pt => matrix.apply(pt));
    });
    
    // Container transform をリセット（重要）
    this.layerTransforms.set(layerId, identityTransform());
    layer.container.setTransform(0, 0, 1, 1, 0);
    
    // Graphics 再構築
    this.rebuildLayerGraphics(layer);
    
    EventBus.emit('layer:transform:confirmed', {layerId});
}
```

#### A4. ClipBoard canonical化
**目的**: コピー＆ペースト時の消失問題解消

```javascript
// ClipboardSystem 改修
copy() {
    const canonicalPaths = this.layerSystem.getLayerCanonicalPaths(layerId);
    this.clipboardData = {
        paths: deepCopy(canonicalPaths), // canonical座標のまま
        transform: identityTransform() // 初期状態で保存
    };
}

paste() {
    const newLayer = this.layerSystem.createLayer(name);
    // canonical座標をそのまま復元
    this.clipboardData.paths.forEach(path => {
        this.layerSystem.addPathToLayer(newLayer, path);
    });
}
```

### フェーズB（中期）

#### B1. rebuildPathGraphics() ルール固定化
- path.graphics の position を {0,0} 固定
- Container transform の非破壊管理

#### B2. EventBus契約定義・配備
```javascript
// イベント定義
'layer:transform:confirmed' → {layerId, layerIndex}
'layer:paths:changed' → {layerId}
'camera:resize' → {width, height}
'clipboard:copied' → {layerId}
'layer:order:changed' → {layerId, newIndex}
```

#### B3. レイヤーパネル階層移動API安定化
- レイヤー順序・アクティブ移動
- 移動時のアンカー補正

### フェーズC（拡張・安定化）

#### C1. キャンバスサイズ変更対応
- キャンバス依存レイヤーの扱い
- サムネイル更新

#### C2. Undo/Redo 拡張
- 変形確定前後の履歴管理

#### C3. テストスイート
- 単体手順チェックリスト

## 具体的改修手順（コピペレベル）

### 1. CameraSystem座標変換API統一（最優先）

```javascript
// systems/camera-system.js
class CameraSystem {
    // DOM getBoundingClientRect()・CSS scale考慮
    screenToWorld(screenPt) {
        const rect = this.app.view.getBoundingClientRect();
        const x = screenPt.x - rect.left;
        const y = screenPt.y - rect.top;
        // devicePixelRatio補正も考慮
        return this.worldContainer.toLocal({x, y}, this.app.stage);
    }
    
    worldToCanvas(worldPt) {
        return this.canvasContainer.toLocal(worldPt, this.worldContainer);
    }
    
    screenToCanvas(screenPt) {
        const world = this.screenToWorld(screenPt);
        return this.worldToCanvas(world);
    }
    
    // 必須：逆変換
    canvasToWorld(canvasPt) {
        return this.worldContainer.toLocal(canvasPt, this.canvasContainer);
    }
    
    canvasToScreen(canvasPt) {
        const world = this.canvasToWorld(canvasPt);
        return this.worldToScreen(world);
    }
}
```

### 2. LayerSystem変形確定非破壊実装

```javascript
// systems/layer-system.js
confirmLayerTransform(layerId) {
    const transform = this.layerTransforms.get(layerId);
    if (this.isIdentityTransform(transform)) return;
    
    const layer = this.getLayerById(layerId);
    
    // アンカー中心でのマトリックス作成
    const centerX = CONFIG.canvas.width / 2;
    const centerY = CONFIG.canvas.height / 2;
    const matrix = this.buildTransformMatrix(transform, centerX, centerY);
    
    // パスに焼き込み（非破壊）
    layer.layerData.paths.forEach(path => {
        path.points = path.points.map(pt => matrix.apply(pt));
    });
    
    // Container リセット（重要）
    this.layerTransforms.set(layerId, this.identityTransform());
    layer.container.setTransform(0, 0, 1, 1, 0);
    layer.container.removeChildren();
    
    // Graphics再構築
    layer.layerData.paths.forEach(path => {
        this.rebuildPathGraphics(path);
        layer.container.addChild(path.graphics);
    });
    
    EventBus.emit('layer:transform:confirmed', {layerId});
}
```

### 3. Clipboard canonical化実装

```javascript
// systems/drawing-clipboard.js
copy() {
    const layerSystem = this.getLayerSystem();
    const canonicalPaths = layerSystem.getLayerCanonicalPaths(this.activeLayerId);
    
    this.clipboardData = {
        paths: this.deepCopyPaths(canonicalPaths), // canonical座標
        metadata: { copiedAt: Date.now(), isCanonical: true }
    };
}

paste() {
    if (!this.clipboardData?.paths) return;
    
    const layerSystem = this.getLayerSystem();
    const newLayer = layerSystem.createLayer('コピーレイヤー');
    
    // canonical座標そのまま復元
    this.clipboardData.paths.forEach(path => {
        const restoredPath = this.deepCopyPath(path);
        layerSystem.addPathToLayer(newLayer, restoredPath);
    });
}
```

## テストチェックリスト（必須実行順序）

### 1. 座標変換API検証
- [ ] ペンで描画 → 見た目通りcanvasに保存される
- [ ] screen→canvas入力が正確
- [ ] マウス位置とペン描画位置の一致

### 2. レイヤー変形確定検証
- [ ] レイヤー移動 → 確定 → 絵が消えない
- [ ] 移動→確定→拡縮・回転 → 消えない
- [ ] 変形確定前後での座標整合性

### 3. コピー&ペースト検証
- [ ] コピー → ペースト → 見た目同一で復元
- [ ] 複数回ペーストが正確
- [ ] 変形中レイヤーのコピーペースト

### 4. レイヤー操作検証
- [ ] レイヤー階層移動の正確性
- [ ] アクティブレイヤー移動が正しく反映
- [ ] 新規レイヤー作成の正常動作

### 5. キャンバスリサイズ検証（フェーズC）
- [ ] 背景レイヤー/依存レイヤーの表示維持
- [ ] サムネイル更新の正確性

## AI（Claude）向け実装ガイド

### 必ず守る実装規則

1. **JSDoc必須**：すべての座標変換関数で @input/@output 明記
```javascript
/**
 * @input screen coordinates {x, y}
 * @output canvas (canonical) coordinates {x, y}
 */
screenToCanvas(screenPt) { /* ... */ }
```

2. **座標破壊禁止**：絶対に path.points を screen/world のまま保存しない
3. **変形確定ルール**：confirmLayerTransform は「焼き込み」方式、Container.transform残し禁止
4. **Clipboard原則**：表示上の transform（見かけ上の座標）を保存しない
5. **EventBus必須**：レイヤー階層移動は EventBus で UI 同期
6. **デバッグログ**：CONFIG.debug ガード下のみ
7. **PixiJS v8.13準拠**：Container.toLocal / toGlobal 等の正確な使用

### よくあるミス防止

| ミス | 結果 | 対処法 |
|------|------|--------|
| Container.transform残し | 後続rebuild時に消える/二重変換 | confirmで必ず焼き込み |
| 見かけ座標でcopy | pasteで座標系不一致 | getLayerCanonicalPaths()使用 |
| 直接clientX/Y使用 | 左ズレ等 | camera.screenToCanvas()経由 |

### レビューチェックポイント

- [ ] 各関数に @input/@output 注記あり
- [ ] screenToCanvasが正しく動作（手動テスト）
- [ ] confirmLayerTransformでcontainer.transformがidentity
- [ ] clipboard pasteで新規layerがidentity transform
- [ ] rebuildPathGraphicsはcanvas前提で描画
- [ ] EventBusイベントが適切に発火・購読
- [ ] console.logがCONFIG.debug下のみ

## 実装ファイル構造定義

### core-engine.js（中枢）
```javascript
class CoreEngine {
    constructor(app) {
        this.app = app;
        this.systems = {}; // システム管理
    }
    
    // システム初期化・統合
    async initialize() {
        await this.loadSystems();
        this.setupEventBus();
        this.setupCrossReferences();
        this.initializeUI();
    }
    
    // 公開API（後方互換）
    getCameraSystem() { return this.systems.camera; }
    getLayerManager() { return this.systems.layer; } 
    getClipboardSystem() { return this.systems.clipboard; }
    
    // 統合制御
    resizeCanvas(width, height) {
        EventBus.emit('canvas:resize', {width, height});
    }
}
```

### systems/camera-system.js（座標変換責務）
```javascript
class CameraSystem {
    // 座標変換API（@input/@output必須）
    screenToWorld(screenPt) { /* 実装 */ }
    worldToCanvas(worldPt) { /* 実装 */ }  
    screenToCanvas(screenPt) { /* 実装 */ }
    
    // 逆変換
    canvasToWorld(canvasPt) { /* 実装 */ }
    canvasToScreen(canvasPt) { /* 実装 */ }
    
    // キャンバスリサイズ対応
    resizeCanvas(width, height) { /* 実装 */ }
}
```

### systems/layer-system.js（レイヤー管理責務）
```javascript
class LayerSystem {
    // 変形管理
    confirmLayerTransform(layerId) { /* 非破壊実装 */ }
    applyTransformToPoints(layerId, transform) { /* Matrix適用 */ }
    
    // パス管理
    getLayerCanonicalPaths(layerId) { /* canonical座標で取得 */ }
    rebuildPathGraphics(path) { /* Graphics再生成 */ }
    
    // レイヤー階層
    setLayerOrder(layerId, newIndex) { /* EventBus発行 */ }
    createLayer(name) { /* 新規作成 */ }
    removeLayer(layerId) { /* 削除 */ }
}
```

### systems/drawing-clipboard.js（非破壊コピーペースト責務）
```javascript
class ClipboardSystem {
    // 非破壊コピー
    copy() {
        const canonicalPaths = this.layerSystem.getLayerCanonicalPaths(layerId);
        this.clipboardData = { paths: deepCopy(canonicalPaths) };
    }
    
    // canonical復元
    paste() {
        const newLayer = this.layerSystem.createLayer('copy');
        this.clipboardData.paths.forEach(path => {
            this.layerSystem.addPathToLayer(newLayer, path);
        });
    }
}
```

## 運用ルール

### コミット方針
1. **Small Step**: 重要な座標修正は小刻みにcommit
2. **Rollback対応**: 明確なcommit messageでrollback容易に
3. **Test添付**: PR にmanual test手順を添付

### 確認事項
1. **ファイルパス一致**: index.htmlが読み込むファイルと改修ファイルの一致確認
2. **PixiJS v8.13対応**: API使用の正確性確認
3. **CONFIG参照統一**: window.TEGAKI_CONFIG の一貫使用

## 期待成果

### フェーズA完了時
- ペン描画の位置ズレ完全解消
- レイヤー変形確定時の絵の消失完全解消  
- コピー&ペーストの安定動作
- 座標変換APIの完全統一

### フェーズB完了時
- レイヤーパネル階層移動の安定動作
- EventBus統合による疎結合アーキテクチャ
- UI操作の完全同期

### フェーズC完了時
- キャンバスサイズ変更対応
- Undo/Redo機能拡張
- 自動テスト環境整備

この改修計画により、phase1b4相当の機能を4ファイル分割構成で完全再現し、さらなる拡張性を確保できます。