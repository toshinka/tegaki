# Phase1b6 改修計画書 - エラー解決とアーキテクチャ統一

## 🚨 致命的エラーの原因分析

### エラー: `Cannot read properties of null (reading 'worldContainer')`

**発生場所**: `DrawingApp.initialize` (index.html:828:70)

**原因**:
1. **二重定義問題**: `index.html`内と`core-runtime.js`で`CoreRuntime`が重複定義
2. **API参照不整合**: `coreRuntime.getWorldContainer()`を呼んでいるが実際は`CoreRuntime.getWorldContainer()`
3. **初期化タイミング**: 各モジュールが異なる初期化順序で競合

## 📋 問題の詳細分析

### 1. 座標変換APIの不一致
- **現状**: 各ファイルで`CoordinateSystem`の使い方が統一されていない
- **問題**: `screenToWorld`、`worldToScreen`の実装が分散し、参照先が不明確

### 2. レイヤーAPIの断片化  
- **現状**: `index.html`内の`LayerSystem`と`layer-system.js`の`LayerSystem`が別物
- **問題**: 同じ名前で異なるAPIを提供し、混乱を招いている

### 3. EventBus統合の不完全性
- **現状**: 各システムが独自の`SimpleEventBus`を持っている
- **問題**: システム間通信が断絶し、統一されたイベント管理ができない

### 4. 設定参照の混在
- **現状**: `window.TEGAKI_CONFIG`を各所で個別参照
- **問題**: 設定の一元管理ができず、依存関係が複雑

### 5. PixiJS v8.13準拠の確認不足
- **現状**: `new PIXI.Application()`と`await app.init()`が混在
- **問題**: v8.13の新しい初期化方法に統一されていない

## 🎯 改修方針（原則）

### 単一責務原則
- 1つのモジュール = 1つの責務
- グローバル変数の排除
- 明示的な依存関係

### 明示初期化
- critical resource（PIXI.Application、worldContainer、EventBus）は明示的生成
- 暗黙の作成・フォールバック禁止
- エラー時は即座に例外で停止

### 初期化順序の固定化
```
1. CoreRuntime.init() (PIXI.Application + EventBus + worldContainer)
2. CoordinateSystem.init() 
3. CameraSystem.init()
4. LayerSystem.init()
5. CoreEngine.init()
6. DrawingApp.initialize()
```

### API契約の厳格化
- モジュール間は明示的accessor関数でやりとり
- 文字列名や直アクセス禁止
- `getWorldContainer()`などの統一API

## 🔧 優先修正項目（必須）

### 1. CoreRuntimeの一本化（最優先）

**問題**: `index.html`と`core-runtime.js`で重複定義

**解決策**:
- `index.html`内の`CoreRuntime`定義を削除
- `core-runtime.js`の読み込みを最優先に
- 統一された初期化エントリポイントの提供

```javascript
// 修正後のindex.html
<script src="core-runtime.js"></script>
<script src="coordinate-system.js"></script>
<script src="layer-system.js"></script>
<script src="camera-system.js"></script>
<script src="core-engine.js"></script>

<script>
async function initializeApp() {
    // 1. CoreRuntime初期化（最優先）
    await CoreRuntime.init({
        canvasElement: document.getElementById('drawing-canvas'),
        width: window.innerWidth - 50,
        height: window.innerHeight
    });
    
    // 2. 各システム順次初期化
    await CoordinateSystem.init(CoreRuntime.getApp());
    await CameraSystem.init(CoreRuntime.getApp(), CoreRuntime.getWorldContainer());
    await LayerSystem.init(CoreRuntime.getApp(), CoreRuntime.getWorldContainer());
    
    // 3. DrawingApp初期化
    const app = new DrawingApp();
    await app.initialize();
}

initializeApp().catch(console.error);
</script>
```

### 2. 座標変換APIの統一

**問題**: `CoordinateSystem`の実装がバラバラ

**解決策**:
```javascript
// coordinate-system.js 統一API
window.CoordinateSystem = {
    init(app, worldContainer) {
        this._app = app;
        this._worldContainer = worldContainer;
    },
    
    screenToWorld(screenPoint) {
        // worldContainerの逆変換を使用
        const worldTransform = this._worldContainer.worldTransform;
        const inverted = new PIXI.Matrix();
        worldTransform.copyTo(inverted);
        inverted.invert();
        return inverted.apply(screenPoint);
    },
    
    worldToScreen(worldPoint) {
        const worldTransform = this._worldContainer.worldTransform;
        return worldTransform.apply(worldPoint);
    },
    
    // その他のAPI...
};
```

### 3. EventBusの統一

**問題**: 各システムが独自EventBus

**解決策**:
```javascript
// core-runtime.js内で単一EventBus管理
class CoreRuntime {
    static init() {
        this._eventBus = new PIXI.EventEmitter(); // PixiJS v8.13準拠
        this._app = new PIXI.Application();
        await this._app.init({ /* options */ });
        // ...
    }
    
    static getEventBus() {
        if (!this._eventBus) throw new Error('CoreRuntime not initialized');
        return this._eventBus;
    }
}

// 各システムは共有EventBusを使用
// layer-system.js
class LayerSystem {
    init(options) {
        this.eventBus = CoreRuntime.getEventBus(); // 共有EventBus
        // ...
    }
}
```

### 4. PixiJS v8.13への完全対応

**問題**: 初期化方法の混在

**解決策**:
```javascript
// core-runtime.js - PixiJS v8.13準拠
async function init() {
    const app = new PIXI.Application();
    await app.init({
        width: opts.width || 1200,
        height: opts.height || 800,
        backgroundAlpha: 0,
        resizeTo: window
    });
    
    // DOM追加
    const root = document.getElementById(opts.rootId || 'drawing-canvas');
    root.appendChild(app.canvas); // app.view → app.canvas
    
    // EventBus (v8.13対応)
    const eventBus = new PIXI.EventEmitter();
    
    // worldContainer作成
    const worldContainer = new PIXI.Container();
    worldContainer.name = 'worldContainer';
    app.stage.addChild(worldContainer);
    
    return { app, worldContainer, eventBus };
}
```

## 🚀 実装ステップ

### ステップ1: 緊急修正（即座に実行）
1. `index.html`内の`CoreRuntime`定義削除
2. スクリプト読み込み順序の修正
3. `DrawingApp.initialize`の参照修正

### ステップ2: システム統合（1-2時間）
1. EventBusの統一
2. 座標変換APIの統一
3. 初期化順序の固定化

### ステップ3: API整理（2-3時間）
1. レイヤーAPI統一
2. カメラAPI整理
3. 設定管理の一元化

### ステップ4: 動作確認（1時間）
1. 基本機能テスト
2. エラーハンドリング確認
3. パフォーマンス確認

## 📝 期待される改善効果

### 即座の効果
- ❌ エラー「Cannot read properties of null」の解決
- ✅ アプリケーションの正常起動
- ✅ 基本描画機能の動作

### 中期的効果  
- 🔧 システム間連携の安定化
- 🚀 開発効率の向上
- 🎯 機能追加の容易性

### 長期的効果
- 📈 AI改修容易性の向上
- 🎨 アニメーション機能追加の準備
- 🌟 Phase2移行の基盤確立

## 🚨 注意事項

### 絶対に避けるべきこと
- フォールバック処理の追加（問題を隠蔽するだけ）
- 複数の初期化パスの並存
- エラー捕捉による強制継続

### 推奨される対応
- エラー時の即座停止
- 明示的なエラーメッセージ
- 依存関係の明確化

## 📊 成功指標

### 技術指標
- [ ] エラーなしでアプリケーション起動
- [ ] 全システムの正常初期化
- [ ] メモリリークなし
- [ ] FPS 60維持

### 機能指標  
- [ ] ペン描画機能正常動作
- [ ] レイヤー操作正常動作
- [ ] カメラ操作正常動作
- [ ] UI連携正常動作

---

**次のアクション**: 上記ステップ1の緊急修正を即座に実行し、エラーを解決します。