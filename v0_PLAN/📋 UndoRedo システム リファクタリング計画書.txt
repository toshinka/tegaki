# Undo/Redo システム リファクタリング計画書

**作成日**: 2025-10-04  
**対象**: v8.13_anime23  
**目的**: データ所有権の明確化と堅牢なUndo/Redoシステムの構築

---

## 📊 現状分析

### 問題点マトリクス

| 問題 | 影響度 | 原因 | 対応優先度 |
|------|--------|------|-----------|
| データ所有権の曖昧さ | ⭐⭐⭐⭐⭐ | LayerSystem と AnimationSystem でレイヤーデータが重複 | **最優先** |
| イベント駆動の順序不定 | ⭐⭐⭐⭐ | EventBusによる非同期処理 | 高 |
| History記録タイミング不統一 | ⭐⭐⭐⭐ | 各所でsaveState()呼び出し | 高 |
| スナップショット方式の限界 | ⭐⭐⭐ | 全データコピーで重い | 中 |
| PixiJSオブジェクトの管理 | ⭐⭐⭐⭐⭐ | Graphics/Container がシリアライズ不可 | **最優先** |

### 診断結果より

```
❌ LayerSystem API - LayerSystem instance not found
❌ Configuration Consistency - Missing config section: drawing
21× Sortable initialized for layer panel
```

→ システム間の結合度が高すぎ、変更が波及しやすい

---

## 🎯 リファクタリング目標

### 1. Single Source of Truth の確立
- アプリケーション状態を**1箇所**で管理
- 各システムは状態を「参照」するのみ

### 2. Command パターンの徹底
- すべての操作を Command オブジェクト化
- Execute / Undo を必ず実装

### 3. 状態とビューの分離
- State: 純粋なデータ（JSON シリアライズ可能）
- View: PixiJS オブジェクト（State から生成）

### 4. 差分管理の導入
- スナップショット方式から差分管理へ
- メモリ効率の向上

---

## 🏗️ 新アーキテクチャ設計

### システム構成図

```
┌─────────────────────────────────────────┐
│        Application State Manager        │
│  (Single Source of Truth)               │
│  - cuts: Cut[]                          │
│  - currentCutIndex: number              │
│  - settings: AnimationSettings          │
└─────────────────┬───────────────────────┘
                  │
        ┌─────────┴─────────┐
        │                   │
┌───────▼────────┐  ┌───────▼────────┐
│ Command Queue  │  │  History Stack │
│ (Execute)      │  │  (Undo/Redo)   │
└───────┬────────┘  └───────┬────────┘
        │                   │
        └─────────┬─────────┘
                  │
        ┌─────────▼─────────┐
        │   View Renderer   │
        │  (PixiJS Layer)   │
        └───────────────────┘
```

### データ構造

```javascript
// State (シリアライズ可能)
{
  cuts: [
    {
      id: "cut_xxx",
      name: "CUT1",
      duration: 0.5,
      layers: [
        {
          id: "layer_xxx",
          name: "レイヤー1",
          visible: true,
          opacity: 1.0,
          transform: { x, y, rotation, scaleX, scaleY },
          paths: [
            {
              id: "path_xxx",
              points: [{x, y}, ...],
              size: 16,
              color: 0x800000,
              opacity: 1.0,
              tool: "pen"
            }
          ]
        }
      ]
    }
  ],
  currentCutIndex: 0,
  settings: { loop: true }
}

// View (PixiJS オブジェクト)
// State から動的に生成
```

---

## 📦 新規ファイル構成

```
system/
├── state/
│   ├── state-manager.js          # 状態管理の中核
│   ├── state-serializer.js       # State ⇔ JSON 変換
│   └── state-validator.js        # 状態整合性チェック
│
├── commands/
│   ├── command-base.js            # Command 基底クラス
│   ├── layer-commands.js          # レイヤー操作 Commands
│   ├── cut-commands.js            # CUT操作 Commands
│   └── drawing-commands.js        # 描画操作 Commands
│
├── history/
│   ├── history-manager.js         # Undo/Redo 管理（改修版）
│   └── diff-tracker.js            # 差分管理（オプション）
│
└── view/
    └── view-renderer.js           # State → PixiJS 変換
```

---

## 🔧 実装ステップ

### Phase 1: 基盤構築（3-4時間）

#### Step 1.1: StateManager の実装
```javascript
class StateManager {
  constructor() {
    this.state = this.createDefaultState();
    this.listeners = new Set();
  }
  
  // State 取得（Immutable）
  getState() {
    return Object.freeze(structuredClone(this.state));
  }
  
  // State 更新（Command経由のみ）
  setState(newState) {
    this.state = newState;
    this.notifyListeners();
  }
  
  // Command 実行
  execute(command) {
    const oldState = this.getState();
    const newState = command.execute(oldState);
    this.setState(newState);
    return { oldState, newState };
  }
}
```

#### Step 1.2: Command 基底クラス
```javascript
class Command {
  constructor(metadata = {}) {
    this.id = `cmd_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.metadata = metadata;
    this.timestamp = Date.now();
  }
  
  // 必須実装
  execute(state) {
    throw new Error('execute() must be implemented');
  }
  
  // 逆操作の生成
  createInverse(oldState, newState) {
    throw new Error('createInverse() must be implemented');
  }
}
```

#### Step 1.3: ViewRenderer の実装
```javascript
class ViewRenderer {
  constructor(pixiApp, stateManager) {
    this.app = pixiApp;
    this.stateManager = stateManager;
    this.containerCache = new Map();
  }
  
  // State → PixiJS Container
  render(state) {
    const cut = state.cuts[state.currentCutIndex];
    const container = this.createCutContainer(cut);
    return container;
  }
  
  createCutContainer(cutData) {
    const container = new PIXI.Container();
    cutData.layers.forEach(layerData => {
      const layer = this.createLayer(layerData);
      container.addChild(layer);
    });
    return container;
  }
  
  createLayer(layerData) {
    const layer = new PIXI.Container();
    layer.label = layerData.id;
    
    // Transform 適用
    layer.position.set(layerData.transform.x, layerData.transform.y);
    layer.rotation = layerData.transform.rotation;
    layer.scale.set(layerData.transform.scaleX, layerData.transform.scaleY);
    
    // Paths を描画
    layerData.paths.forEach(pathData => {
      const graphics = this.createPathGraphics(pathData);
      layer.addChild(graphics);
    });
    
    return layer;
  }
  
  createPathGraphics(pathData) {
    const graphics = new PIXI.Graphics();
    pathData.points.forEach(point => {
      graphics.circle(point.x, point.y, pathData.size / 2);
      graphics.fill({ color: pathData.color, alpha: pathData.opacity });
    });
    return graphics;
  }
}
```

---

### Phase 2: Command 実装（2-3時間）

#### CreateLayerCommand
```javascript
class CreateLayerCommand extends Command {
  constructor(cutIndex, layerData) {
    super({ type: 'layer:create' });
    this.cutIndex = cutIndex;
    this.layerData = layerData;
  }
  
  execute(state) {
    const newState = structuredClone(state);
    newState.cuts[this.cutIndex].layers.push(this.layerData);
    return newState;
  }
  
  createInverse(oldState, newState) {
    return new DeleteLayerCommand(
      this.cutIndex, 
      this.layerData.id
    );
  }
}
```

#### DeleteLayerCommand
```javascript
class DeleteLayerCommand extends Command {
  constructor(cutIndex, layerId) {
    super({ type: 'layer:delete' });
    this.cutIndex = cutIndex;
    this.layerId = layerId;
    this.deletedLayer = null; // Undo用に保存
  }
  
  execute(state) {
    const newState = structuredClone(state);
    const layers = newState.cuts[this.cutIndex].layers;
    const index = layers.findIndex(l => l.id === this.layerId);
    
    if (index !== -1) {
      this.deletedLayer = layers[index];
      layers.splice(index, 1);
    }
    
    return newState;
  }
  
  createInverse(oldState, newState) {
    return new CreateLayerCommand(this.cutIndex, this.deletedLayer);
  }
}
```

#### DrawingCommand
```javascript
class DrawingCommand extends Command {
  constructor(cutIndex, layerId, pathData) {
    super({ type: 'drawing:add' });
    this.cutIndex = cutIndex;
    this.layerId = layerId;
    this.pathData = pathData;
  }
  
  execute(state) {
    const newState = structuredClone(state);
    const layer = newState.cuts[this.cutIndex].layers.find(l => l.id === this.layerId);
    
    if (layer) {
      layer.paths.push(this.pathData);
    }
    
    return newState;
  }
  
  createInverse(oldState, newState) {
    return new DeletePathCommand(
      this.cutIndex, 
      this.layerId, 
      this.pathData.id
    );
  }
}
```

---

### Phase 3: History 統合（1-2時間）

#### 新 HistoryManager
```javascript
class HistoryManager {
  constructor(stateManager) {
    this.stateManager = stateManager;
    this.undoStack = [];
    this.redoStack = [];
    this.maxHistory = 50;
  }
  
  // Command 実行 & 履歴記録
  execute(command) {
    const result = this.stateManager.execute(command);
    
    const inverseCommand = command.createInverse(
      result.oldState, 
      result.newState
    );
    
    this.undoStack.push(inverseCommand);
    this.redoStack = []; // Redo スタックをクリア
    
    if (this.undoStack.length > this.maxHistory) {
      this.undoStack.shift();
    }
  }
  
  undo() {
    if (this.undoStack.length === 0) return false;
    
    const command = this.undoStack.pop();
    const result = this.stateManager.execute(command);
    
    const redoCommand = command.createInverse(
      result.oldState, 
      result.newState
    );
    
    this.redoStack.push(redoCommand);
    return true;
  }
  
  redo() {
    if (this.redoStack.length === 0) return false;
    
    const command = this.redoStack.pop();
    const result = this.stateManager.execute(command);
    
    const undoCommand = command.createInverse(
      result.oldState, 
      result.newState
    );
    
    this.undoStack.push(undoCommand);
    return true;
  }
}
```

---

### Phase 4: 既存システムの統合（3-4時間）

#### LayerSystem の改修
```javascript
class LayerSystem {
  constructor(stateManager, historyManager, viewRenderer) {
    this.stateManager = stateManager;
    this.historyManager = historyManager;
    this.viewRenderer = viewRenderer;
    
    // State 変更を監視
    this.stateManager.addListener((state) => {
      this.syncWithState(state);
    });
  }
  
  // 新規レイヤー作成
  createLayer(name) {
    const state = this.stateManager.getState();
    const layerData = {
      id: `layer_${Date.now()}`,
      name: name,
      visible: true,
      opacity: 1.0,
      transform: { x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1 },
      paths: []
    };
    
    const command = new CreateLayerCommand(
      state.currentCutIndex, 
      layerData
    );
    
    this.historyManager.execute(command);
  }
  
  // State との同期
  syncWithState(state) {
    const cut = state.cuts[state.currentCutIndex];
    
    // View を再構築
    const newContainer = this.viewRenderer.render(state);
    
    // 既存 Container と置き換え
    this.replaceContainer(newContainer);
    
    // UI 更新
    this.updateLayerPanelUI(cut.layers);
  }
}
```

---

## 📈 メリット・デメリット

### ✅ メリット

1. **堅牢性**
   - データの一貫性が保証される
   - Undo/Redo が確実に動作

2. **保守性**
   - データフローが明確
   - テストしやすい

3. **拡張性**
   - 新しい操作を Command として追加するだけ
   - 差分管理への移行が容易

4. **デバッグ性**
   - State の履歴をトレース可能
   - Time Travel Debugging が可能

### ❌ デメリット

1. **初期実装コスト**
   - 3-4日の開発期間
   - 既存コードとの統合作業

2. **パフォーマンス**
   - `structuredClone()` のコスト
   - 大規模データでは差分管理が必要

3. **学習コスト**
   - Command パターンの理解
   - Immutable 思考への転換

---

## ⏱️ 実装スケジュール

| Phase | 作業内容 | 所要時間 | 累計 |
|-------|---------|---------|------|
| Phase 0 | 設計レビュー・詳細仕様 | 2時間 | 2時間 |
| Phase 1 | 基盤構築 | 4時間 | 6時間 |
| Phase 2 | Command 実装 | 3時間 | 9時間 |
| Phase 3 | History 統合 | 2時間 | 11時間 |
| Phase 4 | 既存統合 | 4時間 | 15時間 |
| Phase 5 | テスト・デバッグ | 3時間 | 18時間 |
| Phase 6 | ドキュメント作成 | 2時間 | **20時間** |

**合計**: 約20時間（2.5日）

---

## 🚀 段階的移行計画

### Option A: ビッグバン移行（推奨しない）
- 一度に全システムを置き換え
- リスク高、デバッグ困難

### Option B: 段階的移行（推奨）

#### Step 1: 描画のみ移行
- DrawingCommand の実装
- 既存の Layer/CUT システムはそのまま

#### Step 2: レイヤー操作移行
- CreateLayerCommand, DeleteLayerCommand 実装
- LayerSystem を段階的に置き換え

#### Step 3: CUT操作移行
- CreateCutCommand, DeleteCutCommand 実装
- AnimationSystem を統合

#### Step 4: 完全移行
- 既存 History システムを削除
- 新システムに一本化

---

## 🔍 代替案: 最小限の修正

リファクタリングが大規模すぎる場合、以下の最小限修正も可能：

### 1. Command Queue の導入
```javascript
class CommandQueue {
  constructor() {
    this.queue = [];
    this.isProcessing = false;
  }
  
  enqueue(command) {
    this.queue.push(command);
    this.process();
  }
  
  async process() {
    if (this.isProcessing) return;
    this.isProcessing = true;
    
    while (this.queue.length > 0) {
      const command = this.queue.shift();
      await command.execute();
      // History 記録はここで一括
      History.saveState();
    }
    
    this.isProcessing = false;
  }
}
```

### 2. State Synchronizer の追加
```javascript
class StateSynchronizer {
  constructor(layerSystem, animationSystem) {
    this.layerSystem = layerSystem;
    this.animationSystem = animationSystem;
  }
  
  // 現在の状態をキャプチャ
  capture() {
    const cut = this.animationSystem.getCurrentCut();
    return {
      cutId: cut.id,
      layers: cut.getLayers().map(this.serializeLayer)
    };
  }
  
  // 状態を復元
  restore(snapshot) {
    const cut = this.animationSystem.getCurrentCut();
    // ... 復元処理
  }
}
```

**所要時間**: 4-6時間

---

## 📊 推奨アプローチ

### 🎯 短期（今すぐ）
**最小限修正** を実施
- Command Queue 導入
- State Synchronizer 追加
- 所要時間: 4-6時間

### 🎯 中期（1-2週間後）
**段階的リファクタリング** 開始
- Phase 1-2 の実装
- 描画システムのみ移行
- 所要時間: 8-10時間

### 🎯 長期（1ヶ月後）
**完全リファクタリング** 完了
- Phase 3-6 完了
- 全システム統合
- 所要時間: 累計20時間

---

## 📦 成果物

リファクタリング完了後、以下を提供：

1. **新規ファイル**
   - `state-manager.js`
   - `command-base.js`
   - `layer-commands.js`
   - `drawing-commands.js`
   - `history-manager.js`
   - `view-renderer.js`

2. **改修ファイル**
   - `layer-system.js`（統合版）
   - `animation-system.js`（統合版）
   - `core-engine.js`（統合版）

3. **ドキュメント**
   - アーキテクチャ図
   - API リファレンス
   - 移行ガイド

---

## 🤝 決定事項

以下を決定してください：

1. **アプローチ選択**
   - [ ] 最小限修正（4-6時間）
   - [ ] 段階的リファクタリング（20時間）
   - [ ] 現状維持（個別バグ修正のみ）

2. **優先度**
   - [ ] Undo/Redo の完全動作が最優先
   - [ ] パフォーマンスも重視
   - [ ] 保守性・拡張性も考慮

3. **スケジュール**
   - 実装開始日: ____________
   - 完了目標日: ____________

---

**作成者**: Claude  
**バージョン**: 1.0  
**最終更新**: 2025-10-04