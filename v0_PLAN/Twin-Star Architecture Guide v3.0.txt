# TEGAKI Twin-Star Architecture Guide v3.0
## Claude/AIå¯èª­æ€§æœ€å„ªå…ˆã®æœ€å°æ§‹æˆ

---

# ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ï¼ˆæœ€å°æ§‹æˆç‰ˆï¼‰

```
tegaki/
â”œâ”€â”€ index.html           # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”œâ”€â”€ config.js           # ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®š
â”œâ”€â”€ core-runtime.js     # ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰
â”‚
â”œâ”€â”€ ui/                 # UI Star (2ãƒ•ã‚¡ã‚¤ãƒ«)
â”‚   â”œâ”€â”€ ui-core.js      # UIçµ±æ‹¬ï¼ˆãƒ‘ãƒãƒ«ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ»ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆï¼‰
â”‚   â””â”€â”€ ui-state.js     # UIçŠ¶æ…‹ç®¡ç†
â”‚
â””â”€â”€ engine/             # Engine Star (4ãƒ•ã‚¡ã‚¤ãƒ«)
    â”œâ”€â”€ coordinate-system.js  # åº§æ¨™å¤‰æ›çµ±ä¸€API
    â”œâ”€â”€ layer-system.js      # ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¨æ©Ÿèƒ½ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ»å¤‰å½¢ãƒ»å±¥æ­´ï¼‰
    â”œâ”€â”€ drawing-system.js    # æç”»å…¨æ©Ÿèƒ½ï¼ˆãƒ–ãƒ©ã‚·ãƒ»ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼‰
    â””â”€â”€ camera-system.js     # ã‚«ãƒ¡ãƒ©ãƒ»ãƒ“ãƒ¥ãƒ¼ç®¡ç†
```

**åˆè¨ˆ: 9ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆindex.htmlå«ã‚€ï¼‰**

---

# ğŸ¯ å„ãƒ•ã‚¡ã‚¤ãƒ«ã®è©³ç´°ä»•æ§˜

## ğŸ“ ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ« (3ãƒ•ã‚¡ã‚¤ãƒ«)

### index.html (800-1000è¡Œ)
```html
<!DOCTYPE html>
<html>
<head>
    <title>TEGAKI</title>
    <!-- PixiJS v8.13 CDN -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/pixi.min.js"></script>
</head>
<body>
    <!-- HTMLæ§‹é€  -->
    <div id="app-container">
        <canvas id="main-canvas"></canvas>
        <div id="ui-panels">...</div>
    </div>
    
    <!-- ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿é †åºå³å®ˆ -->
    <script src="config.js"></script>
    <script src="engine/coordinate-system.js"></script>
    <script src="engine/camera-system.js"></script>
    <script src="engine/drawing-system.js"></script>
    <script src="engine/layer-system.js"></script>
    <script src="ui/ui-state.js"></script>
    <script src="ui/ui-core.js"></script>
    <script src="core-runtime.js"></script>
    
    <!-- åˆæœŸåŒ– -->
    <script>
        window.addEventListener('DOMContentLoaded', () => {
            CoreRuntime.init(document.getElementById('main-canvas'));
        });
    </script>
</body>
</html>
```

### config.js (300-500è¡Œ)
```javascript
// è²¬ä»»: å…¨è¨­å®šå€¤ã®ä¸€å…ƒç®¡ç†
window.TegakiConfig = {
    // ã‚­ãƒ£ãƒ³ãƒã‚¹è¨­å®š
    canvas: {
        defaultWidth: 1920,
        defaultHeight: 1080,
        backgroundColor: 0xFFFFFF,
        maxZoom: 10,
        minZoom: 0.1
    },
    
    // ãƒ–ãƒ©ã‚·è¨­å®š
    brush: {
        sizes: [1, 3, 5, 10, 20, 50, 100],
        defaultSize: 10,
        defaultColor: 0x000000,
        defaultOpacity: 1.0,
        smoothing: true,
        pressureSensitivity: true
    },
    
    // ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š
    layer: {
        maxLayers: 100,
        defaultBlendMode: 'normal',
        thumbnailSize: 64
    },
    
    // ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆå®šç¾©
    shortcuts: {
        'ctrl+z': 'undo',
        'ctrl+y': 'redo',
        'ctrl+c': 'copy',
        'ctrl+v': 'paste',
        'b': 'brush',
        'e': 'eraser',
        // ...å…¨ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆå®šç¾©
    },
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨­å®š
    performance: {
        cacheEnabled: true,
        maxCacheSize: 100 * 1024 * 1024, // 100MB
        batchDrawCalls: true
    }
};
```

### core-runtime.js (500-700è¡Œ)
```javascript
// è²¬ä»»: ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®çµ±æ‹¬ã¨ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰
window.CoreRuntime = {
    // ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    app: null,           // PIXI.Application
    coordinate: null,    // CoordinateSystem
    camera: null,        // CameraSystem
    layer: null,         // LayerSystem
    drawing: null,       // DrawingSystem
    ui: null,            // UICore
    
    // åˆæœŸåŒ–
    async init(canvas) {
        // PIXI.Applicationä½œæˆ
        this.app = new PIXI.Application({
            canvas: canvas,
            width: TegakiConfig.canvas.defaultWidth,
            height: TegakiConfig.canvas.defaultHeight,
            backgroundColor: TegakiConfig.canvas.backgroundColor,
            antialias: true,
            resolution: window.devicePixelRatio || 1
        });
        
        // Engine Starã®åˆæœŸåŒ–ï¼ˆé †åºé‡è¦ï¼‰
        this.coordinate = new CoordinateSystem(this.app);
        this.camera = new CameraSystem(this.app, this.coordinate);
        this.drawing = new DrawingSystem(this.app, this.coordinate);
        this.layer = new LayerSystem(this.app, this.coordinate, this.drawing);
        
        // UI Starã®åˆæœŸåŒ–
        this.ui = new UICore(this);
        
        // ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶š
        this.connectEvents();
        
        // åˆæœŸãƒ¬ã‚¤ãƒ¤ãƒ¼ä½œæˆ
        this.layer.createLayer('Background');
    },
    
    // çµ±ä¸€APIï¼ˆUIã‹ã‚‰å‘¼ã°ã‚Œã‚‹ï¼‰
    api: {
        // ã‚«ãƒ¡ãƒ©æ“ä½œ
        panCamera: (dx, dy) => CoreRuntime.camera.pan(dx, dy),
        zoomCamera: (factor, centerX, centerY) => CoreRuntime.camera.zoom(factor, centerX, centerY),
        resetCamera: () => CoreRuntime.camera.reset(),
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œ
        createLayer: (name) => CoreRuntime.layer.create(name),
        deleteLayer: (id) => CoreRuntime.layer.delete(id),
        selectLayer: (id) => CoreRuntime.layer.select(id),
        transformLayer: (transform) => CoreRuntime.layer.transform(transform),
        
        // æç”»æ“ä½œ
        startDrawing: (x, y) => CoreRuntime.drawing.startStroke(x, y),
        continueDrawing: (x, y, pressure) => CoreRuntime.drawing.continueStroke(x, y, pressure),
        endDrawing: () => CoreRuntime.drawing.endStroke(),
        
        // å±¥æ­´æ“ä½œ
        undo: () => CoreRuntime.layer.undo(),
        redo: () => CoreRuntime.layer.redo(),
        
        // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰
        copy: () => CoreRuntime.layer.copySelection(),
        paste: () => CoreRuntime.layer.paste()
    }
};
```

---

# ğŸ”§ Engine Starè©³ç´° (4ãƒ•ã‚¡ã‚¤ãƒ«)

## engine/coordinate-system.js (400-600è¡Œ)
```javascript
// è²¬ä»»: å…¨åº§æ¨™å¤‰æ›ã®ä¸€å…ƒç®¡ç†
class CoordinateSystem {
    constructor(app) {
        this.app = app;
        this.debugMode = false;
    }
    
    // åŸºæœ¬å¤‰æ›ãƒ¡ã‚½ãƒƒãƒ‰
    // coord: screen -> world
    screenToWorld(screenX, screenY) {
        const point = new PIXI.Point(screenX, screenY);
        return this.app.stage.toLocal(point);
    }
    
    // coord: world -> screen  
    worldToScreen(worldX, worldY) {
        const point = new PIXI.Point(worldX, worldY);
        return this.app.stage.toGlobal(point);
    }
    
    // coord: world -> layer
    worldToLayer(layer, worldX, worldY) {
        const point = new PIXI.Point(worldX, worldY);
        return layer.container.toLocal(point);
    }
    
    // coord: layer -> world
    layerToWorld(layer, layerX, layerY) {
        const point = new PIXI.Point(layerX, layerY);
        return layer.container.toGlobal(point);
    }
    
    // å¤‰å½¢è¨ˆç®—
    transformPoint(point, pivot, transform) {
        // pivotä¸­å¿ƒã®å¤‰å½¢ã‚’é©ç”¨
        const dx = point.x - pivot.x;
        const dy = point.y - pivot.y;
        
        // å›è»¢
        const cos = Math.cos(transform.rotation);
        const sin = Math.sin(transform.rotation);
        const rx = dx * cos - dy * sin;
        const ry = dx * sin + dy * cos;
        
        // ã‚¹ã‚±ãƒ¼ãƒ«
        const sx = rx * transform.scale.x;
        const sy = ry * transform.scale.y;
        
        // å¹³è¡Œç§»å‹•
        return {
            x: sx + pivot.x + transform.position.x,
            y: sy + pivot.y + transform.position.y
        };
    }
}

window.CoordinateSystem = CoordinateSystem;
```

## engine/camera-system.js (400-600è¡Œ)
```javascript
// è²¬ä»»: ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆãƒ»ã‚«ãƒ¡ãƒ©ç®¡ç†
class CameraSystem {
    constructor(app, coordinateSystem) {
        this.app = app;
        this.coord = coordinateSystem;
        
        // ã‚«ãƒ¡ãƒ©çŠ¶æ…‹
        this.zoom = 1.0;
        this.position = { x: 0, y: 0 };
        this.rotation = 0;
        
        // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ
        this.viewport = new PIXI.Container();
        this.app.stage.addChild(this.viewport);
    }
    
    pan(dx, dy) {
        this.position.x += dx / this.zoom;
        this.position.y += dy / this.zoom;
        this.updateTransform();
    }
    
    zoom(factor, centerX, centerY) {
        // coord: screen -> world (ã‚ºãƒ¼ãƒ å‰)
        const worldBefore = this.coord.screenToWorld(centerX, centerY);
        
        // ã‚ºãƒ¼ãƒ é©ç”¨
        this.zoom = Math.max(TegakiConfig.canvas.minZoom,
                            Math.min(TegakiConfig.canvas.maxZoom, this.zoom * factor));
        
        // coord: screen -> world (ã‚ºãƒ¼ãƒ å¾Œ)
        const worldAfter = this.coord.screenToWorld(centerX, centerY);
        
        // å·®åˆ†ã§ä½ç½®è£œæ­£
        this.position.x += worldAfter.x - worldBefore.x;
        this.position.y += worldAfter.y - worldBefore.y;
        
        this.updateTransform();
    }
    
    updateTransform() {
        this.viewport.scale.set(this.zoom);
        this.viewport.position.set(
            this.position.x * this.zoom,
            this.position.y * this.zoom
        );
        this.viewport.rotation = this.rotation;
    }
    
    reset() {
        this.zoom = 1.0;
        this.position = { x: 0, y: 0 };
        this.rotation = 0;
        this.updateTransform();
    }
}

window.CameraSystem = CameraSystem;
```

## engine/drawing-system.js (800-1200è¡Œ)
```javascript
// è²¬ä»»: æç”»ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆãƒ–ãƒ©ã‚·ãƒ»ãƒšãƒ³ãƒ»ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼‰
class DrawingSystem {
    constructor(app, coordinateSystem) {
        this.app = app;
        this.coord = coordinateSystem;
        
        // æç”»çŠ¶æ…‹
        this.isDrawing = false;
        this.currentStroke = null;
        this.currentGraphics = null;
        
        // ãƒ–ãƒ©ã‚·è¨­å®š
        this.brushSettings = {
            size: TegakiConfig.brush.defaultSize,
            color: TegakiConfig.brush.defaultColor,
            opacity: TegakiConfig.brush.defaultOpacity,
            smoothing: TegakiConfig.brush.smoothing,
            pressureSensitive: TegakiConfig.brush.pressureSensitivity
        };
        
        // ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        this.renderCache = new Map();
        this.maxCacheSize = TegakiConfig.performance.maxCacheSize;
    }
    
    // ãƒ–ãƒ©ã‚·è¨­å®š
    setBrush(settings) {
        Object.assign(this.brushSettings, settings);
    }
    
    // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯é–‹å§‹
    startStroke(screenX, screenY) {
        if (this.isDrawing) return;
        
        this.isDrawing = true;
        
        // coord: screen -> world -> layer
        const worldPoint = this.coord.screenToWorld(screenX, screenY);
        const activeLayer = CoreRuntime.layer.getActiveLayer();
        const layerPoint = this.coord.worldToLayer(activeLayer, worldPoint.x, worldPoint.y);
        
        // æ–°è¦ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ä½œæˆ
        this.currentStroke = {
            id: `stroke_${Date.now()}`,
            points: [{ x: layerPoint.x, y: layerPoint.y, pressure: 1.0 }],
            brush: { ...this.brushSettings },
            layerId: activeLayer.id
        };
        
        // Graphicsä½œæˆ
        this.currentGraphics = new PIXI.Graphics();
        activeLayer.container.addChild(this.currentGraphics);
        
        // æç”»é–‹å§‹
        this.drawStroke();
    }
    
    // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ç¶™ç¶š
    continueStroke(screenX, screenY, pressure = 1.0) {
        if (!this.isDrawing) return;
        
        // coord: screen -> world -> layer
        const worldPoint = this.coord.screenToWorld(screenX, screenY);
        const activeLayer = CoreRuntime.layer.getActiveLayer();
        const layerPoint = this.coord.worldToLayer(activeLayer, worldPoint.x, worldPoint.y);
        
        // ãƒã‚¤ãƒ³ãƒˆè¿½åŠ 
        this.currentStroke.points.push({
            x: layerPoint.x,
            y: layerPoint.y,
            pressure: pressure
        });
        
        // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨
        if (this.brushSettings.smoothing) {
            this.smoothLastPoints();
        }
        
        // å†æç”»
        this.drawStroke();
    }
    
    // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯çµ‚äº†
    endStroke() {
        if (!this.isDrawing) return;
        
        this.isDrawing = false;
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
        const activeLayer = CoreRuntime.layer.getActiveLayer();
        activeLayer.strokes.push(this.currentStroke);
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°
        this.updateCache(activeLayer.id);
        
        // å±¥æ­´ã«è¨˜éŒ²
        CoreRuntime.layer.recordHistory('stroke', {
            layerId: activeLayer.id,
            stroke: this.currentStroke
        });
        
        // ãƒªã‚»ãƒƒãƒˆ
        this.currentStroke = null;
        this.currentGraphics = null;
    }
    
    // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æç”»
    drawStroke() {
        if (!this.currentGraphics || !this.currentStroke) return;
        
        const g = this.currentGraphics;
        const stroke = this.currentStroke;
        const points = stroke.points;
        
        g.clear();
        
        if (points.length < 2) return;
        
        // ãƒ–ãƒ©ã‚·è¨­å®šé©ç”¨
        g.lineStyle({
            width: stroke.brush.size,
            color: stroke.brush.color,
            alpha: stroke.brush.opacity,
            cap: PIXI.LINE_CAP.ROUND,
            join: PIXI.LINE_JOIN.ROUND
        });
        
        // ãƒ‘ã‚¹æç”»
        g.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length; i++) {
            const p = points[i];
            
            if (stroke.brush.pressureSensitive) {
                // ç­†åœ§å¯¾å¿œ
                const width = stroke.brush.size * p.pressure;
                g.lineStyle({
                    width: width,
                    color: stroke.brush.color,
                    alpha: stroke.brush.opacity
                });
            }
            
            g.lineTo(p.x, p.y);
        }
    }
    
    // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
    smoothLastPoints() {
        const points = this.currentStroke.points;
        if (points.length < 3) return;
        
        const smoothingFactor = 0.3;
        const i = points.length - 2;
        
        points[i].x += (points[i-1].x + points[i+1].x - 2 * points[i].x) * smoothingFactor;
        points[i].y += (points[i-1].y + points[i+1].y - 2 * points[i].y) * smoothingFactor;
    }
    
    // ãƒ¬ã‚¤ãƒ¤ãƒ¼å†æç”»
    redrawLayer(layer) {
        // ã‚³ãƒ³ãƒ†ãƒŠã‚¯ãƒªã‚¢
        layer.container.removeChildren();
        
        // å…¨ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å†æç”»
        layer.strokes.forEach(stroke => {
            const g = new PIXI.Graphics();
            layer.container.addChild(g);
            
            // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å†æ§‹ç¯‰
            this.drawStrokeFromData(g, stroke);
        });
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°
        this.updateCache(layer.id);
    }
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
    updateCache(layerId) {
        if (!TegakiConfig.performance.cacheEnabled) return;
        
        const layer = CoreRuntime.layer.getLayer(layerId);
        if (!layer) return;
        
        // å¤ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç ´æ£„
        if (this.renderCache.has(layerId)) {
            const oldCache = this.renderCache.get(layerId);
            oldCache.destroy(true);
        }
        
        // æ–°è¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä½œæˆ
        const renderTexture = PIXI.RenderTexture.create({
            width: layer.container.width,
            height: layer.container.height
        });
        
        this.app.renderer.render(layer.container, { renderTexture });
        this.renderCache.set(layerId, renderTexture);
    }
}

window.DrawingSystem = DrawingSystem;
```

## engine/layer-system.js (1200-1500è¡Œ)
```javascript
// è²¬ä»»: ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ»å¤‰å½¢ãƒ»å±¥æ­´ãƒ»ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ï¼‰
class LayerSystem {
    constructor(app, coordinateSystem, drawingSystem) {
        this.app = app;
        this.coord = coordinateSystem;
        this.drawing = drawingSystem;
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿
        this.layers = new Map();
        this.layerOrder = [];
        this.activeLayerId = null;
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚³ãƒ³ãƒ†ãƒŠ
        this.layerContainer = new PIXI.Container();
        CoreRuntime.camera.viewport.addChild(this.layerContainer);
        
        // å±¥æ­´ç®¡ç†
        this.history = [];
        this.historyIndex = -1;
        this.maxHistorySize = 100;
        
        // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰
        this.clipboard = null;
        
        // é¸æŠç¯„å›²
        this.selection = null;
    }
    
    // ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½œæˆ
    create(name) {
        const id = `layer_${Date.now()}`;
        
        const layer = {
            id: id,
            name: name || `Layer ${this.layers.size + 1}`,
            visible: true,
            opacity: 1.0,
            blendMode: 'normal',
            locked: false,
            
            // ãƒ‡ãƒ¼ã‚¿
            strokes: [],        // æç”»ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯
            transform: {        // å¤‰å½¢çŠ¶æ…‹
                position: { x: 0, y: 0 },
                scale: { x: 1, y: 1 },
                rotation: 0,
                pivot: { x: 0, y: 0 }
            },
            
            // è¡¨ç¤ºç”¨ã‚³ãƒ³ãƒ†ãƒŠ
            container: new PIXI.Container(),
            
            // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
            created: Date.now(),
            modified: Date.now()
        };
        
        // ç™»éŒ²
        this.layers.set(id, layer);
        this.layerOrder.push(id);
        this.layerContainer.addChild(layer.container);
        
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«è¨­å®š
        this.select(id);
        
        // å±¥æ­´è¨˜éŒ²
        this.recordHistory('create', { layerId: id, layer: layer });
        
        return id;
    }
    
    // ãƒ¬ã‚¤ãƒ¤ãƒ¼å‰Šé™¤
    delete(id) {
        const layer = this.layers.get(id);
        if (!layer) return;
        
        // æœ€å¾Œã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å‰Šé™¤ä¸å¯
        if (this.layers.size <= 1) return;
        
        // ã‚³ãƒ³ãƒ†ãƒŠå‰Šé™¤
        this.layerContainer.removeChild(layer.container);
        layer.container.destroy(true);
        
        // ãƒ‡ãƒ¼ã‚¿å‰Šé™¤
        this.layers.delete(id);
        const index = this.layerOrder.indexOf(id);
        this.layerOrder.splice(index, 1);
        
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¬ã‚¤ãƒ¤ãƒ¼æ›´æ–°
        if (this.activeLayerId === id) {
            this.select(this.layerOrder[Math.max(0, index - 1)]);
        }
        
        // å±¥æ­´è¨˜éŒ²
        this.recordHistory('delete', { layerId: id, layer: layer });
    }
    
    // ãƒ¬ã‚¤ãƒ¤ãƒ¼é¸æŠ
    select(id) {
        if (!this.layers.has(id)) return;
        
        this.activeLayerId = id;
        
        // UIé€šçŸ¥
        if (CoreRuntime.ui) {
            CoreRuntime.ui.onLayerSelected(id);
        }
    }
    
    // ãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰å½¢ï¼ˆéç ´å£Šï¼‰
    transform(transformData) {
        const layer = this.getActiveLayer();
        if (!layer || layer.locked) return;
        
        const oldTransform = { ...layer.transform };
        
        // å¤‰å½¢é©ç”¨
        Object.assign(layer.transform, transformData);
        
        // ã‚³ãƒ³ãƒ†ãƒŠæ›´æ–°
        this.updateLayerTransform(layer);
        
        // å±¥æ­´è¨˜éŒ²
        this.recordHistory('transform', {
            layerId: layer.id,
            oldTransform: oldTransform,
            newTransform: layer.transform
        });
    }
    
    // ãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰å½¢ã‚’ç¢ºå®šï¼ˆç ´å£Šçš„ï¼‰
    applyTransform() {
        const layer = this.getActiveLayer();
        if (!layer) return;
        
        const transform = layer.transform;
        
        // å…¨ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã®ãƒã‚¤ãƒ³ãƒˆã‚’å¤‰å½¢
        layer.strokes.forEach(stroke => {
            stroke.points = stroke.points.map(point => {
                return this.coord.transformPoint(
                    point,
                    transform.pivot,
                    transform
                );
            });
        });
        
        // å¤‰å½¢ãƒªã‚»ãƒƒãƒˆ
        layer.transform = {
            position: { x: 0, y: 0 },
            scale: { x: 1, y: 1 },
            rotation: 0,
            pivot: { x: 0, y: 0 }
        };
        
        // å†æç”»
        this.drawing.redrawLayer(layer);
        this.updateLayerTransform(layer);
        
        // å±¥æ­´è¨˜éŒ²
        this.recordHistory('applyTransform', { layerId: layer.id });
    }
    
    // ã‚³ãƒ³ãƒ†ãƒŠå¤‰å½¢æ›´æ–°
    updateLayerTransform(layer) {
        const t = layer.transform;
        layer.container.position.set(t.position.x, t.position.y);
        layer.container.scale.set(t.scale.x, t.scale.y);
        layer.container.rotation = t.rotation;
        layer.container.pivot.set(t.pivot.x, t.pivot.y);
    }
    
    // å±¥æ­´ç®¡ç†
    recordHistory(action, data) {
        // ç¾åœ¨ä½ç½®ã‚ˆã‚Šå¾Œã®å±¥æ­´ã‚’å‰Šé™¤
        this.history = this.history.slice(0, this.historyIndex + 1);
        
        // æ–°è¦å±¥æ­´è¿½åŠ 
        this.history.push({
            action: action,
            data: data,
            timestamp: Date.now()
        });
        
        // ã‚µã‚¤ã‚ºåˆ¶é™
        if (this.history.length > this.maxHistorySize) {
            this.history.shift();
        } else {
            this.historyIndex++;
        }
    }
    
    // ã‚¢ãƒ³ãƒ‰ã‚¥
    undo() {
        if (this.historyIndex < 0) return;
        
        const entry = this.history[this.historyIndex];
        this.applyHistoryReverse(entry);
        this.historyIndex--;
    }
    
    // ãƒªãƒ‰ã‚¥
    redo() {
        if (this.historyIndex >= this.history.length - 1) return;
        
        this.historyIndex++;
        const entry = this.history[this.historyIndex];
        this.applyHistory(entry);
    }
    
    // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ - ã‚³ãƒ”ãƒ¼
    copySelection() {
        const layer = this.getActiveLayer();
        if (!layer) return;
        
        if (this.selection) {
            // é¸æŠç¯„å›²å†…ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’ã‚³ãƒ”ãƒ¼
            this.clipboard = {
                strokes: this.getStrokesInSelection(layer, this.selection),
                source: layer.id
            };
        } else {
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¨ä½“ã‚’ã‚³ãƒ”ãƒ¼
            this.clipboard = {
                strokes: [...layer.strokes],
                source: layer.id
            };
        }
    }
    
    // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ - ãƒšãƒ¼ã‚¹ãƒˆ
    paste() {
        if (!this.clipboard) return;
        
        const layer = this.getActiveLayer();
        if (!layer) return;
        
        // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’è¤‡è£½ã—ã¦è¿½åŠ 
        const pastedStrokes = this.clipboard.strokes.map(stroke => ({
            ...stroke,
            id: `stroke_${Date.now()}_${Math.random()}`,
            points: [...stroke.points]
        }));
        
        layer.strokes.push(...pastedStrokes);
        
        // å†æç”»
        this.drawing.redrawLayer(layer);
        
        // å±¥æ­´è¨˜éŒ²
        this.recordHistory('paste', {
            layerId: layer.id,
            strokes: pastedStrokes
        });
    }
    
    // ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
    getActiveLayer() {
        return this.layers.get(this.activeLayerId);
    }
    
    getLayer(id) {
        return this.layers.get(id);
    }
    
    getAllLayers() {
        return this.layerOrder.map(id => this.layers.get(id));
    }
}

window.LayerSystem = LayerSystem;
```

---

# ğŸ¨ UI Starè©³ç´° (2ãƒ•ã‚¡ã‚¤ãƒ«)

## ui/ui-state.js (300-500è¡Œ)
```javascript
// è²¬ä»»: UIçŠ¶æ…‹ã®ä¸€å…ƒç®¡ç†
window.UIState = {
    // ãƒ„ãƒ¼ãƒ«çŠ¶æ…‹
    currentTool: 'brush',
    previousTool: null,
    
    // ãƒ‘ãƒãƒ«çŠ¶æ…‹
    panels: {
        layers: { visible: true, x: 10, y: 10 },
        tools: { visible: true, x: 10, y: 200 },
        colors: { visible: true, x: 10, y: 400 }
    },
    
    // å…¥åŠ›çŠ¶æ…‹
    input: {
        mouseDown: false,
        spaceDown: false,
        ctrlDown: false,
        shiftDown: false,
        altDown: false,
        lastX: 0,
        lastY: 0
    },
    
    // ãƒ¢ãƒ¼ãƒ‰çŠ¶æ…‹
    mode: 'draw', // draw, transform, select
    
    // é¸æŠçŠ¶æ…‹
    selection: {
        active: false,
        start: null,
        end: null,
        type: 'rectangle' // rectangle, lasso, magic
    },
    
    // å¤‰å½¢çŠ¶æ…‹
    transform: {
        active: false,
        mode: 'move', // move, rotate, scale
        handles: [],
        pivot: 'center'
    },
    
    // çŠ¶æ…‹æ›´æ–°ãƒ¡ã‚½ãƒƒãƒ‰
    setTool(tool) {
        this.previousTool = this.currentTool;
        this.currentTool = tool;
    },
    
    setPanelVisibility(panelId, visible) {
        if (this.panels[panelId]) {
            this.panels[panelId].visible = visible;
        }
    },
    
    updateInput(key, value) {
        this.input[key] = value;
    },
    
    setMode(mode) {
        this.mode = mode;
        
        // ãƒ¢ãƒ¼ãƒ‰å¤‰æ›´æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if (mode !== 'select') {
            this.selection.active = false;
        }
        if (mode !== 'transform') {
            this.transform.active = false;
        }
    }
};
```

## ui/ui-core.js (1500-2000è¡Œ)
```javascript
// è²¬ä»»: UIå…¨æ©Ÿèƒ½ï¼ˆãƒ‘ãƒãƒ«ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ»ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆãƒ»ã‚¤ãƒ™ãƒ³ãƒˆï¼‰
class UICore {
    constructor(runtime) {
        this.runtime = runtime;
        
        // DOMè¦ç´ 
        this.container = document.getElementById('app-container');
        this.canvas = document.getElementById('main-canvas');
        
        // ãƒ‘ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        this.panels = {
            layers: this.createLayerPanel(),
            tools: this.createToolPanel(),
            colors: this.createColorPanel()
        };
        
        // ã‚¤ãƒ™ãƒ³ãƒˆåˆæœŸåŒ–
        this.initEvents();
        this.initShortcuts();
    }
    
    // === ãƒ‘ãƒãƒ«ä½œæˆ ===
    createLayerPanel() {
        const panel = document.createElement('div');
        panel.className = 'panel layer-panel';
        panel.innerHTML = `
            <div class="panel-header">
                <h3>Layers</h3>
                <button class="panel-close">