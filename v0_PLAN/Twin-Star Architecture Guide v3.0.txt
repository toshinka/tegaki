# TEGAKI Twin-Star Architecture Guide v3.0
## Claude/AI可読性最優先の最小構成

---

# 📁 ファイル構造（最小構成版）

```
tegaki/
├── index.html           # エントリーポイント
├── config.js           # グローバル設定
├── core-runtime.js     # ランタイムファサード
│
├── ui/                 # UI Star (2ファイル)
│   ├── ui-core.js      # UI統括（パネル・ツール・メニュー・ショートカット）
│   └── ui-state.js     # UI状態管理
│
└── engine/             # Engine Star (4ファイル)
    ├── coordinate-system.js  # 座標変換統一API
    ├── layer-system.js      # レイヤー全機能（データ・変形・履歴）
    ├── drawing-system.js    # 描画全機能（ブラシ・レンダリング）
    └── camera-system.js     # カメラ・ビュー管理
```

**合計: 9ファイル（index.html含む）**

---

# 🎯 各ファイルの詳細仕様

## 📍 ルートレベル (3ファイル)

### index.html (800-1000行)
```html
<!DOCTYPE html>
<html>
<head>
    <title>TEGAKI</title>
    <!-- PixiJS v8.13 CDN -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/pixi.min.js"></script>
</head>
<body>
    <!-- HTML構造 -->
    <div id="app-container">
        <canvas id="main-canvas"></canvas>
        <div id="ui-panels">...</div>
    </div>
    
    <!-- ファイル読み込み順序厳守 -->
    <script src="config.js"></script>
    <script src="engine/coordinate-system.js"></script>
    <script src="engine/camera-system.js"></script>
    <script src="engine/drawing-system.js"></script>
    <script src="engine/layer-system.js"></script>
    <script src="ui/ui-state.js"></script>
    <script src="ui/ui-core.js"></script>
    <script src="core-runtime.js"></script>
    
    <!-- 初期化 -->
    <script>
        window.addEventListener('DOMContentLoaded', () => {
            CoreRuntime.init(document.getElementById('main-canvas'));
        });
    </script>
</body>
</html>
```

### config.js (300-500行)
```javascript
// 責任: 全設定値の一元管理
window.TegakiConfig = {
    // キャンバス設定
    canvas: {
        defaultWidth: 1920,
        defaultHeight: 1080,
        backgroundColor: 0xFFFFFF,
        maxZoom: 10,
        minZoom: 0.1
    },
    
    // ブラシ設定
    brush: {
        sizes: [1, 3, 5, 10, 20, 50, 100],
        defaultSize: 10,
        defaultColor: 0x000000,
        defaultOpacity: 1.0,
        smoothing: true,
        pressureSensitivity: true
    },
    
    // レイヤー設定
    layer: {
        maxLayers: 100,
        defaultBlendMode: 'normal',
        thumbnailSize: 64
    },
    
    // ショートカット定義
    shortcuts: {
        'ctrl+z': 'undo',
        'ctrl+y': 'redo',
        'ctrl+c': 'copy',
        'ctrl+v': 'paste',
        'b': 'brush',
        'e': 'eraser',
        // ...全ショートカット定義
    },
    
    // パフォーマンス設定
    performance: {
        cacheEnabled: true,
        maxCacheSize: 100 * 1024 * 1024, // 100MB
        batchDrawCalls: true
    }
};
```

### core-runtime.js (500-700行)
```javascript
// 責任: システム全体の統括とファサード
window.CoreRuntime = {
    // システムコンポーネント
    app: null,           // PIXI.Application
    coordinate: null,    // CoordinateSystem
    camera: null,        // CameraSystem
    layer: null,         // LayerSystem
    drawing: null,       // DrawingSystem
    ui: null,            // UICore
    
    // 初期化
    async init(canvas) {
        // PIXI.Application作成
        this.app = new PIXI.Application({
            canvas: canvas,
            width: TegakiConfig.canvas.defaultWidth,
            height: TegakiConfig.canvas.defaultHeight,
            backgroundColor: TegakiConfig.canvas.backgroundColor,
            antialias: true,
            resolution: window.devicePixelRatio || 1
        });
        
        // Engine Starの初期化（順序重要）
        this.coordinate = new CoordinateSystem(this.app);
        this.camera = new CameraSystem(this.app, this.coordinate);
        this.drawing = new DrawingSystem(this.app, this.coordinate);
        this.layer = new LayerSystem(this.app, this.coordinate, this.drawing);
        
        // UI Starの初期化
        this.ui = new UICore(this);
        
        // イベント接続
        this.connectEvents();
        
        // 初期レイヤー作成
        this.layer.createLayer('Background');
    },
    
    // 統一API（UIから呼ばれる）
    api: {
        // カメラ操作
        panCamera: (dx, dy) => CoreRuntime.camera.pan(dx, dy),
        zoomCamera: (factor, centerX, centerY) => CoreRuntime.camera.zoom(factor, centerX, centerY),
        resetCamera: () => CoreRuntime.camera.reset(),
        
        // レイヤー操作
        createLayer: (name) => CoreRuntime.layer.create(name),
        deleteLayer: (id) => CoreRuntime.layer.delete(id),
        selectLayer: (id) => CoreRuntime.layer.select(id),
        transformLayer: (transform) => CoreRuntime.layer.transform(transform),
        
        // 描画操作
        startDrawing: (x, y) => CoreRuntime.drawing.startStroke(x, y),
        continueDrawing: (x, y, pressure) => CoreRuntime.drawing.continueStroke(x, y, pressure),
        endDrawing: () => CoreRuntime.drawing.endStroke(),
        
        // 履歴操作
        undo: () => CoreRuntime.layer.undo(),
        redo: () => CoreRuntime.layer.redo(),
        
        // クリップボード
        copy: () => CoreRuntime.layer.copySelection(),
        paste: () => CoreRuntime.layer.paste()
    }
};
```

---

# 🔧 Engine Star詳細 (4ファイル)

## engine/coordinate-system.js (400-600行)
```javascript
// 責任: 全座標変換の一元管理
class CoordinateSystem {
    constructor(app) {
        this.app = app;
        this.debugMode = false;
    }
    
    // 基本変換メソッド
    // coord: screen -> world
    screenToWorld(screenX, screenY) {
        const point = new PIXI.Point(screenX, screenY);
        return this.app.stage.toLocal(point);
    }
    
    // coord: world -> screen  
    worldToScreen(worldX, worldY) {
        const point = new PIXI.Point(worldX, worldY);
        return this.app.stage.toGlobal(point);
    }
    
    // coord: world -> layer
    worldToLayer(layer, worldX, worldY) {
        const point = new PIXI.Point(worldX, worldY);
        return layer.container.toLocal(point);
    }
    
    // coord: layer -> world
    layerToWorld(layer, layerX, layerY) {
        const point = new PIXI.Point(layerX, layerY);
        return layer.container.toGlobal(point);
    }
    
    // 変形計算
    transformPoint(point, pivot, transform) {
        // pivot中心の変形を適用
        const dx = point.x - pivot.x;
        const dy = point.y - pivot.y;
        
        // 回転
        const cos = Math.cos(transform.rotation);
        const sin = Math.sin(transform.rotation);
        const rx = dx * cos - dy * sin;
        const ry = dx * sin + dy * cos;
        
        // スケール
        const sx = rx * transform.scale.x;
        const sy = ry * transform.scale.y;
        
        // 平行移動
        return {
            x: sx + pivot.x + transform.position.x,
            y: sy + pivot.y + transform.position.y
        };
    }
}

window.CoordinateSystem = CoordinateSystem;
```

## engine/camera-system.js (400-600行)
```javascript
// 責任: ビューポート・カメラ管理
class CameraSystem {
    constructor(app, coordinateSystem) {
        this.app = app;
        this.coord = coordinateSystem;
        
        // カメラ状態
        this.zoom = 1.0;
        this.position = { x: 0, y: 0 };
        this.rotation = 0;
        
        // ビューポート
        this.viewport = new PIXI.Container();
        this.app.stage.addChild(this.viewport);
    }
    
    pan(dx, dy) {
        this.position.x += dx / this.zoom;
        this.position.y += dy / this.zoom;
        this.updateTransform();
    }
    
    zoom(factor, centerX, centerY) {
        // coord: screen -> world (ズーム前)
        const worldBefore = this.coord.screenToWorld(centerX, centerY);
        
        // ズーム適用
        this.zoom = Math.max(TegakiConfig.canvas.minZoom,
                            Math.min(TegakiConfig.canvas.maxZoom, this.zoom * factor));
        
        // coord: screen -> world (ズーム後)
        const worldAfter = this.coord.screenToWorld(centerX, centerY);
        
        // 差分で位置補正
        this.position.x += worldAfter.x - worldBefore.x;
        this.position.y += worldAfter.y - worldBefore.y;
        
        this.updateTransform();
    }
    
    updateTransform() {
        this.viewport.scale.set(this.zoom);
        this.viewport.position.set(
            this.position.x * this.zoom,
            this.position.y * this.zoom
        );
        this.viewport.rotation = this.rotation;
    }
    
    reset() {
        this.zoom = 1.0;
        this.position = { x: 0, y: 0 };
        this.rotation = 0;
        this.updateTransform();
    }
}

window.CameraSystem = CameraSystem;
```

## engine/drawing-system.js (800-1200行)
```javascript
// 責任: 描画エンジン（ブラシ・ペン・レンダリング）
class DrawingSystem {
    constructor(app, coordinateSystem) {
        this.app = app;
        this.coord = coordinateSystem;
        
        // 描画状態
        this.isDrawing = false;
        this.currentStroke = null;
        this.currentGraphics = null;
        
        // ブラシ設定
        this.brushSettings = {
            size: TegakiConfig.brush.defaultSize,
            color: TegakiConfig.brush.defaultColor,
            opacity: TegakiConfig.brush.defaultOpacity,
            smoothing: TegakiConfig.brush.smoothing,
            pressureSensitive: TegakiConfig.brush.pressureSensitivity
        };
        
        // レンダーキャッシュ
        this.renderCache = new Map();
        this.maxCacheSize = TegakiConfig.performance.maxCacheSize;
    }
    
    // ブラシ設定
    setBrush(settings) {
        Object.assign(this.brushSettings, settings);
    }
    
    // ストローク開始
    startStroke(screenX, screenY) {
        if (this.isDrawing) return;
        
        this.isDrawing = true;
        
        // coord: screen -> world -> layer
        const worldPoint = this.coord.screenToWorld(screenX, screenY);
        const activeLayer = CoreRuntime.layer.getActiveLayer();
        const layerPoint = this.coord.worldToLayer(activeLayer, worldPoint.x, worldPoint.y);
        
        // 新規ストローク作成
        this.currentStroke = {
            id: `stroke_${Date.now()}`,
            points: [{ x: layerPoint.x, y: layerPoint.y, pressure: 1.0 }],
            brush: { ...this.brushSettings },
            layerId: activeLayer.id
        };
        
        // Graphics作成
        this.currentGraphics = new PIXI.Graphics();
        activeLayer.container.addChild(this.currentGraphics);
        
        // 描画開始
        this.drawStroke();
    }
    
    // ストローク継続
    continueStroke(screenX, screenY, pressure = 1.0) {
        if (!this.isDrawing) return;
        
        // coord: screen -> world -> layer
        const worldPoint = this.coord.screenToWorld(screenX, screenY);
        const activeLayer = CoreRuntime.layer.getActiveLayer();
        const layerPoint = this.coord.worldToLayer(activeLayer, worldPoint.x, worldPoint.y);
        
        // ポイント追加
        this.currentStroke.points.push({
            x: layerPoint.x,
            y: layerPoint.y,
            pressure: pressure
        });
        
        // スムージング適用
        if (this.brushSettings.smoothing) {
            this.smoothLastPoints();
        }
        
        // 再描画
        this.drawStroke();
    }
    
    // ストローク終了
    endStroke() {
        if (!this.isDrawing) return;
        
        this.isDrawing = false;
        
        // レイヤーデータに追加
        const activeLayer = CoreRuntime.layer.getActiveLayer();
        activeLayer.strokes.push(this.currentStroke);
        
        // キャッシュ更新
        this.updateCache(activeLayer.id);
        
        // 履歴に記録
        CoreRuntime.layer.recordHistory('stroke', {
            layerId: activeLayer.id,
            stroke: this.currentStroke
        });
        
        // リセット
        this.currentStroke = null;
        this.currentGraphics = null;
    }
    
    // ストローク描画
    drawStroke() {
        if (!this.currentGraphics || !this.currentStroke) return;
        
        const g = this.currentGraphics;
        const stroke = this.currentStroke;
        const points = stroke.points;
        
        g.clear();
        
        if (points.length < 2) return;
        
        // ブラシ設定適用
        g.lineStyle({
            width: stroke.brush.size,
            color: stroke.brush.color,
            alpha: stroke.brush.opacity,
            cap: PIXI.LINE_CAP.ROUND,
            join: PIXI.LINE_JOIN.ROUND
        });
        
        // パス描画
        g.moveTo(points[0].x, points[0].y);
        
        for (let i = 1; i < points.length; i++) {
            const p = points[i];
            
            if (stroke.brush.pressureSensitive) {
                // 筆圧対応
                const width = stroke.brush.size * p.pressure;
                g.lineStyle({
                    width: width,
                    color: stroke.brush.color,
                    alpha: stroke.brush.opacity
                });
            }
            
            g.lineTo(p.x, p.y);
        }
    }
    
    // スムージング
    smoothLastPoints() {
        const points = this.currentStroke.points;
        if (points.length < 3) return;
        
        const smoothingFactor = 0.3;
        const i = points.length - 2;
        
        points[i].x += (points[i-1].x + points[i+1].x - 2 * points[i].x) * smoothingFactor;
        points[i].y += (points[i-1].y + points[i+1].y - 2 * points[i].y) * smoothingFactor;
    }
    
    // レイヤー再描画
    redrawLayer(layer) {
        // コンテナクリア
        layer.container.removeChildren();
        
        // 全ストローク再描画
        layer.strokes.forEach(stroke => {
            const g = new PIXI.Graphics();
            layer.container.addChild(g);
            
            // ストロークデータから再構築
            this.drawStrokeFromData(g, stroke);
        });
        
        // キャッシュ更新
        this.updateCache(layer.id);
    }
    
    // キャッシュ管理
    updateCache(layerId) {
        if (!TegakiConfig.performance.cacheEnabled) return;
        
        const layer = CoreRuntime.layer.getLayer(layerId);
        if (!layer) return;
        
        // 古いキャッシュ破棄
        if (this.renderCache.has(layerId)) {
            const oldCache = this.renderCache.get(layerId);
            oldCache.destroy(true);
        }
        
        // 新規キャッシュ作成
        const renderTexture = PIXI.RenderTexture.create({
            width: layer.container.width,
            height: layer.container.height
        });
        
        this.app.renderer.render(layer.container, { renderTexture });
        this.renderCache.set(layerId, renderTexture);
    }
}

window.DrawingSystem = DrawingSystem;
```

## engine/layer-system.js (1200-1500行)
```javascript
// 責任: レイヤー管理（データ・変形・履歴・クリップボード）
class LayerSystem {
    constructor(app, coordinateSystem, drawingSystem) {
        this.app = app;
        this.coord = coordinateSystem;
        this.drawing = drawingSystem;
        
        // レイヤーデータ
        this.layers = new Map();
        this.layerOrder = [];
        this.activeLayerId = null;
        
        // レイヤーコンテナ
        this.layerContainer = new PIXI.Container();
        CoreRuntime.camera.viewport.addChild(this.layerContainer);
        
        // 履歴管理
        this.history = [];
        this.historyIndex = -1;
        this.maxHistorySize = 100;
        
        // クリップボード
        this.clipboard = null;
        
        // 選択範囲
        this.selection = null;
    }
    
    // レイヤー作成
    create(name) {
        const id = `layer_${Date.now()}`;
        
        const layer = {
            id: id,
            name: name || `Layer ${this.layers.size + 1}`,
            visible: true,
            opacity: 1.0,
            blendMode: 'normal',
            locked: false,
            
            // データ
            strokes: [],        // 描画ストローク
            transform: {        // 変形状態
                position: { x: 0, y: 0 },
                scale: { x: 1, y: 1 },
                rotation: 0,
                pivot: { x: 0, y: 0 }
            },
            
            // 表示用コンテナ
            container: new PIXI.Container(),
            
            // メタデータ
            created: Date.now(),
            modified: Date.now()
        };
        
        // 登録
        this.layers.set(id, layer);
        this.layerOrder.push(id);
        this.layerContainer.addChild(layer.container);
        
        // アクティブに設定
        this.select(id);
        
        // 履歴記録
        this.recordHistory('create', { layerId: id, layer: layer });
        
        return id;
    }
    
    // レイヤー削除
    delete(id) {
        const layer = this.layers.get(id);
        if (!layer) return;
        
        // 最後のレイヤーは削除不可
        if (this.layers.size <= 1) return;
        
        // コンテナ削除
        this.layerContainer.removeChild(layer.container);
        layer.container.destroy(true);
        
        // データ削除
        this.layers.delete(id);
        const index = this.layerOrder.indexOf(id);
        this.layerOrder.splice(index, 1);
        
        // アクティブレイヤー更新
        if (this.activeLayerId === id) {
            this.select(this.layerOrder[Math.max(0, index - 1)]);
        }
        
        // 履歴記録
        this.recordHistory('delete', { layerId: id, layer: layer });
    }
    
    // レイヤー選択
    select(id) {
        if (!this.layers.has(id)) return;
        
        this.activeLayerId = id;
        
        // UI通知
        if (CoreRuntime.ui) {
            CoreRuntime.ui.onLayerSelected(id);
        }
    }
    
    // レイヤー変形（非破壊）
    transform(transformData) {
        const layer = this.getActiveLayer();
        if (!layer || layer.locked) return;
        
        const oldTransform = { ...layer.transform };
        
        // 変形適用
        Object.assign(layer.transform, transformData);
        
        // コンテナ更新
        this.updateLayerTransform(layer);
        
        // 履歴記録
        this.recordHistory('transform', {
            layerId: layer.id,
            oldTransform: oldTransform,
            newTransform: layer.transform
        });
    }
    
    // レイヤー変形を確定（破壊的）
    applyTransform() {
        const layer = this.getActiveLayer();
        if (!layer) return;
        
        const transform = layer.transform;
        
        // 全ストロークのポイントを変形
        layer.strokes.forEach(stroke => {
            stroke.points = stroke.points.map(point => {
                return this.coord.transformPoint(
                    point,
                    transform.pivot,
                    transform
                );
            });
        });
        
        // 変形リセット
        layer.transform = {
            position: { x: 0, y: 0 },
            scale: { x: 1, y: 1 },
            rotation: 0,
            pivot: { x: 0, y: 0 }
        };
        
        // 再描画
        this.drawing.redrawLayer(layer);
        this.updateLayerTransform(layer);
        
        // 履歴記録
        this.recordHistory('applyTransform', { layerId: layer.id });
    }
    
    // コンテナ変形更新
    updateLayerTransform(layer) {
        const t = layer.transform;
        layer.container.position.set(t.position.x, t.position.y);
        layer.container.scale.set(t.scale.x, t.scale.y);
        layer.container.rotation = t.rotation;
        layer.container.pivot.set(t.pivot.x, t.pivot.y);
    }
    
    // 履歴管理
    recordHistory(action, data) {
        // 現在位置より後の履歴を削除
        this.history = this.history.slice(0, this.historyIndex + 1);
        
        // 新規履歴追加
        this.history.push({
            action: action,
            data: data,
            timestamp: Date.now()
        });
        
        // サイズ制限
        if (this.history.length > this.maxHistorySize) {
            this.history.shift();
        } else {
            this.historyIndex++;
        }
    }
    
    // アンドゥ
    undo() {
        if (this.historyIndex < 0) return;
        
        const entry = this.history[this.historyIndex];
        this.applyHistoryReverse(entry);
        this.historyIndex--;
    }
    
    // リドゥ
    redo() {
        if (this.historyIndex >= this.history.length - 1) return;
        
        this.historyIndex++;
        const entry = this.history[this.historyIndex];
        this.applyHistory(entry);
    }
    
    // クリップボード - コピー
    copySelection() {
        const layer = this.getActiveLayer();
        if (!layer) return;
        
        if (this.selection) {
            // 選択範囲内のストロークをコピー
            this.clipboard = {
                strokes: this.getStrokesInSelection(layer, this.selection),
                source: layer.id
            };
        } else {
            // レイヤー全体をコピー
            this.clipboard = {
                strokes: [...layer.strokes],
                source: layer.id
            };
        }
    }
    
    // クリップボード - ペースト
    paste() {
        if (!this.clipboard) return;
        
        const layer = this.getActiveLayer();
        if (!layer) return;
        
        // ストロークを複製して追加
        const pastedStrokes = this.clipboard.strokes.map(stroke => ({
            ...stroke,
            id: `stroke_${Date.now()}_${Math.random()}`,
            points: [...stroke.points]
        }));
        
        layer.strokes.push(...pastedStrokes);
        
        // 再描画
        this.drawing.redrawLayer(layer);
        
        // 履歴記録
        this.recordHistory('paste', {
            layerId: layer.id,
            strokes: pastedStrokes
        });
    }
    
    // ヘルパーメソッド
    getActiveLayer() {
        return this.layers.get(this.activeLayerId);
    }
    
    getLayer(id) {
        return this.layers.get(id);
    }
    
    getAllLayers() {
        return this.layerOrder.map(id => this.layers.get(id));
    }
}

window.LayerSystem = LayerSystem;
```

---

# 🎨 UI Star詳細 (2ファイル)

## ui/ui-state.js (300-500行)
```javascript
// 責任: UI状態の一元管理
window.UIState = {
    // ツール状態
    currentTool: 'brush',
    previousTool: null,
    
    // パネル状態
    panels: {
        layers: { visible: true, x: 10, y: 10 },
        tools: { visible: true, x: 10, y: 200 },
        colors: { visible: true, x: 10, y: 400 }
    },
    
    // 入力状態
    input: {
        mouseDown: false,
        spaceDown: false,
        ctrlDown: false,
        shiftDown: false,
        altDown: false,
        lastX: 0,
        lastY: 0
    },
    
    // モード状態
    mode: 'draw', // draw, transform, select
    
    // 選択状態
    selection: {
        active: false,
        start: null,
        end: null,
        type: 'rectangle' // rectangle, lasso, magic
    },
    
    // 変形状態
    transform: {
        active: false,
        mode: 'move', // move, rotate, scale
        handles: [],
        pivot: 'center'
    },
    
    // 状態更新メソッド
    setTool(tool) {
        this.previousTool = this.currentTool;
        this.currentTool = tool;
    },
    
    setPanelVisibility(panelId, visible) {
        if (this.panels[panelId]) {
            this.panels[panelId].visible = visible;
        }
    },
    
    updateInput(key, value) {
        this.input[key] = value;
    },
    
    setMode(mode) {
        this.mode = mode;
        
        // モード変更時のクリーンアップ
        if (mode !== 'select') {
            this.selection.active = false;
        }
        if (mode !== 'transform') {
            this.transform.active = false;
        }
    }
};
```

## ui/ui-core.js (1500-2000行)
```javascript
// 責任: UI全機能（パネル・ツール・メニュー・ショートカット・イベント）
class UICore {
    constructor(runtime) {
        this.runtime = runtime;
        
        // DOM要素
        this.container = document.getElementById('app-container');
        this.canvas = document.getElementById('main-canvas');
        
        // パネルインスタンス
        this.panels = {
            layers: this.createLayerPanel(),
            tools: this.createToolPanel(),
            colors: this.createColorPanel()
        };
        
        // イベント初期化
        this.initEvents();
        this.initShortcuts();
    }
    
    // === パネル作成 ===
    createLayerPanel() {
        const panel = document.createElement('div');
        panel.className = 'panel layer-panel';
        panel.innerHTML = `
            <div class="panel-header">
                <h3>Layers</h3>
                <button class="panel-close">