# SatellitePlan_RuleBook_v7.txt
# Tegaki PixiJS v8.13 アニメーションツール開発ルールブック（Claude実装最適化版）

## 🎯 基本方針
- **単一ファイル開発 → 段階的分割**: 実装が安定した機能ブロックから順次分離
- **PixiJS v8標準API優先**: 車輪の再発明を避け、Container/Matrix/RenderTexture中心
- **Claude可読性重視**: 座標変換ルール明文化、冗長コード削減、API境界明確化
- **非破壊変形基盤**: JSON記録による履歴管理とKeyframe拡張準備

---

## 📁 ファイル分割戦略（段階的実装）

### Phase1: 単一ファイル統合開発
**対象**: `main.html` 単一ファイル
**内容**: 全機能をHTMLに統合し、機能境界を明確化
**条件**: 各機能ブロックが100行を超えたら分割候補

### Phase2: 核心機能の分離
**分離タイミング**: レイヤー管理・座標変換が安定後
```
main.html          # エントリーポイント + UI制御
core/pixi-engine.js # PixiJS初期化 + 座標変換ルール
core/layer-system.js # レイヤー管理 + 変形処理
```

### Phase3: UI・描画機能の分離
**分離タイミング**: ペン描画・サムネイルが安定後
```
main.html
core/pixi-engine.js
core/layer-system.js
ui/layer-panel.js    # レイヤーパネル + ドラッグ操作
draw/pen-engine.js   # ペン描画 + ストローク管理
```

### Phase4: 完全分離
**分離タイミング**: 全基本機能が安定後
```
main.html            # エントリーポイントのみ
core/
├── pixi-engine.js   # PixiJS管理
├── layer-system.js  # レイヤー管理
├── transform-manager.js # 座標変換・変形処理
ui/
├── layer-panel.js   # レイヤーパネル
├── toolbar.js       # ツールバー
draw/
├── pen-engine.js    # ペン描画
├── brush-system.js  # ブラシ管理
utils/
├── coordinates.js   # 座標変換ユーティリティ
├── thumbnail.js     # サムネイル生成
```

**分割ルール**:
- 機能が安定し、他機能との依存が明確になったブロックから分離
- 1ファイル200行を超えたら分割検討
- Claude改修時の関心事を単一ファイルで完結させる

---

## 🏗 PixiJS v8 アーキテクチャ設計

### 座標系統一ルール
```
[1] DOM座標（ペン入力）
    ↓ app.renderer.events.pointer.normalizeGlobal()
[2] Stage座標（app.stage）
    ↓ canvasContainer.toLocal()
[3] Canvas座標（canvasContainer: 移動・ズーム・回転）
    ↓ layer.toLocal()
[4] Layer座標（layer: 個別変形）
    ↓ graphics.lineTo()
[5] ローカル描画座標
```

**実装ルール**:
- 座標変換は必ず `toLocal(point, from)` / `toGlobal(point)` を使用
- 直接座標計算は禁止
- canvasContainer でキャンバス操作、layer Container でレイヤー操作を分離

### Container階層構造
```javascript
app.stage
└── canvasContainer (PIXI.Container)
    ├── layer1 (PIXI.Container)
    │   ├── graphics (PIXI.Graphics)
    │   └── sprites (PIXI.Sprite[])
    ├── layer2 (PIXI.Container)
    └── selectionMask (PIXI.Graphics)
```

---

## 🔧 採用技術決定（Claude実装最適化）

### ◎ 最優先採用
**理由**: PixiJS v8標準API、Claudeにとって直感的、コード見通し良好

1. **PIXI.Container transform/rotation/scale**
   - キャンバス・レイヤー変形の基本API
   - `container.rotation = Math.PI/4` 直感的記述
   - `scale.x = -1` による反転がシンプル

2. **renderer.render(layer, {renderTexture})**
   - `generateTexture()` より制御明確
   - サムネイル生成の非同期化対応
   - GPU mipmap併用で品質・速度向上

3. **PIXI.Graphics + mask**
   - 選択範囲を非破壊で適用
   - `layer.mask = selectionGraphics` 単純記述
   - 将来の切り抜き・変形に自然対応

4. **PIXI.Assets + PIXI.Ticker.shared**
   - リソース管理とアニメーション更新の一元化
   - setInterval撲滅でUI応答性向上

### ○ 条件付き採用
**理由**: 特定状況で有効だが、基本APIで十分な場合は不要

5. **PIXI.CacheAsBitmap**
   - 静的レイヤーのみ適用
   - 頻繁更新レイヤーでは無効化

6. **WebGL mipmaps**
   - サムネイル品質向上時のみ
   - 基本実装後に追加

### △ 保留・不採用
**理由**: 複雑化リスクまたはClaude実装困難

7. **PIXI.projection（拡張プラグイン）**
   - 2D擬似3D変形用（将来のモーフィング時）
   - 基本機能安定後に検討

8. **OffscreenCanvas + Worker**
   - Worker併用はPixiJSと複雑な連携
   - UI応答性問題が深刻化した時のみ

9. **pixi-viewport**
   - 外部ライブラリ依存
   - 標準Container APIで代替可能

10. **marching-squares**
    - 自動選択・投げ縄用アルゴリズム
    - 基本選択範囲実装後に検討

---

## 🎨 非破壊変形システム設計

### レイヤー状態管理
```javascript
// 各レイヤーのtransformStateをJSON記録
layerState = {
  id: "layer_3",
  position: { x: 100, y: 200 },
  rotation: Math.PI / 6,
  scale: { x: 1.5, y: 0.8 },
  flip: { x: false, y: true },
  visible: true,
  opacity: 1.0,
  blendMode: "normal"
};

// undo/redo履歴配列
transformHistory = [
  { timestamp: Date.now(), states: [layerState1, layerState2, ...] }
];
```

### 変形適用ルール
1. **数値記録**: position/rotation/scale/flip を数値で保持
2. **非破壊適用**: 元RenderTextureに対してtransformを適用表示
3. **履歴管理**: JSON単位でundo/redo管理
4. **Keyframe準備**: 将来的にtimestamp軸でアニメーション化

### Matrix管理（上級者向け）
```javascript
// 複合変形はMatrixで一括管理
const matrix = new PIXI.Matrix();
matrix.translate(layerState.position.x, layerState.position.y);
matrix.rotate(layerState.rotation);
matrix.scale(layerState.scale.x * (layerState.flip.x ? -1 : 1),
             layerState.scale.y * (layerState.flip.y ? -1 : 1));

layer.transform.setFromMatrix(matrix);
```

---

## 🚀 サムネイル生成最適化

### 現行問題点
- `generateTexture()` 依存による遅延発生
- 全レイヤー同時更新でUIカクつき

### 改修方針
```javascript
// 改修前: generateTexture()使用（遅い）
const texture = layer.generateTexture(app.renderer);

// 改修後: renderTexture直接制御（高速）
const thumbTexture = PIXI.RenderTexture.create({width: 64, height: 64});
app.renderer.render(layer, {renderTexture: thumbTexture});

// Ticker制御で更新頻度調整
let needsUpdate = false;
app.ticker.add(() => {
  if (needsUpdate) {
    updateThumbnails();
    needsUpdate = false;
  }
});
```

### GPU最適化
- WebGL mipmaps活用で縮小品質向上
- バッチ処理でGPU効率化

---

## 📐 API設計ルール

### 命名規則
- **camelCase**: JavaScript標準に従う
- **動詞+名詞**: `updateThumbnail()`, `transformLayer()`
- **状態は名詞**: `layerState`, `canvasTransform`
- **boolean接頭辞**: `isVisible`, `hasChanged`, `canTransform`

### 関数設計
```javascript
// 良い例: 単一責任、引数明確
function transformLayer(layerId, transformState) {
  const layer = getLayer(layerId);
  applyTransformState(layer, transformState);
  updateThumbnail(layerId);
}

// 悪い例: 多重責任、引数曖昧
function updateLayer(id, x, y, r, sx, sy, visible) { ... }
```

### エラー処理
```javascript
// エラーは即座に throw、隠蔽禁止
function getLayer(layerId) {
  if (!layers.has(layerId)) {
    throw new Error(`Layer ${layerId} not found`);
  }
  return layers.get(layerId);
}
```

---

## 🔄 開発フロー

### 実装優先度
1. **座標変換システム確立** (canvasContainer + toLocal/toGlobal)
2. **レイヤー変形基盤** (Container + transformState JSON)
3. **サムネイル最適化** (renderTexture + Ticker)
4. **選択範囲基盤** (Graphics + mask)
5. **非破壊変形記憶** (履歴管理 + undo/redo)

### デバッグ指針
- console.log最小限（デバッグ時のみ）
- エラーは意図的に表面化（隠蔽禁止）
- 不具合は検索可能な明確なエラーメッセージ

### テスト方針
- Chrome最新版でfile://直開き動作確認
- レイヤー移動・変形・サムネイル更新の応答性確認
- 座標変換の一貫性確認

---

## 🎯 段階的目標

### Phase1 完了条件
- [x] レイヤーパネル階層ドラッグ対応
- [ ] キャンバス移動・ズーム・回転をcanvasContainerに統一
- [ ] レイヤー個別変形（移動・回転・反転）
- [ ] サムネイル遅延解消

### Phase2 目標
- [ ] 選択範囲マスク機能
- [ ] 無限キャンバス（画面外描画対応）
- [ ] 非破壊変形履歴管理

### Phase3 目標  
- [ ] undo/redo システム
- [ ] Keyframeアニメーション基盤
- [ ] 120Hz対応ベクターペン

### 最終目標
- [ ] GIFアニメ出力
- [ ] LIVE2D/SPINE風モーフィング
- [ ] Procreate級描画体験

---

## ⚠️ 禁止事項（Claude実装時）

### 🚫 技術制約
- Canvas2D混在使用
- TypeScript/ESM/bundler導入
- PixiJS v7/v8バージョン混在対応

### 🚫 実装制約  
- 曖昧なフォールバック処理
- エラー隠蔽・問題先送り
- 過度なユーザー向けエラー演出
- 冗長な二重実装

### 🚫 API設計制約
- 暗黙の型変換・自動修復
- 複数責任を持つ関数
- グローバル変数への直接アクセス
- 座標計算の直接実装（toLocal/toGlobal必須）

---

## 📋 Claude実装チェックリスト

### 新機能実装時
- [ ] PixiJS v8標準APIを最優先選択
- [ ] 座標変換はtoLocal/toGlobalルール遵守  
- [ ] Container階層の責任分離確認
- [ ] transformState JSON記録対応
- [ ] エラーハンドリング明確化

### リファクタリング時
- [ ] 機能境界の明確化
- [ ] 冗長コード削減
- [ ] API命名規則統一
- [ ] ファイル分割タイミング判定
- [ ] デバッグログ最小化

### 品質確認時
- [ ] file://直開き動作確認
- [ ] UI応答性確認（60fps維持）
- [ ] メモリリーク検証
- [ ] 座標変換一貫性確認
- [ ] エラー再現性確認1