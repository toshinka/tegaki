# Phase 5改修計画書：キー処理一元化 & リサイズ機能追加

**作成日**: 2025-01-11  
**対象バージョン**: v8.13_History36  
**前提**: Phase 4完了済み（CUT自動採番、Camera拡縮修正、Vキー競合修正、UI改善）

---

## 📋 目次

1. [改修概要](#改修概要)
2. [Phase 5.1: キャンバスリサイズ機能](#phase-51-キャンバスリサイズ機能)
3. [Phase 5.2: キー処理の完全一元化](#phase-52-キー処理の完全一元化)
4. [Phase 5.3: 新キーマッピングの適用](#phase-53-新キーマッピングの適用)
5. [Phase 5.4: 統合テスト & 競合チェック](#phase-54-統合テスト--競合チェック)

---

## 改修概要

### 目的
1. **キャンバスリサイズ機能の実装** - 現在発火しないリサイズ処理にUIボタンを追加
2. **キー処理の完全一元化** - config.jsを唯一の真実のソースとし、競合を根絶
3. **新キーマッピングの適用** - CTRL操作の統一、Shift+Spaceの競合解消

### 改修方針
- **段階的な移行**: 機能追加 → 一元化 → キーマッピング変更の順で実施
- **後方互換性**: 既存の動作を壊さない
- **AI改修性重視**: 処理フローが1箇所で完結する設計

---

## Phase 5.1: キャンバスリサイズ機能

### 問題
- `core-engine.js`の`resizeCanvas()`メソッドが存在するが、UIから発火する手段がない
- キャンバスサイズ変更時のサムネイル再生成が動作しない

### 対象ファイル

#### 修正ファイル
- `index.html` - リサイズボタンUIの追加
- `core-engine.js` - resizeCanvas()の動作確認・修正

#### 参考ファイル
- `config.js` - canvas.width/height の定義確認
- `camera-system.js` - resizeCanvas()の呼び出し確認
- `animation-system.js` - handleCanvasResize()の動作確認

---

### 実装詳細

#### 1. index.html - リサイズUIの追加

**追加箇所**: ツールパネル内（`#tool-panel`）

```html
<!-- キャンバスサイズ変更UI -->
<div class="canvas-size-controls">
    <label class="control-label">キャンバスサイズ</label>
    <div class="size-input-group">
        <input type="number" id="canvas-width" value="344" min="100" max="2000" step="1">
        <span>×</span>
        <input type="number" id="canvas-height" value="135" min="100" max="2000" step="1">
    </div>
    <button id="resize-canvas-btn" class="control-button">サイズ変更</button>
</div>
```

**イベントリスナー追加**:
```javascript
document.getElementById('resize-canvas-btn')?.addEventListener('click', () => {
    const width = parseInt(document.getElementById('canvas-width').value);
    const height = parseInt(document.getElementById('canvas-height').value);
    
    if (window.coreEngine && width > 0 && height > 0) {
        window.coreEngine.resizeCanvas(width, height);
    }
});
```

---

#### 2. core-engine.js - resizeCanvas()の修正

**対象メソッド**: `CoreEngine.resizeCanvas(newWidth, newHeight)`

**現在の実装**:
```javascript
resizeCanvas(newWidth, newHeight) {
    CONFIG.canvas.width = newWidth;
    CONFIG.canvas.height = newHeight;
    
    this.cameraSystem.resizeCanvas(newWidth, newHeight);
    
    // 背景レイヤーの再描画
    const layers = this.layerSystem.getLayers();
    layers.forEach(layer => { /* ... */ });
    
    // サムネイル更新
    for (let i = 0; i < layers.length; i++) {
        this.layerSystem.requestThumbnailUpdate(i);
    }
    
    this.eventBus.emit('canvas:resized', { width: newWidth, height: newHeight });
}
```

**修正内容**:
- ✅ 既存実装は正しい
- ✅ CUTサムネイル再生成を追加（animation-systemとの連携）

**追加コード**:
```javascript
// CUTサムネイル再生成を追加
if (this.animationSystem) {
    setTimeout(() => {
        const animData = this.animationSystem.getAnimationData();
        for (let i = 0; i < animData.cuts.length; i++) {
            this.animationSystem.generateCutThumbnail(i);
        }
    }, 500);
}
```

---

#### 3. camera-system.js - resizeCanvas()の確認

**対象メソッド**: `CameraSystem.resizeCanvas(newWidth, newHeight)`

**処理内容**:
```javascript
resizeCanvas(newWidth, newHeight) {
    this.updateGuideLinesForCanvasResize();
    if (this.eventBus) {
        this.eventBus.emit('camera:resized', { width: newWidth, height: newHeight });
    }
}
```

**確認項目**:
- ✅ ガイドライン更新
- ✅ カメラフレーム再描画
- ✅ マスク更新

---

#### 4. animation-system.js - handleCanvasResize()の確認

**対象メソッド**: `AnimationSystem.handleCanvasResize(newWidth, newHeight)`

**処理内容**:
```javascript
handleCanvasResize(newWidth, newHeight) {
    if (!this.animationData?.cuts || this.animationData.cuts.length === 0) return;
    
    setTimeout(() => {
        this.regenerateAllThumbnails();
    }, 200);
    
    if (this.eventBus) {
        this.eventBus.emit('animation:thumbnails-need-update');
    }
}
```

**確認項目**:
- ✅ 全CUTのサムネイル再生成
- ✅ イベント発行

---

### Phase 5.1 テスト項目

- [ ] リサイズボタンが表示される
- [ ] 入力値が正しく反映される
- [ ] キャンバスサイズが変更される
- [ ] 背景レイヤーが正しくリサイズされる
- [ ] レイヤーサムネイルが再生成される
- [ ] CUTサムネイルが再生成される
- [ ] カメラフレームが正しく表示される

---

## Phase 5.2: キー処理の完全一元化

### 目的
- **キー処理を1箇所に集約** - `core-engine.js`の`UnifiedKeyHandler`のみが処理
- **競合の完全排除** - 複数のkeydownリスナーによる競合を解消
- **AI改修性向上** - 処理フローが1ファイルで完結

### 現状分析

#### 現在のキー処理箇所
```
1. core-engine.js      - UnifiedKeyHandler.handleKeyDown()
2. timeline-ui.js      - setupKeyboardShortcuts()
3. layer-system.js     - _setupLayerOperations()
4. camera-system.js    - _setupKeyboardEvents()
5. index.html          - 個別のキーイベントリスナー（要確認）
```

#### 問題点
- ❌ 同じキーが複数箇所で処理される
- ❌ `e.preventDefault()`の効果が不確実
- ❌ 処理順序が不定（ブラウザ依存）
- ❌ デバッグが困難

---

### アーキテクチャ設計

#### 新しい処理フロー

```
config.js (定義のみ)
    ↓
UnifiedKeyHandler (唯一のkeydownリスナー)
    ├─ 1. コンテキスト判定
    │   ├─ vKeyPressed (レイヤー操作モード)
    │   ├─ timelineVisible (タイムライン表示)
    │   ├─ isDrawing (描画中)
    │   └─ spacePressed (カメラ操作)
    │
    ├─ 2. 優先順位制御
    │   └─ 高優先度が先に処理（early return）
    │
    ├─ 3. アクション解決
    │   └─ config.jsのTEGAKI_KEYMAPから該当アクション取得
    │
    └─ 4. 各システムのメソッド呼び出し
        ├─ layerSystem.xxx()
        ├─ cameraSystem.xxx()
        ├─ timelineUI.xxx()
        └─ animationSystem.xxx()
```

---

### 対象ファイル

#### 修正ファイル（優先順位順）

1. **core-engine.js** - UnifiedKeyHandlerの拡張
2. **timeline-ui.js** - setupKeyboardShortcuts()の削除/メソッド化
3. **layer-system.js** - _setupLayerOperations()の削除/メソッド化
4. **camera-system.js** - _setupKeyboardEvents()の簡素化

#### 参考ファイル
- `config.js` - TEGAKI_KEYMAPの定義確認

---

### 実装詳細

#### 1. core-engine.js - UnifiedKeyHandlerの拡張

**対象クラス**: `UnifiedKeyHandler`

**追加メソッド**:

```javascript
class UnifiedKeyHandler {
    constructor(cameraSystem, layerSystem, drawingEngine, eventBus, animationSystem) {
        this.cameraSystem = cameraSystem;
        this.layerSystem = layerSystem;
        this.drawingEngine = drawingEngine;
        this.eventBus = eventBus;
        this.animationSystem = animationSystem;
        this.timelineUI = null; // 後で設定
        
        this.keyConfig = window.TEGAKI_KEYMAP;
        this.keyHandlingActive = true;
        
        this.setupKeyHandling();
    }
    
    setTimelineUI(timelineUI) {
        this.timelineUI = timelineUI;
    }
    
    // 🔥 Phase 5.2: コンテキスト取得の統一
    getContext() {
        return {
            vKeyPressed: this.layerSystem?.vKeyPressed || false,
            timelineVisible: this.timelineUI?.isVisible || false,
            isDrawing: this.drawingEngine?.isDrawing || false,
            spacePressed: this.cameraSystem?.spacePressed || false,
            shiftPressed: false, // keydownイベントから取得
            ctrlPressed: false   // keydownイベントから取得
        };
    }
    
    // 🔥 Phase 5.2: 優先順位制御
    handleKeyDown(e) {
        // Undo/Redoは最優先
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        const metaKey = isMac ? e.metaKey : e.ctrlKey;
        if (metaKey && (e.code === 'KeyZ' || e.code === 'KeyY')) {
            return; // History処理に任せる
        }
        
        const context = this.getContext();
        context.shiftPressed = e.shiftKey;
        context.ctrlPressed = e.ctrlKey || e.metaKey;
        
        // 🔥 優先度1: レイヤー操作モード（V押下中）
        if (context.vKeyPressed) {
            this.handleLayerModeKeys(e, context);
            return;
        }
        
        // 🔥 優先度2: タイムライン操作
        if (context.timelineVisible && this.handleTimelineKeys(e, context)) {
            return;
        }
        
        // 🔥 優先度3: カメラ操作
        if (this.handleCameraKeys(e, context)) {
            return;
        }
        
        // 🔥 優先度4: ツール切り替え
        this.handleToolKeys(e, context);
    }
    
    // 🔥 Phase 5.2: レイヤー操作キー処理
    handleLayerModeKeys(e, context) {
        const action = this.keyConfig.getAction(e, { vMode: true });
        
        switch(action) {
            case 'LAYER_MOVE_UP':
            case 'LAYER_MOVE_DOWN':
            case 'LAYER_MOVE_LEFT':
            case 'LAYER_MOVE_RIGHT':
                this.layerSystem.moveActiveLayer(e.code);
                e.preventDefault();
                break;
                
            case 'LAYER_SCALE_UP':
            case 'LAYER_SCALE_DOWN':
            case 'LAYER_ROTATE_LEFT':
            case 'LAYER_ROTATE_RIGHT':
                this.layerSystem.transformActiveLayer(e.code);
                e.preventDefault();
                break;
                
            case 'LAYER_FLIP_HORIZONTAL':
                this.layerSystem.flipActiveLayer('horizontal');
                e.preventDefault();
                break;
                
            case 'LAYER_FLIP_VERTICAL':
                this.layerSystem.flipActiveLayer('vertical');
                e.preventDefault();
                break;
        }
    }
    
    // 🔥 Phase 5.2: タイムライン操作キー処理
    handleTimelineKeys(e, context) {
        const action = this.keyConfig.getAction(e, { vMode: false });
        
        switch(action) {
            case 'GIF_PREV_FRAME':
                if (e.code === 'ArrowLeft' && context.ctrlPressed) {
                    this.timelineUI.goToPreviousCutSafe();
                    e.preventDefault();
                    return true;
                }
                break;
                
            case 'GIF_NEXT_FRAME':
                if (e.code === 'ArrowRight' && context.ctrlPressed) {
                    this.timelineUI.goToNextCutSafe();
                    e.preventDefault();
                    return true;
                }
                break;
                
            case 'GIF_PLAY_PAUSE':
                if (e.code === 'Space' && context.ctrlPressed) {
                    this.animationSystem.togglePlayPause();
                    e.preventDefault();
                    return true;
                }
                break;
        }
        
        return false;
    }
    
    // 🔥 Phase 5.2: カメラ操作キー処理
    handleCameraKeys(e, context) {
        // Ctrl+↑↓: レイヤー階層移動（カメラではない）
        if (context.ctrlPressed && (e.code === 'ArrowUp' || e.code === 'ArrowDown')) {
            this.handleLayerHierarchyKeys(e);
            return true;
        }
        
        // Space or Shift + 方向キー: カメラ操作
        if ((context.spacePressed || context.shiftPressed) && 
            ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
            
            if (context.shiftPressed) {
                // Shift + 方向キー: 回転・拡縮
                this.handleCameraTransform(e);
            } else {
                // Space + 方向キー: パン移動
                this.handleCameraMove(e);
            }
            e.preventDefault();
            return true;
        }
        
        // 素の方向キー: カメラパン移動
        if (!context.ctrlPressed && !context.shiftPressed && 
            ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
            this.handleCameraMove(e);
            e.preventDefault();
            return true;
        }
        
        return false;
    }
    
    // 🔥 Phase 5.2: レイヤー階層移動
    handleLayerHierarchyKeys(e) {
        const activeIndex = this.layerSystem.activeLayerIndex;
        const layers = this.layerSystem.getLayers();
        
        if (e.code === 'ArrowUp' && activeIndex < layers.length - 1) {
            const layer = layers[activeIndex];
            const targetLayer = layers[activeIndex + 1];
            
            if (!layer?.layerData?.isBackground && !targetLayer?.layerData?.isBackground) {
                this.layerSystem.currentCutContainer.removeChildAt(activeIndex);
                this.layerSystem.currentCutContainer.addChildAt(layer, activeIndex + 1);
                this.layerSystem.activeLayerIndex = activeIndex + 1;
                this.layerSystem.updateLayerPanelUI();
            }
        } else if (e.code === 'ArrowDown' && activeIndex > 0) {
            const layer = layers[activeIndex];
            const targetLayer = layers[activeIndex - 1];
            
            if (!layer?.layerData?.isBackground && !targetLayer?.layerData?.isBackground) {
                this.layerSystem.currentCutContainer.removeChildAt(activeIndex);
                this.layerSystem.currentCutContainer.addChildAt(layer, activeIndex - 1);
                this.layerSystem.activeLayerIndex = activeIndex - 1;
                this.layerSystem.updateLayerPanelUI();
            }
        }
    }
    
    // 🔥 Phase 5.2: カメラパン移動
    handleCameraMove(e) {
        const moveAmount = this.cameraSystem.config.camera.keyMoveAmount;
        switch(e.code) {
            case 'ArrowUp':    this.cameraSystem.worldContainer.y -= moveAmount; break;
            case 'ArrowDown':  this.cameraSystem.worldContainer.y += moveAmount; break;
            case 'ArrowLeft':  this.cameraSystem.worldContainer.x -= moveAmount; break;
            case 'ArrowRight': this.cameraSystem.worldContainer.x += moveAmount; break;
        }
        this.cameraSystem.updateTransformDisplay();
    }
    
    // 🔥 Phase 5.2: カメラ回転・拡縮
    handleCameraTransform(e) {
        const centerX = this.cameraSystem.config.canvas.width / 2;
        const centerY = this.cameraSystem.config.canvas.height / 2;
        const worldCenter = this.cameraSystem.worldContainer.toGlobal({ x: centerX, y: centerY });
        
        switch(e.code) {
            case 'ArrowUp':
                this.cameraSystem._scaleCamera(
                    1 + this.cameraSystem.config.camera.wheelZoomSpeed, 
                    worldCenter, centerX, centerY
                );
                break;
            case 'ArrowDown':
                this.cameraSystem._scaleCamera(
                    1 - this.cameraSystem.config.camera.wheelZoomSpeed, 
                    worldCenter, centerX, centerY
                );
                break;
            case 'ArrowLeft':
                this.cameraSystem._rotateCamera(
                    -this.cameraSystem.config.camera.keyRotationDegree, 
                    worldCenter, centerX, centerY
                );
                break;
            case 'ArrowRight':
                this.cameraSystem._rotateCamera(
                    this.cameraSystem.config.camera.keyRotationDegree, 
                    worldCenter, centerX, centerY
                );
                break;
        }
        this.cameraSystem.updateTransformDisplay();
    }
    
    // 🔥 Phase 5.2: ツール切り替えキー処理
    handleToolKeys(e, context) {
        const action = this.keyConfig.getAction(e, { vMode: false });
        
        switch(action) {
            case 'TOOL_PEN':
                if (!e.ctrlKey && !e.altKey && !e.metaKey) {
                    this.switchTool('pen');
                    e.preventDefault();
                }
                break;
                
            case 'TOOL_ERASER':
                if (!e.ctrlKey && !e.altKey && !e.metaKey) {
                    this.switchTool('eraser');
                    e.preventDefault();
                }
                break;
        }
    }
}
```

---

#### 2. timeline-ui.js - setupKeyboardShortcuts()の削除

**現在の実装**:
```javascript
setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        // ... 矢印キー処理
    });
}
```

**修正内容**:
- ✅ `setupKeyboardShortcuts()`を削除
- ✅ `goToPreviousCutSafe()`と`goToNextCutSafe()`はpublicメソッドとして維持
- ✅ UnifiedKeyHandlerから呼び出される形に変更

**修正後**:
```javascript
// setupKeyboardShortcuts()は削除
// 既存のメソッドはそのまま維持
goToPreviousCutSafe() { /* ... */ }
goToNextCutSafe() { /* ... */ }
```

---

#### 3. layer-system.js - _setupLayerOperations()の簡素化

**現在の実装**:
```javascript
_setupLayerOperations() {
    document.addEventListener('keydown', (e) => {
        // ... V+方向キー処理
    });
}
```

**修正内容**:
- ✅ keydownリスナーを削除
- ✅ `moveActiveLayer()`、`transformActiveLayer()`、`flipActiveLayer()`はpublicメソッドとして維持
- ✅ UnifiedKeyHandlerから呼び出される形に変更

**修正後**:
```javascript
_setupLayerOperations() {
    // keydownリスナーは削除
    // window.blurリスナーのみ残す
    window.addEventListener('blur', () => {
        if (this.vKeyPressed) {
            this.exitLayerMoveMode();
        }
    });
}

// 既存のメソッドはそのまま維持
moveActiveLayer(keyCode) { /* ... */ }
transformActiveLayer(keyCode) { /* ... */ }
flipActiveLayer(direction) { /* ... */ }
```

---

#### 4. camera-system.js - _setupKeyboardEvents()の簡素化

**現在の実装**:
```javascript
_setupKeyboardEvents() {
    document.addEventListener('keydown', (e) => {
        // ... カメラ操作
    });
}
```

**修正内容**:
- ✅ カメラ操作のkeydownリスナーを削除
- ✅ Spaceキー状態管理のみ残す（描画停止に必要）
- ✅ `_scaleCamera()`、`_rotateCamera()`はpublicメソッドとして維持

**修正後**:
```javascript
_setupKeyboardEvents() {
    // Spaceキー状態管理のみ
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            this.spacePressed = true;
            this.updateCursor();
            e.preventDefault();
        }
    });
    
    document.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
            this.spacePressed = false;
            this.updateCursor();
        }
    });
    
    window.addEventListener('blur', () => {
        this._resetAllKeyStates();
    });
}

// publicメソッドとして公開
_scaleCamera(scaleFactor, worldCenter, centerX, centerY) { /* ... */ }
_rotateCamera(rotationDelta, worldCenter, centerX, centerY) { /* ... */ }
```

---

### Phase 5.2 テスト項目

- [ ] Vキー押下中のレイヤー操作が動作する
- [ ] Ctrl+←→でCUT移動が動作する
- [ ] 方向キーでカメラ移動が動作する
- [ ] Shift+方向キーでカメラ回転・拡縮が動作する
- [ ] Ctrl+↑↓でレイヤー階層移動が動作する
- [ ] P/Eキーでツール切り替えが動作する
- [ ] キーの競合が発生しない
- [ ] e.preventDefault()が確実に効く

---

## Phase 5.3: 新キーマッピングの適用

### 目的
- **CTRL操作の統一** - CUT移動、レイヤー階層、再生停止をCTRLに統一
- **Shift+Spaceの競合解消** - 削除してカメラ回転と競合しないように

### 新キーマッピング仕様

| 操作 | 旧キーマッピング | 新キーマッピング | 変更理由 |
|------|----------------|----------------|---------|
| **カメラ移動** | Space+方向キー | 方向キー | シンプル化 |
| **カメラ回転・拡縮** | Space+Shift+方向キー | Shift+方向キー | シンプル化 |
| **CUT移動** | ←→ | Ctrl+←→ | CTRL統一 |
| **レイヤー階層移動** | Ctrl+↑↓ | Ctrl+↑↓ | 変更なし |
| **再生/停止** | Ctrl+Space / Shift+Space | Ctrl+Space | Shift削除 |

---

### 対象ファイル

#### 修正ファイル
- `config.js` - TEGAKI_KEYMAPの定義変更

---

### 実装詳細

#### config.js - TEGAKI_KEYMAPの変更

**修正箇所**: `actions`オブジェクト

```javascript
// 🔥 Phase 5.3: 新キーマッピング
actions: {
    // === GIF/アニメーション操作（CTRL統一） ===
    GIF_PREV_FRAME: {
        key: 'ArrowLeft',
        ctrl: true,        // 🔥 変更: Ctrl必須
        shift: false,
        alt: false,
        vMode: false,
        description: '前のCUT'
    },
    GIF_NEXT_FRAME: {
        key: 'ArrowRight',
        ctrl: true,        // 🔥 変更: Ctrl必須
        shift: false,
        alt: false,
        vMode: false,
        description: '次のCUT'
    },
    GIF_PLAY_PAUSE: {
        key: 'Space',
        ctrl: true,        // 🔥 変更: Ctrlのみ（Shift削除）
        shift: false,
        alt: false,
        description: '再生/停止'
    },
    
    // === カメラ操作（シンプル化） ===
    // 🔥 削除: CAMERA_MOVE_XXX（素の方向キーで対応）
    // 🔥 変更: CAMERA_TRANSFORM_XXX → Shift+方向キー
    
    CAMERA_SCALE_UP: {
        key: 'ArrowUp',
        ctrl: false,
        shift: true,       // 🔥 変更: Shift必須（Spaceは不要）
        alt: false,
        vMode: false,
        description: 'カメラ拡大'
    },
    CAMERA_SCALE_DOWN: {
        key: 'ArrowDown',
        ctrl: false,
        shift: true,
        alt: false,
        vMode: false,
        description: 'カメラ縮小'
    },
    CAMERA_ROTATE_LEFT: {
        key: 'ArrowLeft',
        ctrl: false,
        shift: true,
        alt: false,
        vMode: false,
        description: 'カメラ左回転'
    },
    CAMERA_ROTATE_RIGHT: {
        key: 'ArrowRight',
        ctrl: false,
        shift: true,
        alt: false,
        vMode: false,
        description: 'カメラ右回転'
    },
    
    // === レイヤー階層移動（変更なし） ===
    LAYER_HIERARCHY_UP: {
        key: 'ArrowUp',
        ctrl: true,
        shift: false,
        alt: false,
        vMode: false,
        description: 'レイヤー階層を上へ'
    },
    LAYER_HIERARCHY_DOWN: {
        key: 'ArrowDown',
        ctrl: true,
        shift: false,
        alt: false,
        vMode: false,
        description: 'レイヤー階層を下へ'
    }
}
```

---

### Phase 5.3 テスト項目

- [ ] 方向キーでカメラ移動が動作する
- [ ] Shift+↑↓でカメラ拡縮が動作する
- [ ] Shift+←→でカメラ回転が動作する
- [ ] Ctrl+←→でCUT移動が動作する
- [ ] Ctrl+↑↓でレイヤー階層移動が動作する
- [ ] Ctrl+SpaceでGIF再生/停止が動作する
- [ ] Shift+Spaceが無効化されている（競合なし）
- [ ] 素の←→がカメラ操作になっている（CUT移動しない）

---

## Phase 5.4: 統合テスト & 競合チェック

### 目的
- **全キー操作の動作確認** - すべてのキーマッピングが正しく動作するか
- **競合の完全排除** - どのキーも複数箇所で処理されていないか
- **デバッグ支援** - 問題発生時の追跡を容易に

---

### テストマトリクス

#### 1. 基本キー操作

| キー | モディファイア | 期待動作 | テスト結果 |
|------|--------------|---------|-----------|
| P | なし | ペンツール | [ ] |
| E | なし | 消しゴムツール | [ ] |
| V | なし | レイヤー移動モード切替 | [ ] |
| H | なし | キャンバス水平反転 | [ ] |
| Shift+H | なし | キャンバス垂直反転 | [ ] |

#### 2. 方向キー（モディファイアなし）

| キー | コンテキスト | 期待動作 | テスト結果 |
|------|------------|---------|-----------|
| ↑ | 通常 | カメラ上移動 | [ ] |
| ↓ | 通常 | カメラ下移動 | [ ] |
| ← | 通常 | カメラ左移動 | [ ] |
| → | 通常 | カメラ右移動 | [ ] |

#### 3. Shift+方向キー

| キー | コンテキスト | 期待動作 | テスト結果 |
|------|------------|---------|-----------|
| Shift+↑ | 通常 | カメラ拡大 | [ ] |
| Shift+↓ | 通常 | カメラ縮小 | [ ] |
| Shift+← | 通常 | カメラ左回転 | [ ] |
| Shift+→ | 通常 | カメラ右回転 | [ ] |

#### 4. Ctrl+方向キー

| キー | コンテキスト | 期待動作 | テスト結果 |
|------|------------|---------|-----------|
| Ctrl+↑ | 通常 | レイヤー階層上へ | [ ] |
| Ctrl+↓ | 通常 | レイヤー階層下へ | [ ] |
| Ctrl+← | Timeline表示 | 前のCUT | [ ] |
| Ctrl+→ | Timeline表示 | 次のCUT | [ ] |

#### 5. V+方向キー（レイヤー移動モード）

| キー | コンテキスト | 期待動作 | テスト結果 |
|------|------------|---------|-----------|
| V+↑ | Vモード | レイヤー上移動 | [ ] |
| V+↓ | Vモード | レイヤー下移動 | [ ] |
| V+← | Vモード | レイヤー左移動 | [ ] |
| V+→ | Vモード | レイヤー右移動 | [ ] |

#### 6. V+Shift+方向キー（レイヤー変形）

| キー | コンテキスト | 期待動作 | テスト結果 |
|------|------------|---------|-----------|
| V+Shift+↑ | Vモード | レイヤー拡大 | [ ] |
| V+Shift+↓ | Vモード | レイヤー縮小 | [ ] |
| V+Shift+← | Vモード | レイヤー左回転 | [ ] |
| V+Shift+→ | Vモード | レイヤー右回転 | [ ] |

#### 7. V+H（レイヤー反転）

| キー | コンテキスト | 期待動作 | テスト結果 |
|------|------------|---------|-----------|
| V+H | Vモード | レイヤー水平反転 | [ ] |
| V+Shift+H | Vモード | レイヤー垂直反転 | [ ] |

#### 8. Space系操作

| キー | コンテキスト | 期待動作 | テスト結果 |
|------|------------|---------|-----------|
| Space+ドラッグ | 通常 | カメラパン移動 | [ ] |
| Space+Shift+ドラッグ | 通常 | カメラ回転・拡縮 | [ ] |
| Ctrl+Space | Timeline表示 | 再生/停止 | [ ] |
| Shift+Space | 任意 | 無効（競合なし） | [ ] |

#### 9. その他の操作

| キー | コンテキスト | 期待動作 | テスト結果 |
|------|------------|---------|-----------|
| Ctrl+Z | 任意 | Undo | [ ] |
| Ctrl+Y | 任意 | Redo | [ ] |
| Ctrl+0 | 任意 | カメラリセット | [ ] |
| Delete | 任意 | レイヤークリア | [ ] |

---

### 競合チェックリスト

#### 確認項目

- [ ] **keydownリスナーの数**
  - core-engine.js: 1箇所（UnifiedKeyHandler）のみ
  - timeline-ui.js: 0箇所
  - layer-system.js: 0箇所
  - camera-system.js: 1箇所（Spaceキー状態のみ）
  
- [ ] **e.preventDefault()の確実性**
  - すべてのキー操作でpreventDefaultが効いている
  - ブラウザデフォルト動作が発生しない
  
- [ ] **処理の一意性**
  - 同じキーが2箇所以上で処理されていない
  - UnifiedKeyHandlerでearly returnが適切に機能
  
- [ ] **コンテキスト判定の正確性**
  - vKeyPressedの状態が正しく取得される
  - timelineVisibleの状態が正しく取得される
  - 各コンテキストで期待通りの動作になる

---

### デバッグ支援機能

#### 1. キー処理のログ出力

**core-engine.js - UnifiedKeyHandlerに追加**:

```javascript
handleKeyDown(e) {
    // デバッグモード時のログ出力
    if (window.TEGAKI_CONFIG.debug) {
        const context = this.getContext();
        console.log('[UnifiedKeyHandler]', {
            key: e.code,
            ctrl: e.ctrlKey,
            shift: e.shiftKey,
            alt: e.altKey,
            context: context,
            action: this.keyConfig.getAction(e, context)
        });
    }
    
    // ... 既存処理
}
```

#### 2. キーマッピング一覧の表示

**ブラウザコンソールで実行**:

```javascript
// キーマッピング一覧を表示
window.TEGAKI_KEYMAP.debugShowMapping();

// 特定のキーの動作を確認
window.TEGAKI_KEYMAP.getAction(
    { code: 'ArrowUp', ctrlKey: true, shiftKey: false, altKey: false },
    { vMode: false }
);
```

---

## 改修スケジュール

### 推奨順序

1. **Phase 5.1** - キャンバスリサイズ機能（1ファイル）
   - 所要時間: 30分
   - リスク: 低

2. **Phase 5.2** - キー処理の完全一元化（4ファイル）
   - 所要時間: 2時間
   - リスク: 中（既存動作への影響）

3. **Phase 5.3** - 新キーマッピングの適用（1ファイル）
   - 所要時間: 30分
   - リスク: 低

4. **Phase 5.4** - 統合テスト & 競合チェック
   - 所要時間: 1時間
   - リスク: なし（テストのみ）

**総所要時間**: 約4時間

---

## ファイル別改修サマリー

### Phase 5.1: キャンバスリサイズ

| ファイル | 改修内容 | 主要メソッド |
|---------|---------|------------|
| `index.html` | リサイズUIの追加 | - |
| `core-engine.js` | resizeCanvas()の確認・修正 | `resizeCanvas(w, h)` |
| `camera-system.js` | 参考確認のみ | `resizeCanvas(w, h)` |
| `animation-system.js` | 参考確認のみ | `handleCanvasResize(w, h)` |

### Phase 5.2: キー処理一元化

| ファイル | 改修内容 | 主要メソッド |
|---------|---------|------------|
| `core-engine.js` | UnifiedKeyHandlerの拡張 | `handleKeyDown()`, `handleLayerModeKeys()`, `handleTimelineKeys()`, `handleCameraKeys()` |
| `timeline-ui.js` | keydownリスナー削除 | `goToPreviousCutSafe()`, `goToNextCutSafe()` |
| `layer-system.js` | keydownリスナー削除 | `moveActiveLayer()`, `transformActiveLayer()`, `flipActiveLayer()` |
| `camera-system.js` | keydownリスナー簡素化 | `_scaleCamera()`, `_rotateCamera()` |

### Phase 5.3: 新キーマッピング

| ファイル | 改修内容 | 主要定義 |
|---------|---------|---------|
| `config.js` | TEGAKI_KEYMAPの変更 | `GIF_PREV_FRAME`, `GIF_NEXT_FRAME`, `GIF_PLAY_PAUSE`, `CAMERA_SCALE_UP/DOWN`, `CAMERA_ROTATE_LEFT/RIGHT` |

---

## 注意事項

### 1. Space+Shiftの扱い

**問題**: 
- 旧: `Shift+Space`でタイムライン再生/停止
- 新: `Ctrl+Space`のみに統一

**注意点**:
- `timeline-ui.js`の`setupKeyboardShortcuts()`を削除する際、`Shift+Space`の処理も完全に削除
- `config.js`の`GIF_PLAY_PAUSE`定義から`Shift`バリアントを削除

### 2. 素の方向キーの挙動変更

**旧挙動**:
- Timeline表示時: `←→`でCUT移動
- Timeline非表示時: `↑↓`でレイヤーアクティブ変更

**新挙動**:
- 常に: `方向キー`でカメラ移動
- CUT移動: `Ctrl+←→`
- レイヤーアクティブ変更: 廃止（代わりにマウスクリック）

### 3. UnifiedKeyHandlerへのTimelineUI参照設定

**重要**: `CoreEngine.initialize()`内で、TimelineUI生成後に参照を設定すること

```javascript
// core-engine.js - CoreEngine.initialize()
this.timelineUI = new window.TegakiTimelineUI(this.animationSystem);
this.timelineUI.init();

// 🔥 重要: UnifiedKeyHandlerにTimelineUI参照を設定
this.keyHandler.setTimelineUI(this.timelineUI);
```

### 4. デバッグモードの活用

**テスト時は必ずデバッグモードを有効化**:

```javascript
// config.js
window.TEGAKI_CONFIG = {
    // ...
    debug: true  // 🔥 テスト時はtrueに
};
```

---

## トラブルシューティング

### 問題1: キーが反応しない

**原因**:
- UnifiedKeyHandlerにTimelineUI参照が設定されていない
- keydownリスナーが複数箇所で登録されている

**対処**:
1. `this.keyHandler.setTimelineUI()`が呼ばれているか確認
2. コンソールで`document.getEventListeners?.(document)`を実行してリスナー数を確認

### 問題2: キーが二重に反応する

**原因**:
- 旧コードのkeydownリスナーが残っている
- `e.preventDefault()`が呼ばれていない

**対処**:
1. `timeline-ui.js`、`layer-system.js`、`camera-system.js`のkeydownリスナーを削除
2. UnifiedKeyHandlerで確実に`e.preventDefault()`を呼ぶ

### 問題3: コンテキスト判定が機能しない

**原因**:
- `vKeyPressed`や`timelineVisible`の状態が正しく取得できていない

**対処**:
1. `getContext()`メソッドで状態をログ出力
2. 各システムの状態フラグを確認

---

## Phase 5完了後の状態

### 達成目標

- ✅ キャンバスリサイズがUIから実行可能
- ✅ すべてのキー処理がUnifiedKeyHandlerで一元管理
- ✅ キーの競合が完全に解消
- ✅ 新キーマッピングが適用され、CTRL操作に統一感
- ✅ AI改修性が大幅に向上（処理フローが1ファイルで完結）

### ファイル構成

```
config.js          - キーマッピング定義（唯一の真実のソース）
    ↓
core-engine.js     - UnifiedKeyHandler（唯一のkeydownリスナー）
    ├─ timeline-ui.js   - UIメソッドのみ（keydownなし）
    ├─ layer-system.js  - 操作メソッドのみ（keydownなし）
    └─ camera-system.js - 操作メソッドのみ（Spaceキー状態のみ）
```

### キーマッピング最終形

| 操作 | キー | 説明 |
|------|------|------|
| カメラ移動 | 方向キー | シンプル化 |
| カメラ変形 | Shift+方向キー | 拡縮・回転 |
| CUT移動 | Ctrl+←→ | CTRL統一 |
| レイヤー階層 | Ctrl+↑↓ | CTRL統一 |
| 再生/停止 | Ctrl+Space | CTRL統一 |
| レイヤー操作 | Vモード+方向キー | 移動 |
| レイヤー変形 | Vモード+Shift+方向キー | 拡縮・回転 |
| レイヤー反転 | Vモード+H / Vモード+Shift+H | 水平・垂直 |

---

## 次のPhaseへの引き継ぎ

Phase 5完了後、以下の項目が将来的な改修候補となります：

### Phase 6候補: UI改善
- レイヤーアクティブ変更のキーボード操作復活（Tab/Shift+Tab等）
- キーカスタマイズUI（config.jsの値を画面から変更）
- ショートカット一覧の表示機能

### Phase 7候補: パフォーマンス最適化
- サムネイル生成の遅延最適化
- 大量CUT時のメモリ管理
- レンダリングパフォーマンス向上

---

**改修計画書 完**

改修時は本計画書を参照し、Phase順に実施してください。
各Phaseの完了時には必ずテスト項目をチェックし、次のPhaseに進んでください。