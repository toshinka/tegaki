概要（先に要点）

まず PixiJS（v8.13）本体を最初に読み込み、その後に各プラグインのブラウザバンドル（UMD）を読み込む順にします。多くのプラグインは jsDelivr / unpkg にブラウザ向けバンドルを置いています。
pixijs.io
+1

ただし プラグインごとに「ブラウザ用バンドル（dist/browser/*.min.js）」が用意されているか確認する必要があります。提供されていない場合は ESM/CJS しかなく、ブラウザ直読み（moduleなし）では使いにくいです。
GitHub
+1

file:// で直接開ける点：外部 CDN スクリプトを <script src="https://..."> で読み込むのは基本動作しますが、外部リソースの fetch（スプライトJSON・スpine データ等）や CORS を伴う操作はローカル file:// だと制約に当たる確率が高く、最終的には簡易ローカルサーバ（python -m http.server 等）を推奨します。
en.esotericsoftware.com

各プラグイン（導入可否・注意点・導入例）
1) PIXI-Spine（@pixi/spine-pixi / @pixi-spine/runtime-4.0）

可：Pixi v8 向けランタイム（Spine→Pixi のランタイム）は npm で配布されており、jsDelivr 等にブラウザ向けバンドルがあります。UMD/bundled が用意されている版を使えば <script> 読込で非モジュール環境でも利用可能。
jsDelivr
+1

注意：

Spine のバージョン（Spine editor で出力したデータのバージョン）とランタイムのバージョンを合わせる必要あり。
en.esotericsoftware.com

Spine のアセット（.json/.atlas/.png）読み込みは通常 Loader を使うため、file:// ではCORSやパス問題になりやすい。

Spineのエディタライセンスや商用条件は別途確認（ランタイム配布はあるが資産生成には Spine ツールのライセンスが関わる場合あり）。

導入例（CDN）（<script>順序: PIXI → pixi-spine）:

<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/browser/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@pixi/spine-pixi@<version>/dist/spine-pixi.umd.js"></script>
<script>
  // PIXI.Spine や PIXI.spine など、バンドルが提供する名前空間でアクセス
  // 例: const spine = new PIXI.spine.Spine(spineData);
</script>


（実際のパス/ファイル名は jsDelivr のパッケージページで確認してください）。
jsDelivr
+1

2) @pixi/graphics-smooth（描画品質向上）

多くは可：@pixi/graphics-smooth は Pixi 向けプラグインで、jsDelivr にブラウザ向けファイルが置かれていることが確認できます。UMD バンドルがあれば <script> 読込で使えます。
jsDelivr
+1

注意：

もともと v7 系のプラグインとして出ているものが多く、v8 での互換性や API 変化に注意（リリースノート/README を確認）。
GitHub

シェーダ・HHAA を使うので WebGL コンテキストやシェーダ制約（モバイル差）がある点に注意。

導入例:

<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/browser/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@pixi/graphics-smooth@<version>/dist/graphics-smooth.umd.js"></script>
<script>
  // 例えば new PIXI.SmoothGraphics() 等（実APIはREADME参照）
</script>


（バージョンとエクスポート名はパッケージの dist を確認してください）。
jsDelivr

3) PIXI-Tilemap（@pixi/tilemap / pixi-tilemap）

可否は要検討：古くからある pixi-tilemap 系は v3/v4 向けのものや、別実装のものが混在しています。最近は v8 対応の別パッケージ（例：@steel97/tilemap や @pixi/tilemap など）が出ているため、**「v8 対応の実装を選ぶ」**ことが重要です。jsDelivr にパッケージはありますが、パッケージごとにブラウザUMD があるか要確認です。
jsDelivr
+1

注意：

古い pixi-tilemap は v8 非対応の可能性がある（API 変更で動かない）。Issue や README を確認。
GitHub

タイル大量描画はレンダリング戦略（シングルバッチ / shader）を理解してから導入すること。

導入方針：まず v8 対応を明記しているパッケージを探し、ブラウザ向けバンドルがあるかを jsDelivr/unpkg で確認して <script> で追加。必要なら小さなサンプルで動作検証を行う。

4) PIXI-Filters（pixi-filters / @pixi/filter-blur, @pixi/filter-glow 等）

可（推奨）：公式系フィルターはブラウザバンドルを配布しており、CDN から直接読み込めます。ドキュメントでも CDN の <script src="https://cdn.jsdelivr.net/npm/pixi-filters@latest/dist/browser/pixi-filters.min.js"></script> の例が明記されています。個別の @pixi/filter-blur / @pixi/filter-glow も jsDelivr にあります。
pixijs.io
+1

使い方：

<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/browser/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi-filters@<version>/dist/browser/pixi-filters.min.js"></script>
<script>
  const blur = new PIXI.filters.BlurFilter();
  mySprite.filters = [blur];
</script>


注意：

フィルターは WebGL 演算負荷が高くなるため、アニメGIF のフレーム生成やサムネイル作成時はパフォーマンスを計測して使うこと。
pixijs.io

5) @pixi/compressed-textures（圧縮テクスチャ）

導入は可能だが「ちょっと複雑」：@pixi/compressed-textures（あるいは pixi-compressed-textures）自体は存在し、Pixi のロード側に統合する形式で配布されています。ただし 複数フォーマット（KTX, DDS, BASIS 等）や GPU サポートの差分、専用ローダーの登録など実装ステップが必要で、単に <script> 一行で完了することは少ないです。
PixiJS
+1

注意：

圧縮テクスチャは「作る側（ビルド時に変換）」と「ランタイムで対応するフォーマットを選ぶ」両方が必要。file:// 復元やテストもやや面倒（loader の設定やフォルダ構成）。
PixiJS

現実的運用：開発初期は未圧縮 PNG を使い、必要になった段階で圧縮パイプラインとロードコンフィグを導入する方が楽。

実務的なチェックリスト（導入前に必ず）

バージョン整合：PixiJS v8.13 とプラグインの対応バージョンを合わせる。互換性のドキュメント / README を確認。
PixiJS
+1

ブラウザバンドル（UMD）の有無：jsDelivr / unpkg で dist/browser や *.umd.js が存在するか確認。存在すれば <script> で使える。
pixijs.io
+1

読み込み順：pixi.js を最初、次にプラグイン、最後に自分のコード。

file:// の限界：ローカルで試すなら最終的に簡易ローカルサーバを用意するとトラブルが激減（アセット読み込み・CORS）。（※推奨だが、あなたが file:// 前提なら「小さいローカルサーバ」へ移行することを強く勧めます）。
en.esotericsoftware.com

実装サンプルで事前検証：導入前に最小サンプル（1 HTML）で plugin を読み込み、API がグローバルに出ているか（console.log(Object.keys(PIXI)) 等）を確認。

具体的な <script> テンプレ（Pixi v8.13 + フィルターの例）
<!doctype html>
<html>
<head><meta charset="utf-8"><title>pixi8 + filters test</title></head>
<body>
<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/browser/pixi.min.js"></script>
<!-- pixi-filters のブラウザバンドル -->
<script src="https://cdn.jsdelivr.net/npm/pixi-filters@latest/dist/browser/pixi-filters.min.js"></script>
<script>
  const app = new PIXI.Application({width:320, height:240});
  document.body.appendChild(app.view);
  const g = new PIXI.Graphics();
  g.beginFill(0xff0000).drawCircle(160,120,40).endFill();
  app.stage.addChild(g);
  const blur = new PIXI.filters.BlurFilter(4);
  g.filters = [blur];
</script>
</body>
</html>


（他プラグインも同様に PIXI の後に <script src="https://cdn.jsdelivr.net/..."> を追加すれば使えることが多いです）。
pixijs.io

最後に：あなたの開発ルールに合わせた実務アドバイス（短く）

AI が改修する前提なので、導入スクリプトは ui や system フォルダの HTML ヘッダ部にまとめ、明確なエクスポート名（例: PIXI.spine, PIXI.filters）の有無を README にメモしておくと AI が次に触るときに楽です。

まずは「pixi-filters」と「@pixi/spine-pixi（必要なら）」を最初に試すのがコスパ良いです。filters は即戦力で CDN バンドルが整っており、spine はアニメ最適化に有効（ただしアセット周りの運用設計が必要）。
pixijs.io
+1

圧縮テクスチャ・タイルマップは要検討フェーズ：必要になったときに導入（先に設計しておく）で十分。