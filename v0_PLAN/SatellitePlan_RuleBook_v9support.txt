# GIFå®Ÿè£…ã‚µãƒãƒ¼ãƒˆãƒ–ãƒƒã‚¯ - Claudeæ”¹ä¿®åŠ¹ç‡åŒ–ç‰ˆ
# SatellitePlan_RuleBook_v9 ã‚µãƒãƒ¼ãƒˆè³‡æ–™

## ğŸ¯ ã“ã®ã‚µãƒãƒ¼ãƒˆãƒ–ãƒƒã‚¯ã®ç›®çš„
- **å¾Œç¶šã®Claudeæ”¹ä¿®ä½œæ¥­ã‚’åŠ¹ç‡åŒ–**ã™ã‚‹ãŸã‚ã®å®Ÿè£…ã‚¬ã‚¤ãƒ‰
- **GIFæ©Ÿèƒ½å®Ÿè£…**ã«ç‰¹åŒ–ã—ãŸæŠ€è¡“æƒ…å ±ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæƒ…å ±ãƒ»æ³¨æ„ç‚¹ã®é›†ç´„
- **çµ±åˆHTMLãƒ•ã‚¡ã‚¤ãƒ«å†…å®Ÿè£…**ã§ã®å…·ä½“çš„ã‚³ãƒ¼ãƒ‰ä¾‹ã¨å®Ÿè£…æ‰‹é †
- **éç ´å£ŠåŒ– + GIFæ©Ÿèƒ½**ã®åŒæ™‚å®Ÿè£…ã«ãŠã‘ã‚‹æŠ€è¡“çš„èª²é¡Œã®è§£æ±ºç­–

---

## ğŸ“š å¿…é ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªæƒ…å ±ï¼ˆ2024å¹´12æœˆæœ€æ–°ï¼‰

### ç¢ºå®šãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ§‹æˆ
```html
<!-- åŸºç›¤ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆæ—¢å­˜ï¼‰ -->
<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.13.0/dist/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>

<!-- GIFç”Ÿæˆå°‚ç”¨ï¼ˆæ–°è¦è¿½åŠ å¿…é ˆï¼‰ -->
<script src="https://cdn.jsdelivr.net/npm/gif.js@1.0.0/dist/gif.min.js"></script>
```

### PixiJS v8.13 GIFæ©Ÿèƒ½ã®åˆ¶é™
**é‡è¦**: PixiJS v8.13å†…è”µã®GIFæ©Ÿèƒ½ã¯**èª­ã¿è¾¼ã¿ãƒ»å†ç”Ÿå°‚ç”¨**
```javascript
// âŒ PixiJSæ¨™æº–ã§ã¯ GIFä½œæˆä¸å¯
import { GifSprite } from 'pixi.js/gif'; // èª­ã¿è¾¼ã¿å°‚ç”¨

// âœ… GIFä½œæˆã«ã¯åˆ¥é€” gif.js ãŒå¿…é ˆ
const gif = new GIF({ quality: 10, workers: 2 });
```

### å°†æ¥æ¤œè¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆPhase3ä»¥é™ï¼‰
```html
<!-- ãƒ™ã‚¸ã‚¨æ›²ç·šå¼·åŒ–ç”¨ï¼ˆãƒ™ã‚¯ã‚¿ãƒ¼æ©Ÿèƒ½æ‹¡å¼µæ™‚ï¼‰ -->
<script src="https://cdn.jsdelivr.net/npm/bezier-js@6.1.4/lib/bezier.min.js"></script>
```

---

## ğŸ— GIFæ©Ÿèƒ½ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆå®Ÿè£…å¿…é ˆï¼‰

### ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
```javascript
// çµ±åˆHTMLå†…ã®JavaScriptéƒ¨åˆ†ã«è¿½åŠ 
const animationData = {
  id: 'animation_001',
  name: 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³1',
  cuts: [
    {
      id: 'cut_' + Date.now(),
      name: 'CUT1',
      duration: 0.5,                    // è¡¨ç¤ºæ™‚é–“ï¼ˆç§’ï¼‰
      layerStates: [                    // å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ä¿å­˜
        {
          layerId: 'layer_0',
          visible: true,
          opacity: 1.0,
          transform: { 
            x: 0, y: 0, 
            scale: 1.0, 
            rotation: 0,
            flipH: false, 
            flipV: false 
          }
        }
      ],
      thumbnail: null,                  // PIXI.RenderTextureï¼ˆé…å»¶ç”Ÿæˆï¼‰
      createdAt: Date.now(),
      updatedAt: Date.now()
    }
  ],
  settings: {
    fps: 12,                           // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ
    loop: true,                        // ãƒ«ãƒ¼ãƒ—å†ç”Ÿ
    exportWidth: 400,                  // GIFå‡ºåŠ›å¹…
    exportHeight: 400,                 // GIFå‡ºåŠ›é«˜ã•
    quality: 10                        // GIFå“è³ªï¼ˆ1-30, å°ã•ã„ã»ã©é«˜å“è³ªï¼‰
  },
  playback: {
    currentCutIndex: 0,
    state: 'stopped',                  // 'playing' | 'paused' | 'stopped'
    startTime: 0,
    isAnimationMode: false
  }
};
```

### CUTã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆç”¨è¨­å®š
```javascript
// ã‚µãƒ ãƒã‚¤ãƒ«è¨­å®š
const THUMBNAIL_CONFIG = {
  width: 64,
  height: 48,
  resolution: 1,
  backgroundColor: 0xFFFFEE,          // çµ±ä¸€èƒŒæ™¯è‰²
  generateDelay: 100,                 // ç”Ÿæˆé…å»¶ï¼ˆmsï¼‰
  maxConcurrent: 3                    // åŒæ™‚ç”Ÿæˆæ•°åˆ¶é™
};
```

---

## ğŸ¬ GIFæ©Ÿèƒ½å®Ÿè£…æ‰‹é †ï¼ˆæ®µéšçš„ï¼‰

### Phase1: åŸºæœ¬CUTç®¡ç†ï¼ˆæœ€å„ªå…ˆå®Ÿè£…ï¼‰

#### 1-A. AnimationManager ã‚¯ãƒ©ã‚¹
```javascript
// çµ±åˆHTMLå†…ã®JavaScriptéƒ¨åˆ†ã«è¿½åŠ 
class AnimationManager {
  constructor(coreEngine) {
    this.coreEngine = coreEngine;
    this.animationData = this.createDefaultAnimation();
    this.thumbnailQueue = new Set();
    this.isProcessingThumbnails = false;
  }
  
  createDefaultAnimation() {
    return {
      ...animationData, // ä¸Šè¨˜æ§‹é€ ã‚’ä½¿ç”¨
      cuts: []
    };
  }
  
  // CUTä½œæˆï¼ˆç¾åœ¨ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹ã‹ã‚‰ï¼‰
  createCutFromCurrentLayers() {
    const layerManager = this.coreEngine.getLayerManager();
    const layers = layerManager.layers;
    
    const layerStates = layers.map(layer => ({
      layerId: layer.layerData.id,
      visible: layer.layerData.visible,
      opacity: layer.layerData.opacity,
      transform: this.cloneTransform(layerManager.layerTransforms.get(layer.layerData.id))
    }));
    
    const cut = {
      id: 'cut_' + Date.now(),
      name: `CUT${this.animationData.cuts.length + 1}`,
      duration: 0.5,
      layerStates: layerStates,
      thumbnail: null,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    
    this.animationData.cuts.push(cut);
    this.requestThumbnailGeneration(this.animationData.cuts.length - 1);
    return cut;
  }
  
  // ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹å¾©å…ƒ
  applyCutToLayers(cutIndex) {
    const cut = this.animationData.cuts[cutIndex];
    if (!cut) return;
    
    const layerManager = this.coreEngine.getLayerManager();
    
    cut.layerStates.forEach(state => {
      const layer = layerManager.getLayerById(state.layerId);
      if (!layer) return;
      
      // è¡¨ç¤ºçŠ¶æ…‹é©ç”¨
      layer.layerData.visible = state.visible;
      layer.layerData.opacity = state.opacity;
      layer.visible = state.visible;
      layer.alpha = state.opacity;
      
      // å¤‰å½¢çŠ¶æ…‹é©ç”¨
      layerManager.layerTransforms.set(state.layerId, { ...state.transform });
      this.applyTransformToLayer(layer, state.transform);
    });
    
    layerManager.updateLayerPanelUI();
  }
}
```

#### 1-B. ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 
```javascript
// AnimationManagerå†…ã«è¿½åŠ 
requestThumbnailGeneration(cutIndex) {
  this.thumbnailQueue.add(cutIndex);
  if (!this.isProcessingThumbnails) {
    this.processThumbnailQueue();
  }
}

async processThumbnailQueue() {
  this.isProcessingThumbnails = true;
  
  for (const cutIndex of this.thumbnailQueue) {
    await this.generateCutThumbnail(cutIndex);
    // ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†å‰²ã§UIå¿œç­”æ€§ç¢ºä¿
    await new Promise(resolve => requestAnimationFrame(resolve));
  }
  
  this.thumbnailQueue.clear();
  this.isProcessingThumbnails = false;
}

async generateCutThumbnail(cutIndex) {
  const cut = this.animationData.cuts[cutIndex];
  if (!cut) return;
  
  // ç¾åœ¨çŠ¶æ…‹ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
  const originalStates = this.backupCurrentLayerStates();
  
  // CUTçŠ¶æ…‹ã‚’ä¸€æ™‚é©ç”¨
  this.applyCutToLayers(cutIndex);
  
  // RenderTextureä½œæˆ
  const renderTexture = PIXI.RenderTexture.create({
    width: THUMBNAIL_CONFIG.width,
    height: THUMBNAIL_CONFIG.height,
    resolution: THUMBNAIL_CONFIG.resolution
  });
  
  // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  const layerManager = this.coreEngine.getLayerManager();
  this.coreEngine.app.renderer.render(layerManager.layersContainer, {
    renderTexture: renderTexture
  });
  
  // ã‚µãƒ ãƒã‚¤ãƒ«ä¿å­˜
  cut.thumbnail = renderTexture;
  cut.updatedAt = Date.now();
  
  // å…ƒçŠ¶æ…‹å¾©å…ƒ
  this.restoreLayerStates(originalStates);
  
  // UIæ›´æ–°é€šçŸ¥
  this.notifyThumbnailUpdated(cutIndex);
}
```

### Phase2: ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ UIå®Ÿè£…

#### 2-A. HTMLæ§‹é€ è¿½åŠ 
```html
<!-- çµ±åˆHTMLå†…ã«è¿½åŠ  -->
<div class="tool-button" id="animation-tool" title="GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (ALT+A)">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#800000" stroke-width="1.5">
    <rect width="18" height="18" x="3" y="3" rx="2"/>
    <path d="M7 3v18"/><path d="M3 7.5h4"/>
    <path d="M3 12h18"/><path d="M3 16.5h4"/>
    <path d="M17 3v18"/><path d="M17 7.5h4"/>
    <path d="M17 16.5h4"/>
  </svg>
</div>

<div class="timeline-panel" id="timeline-panel">
  <div class="timeline-header">
    <h3>GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³</h3>
    <button class="close-timeline-btn" id="close-timeline-btn">Ã—</button>
  </div>
  
  <div class="playback-controls">
    <button id="prev-cut-btn" title="å‰CUT (ALT+â†)">â—€</button>
    <button id="play-pause-btn" title="å†ç”Ÿ/åœæ­¢ (ALT+Space)">â¯</button>
    <button id="next-cut-btn" title="æ¬¡CUT (ALT+â†’)">â–¶</button>
    <button id="loop-btn" title="ãƒ«ãƒ¼ãƒ— (ALT+L)">ğŸ”„</button>
    <span class="current-time">00:00.0</span> / <span class="total-time">00:01.2</span>
  </div>
  
  <div class="timeline-settings">
    <label>FPS: <input type="number" id="animation-fps" min="1" max="60" value="12"></label>
    <label>å“è³ª: <input type="range" id="gif-quality" min="1" max="30" value="10"></label>
  </div>
  
  <div class="cuts-container">
    <div class="cuts-list" id="cuts-list"></div>
    <button class="add-cut-btn" id="add-cut-btn">[+ CUTè¿½åŠ ]</button>
  </div>
  
  <div class="export-controls">
    <button class="export-gif-btn" id="export-gif-btn">GIFæ›¸ãå‡ºã—</button>
    <div class="export-progress" id="export-progress" style="display:none;">
      <div class="progress-bar"><div class="progress-fill"></div></div>
      <span class="progress-text">0%</span>
    </div>
  </div>
</div>
```

#### 2-B. CSS ã‚¹ã‚¿ã‚¤ãƒ«è¿½åŠ 
```css
/* çµ±åˆHTMLå†…ã®styleè¦ç´ ã«è¿½åŠ  */
.timeline-panel {
  position: fixed;
  bottom: 80px;
  left: 70px;
  right: 220px;
  background: var(--futaba-cream);
  border: 2px solid var(--futaba-maroon);
  border-radius: 12px;
  padding: 16px;
  z-index: 1500;
  display: none;
  max-height: 300px;
  overflow-y: auto;
}

.timeline-panel.show { display: block; animation: slideUp 0.3s ease-out; }

@keyframes slideUp {
  from { opacity: 0; transform: translateY(20px); }
  to   { opacity: 1; transform: translateY(0); }
}

.timeline-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  border-bottom: 1px solid var(--futaba-light-medium);
  padding-bottom: 8px;
}

.playback-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  padding: 8px;
  background: var(--futaba-background);
  border-radius: 6px;
}

.playback-controls button {
  padding: 4px 8px;
  border: 1px solid var(--futaba-medium);
  border-radius: 4px;
  background: var(--futaba-background);
  cursor: pointer;
  font-size: 12px;
}

.cuts-container {
  display: flex;
  align-items: center;
  gap: 8px;
  overflow-x: auto;
  padding: 8px 0;
}

.cuts-list {
  display: flex;
  gap: 4px;
  min-height: 60px;
}

.cut-item {
  min-width: 80px;
  background: var(--futaba-background);
  border: 2px solid var(--futaba-light-medium);
  border-radius: 6px;
  padding: 4px;
  cursor: pointer;
  position: relative;
}

.cut-item.active {
  border-color: var(--futaba-maroon);
  background: var(--futaba-light-medium);
}

.cut-thumbnail {
  width: 64px;
  height: 48px;
  background: var(--futaba-background);
  border: 1px solid var(--futaba-light-medium);
  border-radius: 3px;
  margin-bottom: 4px;
  overflow: hidden;
}

.cut-name {
  font-size: 10px;
  text-align: center;
  color: var(--text-primary);
}

.cut-duration {
  width: 40px;
  font-size: 9px;
  text-align: center;
  border: 1px solid var(--futaba-light-medium);
  border-radius: 2px;
  margin-top: 2px;
}

.export-controls {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--futaba-light-medium);
}

.export-gif-btn {
  padding: 8px 16px;
  background: var(--futaba-maroon);
  color: var(--text-inverse);
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: bold;
}

.export-progress {
  margin-top: 8px;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: var(--futaba-light-medium);
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--futaba-maroon);
  width: 0%;
  transition: width 0.2s ease;
}
```

### Phase3: GIFæ›¸ãå‡ºã—å®Ÿè£…

#### 3-A. GIFExporter ã‚¯ãƒ©ã‚¹
```javascript
// çµ±åˆHTMLå†…ã®JavaScriptéƒ¨åˆ†ã«è¿½åŠ 
class GIFExporter {
  constructor(animationManager) {
    this.animationManager = animationManager;
    this.isExporting = false;
  }
  
  async exportGIF() {
    if (this.isExporting) return;
    this.isExporting = true;
    
    const animation = this.animationManager.animationData;
    const settings = animation.settings;
    
    // GIF.js åˆæœŸåŒ–
    const gif = new GIF({
      workers: 2,
      quality: settings.quality,
      width: settings.exportWidth,
      height: settings.exportHeight,
      transparent: null,
      background: '#FFFFEE'  // èƒŒæ™¯è‰²
    });
    
    try {
      // é€²æ—è¡¨ç¤ºé–‹å§‹
      this.showProgress(0);
      
      // å„CUTã‚’ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ã—ã¦è¿½åŠ 
      for (let i = 0; i < animation.cuts.length; i++) {
        const cut = animation.cuts[i];
        
        // é«˜è§£åƒåº¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
        const canvas = await this.renderCutToCanvas(cut, {
          width: settings.exportWidth,
          height: settings.exportHeight,
          resolution: 2  // é«˜è§£åƒåº¦
        });
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ è¿½åŠ 
        gif.addFrame(canvas, {
          delay: cut.duration * 1000  // ãƒŸãƒªç§’å¤‰æ›
        });
        
        // é€²æ—æ›´æ–°
        this.updateProgress((i + 1) / animation.cuts.length * 50);
      }
      
      // GIFç”Ÿæˆé–‹å§‹
      gif.on('progress', (progress) => {
        this.updateProgress(50 + progress * 50);
      });
      
      gif.on('finished', (blob) => {
        this.downloadGIF(blob, animation.name);
        this.hideProgress();
        this.isExporting = false;
      });
      
      gif.render();
      
    } catch (error) {
      console.error('GIF export failed:', error);
      this.hideProgress();
      this.isExporting = false;
      alert('GIFæ›¸ãå‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
    }
  }
  
  async renderCutToCanvas(cut, options) {
    // ç¾åœ¨çŠ¶æ…‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    const originalStates = this.animationManager.backupCurrentLayerStates();
    
    // CUTçŠ¶æ…‹é©ç”¨
    this.animationManager.applyCutToLayers(
      this.animationManager.animationData.cuts.indexOf(cut)
    );
    
    // é«˜è§£åƒåº¦RenderTextureä½œæˆ
    const renderTexture = PIXI.RenderTexture.create({
      width: options.width,
      height: options.height,
      resolution: options.resolution
    });
    
    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    const layerManager = this.animationManager.coreEngine.getLayerManager();
    this.animationManager.coreEngine.app.renderer.render(
      layerManager.layersContainer, 
      { renderTexture: renderTexture }
    );
    
    // CanvasæŠ½å‡º
    const canvas = this.animationManager.coreEngine.app.renderer.extract.canvas(renderTexture);
    
    // ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
    renderTexture.destroy();
    
    // çŠ¶æ…‹å¾©å…ƒ
    this.animationManager.restoreLayerStates(originalStates);
    
    return canvas;
  }
  
  downloadGIF(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = (filename || 'animation') + '.gif';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  showProgress(percent) {
    const progressEl = document.getElementById('export-progress');
    const fillEl = progressEl.querySelector('.progress-fill');
    const textEl = progressEl.querySelector('.progress-text');
    
    progressEl.style.display = 'block';
    fillEl.style.width = percent + '%';
    textEl.textContent = Math.round(percent) + '%';
  }
  
  updateProgress(percent) {
    this.showProgress(Math.min(percent, 100));
  }
  
  hideProgress() {
    const progressEl = document.getElementById('export-progress');
    progressEl.style.display = 'none';
  }
}
```

---

## ğŸš¨ å®Ÿè£…æ™‚ã®é‡è¦æ³¨æ„ç‚¹

### 1. ãƒ¡ãƒ¢ãƒªç®¡ç†ï¼ˆå¿…é ˆå¯¾å¿œï¼‰
```javascript
// RenderTextureé©åˆ‡ãªç ´æ£„
function destroyCutThumbnails(cuts) {
  cuts.forEach(cut => {
    if (cut.thumbnail) {
      cut.thumbnail.destroy(true);  // baseTextureå«ã‚€å®Œå…¨ç ´æ£„
      cut.thumbnail = null;
    }
  });
}

// GIFæ›¸ãå‡ºã—æ™‚ã®ãƒ¡ãƒ¢ãƒªç›£è¦–
class MemoryManager {
  static checkMemoryUsage() {
    if (performance.memory) {
      const used = performance.memory.usedJSHeapSize / 1048576; // MB
      if (used > 512) { // 512MBè¶…éã§è­¦å‘Š
        console.warn('High memory usage:', Math.round(used) + 'MB');
        return false;
      }
    }
    return true;
  }
}
```

### 2. éç ´å£ŠåŒ–ã¨ã®é€£æº
```javascript
// CUTä½œæˆæ™‚ã¯éç ´å£ŠçŠ¶æ…‹ã§ä¿å­˜
createCutFromCurrentLayers() {
  // å¤‰å½¢ç¢ºå®šå‰ã®çŠ¶æ…‹ã§ä¿å­˜ï¼ˆé‡è¦ï¼‰
  const layerManager = this.coreEngine.getLayerManager();
  
  // æœªç¢ºå®šã®å¤‰å½¢ãŒã‚ã‚‹å ´åˆã¯ä¸€æ™‚ç¢ºå®š
  const hasUncommittedTransforms = layerManager.hasUncommittedTransforms();
  if (hasUncommittedTransforms) {
    // éç ´å£Šçš„ç¢ºå®šå®Ÿè¡Œ
    layerManager.confirmLayerTransform(false); // éç ´å£Šãƒ•ãƒ©ã‚°
  }
  
  // ã“ã®çŠ¶æ…‹ã§CUTä¿å­˜
  return this.captureCutData();
}
```

### 3. ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚­ãƒ¼å®Ÿè£…
```javascript
// çµ±åˆHTMLå†…ã«è¿½åŠ 
document.addEventListener('keydown', (e) => {
  if (!animationManager.animationData.playback.isAnimationMode) return;
  
  if (e.altKey && !e.ctrlKey && !e.metaKey) {
    switch(e.key) {
      case 'a': case 'A':
        toggleAnimationMode();
        e.preventDefault();
        break;
      case ' ':
        playPauseAnimation();
        e.preventDefault();
        break;
      case 'ArrowLeft':
        goToPreviousCut();
        e.preventDefault();
        break;
      case 'ArrowRight':
        goToNextCut();
        e.preventDefault();
        break;
      case 'l': case 'L':
        toggleLoop();
        e.preventDefault();
        break;
    }
  }
});
```

---

## ğŸ”§ PixiJS v8.13 æœ€é©åŒ–æ´»ç”¨

### æ¨™æº–æ©Ÿèƒ½ã®æ´»ç”¨
```javascript
// 1. Culling APIã§ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æœ€é©åŒ–
timelineContainer.cullable = true;
timelineContainer.cullArea = new PIXI.Rectangle(0, 0, viewWidth, viewHeight);

// 2. Deprecationè­¦å‘Šåˆ¶å¾¡ï¼ˆé–‹ç™ºæ™‚ï¼‰
PIXI.settings.DEPRECATION_WARNINGS = false;

// 3. ãƒ†ã‚­ã‚¹ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã§UIé«˜é€ŸåŒ–
const cutNameStyle = new PIXI.TextStyle({
  fontFamily: 'monospace',
  fontSize: 10,
  fill: 0x2c1810
}); // åŒã˜ã‚¹ã‚¿ã‚¤ãƒ«ä½¿ã„å›ã—
```

---

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™ãƒ»åˆ¶é™

### æ¨å¥¨åˆ¶é™å€¤
```javascript
const PERFORMANCE_LIMITS = {
  maxCuts: 50,              // CUTæ•°ä¸Šé™
  maxThumbnailConcurrent: 3, // åŒæ™‚ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆæ•°
  thumbnailCacheSize: 20,   // ã‚µãƒ ãƒã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ•°
  exportTimeoutMs: 300000,  // æ›¸ãå‡ºã—ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ5åˆ†ï¼‰
  memoryLimitMB: 512        // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ä¸Šé™
};
```

### å“è³ª vs ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ãƒãƒ©ãƒ³ã‚¹
```javascript
// GIFå“è³ªè¨­å®šï¼ˆå‚è€ƒå€¤ï¼‰
const GIF_QUALITY_PRESETS = {
  draft: { quality: 20, resolution: 1 },      // ä¸‹æ›¸ãç”¨
  normal: { quality: 10, resolution: 1 },     // é€šå¸¸
  high: { quality: 5, resolution: 1.5 },     // é«˜å“è³ª
  ultra: { quality: 1, resolution: 2 }       // æœ€é«˜å“è³ªï¼ˆé‡ã„ï¼‰
};
```

---

## ğŸ› ã‚ˆãã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã¨å¯¾å‡¦æ³•

### 1. ãƒ¡ãƒ¢ãƒªä¸è¶³ã‚¨ãƒ©ãƒ¼
```javascript
// å¯¾å‡¦: æ®µéšçš„ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
if (!MemoryManager.checkMemoryUsage()) {
  // ä¸è¦ãªã‚µãƒ ãƒã‚¤ãƒ«ç ´æ£„
  this.cleanupOldThumbnails();
  
  // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ä¿ƒé€²
  if (window.gc) window.gc();
  
  // è§£åƒåº¦ã‚’ä¸‹ã’ã¦å†è©¦è¡Œ
  options.resolution = Math.max(0.5, options.resolution * 0.8);
}
```

### 2. GIFç”ŸæˆãŒçµ‚ã‚ã‚‰ãªã„
```javascript
// å¯¾å‡¦: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
const exportTimeout = setTimeout(() => {
  gif.abort();
  this.hideProgress();
  this.isExporting = false;
  alert('æ›¸ãå‡ºã—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ');
}, PERFORMANCE_LIMITS.exportTimeoutMs);

gif.on('finished', (blob) => {
  clearTimeout(exportTimeout);
  // é€šå¸¸å‡¦ç†...
});
```

### 3. ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆå¤±æ•—
```javascript
// å¯¾å‡¦: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
async generateCutThumbnail(cutIndex) {
  try {
    // é€šå¸¸å‡¦ç†
    return await this.normalThumbnailGeneration(cutIndex);
  } catch (error) {
    console.warn('Thumbnail generation failed:', error);
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ç©ºã®ã‚µãƒ ãƒã‚¤ãƒ«ä½œæˆ
    return this.createPlaceholderThumbnail();
  }
}
```

---

## ğŸ¯ å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆï¼ˆClaudeç”¨ï¼‰

### å¿…é ˆå®Ÿè£…é …ç›®
- [ ] AnimationManager ã‚¯ãƒ©ã‚¹å®Ÿè£…å®Œäº†
- [ ] CUTä½œæˆãƒ»å‰Šé™¤ãƒ»ä¸¦ã³æ›¿ãˆæ©Ÿèƒ½å‹•ä½œ
- [ ] ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ å‹•ä½œ
- [ ] ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³UIè¡¨ç¤ºãƒ»éè¡¨ç¤ºæ­£å¸¸
- [ ] GIFæ›¸ãå‡ºã—åŸºæœ¬æ©Ÿèƒ½å‹•ä½œ

### å“è³ªç¢ºèªé …ç›®
- [ ] ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ç™ºç”Ÿãªã—
- [ ] 50CUTä½œæˆã§ã‚‚å‹•ä½œå®‰å®š
- [ ] GIFæ›¸ãå‡ºã—æ™‚é–“ãŒè¨±å®¹ç¯„å›²å†…
- [ ] éç ´å£ŠåŒ–æ©Ÿèƒ½ã¨ã®ç«¶åˆãªã—
- [ ] ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚­ãƒ¼å…¨ã¦å‹•ä½œ

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç¢ºèªé …ç›®
- [ ] ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆã§UIå¿œç­”æ€§ç¶­æŒ
- [ ] ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ“ä½œ60fpsç¶­æŒ
- [ ] å¤§é‡CUTæ™‚ã‚‚ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ»‘ã‚‰ã‹
- [ ] ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒåˆ¶é™å†…
- [ ] GIFæ›¸ãå‡ºã—é€²æ—è¡¨ç¤ºæ­£å¸¸

ã“ã®ã‚µãƒãƒ¼ãƒˆãƒ–ãƒƒã‚¯ã«ã‚ˆã‚Šã€å¾Œç¶šã®Claudeæ”¹ä¿®ä½œæ¥­ãŒåŠ¹ç‡åŒ–ã•ã‚Œã€GIFæ©Ÿèƒ½ã®ç¢ºå®Ÿãªå®Ÿè£…ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚