# 改修計画書v2：CUT独立性とサムネイル反映の明確化

## 現状の問題分析

### 根本原因
1. **AnimationSystemとLayerSystemの責務が不明確**
   - AnimationSystemがCUT管理とLayer管理を両方持っている
   - LayerSystemがグローバルlayers配列を持ち、AnimationSystemと二重管理
   - 描画時にどちらに保存されるか不明確

2. **サムネイル生成フローが複雑**
   - AnimationSystemが独自にサムネイル生成
   - LayerSystemも独自にサムネイル生成
   - どちらが優先されるか不明確

3. **肥大化したコード**
   - 防御的プログラミングによる過剰なtry-catch
   - 使われていないconsole.log
   - 重複したエラーハンドリング

---

## 改修方針：シンプル化と責務の明確化

### 設計原則
```
描画 → LayerSystem（現在のCUTのLayerを更新）
     ↓
     AnimationSystem.saveCutLayerStates()（CUTにスナップショット保存）
     ↓
     AnimationSystem.generateCutThumbnailOptimized()（サムネイル生成）
     ↓
     TimelineUI（サムネイル表示）
```

### 責務分離
| システム | 責務 | 持つデータ |
|---------|------|-----------|
| **AnimationSystem** | CUT管理・保存・サムネイル生成 | `cuts[]` - CUT毎のLayerスナップショット |
| **LayerSystem** | 現在アクティブなCUTのLayer操作のみ | `layers[]` - 現在のCUTのPixi.Container |
| **TimelineUI** | サムネイル表示・CUT切替UI | なし（AnimationSystemから取得） |

---

## ファイル別改修内容

### ① AnimationSystem - CUT管理とサムネイル生成の中核

**役割:** CUT管理・Layerスナップショット保存・サムネイル生成

**データ構造（簡潔版）:**
```javascript
animationData = {
  cuts: [
    {
      id: 'cut_xxx',
      name: 'CUT1',
      duration: 0.5,
      layers: [LayerData, ...],  // スナップショット
      thumbnailCanvas: Canvas    // サムネイル
    }
  ],
  playback: {
    currentCutIndex: 0
  }
}
```

**主要API（削減版）:**
```javascript
// CUT管理
createNewEmptyCut()              // 新規空CUT作成
getCurrentCut()                   // 現在のCUT取得
switchToActiveCutSafely(index)    // CUT切替

// スナップショット保存
saveCutLayerStates()              // LayerSystemから現在状態を保存

// サムネイル生成（これだけ！）
generateCutThumbnailOptimized(cutIndex)  // サムネイル生成
```

**削除するもの:**
- 複雑なエラーハンドリング（throw error除く）
- 詳細なconsole.log（エラー以外）
- 未使用のコメント
- temporarilyApplyCutState等の複雑な処理

**簡潔化ポイント:**
```javascript
// ❌ 削除: 過剰な防御
if (!cut || !cut.layers || !Array.isArray(cut.layers)) {
  console.warn('Invalid cut data');
  return null;
}

// ✅ 簡潔に
if (!cut?.layers) return null;
```

---

### ② LayerSystem - 現在CUTのLayer操作のみ

**役割:** 現在アクティブなCUTのLayer操作・描画

**データ構造（最小限）:**
```javascript
layers: []              // 現在のCUTのPixi.Container配列
layerTransforms: Map    // Transform情報
```

**主要API（削減版）:**
```javascript
// Layer操作
createLayer(name)                // Layer作成
getActiveLayer()                 // アクティブLayer取得
addPathToActiveLayer(path)       // 描画追加 → saveCutLayerStates()呼び出し

// CUT切替時の同期
syncFromAnimationSystem()        // AnimationSystemからLayer再構築
```

**削除するもの:**
- グローバルlayers配列の複雑な管理
- 独自のサムネイル生成（AnimationSystemに一本化）
- 過剰なエラーハンドリング
- 未使用のconsole.log

**簡潔化ポイント:**
```javascript
// ❌ 削除: LayerSystemでのサムネイル生成
updateThumbnail(layerIndex) { ... }  // 削除

// ✅ 簡潔に: 描画時にAnimationSystemへ通知のみ
addPathToActiveLayer(path) {
  layer.layerData.paths.push(path);
  layer.addChild(path.graphics);
  
  // AnimationSystemへ保存とサムネイル生成を依頼
  this.animationSystem?.saveCutLayerStates();
  this.animationSystem?.generateCutThumbnailOptimized(this.animationSystem.getCurrentCutIndex());
}
```

---

### ③ TimelineUI - サムネイル表示のみ

**役割:** サムネイル表示・CUT切替UI

**主要API（削減版）:**
```javascript
updateCutsList()                  // CUT一覧更新
updateSingleCutThumbnail(index)  // 単一サムネイル更新
```

**削除するもの:**
- refreshAllCutThumbnails()（AnimationSystemが生成するので不要）
- applyCutThumbnailAspectRatio()の複雑な計算（CSS固定値化）
- 過剰なエラーハンドリング

**簡潔化ポイント:**
```javascript
// ✅ サムネイル表示は単純に
updateSingleCutThumbnail(cutIndex) {
  const cut = this.animationSystem.animationData.cuts[cutIndex];
  if (!cut?.thumbnailCanvas) return;
  
  const thumbnail = this.cutsContainer.querySelector(`[data-cut-index="${cutIndex}"] .cut-thumbnail`);
  if (!thumbnail) return;
  
  thumbnail.innerHTML = `<img src="${cut.thumbnailCanvas.toDataURL()}" />`;
}
```

---

## フロー図

### 描画時のフロー
```
1. ユーザー描画
   ↓
2. DrawingClipboard → LayerSystem.addPathToActiveLayer(path)
   ↓
3. LayerSystem: layer.paths.push(path) + layer.addChild(graphics)
   ↓
4. AnimationSystem.saveCutLayerStates()
   ↓
5. AnimationSystem.generateCutThumbnailOptimized(cutIndex)
   ↓
6. EventBus.emit('animation:thumbnail-generated', {cutIndex})
   ↓
7. TimelineUI.updateSingleCutThumbnail(cutIndex)
```

### CUT切替時のフロー
```
1. TimelineUI: ユーザーがCUTクリック
   ↓
2. AnimationSystem.switchToActiveCutSafely(index)
   ↓
3. AnimationSystem.saveCutLayerStatesBeforeSwitch()（現在CUTを保存）
   ↓
4. LayerSystem.syncFromAnimationSystem()（新CUTのLayerを再構築）
   ↓
5. EventBus.emit('animation:cut-applied', {cutIndex})
   ↓
6. TimelineUI: アクティブ表示更新
```

### 新規CUT作成時のフロー
```
1. TimelineUI: +CUTボタン
   ↓
2. AnimationSystem.createNewEmptyCut()
   ↓
3. AnimationSystem.switchToActiveCutSafely(newIndex)（自動アクティブ化）
   ↓
4. LayerSystem.createLayer('背景', true)
   LayerSystem.createLayer('レイヤー1', false)
   ↓
5. AnimationSystem.saveCutLayerStates()
   ↓
6. AnimationSystem.generateCutThumbnailOptimized(newIndex)
   ↓
7. TimelineUI.updateCutsList()
```

---

## API辞典（簡潔版）

### AnimationSystem
```javascript
// CUT管理
createNewEmptyCut()                      // 新規空CUT作成 → 自動アクティブ化
getCurrentCut()                          // 現在のCUT取得
getCurrentCutIndex()                     // 現在のCUTインデックス
switchToActiveCutSafely(cutIndex)        // CUT切替

// スナップショット保存
saveCutLayerStates()                     // LayerSystemから現在状態を保存
saveCutLayerStatesBeforeSwitch()         // 切替前の保存

// サムネイル生成
generateCutThumbnailOptimized(cutIndex)  // サムネイル生成 → EventBus通知

// Layer管理（最小限）
addLayerToCurrentCut(layerData)          // Layer追加
updateCurrentCutLayer(layerIndex, data)  // Layer更新
```

### LayerSystem
```javascript
// Layer操作
createLayer(name, isBackground)          // Layer作成
getActiveLayer()                         // アクティブLayer取得
addPathToActiveLayer(path)               // 描画追加 → AnimationSystem通知

// CUT同期
syncFromAnimationSystem()                // AnimationSystemからLayer再構築

// UI更新
updateLayerPanelUI()                     // レイヤーパネル更新
```

### TimelineUI
```javascript
// UI更新
updateCutsList()                         // CUT一覧更新
updateSingleCutThumbnail(cutIndex)       // 単一サムネイル更新
setActiveCut(cutIndex)                   // アクティブ表示更新
```

---

## コード簡潔化ルール

### 削除対象
1. **過剰なtry-catch**
   ```javascript
   // ❌ 削除
   try {
     doSomething();
   } catch (error) {
     console.warn('Error:', error);
     return null;
   }
   
   // ✅ 簡潔に
   doSomething();
   ```

2. **詳細なconsole.log**
   ```javascript
   // ❌ 削除
   console.log('✅ AnimationSystem: 確実な同期化改修版 初期化完了');
   console.log('  - ✅ Canvas直接保存・完全2次元マトリクス維持');
   
   // ✅ エラー時のみ
   console.error('AnimationSystem init failed:', error);
   ```

3. **未使用のコメント**
   ```javascript
   // ❌ 削除
   // 【改修完了】描画→保存→サムネイル生成の確実な同期化
   // 【改修完了】requestAnimationFrameによる即時同期
   
   // ✅ 必要最小限のみ
   // CUT切替時のLayer再構築
   ```

4. **冗長な条件分岐**
   ```javascript
   // ❌ 削除
   if (data && typeof data === 'object' && data !== null && Array.isArray(data.items)) {
   
   // ✅ 簡潔に
   if (data?.items) {
   ```

### 残すもの
- 必須のエラー処理（throw error）
- APIの引数チェック（公開メソッドのみ）
- 重要な状態変更のEventBus通知

---

## 実装優先順位

### Phase 1: AnimationSystem簡潔化（最優先）
**目的:** サムネイル生成の中核を明確化

**作業内容:**
1. 過剰なconsole.log削除
2. try-catch簡潔化
3. `generateCutThumbnailOptimized()`の簡潔化
4. 未使用メソッド削除

**成功条件:**
- `generateCutThumbnailOptimized()`が100行以内
- サムネイル生成が確実に動作

---

### Phase 2: LayerSystem簡潔化
**目的:** 現在CUTのLayer操作のみに特化

**作業内容:**
1. 独自サムネイル生成削除（AnimationSystemに一本化）
2. `syncFromAnimationSystem()`実装
3. `addPathToActiveLayer()`でAnimationSystem連携
4. 過剰なエラーハンドリング削除

**成功条件:**
- `addPathToActiveLayer()`からAnimationSystemへ確実に通知
- CUT切替時にLayerが正しく再構築

---

### Phase 3: TimelineUI簡潔化
**目的:** サムネイル表示のみに特化

**作業内容:**
1. サムネイル生成処理削除（表示のみ）
2. CSS固定値化でJavaScript計算削減
3. イベントリスナー整理

**成功条件:**
- サムネイルが即座に表示
- CUT切替がスムーズ

---

## テストケース（簡潔版）

```javascript
// ✅ Test 1: 描画 → サムネイル反映
// 1. CUT1でペン描画
// 2. タイムラインのCUT1サムネイルに即反映されること

// ✅ Test 2: CUT独立性
// 1. CUT1に赤で描画
// 2. +CUTで新規CUT2作成
// 3. CUT2に青で描画
// 4. CUT1に戻る → 赤のみ表示されること

// ✅ Test 3: 新規CUT自動アクティブ化
// 1. +CUTボタン押下
// 2. 新CUTが即アクティブになること
// 3. レイヤーパネルに「CUT2」表示されること

// ✅ Test 4: キャンバスサイズ変更
// 1. キャンバスを800x600から1000x750に変更
// 2. タイムラインの全サムネイルが新比率で表示されること
```

---

## 改修時の注意点

### 🚫 禁止事項
1. **フォールバック追加禁止** - エラー時はエラーにする
2. **防御的プログラミング禁止** - 過剰なチェック不要
3. **console.log乱用禁止** - エラー時のみ
4. **コメント冗長化禁止** - 最小限のみ

### ✅ 推奨事項
1. **シンプルなエラー処理** - 早期return
2. **明確な責務分離** - 各ファイルの役割を守る
3. **EventBus活用** - システム間連携はイベント経由
4. **Null安全演算子活用** - `obj?.prop`

---

## 改修後の期待される状態

### コード行数削減目標
- AnimationSystem: 1500行 → **800行**
- LayerSystem: 1200行 → **600行**
- TimelineUI: 800行 → **500行**

### 動作確認項目
1. ✅ 描画 → サムネイル即反映
2. ✅ CUT独立性確保
3. ✅ 新規CUT自動アクティブ化
4. ✅ キャンバスサイズ変更の全CUT反映
5. ✅ CUT切替のスムーズな動作

---

## まとめ

**改修の核心:**
1. **AnimationSystem**: CUT管理とサムネイル生成の唯一の責任者
2. **LayerSystem**: 現在CUTのLayer操作のみ、AnimationSystemへ通知
3. **TimelineUI**: サムネイル表示のみ、生成はしない

**実装順序:**
1. AnimationSystem簡潔化（サムネイル生成を確実に）
2. LayerSystem簡潔化（AnimationSystem連携を確実に）
3. TimelineUI簡潔化（表示のみに特化）

この計画書に従えば、**シンプルで見通しの良いコード**になり、**CUT独立性とサムネイル反映が確実に動作**します。