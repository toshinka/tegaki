🔍 現状分析結果
✅ 完了している改修

Canvas直接保存: animation-system.jsでcut.thumbnailCanvasにCanvas形式で保存
Texture往復排除: generateLayerCompositeCanvasOptimized()でCanvas直接生成
キャンバス比率計算: applyCutThumbnailAspectRatio()で動的調整

❌ 残存する問題
1. サムネイルの更新タイミング問題

CUTを増やした時のみ反映されるのは、generateCutThumbnailOptimized()の呼び出しが非同期で、描画完了を待たずに実行されているため
レイヤーパネルのサムネイルは同期的に即座更新される一方、CUTサムネイルは非同期で遅延発生

2. CUT独立性の不完全な実装

AnimationSystem側は完全独立(cutLayerStates Map)
しかしLayerSystem側の自動保存タイミングが不適切で、描画完了時に即座保存されていない

3. 初期CUT作成タイミングの問題

ensureInitialCut()がcreateNewCutFromCurrentLayers()を呼ぶが、この時点でレイヤーが空の場合がある

🎯 改修計画
優先度A：描画→保存→サムネイル生成の同期化

// layer-system.js側での即時保存強化
addPathToActiveLayer(path) {
    // パス追加後、即座にAnimationSystemへ通知
    this.addPathToLayer(this.activeLayerIndex, path);
    
    if (this.animationSystem) {
        // 描画完了後、即座に保存
        requestAnimationFrame(() => {
            this.animationSystem.saveCutLayerStates();
        });
    }
}

優先度B：サムネイル生成の確実性向上

// animation-system.js
async generateCutThumbnailOptimized(cutIndex) {
    // Canvas生成前にレンダラーの完了を確実に待つ
    await this.app.renderer.render(this.layerSystem.layersContainer);
    
    const thumbnailCanvas = await this.generateLayerCompositeCanvasOptimized();
    // ...
}

優先度C：初期CUT作成の改善

// timeline-ui.js
ensureInitialCut() {
    const animData = this.animationSystem.getAnimationData();
    if (animData.cuts.length === 0) {
        // レイヤーが存在する場合のみCUT作成
        if (this.animationSystem.layerSystem?.layers?.length > 0) {
            this.animationSystem.createNewCutFromCurrentLayers();
        } else {
            // レイヤーが無い場合は空CUT作成
            this.animationSystem.createNewBlankCut();
        }
    }
    this.updateLayerPanelIndicator();
}

以下の順序で進めます：

1.system/layer-system.js - AnimationSystem同期強化
2.system/animation-system.js - サムネイル生成の確実性向上
3.ui/timeline-ui.js - 初期CUT作成改善

