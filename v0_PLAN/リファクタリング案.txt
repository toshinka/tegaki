🎯 非破壊変形の実装に相性の良い仕組み
1. Transform 記録方式

PIXI.Container.transform / position / rotation / scale / skew を数値で保持

描画は常に「元画像テクスチャ」をベースにして transform を適用

記憶系として「変形プロパティ履歴」を持つ

// 例: レイヤーの変形状態を保存
layerState = {
  x: 100,
  y: 200,
  rotation: Math.PI / 6,
  scaleX: 1.5,
  scaleY: 0.8,
  flipX: false,
  flipY: true
};

// 再適用
layer.position.set(layerState.x, layerState.y);
layer.rotation = layerState.rotation;
layer.scale.set(layerState.scaleX * (layerState.flipX ? -1 : 1),
                layerState.scaleY * (layerState.flipY ? -1 : 1));


✅ メリット:

コードが見やすくAIに優しい

JSONで履歴管理しやすい

2. Matrix ベース管理

PIXI.Matrix で変形をまとめて管理

JSON化 → undo/redo やモーション補間が容易

const m = new PIXI.Matrix();
m.translate(100, 200);
m.rotate(Math.PI / 6);
m.scale(1.5, 0.8);

layer.transform.setFromMatrix(m);


✅ メリット:

座標変換を一元的に扱える

非破壊で回転・拡縮・反転を合成可能

3. RenderTexture + 元データ保持

レイヤー描画内容を「ベースの RenderTexture」に保持

画面表示は transform をかけた Sprite を表示するだけ

変形自体は数値記録 → 再レンダリング時に元データに適用

✅ メリット:

元データを壊さず何度でも再変形可能

サムネイル生成も同じ RenderTexture から可能

4. タイムライン記録（将来アニメ用）

「非破壊変形 = キーフレーム管理」に拡張

transform 値を時間軸に沿って保存 → アニメーション化

JSON例:

{
  "layerId": 3,
  "keyframes": [
    { "t": 0, "x": 100, "y": 200, "scaleX": 1, "scaleY": 1, "rotation": 0 },
    { "t": 30, "x": 200, "y": 250, "scaleX": 1.2, "scaleY": 0.9, "rotation": 0.5 }
  ]
}

📌 推奨ルール化（ルールブック追記例）
- 非破壊変形ルール
  1. レイヤーの変形は position / rotation / scale / skew の数値として保持する。
  2. 反転は scale.x / scale.y の符号で表現する。
  3. 保存形式は JSON とし、undo/redo に対応可能にする。
  4. 実描画は元テクスチャに対して transform を適用して行う。
  5. 将来的なアニメーション対応のため、時間軸付き keyframe 形式を許容する。

🚀 結論

PixiJS v8 の Container.transform（Matrix） と RenderTexture元データ保持 を組み合わせるのが最適。

まずは 数値プロパティ（position/scale/rotation）をJSONで記録 → 非破壊変形。

将来は Matrix管理 or Keyframe拡張 に発展させるとアニメやモーフィングまで自然に進化できる。



📝Tegaki v8.13 リファクタリング計画書
（SatellitePlan_RuleBook_v6 準拠）

---

## 🎯 目的
- コードの見通しを良くし、AIによる改修・拡張を容易化する。  
- PixiJS v8 標準APIを活用し、DOM依存処理を削減。  
- 応答性（サムネイル更新など）を改善し、将来の拡張（アニメ・モーフィング）に対応可能な基盤を整える。  

---

## 📌 改修対象と方針

### 1. キャンバス移動のリファクタリング
- **現行**: DOMイベントによる直接移動、回転・拡縮・反転未対応  
- **改修**:
  - `canvasContainer (PIXI.Container)` を導入  
  - `canvasContainer.position / rotation / scale` に一元化  
  - 座標変換は `toLocal / toGlobal` をルール化  

**ゴール:** キャンバス移動・回転・ズーム・反転をシンプルに管理可能にする。  

---

### 2. レイヤー移動・変形のリファクタリング
- **現行**: レイヤー移動のみ。回転・反転未対応。  
- **改修**:
  - レイヤーを **個別の Container** にまとめる  
  - `scale.x = -1` / `scale.y = -1` による反転を追加  
  - **非破壊変形の記憶系** を導入（position/rotation/scale/flipをJSON保存）  

**ゴール:** レイヤー単位で非破壊的に回転・拡縮・反転が可能。  

---

### 3. サムネイル生成のリファクタリング
- **現行**: `generateTexture()` に依存 → 遅延発生  
- **改修**:
  - `renderer.render(layer, { renderTexture })` へ置き換え  
  - GPUのmipmapで縮小 → 画質維持 & 高速化  
  - `PIXI.Ticker.shared` で更新頻度を制御（一定間隔でまとめ更新）  

**ゴール:** サムネイル更新の遅延解消とUI応答性向上。  

---

### 4. 選択範囲処理のリファクタリング
- **現行**: 未実装、mask利用も未定義  
- **改修**:
  - **PIXI.Graphics + mask** に統一  
  - 投げ縄・自動選択などは後続拡張（marching-squares等）で対応  

**ゴール:** 非破壊マスクによる選択範囲編集を標準化。  

---

### 5. 非破壊変形の記憶系の導入
- **現行**: レイヤー状態を直接保持、履歴管理なし  
- **改修**:
  - 各レイヤーに **transformState JSON** を保持  
  - undo/redo用の履歴配列に push/pop で管理  
  - 将来的に **Keyframe方式** に拡張可能に設計  

**ゴール:** レイヤー変形を非破壊で再編集可能にし、履歴やアニメ拡張にも対応。  

---

## 🛠 実施ステップ

1. **基盤整理**
   - canvasContainer を導入し、DOM依存の移動処理を削除  
   - toLocal / toGlobal を導入し座標変換ルールを明文化  

2. **レイヤー変形対応**
   - 各レイヤーを Container でラップ  
   - position/rotation/scale/flip を JSON で管理  

3. **サムネイル最適化**
   - generateTexture → renderer.render に置換  
   - Ticker制御で更新頻度を調整  

4. **選択範囲処理追加**
   - Graphics.mask を基本にした選択範囲適用を導入  
   - UI操作から mask に反映する仕組みを構築  

5. **非破壊変形の記憶系導入**
   - transformState をレイヤーごとに持たせる  
   - undo/redo 履歴管理を JSON 単位で実装  
   - Keyframe 拡張の余地を残す  

---

## ⚖️ 評価基準

- **AI実装しやすさ**: transform API と JSON化でコードがシンプル → ◎  
- **改修難易度**: DOM依存部分を削除する負担はあるが、移行は段階的に可能 → ○  
- **相性**: PixiJS 標準APIのみで完結 → ◎  
- **軽量化恩恵**: サムネイル更新のGPU化と非破壊変形の保持で描画効率向上 → ◎  

---

## 🚀 最終ゴール
- PixiJS v8 の座標変換・変形APIを最大限活用し、  
  DOM依存や冗長処理を廃止。  
- **非破壊・履歴可能・拡張可能なレイヤー変形基盤** を確立。  
- **応答性の高いUI** と **将来のアニメ・モーフィング拡張** に備える。  
