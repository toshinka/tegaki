PixiJS v8.13 お絵かきツール改修計画書
CUT独立化・タイムラインサムネイル最適化対応
================================================================================
目次

現状分析と問題の根本原因
改修アプローチと設計方針
データ構造の再設計
動作フロー詳細
ファイル別改修仕様
メソッド辞典
改修の優先順位と手順
検証項目

================================================================================

現状分析と問題の根本原因
================================================================================

【問題A: 全CUTに同じ絵が描画される】
■ 原因

現状のlayer-system.jsでは、全CUTが同一のContainerインスタンスを参照している
可能性が高い
CUT切り替え時に「Containerの参照を切り替える」のではなく、「Containerの
中身を入れ替えている」ため、GPU上では同一テクスチャを全CUTが共有

■ 証跡

レイヤーパネルでは正常 → レイヤー自体は独立
Timeline切り替え時に全CUTが同期 → CUTレベルでの分離が未実装

【問題B: 描画時のチラつきと左上キャンバス出現】
■ 原因

timeline-ui.jsのupdateCutThumbnail()が描画イベント毎にextract.canvas()を
呼び出している
extract.canvas()は内部的にGPU→CPU転送を行うため、描画のたびに
レンダリングパイプラインが中断
抽出したCanvasが一瞬DOM上の別要素として現れる（位置指定不足）

■ 証跡

レイヤーパネルではスムーズ → レイヤーサムネイルは適切に差分更新されている
Timelineのみチラつく → Timeline固有の更新ロジックに問題

================================================================================
2. 改修アプローチと設計方針
【核心となる設計変更】
■ A. CUTを「独立したRenderTextureを持つコンテナ」として実装
従来の構造（問題あり）:
├─ Stage (Container)
└─ layersContainer (Container) ← 全CUTで共有
├─ Layer1 (Graphics)
└─ Layer2 (Graphics)
新しい構造:
├─ Stage (Container)
├─ Cut1 (Container) + RenderTexture1
│   ├─ Layer1-1 (Graphics)
│   └─ Layer1-2 (Graphics)
└─ Cut2 (Container) + RenderTexture2
├─ Layer2-1 (Graphics)
└─ Layer2-2 (Graphics)
■ B. RenderTextureの役割

GPU上の独立したフレームバッファとして機能
各CUTの全レイヤーを合成した最終画像を保持
Timeline表示時はRenderTexture → Canvas2Dの変換を必要時のみ実行

■ C. レイヤーフォルダとの設計統一
CUTは「最上位の特殊なレイヤーフォルダ」として実装:

type: 'cut'を持つレイヤーオブジェクト
子要素として通常レイヤーを持つ
将来的なレイヤーフォルダ実装と構造を共通化

================================================================================
3. データ構造の再設計
【3.1 CUTオブジェクト定義】
{
id: 'cut_1728000000000',          // 一意のID
type: 'cut',                       // オブジェクトタイプ
name: 'Cut 1',                     // 表示名
duration: 1000,                    // 再生時間（ミリ秒）
container: Container,              // Pixi.Container instance
renderTexture: RenderTexture,      // GPU上の描画結果
layers: [],                        // 子レイヤーの配列
activeLayerId: 'layer_xxx',        // アクティブレイヤーID
visible: true,                     // 表示状態
locked: false,                     // ロック状態
thumbnailCache: null,              // Canvas2D thumbnail cache
thumbnailDirty: true               // 再生成フラグ
}
【3.2 レイヤーオブジェクト定義（変更なし）】
{
id: 'layer_1728000000001',        // 一意のID
type: 'raster',                    // 'raster' | 'vector' | 'folder'
name: 'Layer 1',                   // 表示名
parentId: 'cut_xxx',               // 親CUT or フォルダID
container: Container,              // Pixi.Container instance
graphics: Graphics,                // Pixi.Graphics instance
visible: true,                     // 表示状態
opacity: 1.0,                      // 不透明度
locked: false,                     // ロック状態
blendMode: 'normal'                // ブレンドモード
}
【3.3 LayerSystem内部状態】
{
cuts: Map<id, CutObject>,          // 全CUT
layers: Map<id, LayerObject>,      // 全レイヤー（フラット構造）
activeCutId: 'cut_xxx',            // 現在アクティブなCUT
cutOrder: ['cut_1', 'cut_2'],     // 表示順序配列
}
================================================================================
4. 動作フロー詳細
【4.1 初期化フロー】
core-engine.js: initPixiApp()
↓
layer-system.js: initialize()
├─ createCut('cut_default')
│   ├─ new Container()
│   ├─ RenderTexture.create({ width, height })
│   └─ createLayer(cutId, 'Layer 1')
└─ setActiveCut('cut_default')
↓
animation-system.js: initialize()
└─ registerCut('cut_default')
↓
timeline-ui.js: initialize()
└─ refreshTimeline()
【4.2 描画フロー（ペンツール使用時）】
user: mousedown on canvas
↓
core-runtime.js: handleDrawingStart()
↓
layer-system.js: getActiveLayer(activeCutId)
↓ 返り値: activeLayer
↓
core-runtime.js: graphics.moveTo(x, y)
↓
user: mousemove
↓
core-runtime.js: graphics.lineTo(x, y)
↓ (毎フレーム自動レンダリング)
↓
user: mouseup
↓
layer-system.js: renderCutToTexture(activeCutId)
├─ renderer.render(cutContainer, { renderTexture })
└─ markThumbnailDirty(cutId)
↓
EventBus.emit('cut:updated', { cutId })
↓
timeline-ui.js: onCutUpdated({ cutId })
└─ scheduleThrottledUpdate(cutId)
【4.3 CUT切り替えフロー】
user: click on timeline cut
↓
timeline-ui.js: handleCutClick(cutId)
↓
animation-system.js: gotoCut(cutId)
↓
layer-system.js: setActiveCut(cutId)
├─ 旧CUT: cutContainer.visible = false
├─ 新CUT: cutContainer.visible = true
└─ EventBus.emit('cut:changed', { cutId })
↓
ui-panels.js: refreshLayerPanel(cutId)
【4.4 Timelineサムネイル更新フロー（最適化版）】
EventBus.on('cut:updated', { cutId })
↓
timeline-ui.js: scheduleThrottledUpdate(cutId)
├─ throttle: 300ms
└─ dirtyFlags.add(cutId)
↓
timeline-ui.js: processDirtyThumbnails()
└─ for each dirtyCutId:
updateCutThumbnail(dirtyCutId)
├─ if (cut.thumbnailDirty === false) return
├─ const canvas = extract.canvas(cutContainer)
├─ const dataURL = canvas.toDataURL()
├─ imgElement.src = dataURL
├─ cut.thumbnailCache = canvas
└─ cut.thumbnailDirty = false
================================================================================
5. ファイル別改修仕様
【5.1 system/layer-system.js】
■ 責務

CUT/レイヤーの作成・削除・取得
CUTごとのRenderTexture管理
描画内容のテクスチャへの反映

■ 改修内容
▼ 新規追加メソッド
class LayerSystem {
  constructor(app) {
    this.app = app;
    this.renderer = app.renderer;
    this.stage = app.stage;
    this.cuts = new Map();
    this.layers = new Map();
    this.activeCutId = null;
    this.cutOrder = [];
  }

  // CUT管理
  createCut(options = {})
  getCut(id)
  setActiveCut(id)
  deleteCut(id)
  
  // RenderTexture管理
  renderCutToTexture(cutId)
  markThumbnailDirty(cutId)
  
  // レイヤー管理（既存を改修）
  createLayer(cutId, options)
  getActiveLayer(cutId)
}
▼ 改修対象の既存メソッド
- createLayer()
変更点: parentIdパラメータを追加（cutId必須化）
- deleteLayer()
  変更点: 親CUTのthumbnailDirtyフラグを立てる

- setLayerVisibility()
  変更点: 親CUTのthumbnailDirtyフラグを立てる
【5.2 system/animation-system.js】
■ 責務

CUTの登録・順序管理
再生/停止制御
CUT間の遷移

■ 改修内容
▼ 新規追加メソッド
class AnimationSystem {
  constructor(layerSystem) {
    this.layerSystem = layerSystem;
    this.isPlaying = false;
    this.currentCutIndex = 0;
    this.animationId = null;
  }

  addCut(options)
    説明: layerSystem.createCut()を呼び出し
  
  removeCut(cutId)
    説明: layerSystem.deleteCut()を呼び出し
  
  gotoCut(cutId)
    説明: layerSystem.setActiveCut()を呼び出し
  
  playAnimation()
    説明: CUT順次再生
  
  pauseAnimation()
    説明: 再生停止
  
  nextCut()
    説明: 次のCUTへ移動
  
  prevCut()
    説明: 前のCUTへ移動
}
▼ 既存からの変更
- CUT管理の責務をlayer-system.jsに移譲
- animation-system.jsは再生制御に専念
【5.3 ui/timeline-ui.js】
■ 責務

Timeline UIの描画
CUTサムネイルの生成・更新
ユーザーインタラクション処理

■ 改修内容
▼ 新規追加メソッド
class TimelineUI {
  constructor(layerSystem, animationSystem) {
    this.layerSystem = layerSystem;
    this.animationSystem = animationSystem;
    this.dirtyFlags = new Set();
    this.updateThrottle = null;
  }

  // サムネイル更新（最適化）
  scheduleThrottledUpdate(cutId)
    説明: 300ms throttleで更新予約
  
  processDirtyThumbnails()
    説明: 予約済み更新をバッチ処理
  
  updateCutThumbnail(cutId)
    説明: extract.canvas()を呼び、サムネイル生成
  
  // Timeline描画
  refreshTimeline()
    説明: 全CUTのUI再構築
  
  renderCutElement(cut)
    説明: 個別CUT要素のHTML生成
  
  // イベント
  bindTimelineEvents()
    説明: クリック等のイベントリスナー登録
}
▼ 重要な最適化ポイント
updateCutThumbnail(cutId) {
  const cut = this.layerSystem.getCut(cutId);
  
  // 差分チェック
  if (!cut.thumbnailDirty) return;
  
  // Extract実行（ここだけ）
  const canvas = this.layerSystem.renderer.extract.canvas(cut.container);
  const dataURL = canvas.toDataURL('image/png');
  
  // DOM更新
  const imgElement = document.querySelector(`[data-cut-id="${cutId}"] img`);
  if (imgElement) {
    imgElement.src = dataURL;
  }
  
  // キャッシュ保存
  cut.thumbnailCache = canvas;
  cut.thumbnailDirty = false;
}
【5.4 system/history.js】
■ 責務

Undo/Redo履歴管理
CUT単位での履歴分離

■ 改修内容
▼ データ構造変更
従来: 単一の履歴配列
  histories: []

改修後: CUT別の履歴Map
  histories: Map<cutId, HistoryEntry[]>
▼ 新規追加メソッド
class HistorySystem {
  constructor(layerSystem) {
    this.layerSystem = layerSystem;
    this.histories = new Map(); // cutId -> []
    this.historyIndices = new Map(); // cutId -> index
  }

  pushState(cutId, action, data)
    説明: CUT別に履歴追加
  
  undo(cutId)
    説明: 指定CUTのみUndo
  
  redo(cutId)
    説明: 指定CUTのみRedo
  
  clearHistory(cutId)
    説明: CUT削除時の履歴クリア
}
▼ 既存からの変更
- グローバルな履歴 → CUT別の履歴に変更
- undo()/redo()にcutIdパラメータ追加
【5.5 system/gif-exporter.js】
■ 責務

全CUTのRenderTexture→PNG変換
GIF生成・ダウンロード

■ 改修内容
▼ 新規追加メソッド
class GifExporter {
  constructor(layerSystem, animationSystem) {
    this.layerSystem = layerSystem;
    this.animationSystem = animationSystem;
  }

  async renderCutFrames() {
    const frames = [];
    const cutOrder = this.layerSystem.cutOrder;
    
    for (const cutId of cutOrder) {
      const cut = this.layerSystem.getCut(cutId);
      
      // RenderTextureから直接Canvas取得
      const canvas = this.layerSystem.renderer.extract
                          .canvas(cut.renderTexture);
      frames.push({
        canvas: canvas,
        delay: cut.duration
      });
    }
    
    return frames;
  }

  async exportGIF(frames)
    説明: gif.js使用してGIF生成
  
  downloadGIF(blob, filename)
    説明: Blob形式で保存
}
▼ 最適化ポイント
- renderTextureから直接抽出（再レンダリング不要）
- 非同期処理でUI凍結を防止
【5.6 core-engine.js】
■ 責務

PixiJSアプリケーション初期化
各システムのインスタンス生成
グローバル参照の管理

■ 改修内容
▼ 初期化順序の明確化
async function initPixiApp() {
  // 1. PixiJS Application
  const app = new PIXI.Application();
  await app.init({ /* options */ });
  
  // 2. Core Systems
  window.eventBus = new EventBus();
  window.layerSystem = new LayerSystem(app);
  window.cameraSystem = new CameraSystem(app);
  
  // 3. Feature Systems
  window.animationSystem = new AnimationSystem(layerSystem);
  window.historySystem = new HistorySystem(layerSystem);
  window.gifExporter = new GifExporter(layerSystem, animationSystem);
  
  // 4. UI
  window.timelineUI = new TimelineUI(layerSystem, animationSystem);
  window.uiPanels = new UIPanels(layerSystem, historySystem);
  
  // 5. Initialize all
  layerSystem.initialize();
  animationSystem.initialize();
  timelineUI.initialize();
  
  return app;
}
================================================================================
6. メソッド辞典
【6.1 LayerSystem】
■ createCut()
種別: 新規
説明: CUT作成、RenderTexture割当
パラメータ: { name, duration }
戻り値: cutId
■ getCut()
種別: 新規
説明: CUT取得
パラメータ: cutId
戻り値: CutObject
■ setActiveCut()
種別: 新規
説明: アクティブCUT切替
パラメータ: cutId
戻り値: void
■ deleteCut()
種別: 新規
説明: CUT削除
パラメータ: cutId
戻り値: void
■ renderCutToTexture()
種別: 新規
説明: CUTをRenderTextureに描画
パラメータ: cutId
戻り値: void
■ markThumbnailDirty()
種別: 新規
説明: サムネイル再生成フラグ
パラメータ: cutId
戻り値: void
■ createLayer()
種別: 改修
説明: レイヤー作成
パラメータ: cutId, { name, type }
戻り値: layerId
変更点: cutId必須化、parentId対応
■ getActiveLayer()
種別: 改修
説明: アクティブレイヤー取得
パラメータ: cutId
戻り値: LayerObject
変更点: CUT指定版に変更
■ deleteLayer()
種別: 改修
説明: レイヤー削除
パラメータ: layerId
戻り値: void
変更点: dirty更新追加
■ setLayerVisibility()
種別: 改修
説明: 表示切替
パラメータ: layerId, visible
戻り値: void
変更点: dirty更新追加
【6.2 AnimationSystem】
■ addCut()
種別: 新規
説明: CUT追加
パラメータ: options
戻り値: cutId
■ removeCut()
種別: 新規
説明: CUT削除
パラメータ: cutId
戻り値: void
■ gotoCut()
種別: 新規
説明: CUT移動
パラメータ: cutId
戻り値: void
■ nextCut()
種別: 新規
説明: 次のCUTへ
パラメータ: なし
戻り値: void
■ prevCut()
種別: 新規
説明: 前のCUTへ
パラメータ: なし
戻り値: void
■ playAnimation()
種別: 新規
説明: 再生開始
パラメータ: なし
戻り値: void
■ pauseAnimation()
種別: 新規
説明: 再生停止
パラメータ: なし
戻り値: void
【6.3 TimelineUI】
■ scheduleThrottledUpdate()
種別: 新規
説明: サムネイル更新予約（throttle）
パラメータ: cutId
戻り値: void
■ processDirtyThumbnails()
種別: 新規
説明: 予約済み更新を一括処理
パラメータ: なし
戻り値: void
■ updateCutThumbnail()
種別: 新規
説明: 単一CUTサムネイル更新
パラメータ: cutId
戻り値: void
■ refreshTimeline()
種別: 改修
説明: Timeline全体再描画
パラメータ: なし
戻り値: void
■ renderCutElement()
種別: 新規
説明: CUT要素HTML生成
パラメータ: cutObject
戻り値: HTMLElement
■ bindTimelineEvents()
種別: 改修
説明: イベントリスナー登録
パラメータ: なし
戻り値: void
【6.4 HistorySystem】
■ pushState()
種別: 改修
説明: 履歴追加（CUT別）
パラメータ: cutId, action, data
戻り値: void
■ undo()
種別: 改修
説明: Undo（CUT別）
パラメータ: cutId
戻り値: void
■ redo()
種別: 改修
説明: Redo（CUT別）
パラメータ: cutId
戻り値: void
■ clearHistory()
種別: 新規
説明: CUT削除時の履歴クリア
パラメータ: cutId
戻り値: void
■ canUndo()
種別: 改修
説明: Undo可能判定
パラメータ: cutId
戻り値: boolean
■ canRedo()
種別: 改修
説明: Redo可能判定
パラメータ: cutId
戻り値: boolean
【6.5 GifExporter】
■ renderCutFrames()
種別: 新規
説明: 全CUTをCanvas配列化
パラメータ: なし
戻り値: Promise<Frame[]>
■ exportGIF()
種別: 改修
説明: GIF生成
パラメータ: frames
戻り値: Promise<Blob>
■ downloadGIF()
種別: 継承
説明: GIFダウンロード
パラメータ: blob, filename
戻り値: void
================================================================================
7. 改修の優先順位と手順
【Phase 1: CUT独立化（最優先）】
目的: 全CUTに同じ絵が描画される問題の解決
■ 1. layer-system.js改修

createCut()実装: Container + RenderTexture生成
setActiveCut()実装: Container切り替え
renderCutToTexture()実装: 描画後のテクスチャ更新

■ 2. animation-system.js改修

CUT管理ロジックをlayerSystemに委譲
gotoCut()でlayerSystem.setActiveCut()を呼ぶ

■ 3. 検証

CUT間で絵が独立していることを確認
CUT切り替え時に正しいレイヤーが表示されることを確認

【Phase 2: Timelineサムネイル最適化】
目的: チラつきと左上キャンバス出現の解消
■ 1. layer-system.js拡張

markThumbnailDirty()実装
thumbnailDirtyフラグ管理

■ 2. timeline-ui.js改修

scheduleThrottledUpdate()実装（300ms throttle）
updateCutThumbnail()を差分更新版に書き換え
EventBus連携（cut:updatedイベント受信）

■ 3. 検証

描画時のチラつきが消えることを確認
サムネイル更新が適切なタイミングで行われることを確認

【Phase 3: 履歴のCUT単位対応】
目的: Undo/RedoがCUT別に動作する
■ 1. history.js改修

historiesをMap化
pushState(), undo(), redo()にcutId追加

■ 2. core-runtime.js調整

描画終了時にhistorySystem.pushState(activeCutId, ...)を呼ぶ

■ 3. 検証

CUT1でUndo → CUT2に影響しないことを確認

【Phase 4: GIF Export最適化】
目的: RenderTextureから高速エクスポート
■ 1. gif-exporter.js改修

renderCutFrames()をRenderTexture使用版に書き換え

■ 2. 検証

全CUTが正しくGIFに含まれることを確認
エクスポート速度の向上を確認

================================================================================
8. 検証項目
【機能検証】
■ CUT独立性
検証内容: CUT1に描画→CUT2に移動→CUT1に戻る
期待結果: CUT1の絵が残っている
■ Timeline切替
検証内容: CUT切替時の表示
期待結果: 正しいCUTのレイヤーが表示される
■ サムネイル更新
検証内容: 描画時のチラつき
期待結果: チラつきなし、左上に何も出ない
■ サムネイル正確性
検証内容: Timeline画像
期待結果: 実際の描画内容と一致
■ Undo/Redo
検証内容: CUT別の履歴
期待結果: 他CUTに影響しない
■ GIF Export
検証内容: 全CUT出力
期待結果: 各CUTが独立したフレームとして出力
【パフォーマンス検証】
■ 描画レスポンス
測定方法: requestAnimationFrameのfps
目標値: 60fps維持
■ サムネイル更新頻度
測定方法: console.time測定
目標値: 300ms以下の間隔
■ GIF Export時間
測定方法: 10CUTのエクスポート時間
目標値: 5秒以内
【互換性検証】
■ 既存レイヤー機能
確認内容: レイヤー作成・削除・可視性が動作
■ カメラ操作
確認内容: Pan/Zoomが全CUTで機能
■ ショートカット
確認内容: Ctrl+Z等が正常動作
================================================================================
重要な設計判断
【なぜRenderTextureを使うのか？】

GPU上での独立性
各CUTが独自のGPUメモリ領域を持つ
描画効率
毎フレーム全レイヤーを再合成せず、RenderTextureをそのまま表示
Extract最適化
RenderTextureから直接Canvas抽出可能

【なぜCUTとレイヤーフォルダを同じ構造にするのか？】

将来の拡張性
レイヤーフォルダ実装時にコードを再利用できる
一貫性
階層構造の扱いが統一される
理解しやすさ
AI改修時の認知負荷が減る

【throttle 300msの根拠】

人間の知覚: 100ms以下の遅延は気づかれない
描画頻度: 60fpsでも16.7ms間隔なので、300msは十分な間引き
GPU負荷: extract.canvas()は重い処理なので、過度な呼び出しを防ぐ

================================================================================
注意事項
【localStorage禁止】

PixiJS v8.13環境では使用不可
全てメモリ上で管理（Session終了で消える設計）

【Canvas2D使用箇再試行Claudeは現在、生成したコードを実行する機能を持っていません。も続ける編集所の限定】

サムネイル生成時のextract.canvas()のみ許可
描画本体は必ずPixiJS（WebGL）を使用

【座標系の一貫性】

全ての座標はcoordinate-system.js経由で変換
Container間の親子関係に注意（CUT→Layer）

================================================================================
補足: 実装時の具体的なコード例
【LayerSystem.createCut() の実装イメージ】
createCut(options = {}) {
const id = options.id || cut_${Date.now()};
const name = options.name || Cut ${this.cuts.size + 1};
const duration = options.duration || 1000;
// Container作成
const container = new PIXI.Container();
container.label = name;
this.stage.addChild(container);
// RenderTexture作成
const renderTexture = PIXI.RenderTexture.create({
width: this.app.screen.width,
height: this.app.screen.height
});
// CUTオブジェクト作成
const cut = {
id: id,
type: 'cut',
name: name,
duration: duration,
container: container,
renderTexture: renderTexture,
layers: [],
activeLayerId: null,
visible: false,
locked: false,
thumbnailCache: null,
thumbnailDirty: true
};
this.cuts.set(id, cut);
this.cutOrder.push(id);
// デフォルトレイヤーを作成
const defaultLayerId = this.createLayer(id, { name: 'Layer 1' });
cut.activeLayerId = defaultLayerId;
return id;
}
【LayerSystem.setActiveCut() の実装イメージ】
setActiveCut(cutId) {
if (!this.cuts.has(cutId)) {
throw new Error(Cut not found: ${cutId});
}
// 既存のアクティブCUTを非表示
if (this.activeCutId) {
const oldCut = this.cuts.get(this.activeCutId);
if (oldCut) {
oldCut.container.visible = false;
}
}
// 新しいCUTを表示
const newCut = this.cuts.get(cutId);
newCut.container.visible = true;
this.activeCutId = cutId;
// イベント発火
if (window.eventBus) {
window.eventBus.emit('cut:changed', { cutId: cutId });
}
}
【LayerSystem.renderCutToTexture() の実装イメージ】
renderCutToTexture(cutId) {
const cut = this.cuts.get(cutId);
if (!cut) return;
// CUTのContainerをRenderTextureに描画
this.renderer.render({
container: cut.container,
target: cut.renderTexture,
clear: true
});
// サムネイル更新フラグを立てる
this.markThumbnailDirty(cutId);
}
【LayerSystem.markThumbnailDirty() の実装イメージ】
markThumbnailDirty(cutId) {
const cut = this.cuts.get(cutId);
if (cut) {
cut.thumbnailDirty = true;
// Timeline UIに通知
if (window.eventBus) {
  window.eventBus.emit('cut:updated', { cutId: cutId });
}
}
}
【TimelineUI.scheduleThrottledUpdate() の実装イメージ】
scheduleThrottledUpdate(cutId) {
// dirtyフラグに追加
this.dirtyFlags.add(cutId);
// 既にthrottle中なら何もしない
if (this.updateThrottle) return;
// 300ms後に実行
this.updateThrottle = setTimeout(() => {
this.processDirtyThumbnails();
this.updateThrottle = null;
}, 300);
}
【TimelineUI.processDirtyThumbnails() の実装イメージ】
processDirtyThumbnails() {
for (const cutId of this.dirtyFlags) {
this.updateCutThumbnail(cutId);
}
this.dirtyFlags.clear();
}
【TimelineUI.updateCutThumbnail() の実装イメージ】
updateCutThumbnail(cutId) {
const cut = this.layerSystem.getCut(cutId);
if (!cut) return;
// 差分チェック
if (!cut.thumbnailDirty) return;
// Extract実行（GPU → CPU転送）
const canvas = this.layerSystem.renderer.extract.canvas(cut.container);
// Canvas2D → Data URL変換
const dataURL = canvas.toDataURL('image/png');
// DOM更新
const imgElement = document.querySelector(
[data-cut-id="${cutId}"] .timeline-thumbnail
);
if (imgElement) {
imgElement.src = dataURL;
}
// キャッシュ保存とフラグクリア
cut.thumbnailCache = canvas;
cut.thumbnailDirty = false;
}
【AnimationSystem.gotoCut() の実装イメージ】
gotoCut(cutId) {
if (!this.layerSystem.cuts.has(cutId)) {
throw new Error(Cut not found: ${cutId});
}
// LayerSystemに切替を委譲
this.layerSystem.setActiveCut(cutId);
// 現在のインデックスを更新
this.currentCutIndex = this.layerSystem.cutOrder.indexOf(cutId);
}
【HistorySystem.pushState() の実装イメージ（CUT別対応）】
pushState(cutId, action, data) {
// CUT別の履歴を取得（なければ作成）
if (!this.histories.has(cutId)) {
this.histories.set(cutId, []);
this.historyIndices.set(cutId, -1);
}
const history = this.histories.get(cutId);
let index = this.historyIndices.get(cutId);
// 現在位置より後ろの履歴を削除
history.splice(index + 1);
// 新しい履歴を追加
history.push({
action: action,
data: data,
timestamp: Date.now()
});
// インデックスを進める
index = history.length - 1;
this.historyIndices.set(cutId, index);
// 履歴上限チェック（例: 50件）
if (history.length > 50) {
history.shift();
this.historyIndices.set(cutId, index - 1);
}
}
【HistorySystem.undo() の実装イメージ（CUT別対応）】
undo(cutId) {
if (!this.canUndo(cutId)) return;
const history = this.histories.get(cutId);
let index = this.historyIndices.get(cutId);
// 現在の状態を取得
const state = history[index];
// 状態を復元（actionに応じた処理）
this.restoreState(cutId, state);
// インデックスを戻す
index--;
this.historyIndices.set(cutId, index);
// 画面更新
this.layerSystem.renderCutToTexture(cutId);
}
【GifExporter.renderCutFrames() の実装イメージ】
async renderCutFrames() {
const frames = [];
const cutOrder = this.layerSystem.cutOrder;
for (const cutId of cutOrder) {
const cut = this.layerSystem.getCut(cutId);
// RenderTextureが未更新なら描画
if (cut.thumbnailDirty) {
  this.layerSystem.renderCutToTexture(cutId);
}

// RenderTextureから直接Canvas取得
const canvas = this.layerSystem.renderer.extract.canvas(cut.renderTexture);

frames.push({
  canvas: canvas,
  delay: cut.duration,
  cutId: cutId
});

// UI凍結防止のため非同期待機
await new Promise(resolve => setTimeout(resolve, 0));
}
return frames;
}
================================================================================
EventBusイベント一覧
改修に伴い新規追加・変更されるイベント
【新規追加イベント】
■ cut:created
発火元: LayerSystem.createCut()
ペイロード: { cutId }
用途: Timeline UIの更新
■ cut:deleted
発火元: LayerSystem.deleteCut()
ペイロード: { cutId }
用途: Timeline UIからCUT削除
■ cut:changed
発火元: LayerSystem.setActiveCut()
ペイロード: { cutId }
用途: レイヤーパネル・Timeline UIの同期
■ cut:updated
発火元: LayerSystem.markThumbnailDirty()
ペイロード: { cutId }
用途: Timelineサムネイル更新トリガー
【既存イベントの変更】
■ layer:created
変更点: ペイロードにcutIdを追加
新ペイロード: { layerId, cutId }
■ layer:deleted
変更点: ペイロードにcutIdを追加
新ペイロード: { layerId, cutId }
■ layer:visibility:changed
変更点: 親CUTのdirtyフラグ更新を追加
新ペイロード: { layerId, cutId, visible }
================================================================================
改修後のファイル間依存関係
core-engine.js
├─ 依存: なし
└─ 生成: app, eventBus, layerSystem, cameraSystem, animationSystem,
historySystem, gifExporter, timelineUI, uiPanels
system/layer-system.js
├─ 依存: PIXI, eventBus
└─ 使用元: animationSystem, historySystem, timelineUI, uiPanels,
core-runtime
system/animation-system.js
├─ 依存: layerSystem, eventBus
└─ 使用元: timelineUI, core-runtime
system/history.js
├─ 依存: layerSystem, eventBus
└─ 使用元: core-runtime, uiPanels
system/gif-exporter.js
├─ 依存: layerSystem, animationSystem, gif.js
└─ 使用元: uiPanels（Export実行時）
ui/timeline-ui.js
├─ 依存: layerSystem, animationSystem, eventBus
└─ 使用元: なし（UIレイヤー最上位）
ui/ui-panels.js
├─ 依存: layerSystem, historySystem, gifExporter, eventBus
└─ 使用元: なし（UIレイヤー最上位）
core-runtime.js
├─ 依存: layerSystem, animationSystem, historySystem, cameraSystem,
eventBus
└─ 使用元: なし（メインループ）
================================================================================
改修時の注意点とトラブルシューティング
【問題: CUT切替時にレイヤーが消える】
原因候補:

setActiveCut()でcontainer.visible = trueにし忘れ
Containerがstageに追加されていない
z-indexが他のCUTの下になっている

対処法:

createCut()でstage.addChild(container)を確認
setActiveCut()でvisibleフラグの設定を確認
Container.zIndexを明示的に設定

【問題: サムネイルが真っ白/真っ黒になる】
原因候補:

renderCutToTexture()が呼ばれていない
extract.canvas()の対象が空のContainer
RenderTextureのサイズが0

対処法:

描画後に必ずrenderCutToTexture()を呼ぶ
Containerに少なくとも1つのレイヤーが存在することを確認
RenderTexture作成時のwidth/heightを確認

【問題: メモリリークが発生する】
原因候補:

deleteCut()時にRenderTexture.destroy()を呼んでいない
EventBusのリスナーが解除されていない
Canvas要素がDOM上に残り続けている

対処法:

deleteCut()で以下を必ず実行:

renderTexture.destroy(true)
container.destroy({ children: true })
eventBus.off()で全リスナー解除


thumbnailCacheも明示的にnullにする

【問題: Timeline更新が遅い】
原因候補:

throttleが効いていない
毎フレームextract.canvas()が呼ばれている
大量のCUTが存在する

対処法:

scheduleThrottledUpdate()の実装を確認
updateCutThumbnail()の呼び出し回数をconsole.countで計測
CUT数が多い場合は仮想スクロール導入を検討

【問題: Undo/Redoが動作しない】
原因候補:

pushState()にcutIdを渡していない
履歴Mapが初期化されていない
復元処理が不完全

対処法:

core-runtime.jsの描画終了時にcutIdを渡しているか確認
HistorySystem.initialize()で各CUTの履歴を初期化
restoreState()の実装を確認

================================================================================
将来的な拡張への準備
【レイヤーフォルダ実装時の対応】
現在のCUT構造を踏襲することで、レイヤーフォルダは以下の変更のみで実装可能:

LayerObjectにchildrenプロパティ追加
{
id: 'folder_xxx',
type: 'folder',
name: 'Folder 1',
parentId: 'cut_xxx',
children: ['layer_yyy', 'layer_zzz'],
expanded: true,
visible: true,
locked: false
}
createFolder()メソッド追加
LayerSystem.createFolder(parentId, options)
再帰的なレンダリング処理
renderFolderRecursive(folderId)
UI側の階層表示
ui-panels.jsでインデント表示実装

【オニオンスキン実装時の対応】
RenderTextureを使用することで、オニオンスキンは比較的簡単に実装可能:

前後のCUTのRenderTextureを取得
半透明でオーバーレイ表示
カスタムシェーダーで色調変更（赤/青など）

【タイムライン再生の拡張】
現在の設計では以下が容易に実装可能:

フレーム補間（Tweening）
各CUT間で補間フレームを生成
イージング関数対応
CUT遷移時にイージング適用
ループ再生
cutOrderを循環させる

================================================================================
最終チェックリスト
Phase 1実装後:
□ createCut()が正常に動作する
□ setActiveCut()でCUTが切り替わる
□ 各CUTで独立して描画できる
□ CUT間で絵が混ざらない
Phase 2実装後:
□ 描画時のチラつきが消えた
□ 左上にキャンバスが出なくなった
□ サムネイルが正確に更新される
□ 300ms throttleが機能している
Phase 3実装後:
□ CUT別にUndo/Redoが動作する
□ 他CUTに影響しない
□ 履歴が正しく保存される
Phase 4実装後:
□ GIF Exportが高速化した
□ 全CUTが正しく出力される
□ メモリリークがない
全Phase完了後:
□ 既存機能が全て動作する
□ パフォーマンスが60fps維持
□ メモリ使用量が適切
□ コードの可読性が高い