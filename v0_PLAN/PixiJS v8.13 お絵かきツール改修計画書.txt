CUT独立化・タイムラインサムネイル最適化対応

📋 目次

現状分析と問題の根本原因
改修アプローチと設計方針
データ構造の再設計
動作フロー詳細
ファイル別改修仕様
メソッド辞典
改修の優先順位と手順
検証項目


1. 現状分析と問題の根本原因
🔴 問題A: 全CUTに同じ絵が描画される
原因

現状のlayer-system.jsでは、全CUTが同一のContainerインスタンスを参照している可能性が高い
CUT切り替え時に「Container の参照を切り替える」のではなく、「Container の中身を入れ替えている」ため、GPU上では同一テクスチャを全CUTが共有

証跡

レイヤーパネルでは正常 → レイヤー自体は独立
Timeline切り替え時に全CUTが同期 → CUTレベルでの分離が未実装

🔴 問題B: 描画時のチラつきと左上キャンバス出現
原因

timeline-ui.jsのupdateCutThumbnail()が描画イベント毎にextract.canvas()を呼び出している
extract.canvas()は内部的にGPU→CPU転送を行うため、描画のたびにレンダリングパイプラインが中断
抽出したCanvasが一瞬DOM上の別要素として現れる（位置指定不足）

証跡

レイヤーパネルではスムーズ → レイヤーサムネイルは適切に差分更新されている
Timelineのみチラつく → Timeline固有の更新ロジックに問題


2. 改修アプローチと設計方針
🎯 核心となる設計変更
A. CUTを「独立したRenderTextureを持つコンテナ」として実装
従来の構造（問題あり）:
├─ Stage (Container)
    └─ layersContainer (Container) ← 全CUTで共有
        ├─ Layer1 (Graphics)
        └─ Layer2 (Graphics)

新しい構造:
├─ Stage (Container)
    ├─ Cut1 (Container) + RenderTexture1
    │   ├─ Layer1-1 (Graphics)
    │   └─ Layer1-2 (Graphics)
    └─ Cut2 (Container) + RenderTexture2
        ├─ Layer2-1 (Graphics)
        └─ Layer2-2 (Graphics)
B. RenderTextureの役割

GPU上の独立したフレームバッファとして機能
各CUTの全レイヤーを合成した最終画像を保持
Timeline表示時はRenderTexture → Canvas2Dの変換を必要時のみ実行

C. レイヤーフォルダとの設計統一
CUTは「最上位の特殊なレイヤーフォルダ」として実装:

type: 'cut'を持つレイヤーオブジェクト
子要素として通常レイヤーを持つ
将来的なレイヤーフォルダ実装と構造を共通化


3. データ構造の再設計
3.1 CUTオブジェクト定義
javascript{
  id: 'cut_1728000000000',
  type: 'cut',
  name: 'Cut 1',
  duration: 1000,           // ミリ秒
  container: Container,      // Pixi.Container instance
  renderTexture: RenderTexture, // GPU上の描画結果
  layers: [],               // 子レイヤーの配列
  activeLayerId: 'layer_xxx',
  visible: true,
  locked: false,
  thumbnailCache: null,     // Canvas2D thumbnail cache
  thumbnailDirty: true      // 再生成フラグ
}
3.2 レイヤーオブジェクト定義（変更なし）
javascript{
  id: 'layer_1728000000001',
  type: 'raster',           // 'raster' | 'vector' | 'folder'
  name: 'Layer 1',
  parentId: 'cut_xxx',      // 親CUT or フォルダID
  container: Container,
  graphics: Graphics,
  visible: true,
  opacity: 1.0,
  locked: false,
  blendMode: 'normal'
}
3.3 LayerSystem内部状態
javascript{
  cuts: Map<id, CutObject>,        // 全CUT
  layers: Map<id, LayerObject>,    // 全レイヤー（フラット）
  activeCutId: 'cut_xxx',
  cutOrder: ['cut_1', 'cut_2'],   // 表示順序
}

4. 動作フロー詳細
4.1 初期化フロー
core-engine.js: initPixiApp()
  ↓
layer-system.js: initialize()
  ├─ createCut('cut_default')
  │   ├─ new Container()
  │   ├─ RenderTexture.create({ width, height })
  │   └─ createLayer(cutId, 'Layer 1')
  └─ setActiveCut('cut_default')
  ↓
animation-system.js: initialize()
  └─ registerCut('cut_default')
  ↓
timeline-ui.js: initialize()
  └─ refreshTimeline()
4.2 描画フロー（ペンツール使用時）
user: mousedown on canvas
  ↓
core-runtime.js: handleDrawingStart()
  ↓
layer-system.js: getActiveLayer(activeCutId)
  ↓ 返り値: activeLayer
  ↓
core-runtime.js: graphics.moveTo(x, y)
  ↓
user: mousemove
  ↓
core-runtime.js: graphics.lineTo(x, y)
  ↓ (毎フレーム自動レンダリング)
  ↓
user: mouseup
  ↓
layer-system.js: renderCutToTexture(activeCutId)
  ├─ renderer.render(cutContainer, { renderTexture })
  └─ markThumbnailDirty(cutId)
  ↓
EventBus.emit('cut:updated', { cutId })
  ↓
timeline-ui.js: onCutUpdated({ cutId })
  └─ scheduleThrottledUpdate(cutId)
4.3 CUT切り替えフロー
user: click on timeline cut
  ↓
timeline-ui.js: handleCutClick(cutId)
  ↓
animation-system.js: gotoCut(cutId)
  ↓
layer-system.js: setActiveCut(cutId)
  ├─ 旧CUT: cutContainer.visible = false
  ├─ 新CUT: cutContainer.visible = true
  └─ EventBus.emit('cut:changed', { cutId })
  ↓
ui-panels.js: refreshLayerPanel(cutId)
4.4 Timelineサムネイル更新フロー（最適化版）
EventBus.on('cut:updated', { cutId })
  ↓
timeline-ui.js: scheduleThrottledUpdate(cutId)
  ├─ throttle: 300ms
  └─ dirtyFlags.add(cutId)
  ↓
timeline-ui.js: processDirtyThumbnails()
  └─ for each dirtyCutId:
      updateCutThumbnail(dirtyCutId)
        ├─ if (cut.thumbnailDirty === false) return
        ├─ const canvas = extract.canvas(cutContainer)
        ├─ const dataURL = canvas.toDataURL()
        ├─ imgElement.src = dataURL
        ├─ cut.thumbnailCache = canvas
        └─ cut.thumbnailDirty = false

5. ファイル別改修仕様
5.1 system/layer-system.js
責務

CUT/レイヤーの作成・削除・取得
CUTごとのRenderTexture管理
描画内容のテクスチャへの反映

改修内容
新規追加
javascriptclass LayerSystem {
  constructor(app) {
    this.app = app;
    this.renderer = app.renderer;
    this.stage = app.stage;
    this.cuts = new Map();
    this.layers = new Map();
    this.activeCutId = null;
    this.cutOrder = [];
  }

  // CUT管理
  createCut(options = {}) { /* 実装 */ }
  getCut(id) { /* 実装 */ }
  setActiveCut(id) { /* 実装 */ }
  deleteCut(id) { /* 実装 */ }
  
  // RenderTexture管理
  renderCutToTexture(cutId) { /* 実装 */ }
  markThumbnailDirty(cutId) { /* 実装 */ }
  
  // レイヤー管理（既存を改修）
  createLayer(cutId, options) { /* parentId対応 */ }
  getActiveLayer(cutId) { /* CUT指定版 */ }
}
改修対象の既存メソッド

createLayer(): parentIdパラメータを追加（cutId必須化）
deleteLayer(): 親CUTのthumbnailDirtyフラグを立てる
setLayerVisibility(): 同上


5.2 system/animation-system.js
責務

CUTの登録・順序管理
再生/停止制御
CUT間の遷移

改修内容
新規追加
javascriptclass AnimationSystem {
  constructor(layerSystem) {
    this.layerSystem = layerSystem;
    this.isPlaying = false;
    this.currentCutIndex = 0;
    this.animationId = null;
  }

  addCut(options) { /* layerSystem.createCut()を呼び出し */ }
  removeCut(cutId) { /* layerSystem.deleteCut()を呼び出し */ }
  gotoCut(cutId) { /* layerSystem.setActiveCut()を呼び出し */ }
  
  playAnimation() { /* 実装 */ }
  pauseAnimation() { /* 実装 */ }
  nextCut() { /* 実装 */ }
  prevCut() { /* 実装 */ }
}
既存からの変更

CUT管理の責務をlayer-system.jsに移譲
animation-system.jsは再生制御に専念


5.3 ui/timeline-ui.js
責務

Timeline UIの描画
CUTサムネイルの生成・更新
ユーザーインタラクション処理

改修内容
新規追加
javascriptclass TimelineUI {
  constructor(layerSystem, animationSystem) {
    this.layerSystem = layerSystem;
    this.animationSystem = animationSystem;
    this.dirtyFlags = new Set();
    this.updateThrottle = null;
  }

  // サムネイル更新（最適化）
  scheduleThrottledUpdate(cutId) { /* 300ms throttle */ }
  processDirtyThumbnails() { /* バッチ処理 */ }
  updateCutThumbnail(cutId) { /* extract.canvas()を呼ぶ */ }
  
  // Timeline描画
  refreshTimeline() { /* 全CUTのUI再構築 */ }
  renderCutElement(cut) { /* 個別CUT要素生成 */ }
  
  // イベント
  bindTimelineEvents() { /* クリック等 */ }
}
重要な最適化ポイント
javascriptupdateCutThumbnail(cutId) {
  const cut = this.layerSystem.getCut(cutId);
  
  // 差分チェック
  if (!cut.thumbnailDirty) return;
  
  // Extract実行（ここだけ）
  const canvas = this.layerSystem.renderer.extract.canvas(cut.container);
  const dataURL = canvas.toDataURL('image/png');
  
  // DOM更新
  const imgElement = document.querySelector(`[data-cut-id="${cutId}"] img`);
  if (imgElement) {
    imgElement.src = dataURL;
  }
  
  // キャッシュ保存
  cut.thumbnailCache = canvas;
  cut.thumbnailDirty = false;
}

5.4 system/history.js
責務

Undo/Redo履歴管理
CUT単位での履歴分離

改修内容
データ構造変更
javascript// 従来: 単一の履歴配列
histories: []

// 改修後: CUT別の履歴Map
histories: Map<cutId, HistoryEntry[]>
新規追加
javascriptclass HistorySystem {
  constructor(layerSystem) {
    this.layerSystem = layerSystem;
    this.histories = new Map(); // cutId -> []
    this.historyIndices = new Map(); // cutId -> index
  }

  pushState(cutId, action, data) { /* CUT別に追加 */ }
  undo(cutId) { /* 指定CUTのみ */ }
  redo(cutId) { /* 指定CUTのみ */ }
  clearHistory(cutId) { /* CUT削除時 */ }
}
既存からの変更

グローバルな履歴 → CUT別の履歴に変更
undo()/redo()にcutIdパラメータ追加


5.5 system/gif-exporter.js
責務

全CUTのRenderTexture→PNG変換
GIF生成・ダウンロード

改修内容
新規追加
javascriptclass GifExporter {
  constructor(layerSystem, animationSystem) {
    this.layerSystem = layerSystem;
    this.animationSystem = animationSystem;
  }

  async renderCutFrames() {
    const frames = [];
    const cutOrder = this.layerSystem.cutOrder;
    
    for (const cutId of cutOrder) {
      const cut = this.layerSystem.getCut(cutId);
      
      // RenderTextureから直接Canvas取得
      const canvas = this.layerSystem.renderer.extract.canvas(cut.renderTexture);
      frames.push({
        canvas: canvas,
        delay: cut.duration
      });
    }
    
    return frames;
  }

  async exportGIF(frames) { /* gif.js使用 */ }
  downloadGIF(blob, filename) { /* Blob保存 */ }
}
最適化ポイント

renderTextureから直接抽出（再レンダリング不要）
非同期処理でUI凍結を防止


5.6 core-engine.js
責務

PixiJSアプリケーション初期化
各システムのインスタンス生成
グローバル参照の管理

改修内容
初期化順序の明確化
javascriptasync function initPixiApp() {
  // 1. PixiJS Application
  const app = new PIXI.Application();
  await app.init({ /* options */ });
  
  // 2. Core Systems
  window.eventBus = new EventBus();
  window.layerSystem = new LayerSystem(app);
  window.cameraSystem = new CameraSystem(app);
  
  // 3. Feature Systems
  window.animationSystem = new AnimationSystem(layerSystem);
  window.historySystem = new HistorySystem(layerSystem);
  window.gifExporter = new GifExporter(layerSystem, animationSystem);
  
  // 4. UI
  window.timelineUI = new TimelineUI(layerSystem, animationSystem);
  window.uiPanels = new UIPanels(layerSystem, historySystem);
  
  // 5. Initialize all
  layerSystem.initialize();
  animationSystem.initialize();
  timelineUI.initialize();
  
  return app;
}

6. メソッド辞典
【6.1 LayerSystem】
■ createCut()
種別: 新規
説明: CUT作成、RenderTexture割当
パラメータ: { name, duration }
戻り値: cutId
■ getCut()
種別: 新規
説明: CUT取得
パラメータ: cutId
戻り値: CutObject
■ setActiveCut()
種別: 新規
説明: アクティブCUT切替
パラメータ: cutId
戻り値: void
■ deleteCut()
種別: 新規
説明: CUT削除
パラメータ: cutId
戻り値: void
■ renderCutToTexture()
種別: 新規
説明: CUTをRenderTextureに描画
パラメータ: cutId
戻り値: void
■ markThumbnailDirty()
種別: 新規
説明: サムネイル再生成フラグ
パラメータ: cutId
戻り値: void
■ createLayer()
種別: 改修
説明: レイヤー作成
パラメータ: cutId, { name, type }
戻り値: layerId
変更点: cutId必須化、parentId対応
■ getActiveLayer()
種別: 改修
説明: アクティブレイヤー取得
パラメータ: cutId
戻り値: LayerObject
変更点: CUT指定版に変更
■ deleteLayer()
種別: 改修
説明: レイヤー削除
パラメータ: layerId
戻り値: void
変更点: dirty更新追加
■ setLayerVisibility()
種別: 改修
説明: 表示切替
パラメータ: layerId, visible
戻り値: void
変更点: dirty更新追加
【6.2 AnimationSystem】
■ addCut()
種別: 新規
説明: CUT追加
パラメータ: options
戻り値: cutId
■ removeCut()
種別: 新規
説明: CUT削除
パラメータ: cutId
戻り値: void
■ gotoCut()
種別: 新規
説明: CUT移動
パラメータ: cutId
戻り値: void
■ nextCut()
種別: 新規
説明: 次のCUTへ
パラメータ: なし
戻り値: void
■ prevCut()
種別: 新規
説明: 前のCUTへ
パラメータ: なし
戻り値: void
■ playAnimation()
種別: 新規
説明: 再生開始
パラメータ: なし
戻り値: void
■ pauseAnimation()
種別: 新規
説明: 再生停止
パラメータ: なし
戻り値: void
【6.3 TimelineUI】
■ scheduleThrottledUpdate()
種別: 新規
説明: サムネイル更新予約（throttle）
パラメータ: cutId
戻り値: void
■ processDirtyThumbnails()
種別: 新規
説明: 予約済み更新を一括処理
パラメータ: なし
戻り値: void
■ updateCutThumbnail()
種別: 新規
説明: 単一CUTサムネイル更新
パラメータ: cutId
戻り値: void
■ refreshTimeline()
種別: 改修
説明: Timeline全体再描画
パラメータ: なし
戻り値: void
■ renderCutElement()
種別: 新規
説明: CUT要素HTML生成
パラメータ: cutObject
戻り値: HTMLElement
■ bindTimelineEvents()
種別: 改修
説明: イベントリスナー登録
パラメータ: なし
戻り値: void
【6.4 HistorySystem】
■ pushState()
種別: 改修
説明: 履歴追加（CUT別）
パラメータ: cutId, action, data
戻り値: void
■ undo()
種別: 改修
説明: Undo（CUT別）
パラメータ: cutId
戻り値: void
■ redo()
種別: 改修
説明: Redo（CUT別）
パラメータ: cutId
戻り値: void
■ clearHistory()
種別: 新規
説明: CUT削除時の履歴クリア
パラメータ: cutId
戻り値: void
■ canUndo()
種別: 改修
説明: Undo可能判定
パラメータ: cutId
戻り値: boolean
■ canRedo()
種別: 改修
説明: Redo可能判定
パラメータ: cutId
戻り値: boolean
【6.5 GifExporter】
■ renderCutFrames()
種別: 新規
説明: 全CUTをCanvas配列化
パラメータ: なし
戻り値: Promise<Frame[]>
■ exportGIF()
種別: 改修
説明: GIF生成
パラメータ: frames
戻り値: Promise<Blob>
■ downloadGIF()
種別: 継承
説明: GIFダウンロード
パラメータ: blob, filename
戻り値: void

7. 改修の優先順位と手順
Phase 1: CUT独立化（最優先）
目的: 全CUTに同じ絵が描画される問題の解決

layer-system.js改修

createCut()実装: Container + RenderTexture生成
setActiveCut()実装: Container切り替え
renderCutToTexture()実装: 描画後のテクスチャ更新


animation-system.js改修

CUT管理ロジックをlayerSystemに委譲
gotoCut()でlayerSystem.setActiveCut()を呼ぶ


検証

CUT間で絵が独立していることを確認
CUT切り替え時に正しいレイヤーが表示されることを確認



Phase 2: Timelineサムネイル最適化
目的: チラつきと左上キャンバス出現の解消

layer-system.js拡張

markThumbnailDirty()実装
thumbnailDirtyフラグ管理


timeline-ui.js改修

scheduleThrottledUpdate()実装（300ms throttle）
updateCutThumbnail()を差分更新版に書き換え
EventBus連携（cut:updatedイベント受信）


検証

描画時のチラつきが消えることを確認
サムネイル更新が適切なタイミングで行われることを確認



Phase 3: 履歴のCUT単位対応
目的: Undo/RedoがCUT別に動作する

history.js改修

historiesをMap化
pushState(), undo(), redo()にcutId追加


core-runtime.js調整

描画終了時にhistorySystem.pushState(activeCutId, ...)を呼ぶ


検証

CUT1でUndo → CUT2に影響しないことを確認



Phase 4: GIF Export最適化
目的: RenderTextureから高速エクスポート

gif-exporter.js改修

renderCutFrames()をRenderTexture使用版に書き換え


検証

全CUTが正しくGIFに含まれることを確認
エクスポート速度の向上を確認




8. 検証項目
機能検証
項目検証内容期待結果CUT独立性CUT1に描画→CUT2に移動→CUT1に戻るCUT1の絵が残っているTimeline切替CUT切替時の表示正しいCUTのレイヤーが表示されるサムネイル更新描画時のチラつきチラつきなし、左上に何も出ないサムネイル正確性Timeline画像実際の描画内容と一致Undo/RedoCUT別の履歴他CUTに影響しないGIF Export全CUT出力各CUTが独立したフレームとして出力
パフォーマンス検証
項目測定方法目標値描画レスポンスrequestAnimationFrameのfps60fps維持サムネイル更新頻度console.time測定300ms以下の間隔GIF Export時間10CUTのエクスポート時間5秒以内
互換性検証
項目確認内容既存レイヤー機能レイヤー作成・削除・可視性が動作カメラ操作Pan/Zoomが全CUTで機能ショートカットCtrl+Z等が正常動作

📌 重要な設計判断
なぜRenderTextureを使うのか？

GPU上での独立性: 各CUTが独自のGPUメモリ領域を持つ
描画効率: 毎フレーム全レイヤーを再合成せず、RenderTextureをそのまま表示
Extract最適化: RenderTextureから直接Canvas抽出可能

なぜCUTとレイヤーフォルダを同じ構造にするのか？

将来の拡張性: レイヤーフォルダ実装時にコードを再利用できる
一貫性: 階層構造の扱いが統一される
理解しやすさ: AI改修時の認知負荷が減る

throttle 300msの根拠

人間の知覚: 100ms以下の遅延は気づかれない
描画頻度: 60fpsでも16.7ms間隔なので、300msは十分な間引き
GPU負荷: extract.canvas()は重い処理なので、過度な呼び出しを防ぐ


🚨 注意事項
localStorage禁止

PixiJS v8.13環境では使用不可
全てメモリ上で管理（Session終了で消える設計）

Canvas2D使用箇所の限定

サムネイル生成時のextract.canvas()のみ許可
描画本体は必ずPixiJS（WebGL）を使用

座標系の一貫性

全ての座標はcoordinate-system.js経由で変換
Container間の親子関係に注意（CUT→Layer）


所の限定】

サムネイル生成時のextract.canvas()のみ許可
描画本体は必ずPixiJS（WebGL）を使用

【座標系の一貫性】

全ての座標はcoordinate-system.js経由で変換
Container間の親子関係に注意（CUT→Layer）

================================================================================
補足: 実装時の具体的なコード例
【LayerSystem.createCut() の実装イメージ】
createCut(options = {}) {
const id = options.id || cut_${Date.now()};
const name = options.name || Cut ${this.cuts.size + 1};
const duration = options.duration || 1000;
// Container作成
const container = new PIXI.Container();
container.label = name;
this.stage.addChild(container);
// RenderTexture作成
const renderTexture = PIXI.RenderTexture.create({
width: this.app.screen.width,
height: this.app.screen.height
});
// CUTオブジェクト作成
const cut = {
id: id,
type: 'cut',
name: name,
duration: duration,
container: container,
renderTexture: renderTexture,
layers: [],
activeLayerId: null,
visible: false,
locked: false,
thumbnailCache: null,
thumbnailDirty: true
};
this.cuts.set(id, cut);
this.cutOrder.push(id);
// デフォルトレイヤーを作成
const defaultLayerId = this.createLayer(id, { name: 'Layer 1' });
cut.activeLayerId = defaultLayerId;
return id;
}
【LayerSystem.setActiveCut() の実装イメージ】
setActiveCut(cutId) {
if (!this.cuts.has(cutId)) {
throw new Error(Cut not found: ${cutId});
}
// 既存のアクティブCUTを非表示
if (this.activeCutId) {
const oldCut = this.cuts.get(this.activeCutId);
if (oldCut) {
oldCut.container.visible = false;
}
}
// 新しいCUTを表示
const newCut = this.cuts.get(cutId);
newCut.container.visible = true;
this.activeCutId = cutId;
// イベント発火
if (window.eventBus) {
window.eventBus.emit('cut:changed', { cutId: cutId });
}
}
【LayerSystem.renderCutToTexture() の実装イメージ】
renderCutToTexture(cutId) {
const cut = this.cuts.get(cutId);
if (!cut) return;
// CUTのContainerをRenderTextureに描画
this.renderer.render({
container: cut.container,
target: cut.renderTexture,
clear: true
});
// サムネイル更新フラグを立てる
this.markThumbnailDirty(cutId);
}
【LayerSystem.markThumbnailDirty() の実装イメージ】
markThumbnailDirty(cutId) {
const cut = this.cuts.get(cutId);
if (cut) {
cut.thumbnailDirty = true;
// Timeline UIに通知
if (window.eventBus) {
  window.eventBus.emit('cut:updated', { cutId: cutId });
}
}
}
【TimelineUI.scheduleThrottledUpdate() の実装イメージ】
scheduleThrottledUpdate(cutId) {
// dirtyフラグに追加
this.dirtyFlags.add(cutId);
// 既にthrottle中なら何もしない
if (this.updateThrottle) return;
// 300ms後に実行
this.updateThrottle = setTimeout(() => {
this.processDirtyThumbnails();
this.updateThrottle = null;
}, 300);
}
【TimelineUI.processDirtyThumbnails() の実装イメージ】
processDirtyThumbnails() {
for (const cutId of this.dirtyFlags) {
this.updateCutThumbnail(cutId);
}
this.dirtyFlags.clear();
}
【TimelineUI.updateCutThumbnail() の実装イメージ】
updateCutThumbnail(cutId) {
const cut = this.layerSystem.getCut(cutId);
if (!cut) return;
// 差分チェック
if (!cut.thumbnailDirty) return;
// Extract実行（GPU → CPU転送）
const canvas = this.layerSystem.renderer.extract.canvas(cut.container);
// Canvas2D → Data URL変換
const dataURL = canvas.toDataURL('image/png');
// DOM更新
const imgElement = document.querySelector(
[data-cut-id="${cutId}"] .timeline-thumbnail
);
if (imgElement) {
imgElement.src = dataURL;
}
// キャッシュ保存とフラグクリア
cut.thumbnailCache = canvas;
cut.thumbnailDirty = false;
}
【AnimationSystem.gotoCut() の実装イメージ】
gotoCut(cutId) {
if (!this.layerSystem.cuts.has(cutId)) {
throw new Error(Cut not found: ${cutId});
}
// LayerSystemに切替を委譲
this.layerSystem.setActiveCut(cutId);
// 現在のインデックスを更新
this.currentCutIndex = this.layerSystem.cutOrder.indexOf(cutId);
}
【HistorySystem.pushState() の実装イメージ（CUT別対応）】
pushState(cutId, action, data) {
// CUT別の履歴を取得（なければ作成）
if (!this.histories.has(cutId)) {
this.histories.set(cutId, []);
this.historyIndices.set(cutId, -1);
}
const history = this.histories.get(cutId);
let index = this.historyIndices.get(cutId);
// 現在位置より後ろの履歴を削除
history.splice(index + 1);
// 新しい履歴を追加
history.push({
action: action,
data: data,
timestamp: Date.now()
});
// インデックスを進める
index = history.length - 1;
this.historyIndices.set(cutId, index);
// 履歴上限チェック（例: 50件）
if (history.length > 50) {
history.shift();
this.historyIndices.set(cutId, index - 1);
}
}
【HistorySystem.undo() の実装イメージ（CUT別対応）】
undo(cutId) {
if (!this.canUndo(cutId)) return;
const history = this.histories.get(cutId);
let index = this.historyIndices.get(cutId);
// 現在の状態を取得
const state = history[index];
// 状態を復元（actionに応じた処理）
this.restoreState(cutId, state);
// インデックスを戻す
index--;
this.historyIndices.set(cutId, index);
// 画面更新
this.layerSystem.renderCutToTexture(cutId);
}
【GifExporter.renderCutFrames() の実装イメージ】
async renderCutFrames() {
const frames = [];
const cutOrder = this.layerSystem.cutOrder;
for (const cutId of cutOrder) {
const cut = this.layerSystem.getCut(cutId);
// RenderTextureが未更新なら描画
if (cut.thumbnailDirty) {
  this.layerSystem.renderCutToTexture(cutId);
}

// RenderTextureから直接Canvas取得
const canvas = this.layerSystem.renderer.extract.canvas(cut.renderTexture);

frames.push({
  canvas: canvas,
  delay: cut.duration,
  cutId: cutId
});

// UI凍結防止のため非同期待機
await new Promise(resolve => setTimeout(resolve, 0));
}
return frames;
}
================================================================================
EventBusイベント一覧
改修に伴い新規追加・変更されるイベント
【新規追加イベント】
■ cut:created
発火元: LayerSystem.createCut()
ペイロード: { cutId }
用途: Timeline UIの更新
■ cut:deleted
発火元: LayerSystem.deleteCut()
ペイロード: { cutId }
用途: Timeline UIからCUT削除
■ cut:changed
発火元: LayerSystem.setActiveCut()
ペイロード: { cutId }
用途: レイヤーパネル・Timeline UIの同期
■ cut:updated
発火元: LayerSystem.markThumbnailDirty()
ペイロード: { cutId }
用途: Timelineサムネイル更新トリガー
【既存イベントの変更】
■ layer:created
変更点: ペイロードにcutIdを追加
新ペイロード: { layerId, cutId }
■ layer:deleted
変更点: ペイロードにcutIdを追加
新ペイロード: { layerId, cutId }
■ layer:visibility:changed
変更点: 親CUTのdirtyフラグ更新を追加
新ペイロード: { layerId, cutId, visible }
================================================================================
改修後のファイル間依存関係
core-engine.js
├─ 依存: なし
└─ 生成: app, eventBus, layerSystem, cameraSystem, animationSystem,
historySystem, gifExporter, timelineUI, uiPanels
system/layer-system.js
├─ 依存: PIXI, eventBus
└─ 使用元: animationSystem, historySystem, timelineUI, uiPanels,
core-runtime
system/animation-system.js
├─ 依存: layerSystem, eventBus
└─ 使用元: timelineUI, core-runtime
system/history.js
├─ 依存: layerSystem, eventBus
└─ 使用元: core-runtime, uiPanels
system/gif-exporter.js
├─ 依存: layerSystem, animationSystem, gif.js
└─ 使用元: uiPanels（Export実行時）
ui/timeline-ui.js
├─ 依存: layerSystem, animationSystem, eventBus
└─ 使用元: なし（UIレイヤー最上位）
ui/ui-panels.js
├─ 依存: layerSystem, historySystem, gifExporter, eventBus
└─ 使用元: なし（UIレイヤー最上位）
core-runtime.js
├─ 依存: layerSystem, animationSystem, historySystem, cameraSystem,
eventBus
└─ 使用元: なし（メインループ）
================================================================================
改修時の注意点とトラブルシューティング
【問題: CUT切替時にレイヤーが消える】
原因候補:

setActiveCut()でcontainer.visible = trueにし忘れ
Containerがstageに追加されていない
z-indexが他のCUTの下になっている

対処法:

createCut()でstage.addChild(container)を確認
setActiveCut()でvisibleフラグの設定を確認
Container.zIndexを明示的に設定

【問題: サムネイルが真っ白/真っ黒になる】
原因候補:

renderCutToTexture()が呼ばれていない
extract.canvas()の対象が空のContainer
RenderTextureのサイズが0

対処法:

描画後に必ずrenderCutToTexture()を呼ぶ
Containerに少なくとも1つのレイヤーが存在することを確認
RenderTexture作成時のwidth/heightを確認

【問題: メモリリークが発生する】
原因候補:

deleteCut()時にRenderTexture.destroy()を呼んでいない
EventBusのリスナーが解除されていない
Canvas要素がDOM上に残り続けている

対処法:

deleteCut()で以下を必ず実行:

renderTexture.destroy(true)
container.destroy({ children: true })
eventBus.off()で全リスナー解除


thumbnailCacheも明示的にnullにする

【問題: Timeline更新が遅い】
原因候補:

throttleが効いていない
毎フレームextract.canvas()が呼ばれている
大量のCUTが存在する

対処法:

scheduleThrottledUpdate()の実装を確認
updateCutThumbnail()の呼び出し回数をconsole.countで計測
CUT数が多い場合は仮想スクロール導入を検討

【問題: Undo/Redoが動作しない】
原因候補:

pushState()にcutIdを渡していない
履歴Mapが初期化されていない
復元処理が不完全

対処法:

core-runtime.jsの描画終了時にcutIdを渡しているか確認
HistorySystem.initialize()で各CUTの履歴を初期化
restoreState()の実装を確認

================================================================================
将来的な拡張への準備
【レイヤーフォルダ実装時の対応】
現在のCUT構造を踏襲することで、レイヤーフォルダは以下の変更のみで実装可能:

LayerObjectにchildrenプロパティ追加
{
id: 'folder_xxx',
type: 'folder',
name: 'Folder 1',
parentId: 'cut_xxx',
children: ['layer_yyy', 'layer_zzz'],
expanded: true,
visible: true,
locked: false
}
createFolder()メソッド追加
LayerSystem.createFolder(parentId, options)
再帰的なレンダリング処理
renderFolderRecursive(folderId)
UI側の階層表示
ui-panels.jsでインデント表示実装

【オニオンスキン実装時の対応】
RenderTextureを使用することで、オニオンスキンは比較的簡単に実装可能:

前後のCUTのRenderTextureを取得
半透明でオーバーレイ表示
カスタムシェーダーで色調変更（赤/青など）

【タイムライン再生の拡張】
現在の設計では以下が容易に実装可能:

フレーム補間（Tweening）
各CUT間で補間フレームを生成
イージング関数対応
CUT遷移時にイージング適用
ループ再生
cutOrderを循環させる

================================================================================
最終チェックリスト
Phase 1実装後:
□ createCut()が正常に動作する
□ setActiveCut()でCUTが切り替わる
□ 各CUTで独立して描画できる
□ CUT間で絵が混ざらない
Phase 2実装後:
□ 描画時のチラつきが消えた
□ 左上にキャンバスが出なくなった
□ サムネイルが正確に更新される
□ 300ms throttleが機能している
Phase 3実装後:
□ CUT別にUndo/Redoが動作する
□ 他CUTに影響しない
□ 履歴が正しく保存される
Phase 4実装後:
□ GIF Exportが高速化した
□ 全CUTが正しく出力される
□ メモリリークがない
全Phase完了後:
□ 既存機能が全て動作する
□ パフォーマンスが60fps維持
□ メモリ使用量が適切
□ コードの可読性が高い
================================================================================
終わりに
本改修計画書は、AIが改修作業を行う際の完全なガイドとして機能することを
目的としています。
各フェーズは独立しており、段階的な実装とテストが可能です。
問題が発生した場合は、本書の「改修時の注意点とトラブルシューティング」
セクションを参照してください。
改修完了後は、全ての検証項目をクリアしていることを確認してください。再試行Claudeは現在、生成したコードを実行する機能を持っていません。