# AI（Claude）向け実装ガイド - 厳格版

## 改修対象ファイル構造と責務定義

### 🎯 絶対に改修する4ファイル

#### 1. `core-engine.js`（中枢制御）
**責務**: システム統合・EventBus管理・公開API・後方互換性
```javascript
// 必ず実装すべき構造
class CoreEngine {
    constructor(app) {
        this.app = app;
        this.CONFIG = window.TEGAKI_CONFIG; // 設定統一
        this.systems = {}; // システム管理統一
    }
    
    // システム読み込み・初期化（必須）
    async initialize() {
        await this.loadSystemFiles(); // 動的読み込み
        this.setupEventBus();          // EventBus初期化
        this.setupCrossReferences();   // 相互参照設定
        this.createInitialLayers();    // 初期レイヤー作成
    }
    
    // 後方互換API（必須：main.jsから呼ばれる）
    getCameraSystem() { return this.systems.camera; }
    getLayerManager() { return this.systems.layer; }
    getDrawingEngine() { return this.systems.drawing; }
    getClipboardSystem() { return this.systems.clipboard; }
    
    // 統合制御API（必須：外部から呼ばれる）
    resizeCanvas(width, height) {
        window.Tegaki.EventBus.emit('canvas:resize', {width, height});
    }
}
```

#### 2. `systems/camera-system.js`（座標変換API）
**責務**: 座標変換・カメラ制御・DOM イベント処理
```javascript
// 必ず実装すべき座標変換API
class CameraSystem {
    /**
     * @input screen coordinates {x, y}
     * @output world coordinates {x, y}
     */
    screenToWorld(screenPt) {
        const rect = this.app.view.getBoundingClientRect();
        // CSS scale・devicePixelRatio考慮必須
        return this.worldContainer.toLocal(screenPt, this.app.stage);
    }
    
    /**
     * @input world coordinates {x, y}
     * @output canvas (canonical) coordinates {x, y}
     */
    worldToCanvas(worldPt) {
        return this.canvasContainer.toLocal(worldPt, this.worldContainer);
    }
    
    /**
     * @input screen coordinates {x, y}
     * @output canvas (canonical) coordinates {x, y}
     */
    screenToCanvas(screenPt) {
        const world = this.screenToWorld(screenPt);
        return this.worldToCanvas(world);
    }
    
    // 逆変換（必須）
    canvasToWorld(canvasPt) { /* 実装必須 */ }
    canvasToScreen(canvasPt) { /* 実装必須 */ }
}
```

#### 3. `systems/layer-system.js`（レイヤー管理）
**責務**: レイヤー管理・変形確定・パス管理
```javascript
class LayerSystem {
    // 非破壊変形確定（最重要）
    confirmLayerTransform(layerId) {
        const transform = this.layerTransforms.get(layerId);
        if (this.isIdentityTransform(transform)) return;
        
        // Matrix作成（アンカー中央必須）
        const centerX = CONFIG.canvas.width / 2;
        const centerY = CONFIG.canvas.height / 2;
        const matrix = this.buildTransformMatrix(transform, centerX, centerY);
        
        // パス座標に焼き込み（非破壊）
        layer.layerData.paths.forEach(path => {
            path.points = path.points.map(pt => matrix.apply(pt));
        });
        
        // Container transform 完全リセット（必須）
        this.layerTransforms.set(layerId, this.identityTransform());
        layer.setTransform(0, 0, 1, 1, 0);
        
        // Graphics再構築
        this.rebuildLayerGraphics(layer);
        
        // EventBus発行
        window.Tegaki.EventBus.emit('layer:transform:confirmed', {layerId});
    }
    
    // canonical座標でパス取得（必須）
    getLayerCanonicalPaths(layerId) {
        // 常にcanonical座標でパスを返す
        return layer.layerData.paths; // すでにcanonical
    }
}
```

#### 4. `systems/drawing-clipboard.js`（非破壊コピーペースト）
**責務**: 非破壊コピー&ペースト・canonical座標管理
```javascript
class ClipboardSystem {
    // 非破壊コピー（必須実装）
    copy() {
        const layerSystem = this.getLayerSystem();
        const canonicalPaths = layerSystem.getLayerCanonicalPaths(activeLayerId);
        
        // canonical座標で保存（変形適用済み座標）
        this.clipboardData = {
            paths: this.deepCopyPaths(canonicalPaths),
            metadata: { isCanonical: true, copiedAt: Date.now() }
        };
    }
    
    // canonical復元（必須実装）
    paste() {
        const layerSystem = this.getLayerSystem();
        const newLayer = layerSystem.createLayer('コピーレイヤー');
        
        // canonical座標をそのまま復元（transform初期化）
        this.clipboardData.paths.forEach(path => {
            layerSystem.addPathToLayer(newLayer, path);
        });
        
        // レイヤーtransformは初期状態
        layerSystem.layerTransforms.set(newLayer.id, identityTransform());
    }
}
```

### 🚫 絶対に触らないファイル
- `ui-panels.js`
- `core-runtime.js` 
- `config.js`
- `coordinate-system.js`
- `index.html`

## 厳格なコーディングルール

### 1. JSDoc必須
```javascript
/**
 * @input screen coordinates {x, y} - ブラウザクライアントピクセル
 * @output canvas coordinates {x, y} - キャンバス論理座標（canonical）
 */
screenToCanvas(screenPt) {
    // 実装
}
```

### 2. 座標保存の絶対ルール
```javascript
// ✅ 正しい：canonical座標で保存
path.points = [
    {x: 100, y: 200}, // canvas座標
    {x: 150, y: 250}  // canvas座標  
];

// ❌ 絶対禁止：screen/world座標で保存
path.points = [
    {x: clientX, y: clientY}, // screen座標（禁止）
    {x: worldX, y: worldY}    // world座標（禁止）
];
```

### 3. 変形確定の絶対ルール
```javascript
// ✅ 正しい：焼き込み後のContainer完全リセット
confirmLayerTransform(layerId) {
    // 1. パスに焼き込み
    layer.layerData.paths.forEach(path => {
        path.points = path.points.map(pt => matrix.apply(pt));
    });
    
    // 2. Container完全リセット（必須）
    layer.setTransform(0, 0, 1, 1, 0);
    this.layerTransforms.set(layerId, identityTransform());
    
    // 3. Graphics再構築
    this.rebuildLayerGraphics(layer);
}

// ❌ 絶対禁止：Container transform残し
confirmLayerTransform(layerId) {
    // Container.transformを残すと二重適用で消失
    layer.scale.set(1.5, 1.5); // 禁止
}
```

### 4. EventBus使用の絶対ルール
```javascript
// ✅ 正しい：EventBusで疎結合
window.Tegaki.EventBus.emit('layer:transform:confirmed', {
    layerId: 'layer_001',
    layerIndex: 2
});

window.Tegaki.EventBus.on('layer:transform:confirmed', (data) => {
    this.updateThumbnail(data.layerIndex);
});

// ❌ 禁止：直接参照による密結合
this.layerManager.updateThumbnail(layerIndex); // 禁止
```

### 5. CONFIG参照統一ルール
```javascript
// ✅ 正しい：統一されたCONFIG参照
const CONFIG = window.TEGAKI_CONFIG;
const centerX = CONFIG.canvas.width / 2;
const centerY = CONFIG.canvas.height / 2;

// ❌ 禁止：複数のCONFIG参照混在
const config1 = window.CONFIG; // 禁止
const config2 = this.config;   // 禁止
```

### 6. デバッグログ制限ルール
```javascript
// ✅ 正しい：CONFIG.debug下のみ
if (CONFIG.debug) {
    console.log('Layer transform confirmed:', layerId);
}

// ❌ 禁止：無条件ログ出力
console.log('Debug message'); // 禁止
```

## PixiJS v8.13 厳格仕様

### Container Transform操作
```javascript
// ✅ 正しい：PixiJS v8.13対応
container.position.set(x, y);
container.scale.set(scaleX, scaleY);
container.rotation = rotation;
container.pivot.set(pivotX, pivotY);

// 座標変換
const localPoint = container.toLocal(globalPoint, parentContainer);
const globalPoint = container.toGlobal(localPoint);

// ❌ 禁止：古いバージョンのAPI
container.transform.position = {x, y}; // v7以前（禁止）
```

### Graphics作成・描画
```javascript
// ✅ 正しい：v8.13の描画API
const graphics = new PIXI.Graphics();
graphics.circle(x, y, radius);
graphics.fill({color: 0xff0000, alpha: 0.8});

graphics.rect(x, y, width, height);
graphics.stroke({width: 2, color: 0x000000});

// ❌ 禁止：古いAPI
graphics.beginFill(0xff0000); // v7以前（禁止）
graphics.drawCircle(x, y, radius); // v7以前（禁止）
```

## 必須実装パターン

### 1. システム登録パターン
```javascript
// systems/xxx-system.js の末尾
(function() {
    'use strict';
    
    class XxxSystem {
        // 実装
    }
    
    // 必須：TegakiSystemsに登録
    window.TegakiSystems.Register('XxxSystem', XxxSystem);
    
    console.log('✅ xxx-system.js loaded');
})();
```

### 2. 座標変換統一パターン
```javascript
// 描画時の座標変換（必須パターン）
startDrawing(screenX, screenY) {
    // 必ず統一APIを使用
    const canvasPoint = this.cameraSystem.screenToCanvas({x: screenX, y: screenY});
    
    // canonical座標でパス保存
    this.currentPath = {
        points: [canvasPoint], // canonical座標
        color: this.brushColor,
        size: this.brushSize
    };
}
```

### 3. 変形確定統一パターン
```javascript
// 変形確定の必須パターン
confirmLayerTransform(layerId) {
    const layer = this.getLayerById(layerId);
    const transform = this.layerTransforms.get(layerId);
    
    // 1. Matrix作成（中央アンカー）
    const matrix = this.createTransformMatrix(transform);
    
    // 2. パス座標焼き込み（非破壊）
    const transformedPaths = layer.layerData.paths.map(path => ({
        ...path,
        points: path.points.map(pt => matrix.apply(pt))
    }));
    
    // 3. Container完全リセット
    layer.setTransform(0, 0, 1, 1, 0);
    layer.removeChildren();
    this.layerTransforms.set(layerId, this.identityTransform());
    
    // 4. データ更新・Graphics再構築
    layer.layerData.paths = transformedPaths;
    this.rebuildLayerGraphics(layer);
    
    // 5. EventBus発行
    window.Tegaki.EventBus.emit('layer:transform:confirmed', {layerId});
}
```

### 4. Clipboard統一パターン
```javascript
// 非破壊コピーの必須パターン
copy() {
    const layerSystem = this.getLayerSystem();
    const activeLayer = layerSystem.getActiveLayer();
    
    // canonical座標でパス取得
    const canonicalPaths = layerSystem.getLayerCanonicalPaths(activeLayer.id);
    
    // transform適用済みの最終座標として保存
    this.clipboardData = {
        paths: this.deepCopyPaths(canonicalPaths),
        metadata: {
            isCanonical: true,
            copiedAt: Date.now(),
            originalLayerId: activeLayer.id
        }
    };
    
    console.log('Non-destructive copy completed');
}

// canonical復元の必須パターン  
paste() {
    if (!this.clipboardData?.paths) return;
    
    const layerSystem = this.getLayerSystem();
    const newLayer = layerSystem.createLayer('コピーレイヤー');
    
    // canonical座標をそのまま復元
    this.clipboardData.paths.forEach(path => {
        const restoredPath = this.deepCopyPath(path);
        newLayer.layerData.paths.push(restoredPath);
        layerSystem.rebuildPathGraphics(restoredPath);
        newLayer.addChild(restoredPath.graphics);
    });
    
    // transform初期化
    layerSystem.layerTransforms.set(newLayer.id, layerSystem.identityTransform());
    
    console.log('Canonical paste completed');
}
```

## 絶対に避けるべき実装ミス

### ❌ 致命的ミス1：座標系混在
```javascript
// 絶対禁止：座標系を混在させる
startDrawing(screenX, screenY) {
    // screenそのまま保存（禁止）
    this.currentPath.points.push({x: screenX, y: screenY});
}

// 絶対禁止：world座標で保存
addPoint(worldX, worldY) {
    // world座標で保存（禁止）
    this.currentPath.points.push({x: worldX, y: worldY});
}
```

### ❌ 致命的ミス2：Container transform残し
```javascript
// 絶対禁止：変形確定でContainer transform残す
confirmLayerTransform(layerId) {
    // パスに適用だけしてContainer残す（禁止）
    this.applyTransformToPaths(layerId);
    // layer.setTransform(0,0,1,1,0); ← これを忘れると二重適用で消失
}
```

### ❌ 致命的ミス3：見かけ座標でClipboard
```javascript
// 絶対禁止：表示状態（見かけ）でコピー
copy() {
    const displayPaths = this.getDisplayPaths(); // 表示座標（禁止）
    this.clipboardData = {paths: displayPaths};
}
```

### ❌ 致命的ミス4：直接参照による密結合
```javascript
// 絶対禁止：直接参照でシステム連携
updateLayer() {
    this.layerManager.updateThumbnail(); // 直接参照（禁止）
    this.cameraSystem.redraw();          // 直接参照（禁止）
}
```

## 必須テストケース（実装後チェック）

### 1. 座標変換テスト
```javascript
// 手動テスト：ペン描画位置確認
// 1. キャンバス中央をクリック
// 2. 描画位置がクリック位置と一致するか確認
// 3. カメラ移動・拡縮後も位置が正確か確認
```

### 2. 変形確定テスト
```javascript
// 手動テスト：レイヤー変形確定
// 1. レイヤー移動・回転・拡縮
// 2. V キー解除で確定
// 3. 絵が消失せず位置が正確か確認
// 4. 確定後の再変形が正常か確認
```

### 3. コピーペーストテスト
```javascript
// 手動テスト：非破壊コピーペースト
// 1. 変形中レイヤーでCtrl+C
// 2. Ctrl+V で復元
// 3. 見た目が同一で位置が正確か確認
// 4. 複数回ペーストが正常か確認
```

## EventBus契約定義

### 必須イベント定義
```javascript
// layer:transform:confirmed - レイヤー変形確定時
{
    layerId: 'layer_001',
    layerIndex: 2
}

// layer:paths:changed - レイヤーパス変更時
{
    layerId: 'layer_001',
    pathCount: 5
}

// camera:resize - キャンバスリサイズ時
{
    width: 1920,
    height: 1080
}

// clipboard:copied - クリップボードコピー時
{
    layerId: 'layer_001',
    pathCount: 3,
    isCanonical: true
}

// layer:order:changed - レイヤー順序変更時
{
    layerId: 'layer_001',
    oldIndex: 2,
    newIndex: 1
}
```

## ファイル間依存関係マップ

```mermaid
graph TD
    A[core-engine.js] --> B[systems/camera-system.js]
    A --> C[systems/layer-system.js] 
    A --> D[systems/drawing-clipboard.js]
    
    B --> E[EventBus]
    C --> E
    D --> E
    
    A --> F[CONFIG統一]
    B --> F
    C --> F
    D --> F
    
    G[ui-panels.js] -.-> E
    H[main.js] --> A
```

### 依存関係ルール
1. **core-engine.js**: 他3システムに依存、統合制御
2. **systems/*.js**: core-engineに依存、相互にはEventBus経由のみ
3. **外部ファイル**: EventBus購読可、直接参照禁止

## 実装完了チェックリスト

### Phase A完了確認
- [ ] CameraSystem.screenToCanvas() で正確な座標変換
- [ ] DrawingEngine で canonical 座標保存
- [ ] LayerSystem.confirmLayerTransform() で非破壊確定
- [ ] ClipboardSystem で canonical コピーペースト
- [ ] 全座標変換関数に @input/@output 注記
- [ ] Container transform 完全リセット実装

### Phase B完了確認
- [ ] rebuildPathGraphics() で position {0,0} 固定
- [ ] EventBus 契約定義・実装
- [ ] レイヤー階層移動 API 実装
- [ ] UI 同期の EventBus 対応

### Phase C完了確認
- [ ] キャンバスリサイズ対応
- [ ] サムネイル更新システム
- [ ] テストケース自動化

この厳格なガイドに従って実装することで、座標系統一と非破壊変形確定を完全に実現し、phase1b4と同等以上の機能を4ファイル分割構成で提供できます。