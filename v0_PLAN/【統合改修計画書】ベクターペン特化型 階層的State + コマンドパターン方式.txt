================================================================================
【統合改修計画書】ベクターペン特化型 階層的State + コマンドパターン方式
================================================================================

【改修の核心理念】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
現状: PixiJSオブジェクト直接操作 + Canvas全体スナップショット
改修: 階層的State管理 + 軽量コマンド記録
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【設計思想】
1. State構造の階層化: timeline → frames → layers → strokes
2. 操作履歴の軽量化: コマンドパターンで差分記録
3. PixiJS同期の効率化: 必要な部分のみ更新、全再描画しない
4. 将来拡張への準備: フレーム構造でアニメーション対応可能


================================================================================
■ 1. 全体アーキテクチャ概要
================================================================================

┌─────────────────────────────────────────────────────────────┐
│                         UI Layer                             │
│  ┌─────────┐  ┌─────────┐  ┌──────────┐  ┌─────────┐     │
│  │Timeline │  │ Layer   │  │ Drawing  │  │ToolBar  │     │
│  │   UI    │  │  Panel  │  │  Canvas  │  │         │     │
│  └────┬────┘  └────┬────┘  └────┬─────┘  └────┬────┘     │
└───────┼────────────┼────────────┼─────────────┼───────────┘
        │            │            │             │
        └────────────┴────────────┴─────────────┘
                     │
                     ▼
        ┌────────────────────────┐
        │      EventBus          │  イベント駆動通信
        │  (優先度付きリスナー)   │
        └────────────────────────┘
                     │
        ┌────────────┴────────────┐
        │                         │
        ▼                         ▼
┌──────────────┐          ┌──────────────┐
│ StateManager │◄────────►│   History    │
│ (階層State)  │          │ (コマンド管理)│
└──────┬───────┘          └──────────────┘
       │
       │ state.timeline.frames[i].layers[j].strokes[]
       │
       ▼
┌──────────────────────────────────────────┐
│           PixiJS Rendering Layer          │
│  ┌────────────────────────────────────┐  │
│  │  Stage                             │  │
│  │   └─ Frame Container               │  │
│  │        └─ Layer Container          │  │
│  │             └─ Graphics (strokes)  │  │
│  └────────────────────────────────────┘  │
└──────────────────────────────────────────┘


【データフロー】
1. ユーザー操作 → EventBus発火
2. StateManager が state を更新
3. Command 生成 → Command.do() 実行
4. History.push(Command)
5. PixiJS差分更新（必要な部分のみ）

Undo: History.undo() → Command.undo() → state巻き戻し → PixiJS差分更新
Redo: History.redo() → Command.do() → state進める → PixiJS差分更新


================================================================================
■ 2. State構造定義
================================================================================

【完全な型定義】
const state = {
    timeline: {
        currentFrameId: "frame_001",  // 現在表示中のフレームID
        frames: [
            {
                id: "frame_001",          // ユニークID
                name: "Frame 1",          // 表示名
                duration: 1,              // フレーム長（将来のアニメーション用）
                layers: [
                    {
                        id: "layer_001",      // ユニークID
                        name: "Layer 1",      // 表示名
                        type: "vector",       // "vector" | "raster"
                        visible: true,        // 表示/非表示
                        opacity: 1.0,         // 不透明度 (0.0 - 1.0)
                        locked: false,        // ロック状態
                        transform: {
                            x: 0,
                            y: 0,
                            scaleX: 1.0,
                            scaleY: 1.0,
                            rotation: 0
                        },
                        strokes: [            // ベクターパス配列
                            {
                                id: "stroke_001",
                                tool: "pen",      // "pen" | "eraser" | "brush"
                                color: "#ff0000",
                                width: 2,
                                opacity: 1.0,
                                points: [
                                    {x: 0, y: 0},
                                    {x: 50, y: 20}
                                ],
                                isComplete: true
                            }
                        ],
                        bitmap: null          // ラスター用（将来実装）
                    }
                ]
            }
        ]
    },
    
    ui: {
        activeLayerIndex: 0,      // 現在選択中のレイヤーindex
        selectedTool: "pen",
        brushSize: 2,
        brushColor: "#000000",
        brushOpacity: 1.0
    }
};

【重要な設計原則】
✓ 全stateはJSONシリアライズ可能（PixiJSオブジェクト参照を含まない）
✓ IDは文字列型で統一（"frame_001", "layer_001", "stroke_001"）
✓ PixiJSオブジェクトはstateから再構築可能（state = Source of Truth）
✓ 循環参照禁止（structuredClone可能な構造）


================================================================================
■ 3. Phase別改修計画
================================================================================

【全体スケジュール】
Phase 1: History.js コマンドパターン化          [最重要 - Undo/Redo安定化]
Phase 2: StateManager 階層構造導入             [State一元管理]
Phase 3: LayerSystem 階層State対応             [既存機能の移行]
Phase 4: CoreEngine 描画コマンド化              [描画履歴の安定化]
Phase 5: Timeline機能追加                      [フレーム管理]
Phase 6: 統合テスト + 最適化                    [品質保証]


================================================================================
■ Phase 1: system/history.js - コマンドパターン完全移行
================================================================================

【目的】
- Undo/Redoの不整合を根本解決
- 軽量な操作記録方式に変更
- 再入防止の完全実装

【現状の問題】
問題1: saveState() がCanvas全体をスナップショット保存
  → メモリ肥大化（1操作で数MB）
  → ベクターパス情報が失われる

問題2: currentIndex の定義が曖昧
  → 「最後に適用済み」か「次に適用する」か不明
  → Undo 1回目が無反応になる原因

問題3: 再入防止が不完全
  → Undo/Redo中にイベントが発火して履歴破損

【改修内容】

class History {
    constructor() {
        this.stack = [];           // コマンド配列
        this.index = -1;           // 最後に適用済みのindex（初期値-1）
        this.isApplying = false;   // 再入防止フラグ
        this.maxSize = 500;        // 履歴保持上限
    }

    /**
     * コマンドを履歴に追加して実行
     * @param {Object} command - { name, do, undo, meta? }
     */
    push(command) {
        // 再入防止
        if (this.isApplying) {
            return;
        }
        
        // 検証
        if (!this._validateCommand(command)) {
            console.error('[History] Invalid command structure:', command);
            return;
        }

        try {
            this.isApplying = true;
            
            // 分岐した履歴を破棄（Redo不可能な未来を削除）
            this.stack.splice(this.index + 1);
            
            // コマンド実行
            command.do();
            
            // 履歴に追加
            this.stack.push(command);
            this.index++;
            
            // 上限チェック
            if (this.stack.length > this.maxSize) {
                this.stack.shift();
                this.index--;
            }
            
            // UI更新通知
            this._notifyHistoryChanged();
            
        } catch (error) {
            console.error('[History] Command execution failed:', error);
            // 失敗したコマンドは履歴に追加しない
            this.stack.splice(this.index + 1);
        } finally {
            this.isApplying = false;
        }
    }

    /**
     * 1つ前の状態に戻す
     */
    undo() {
        if (!this.canUndo() || this.isApplying) {
            return;
        }
        
        try {
            this.isApplying = true;
            
            const command = this.stack[this.index];
            command.undo();
            this.index--;
            
            this._notifyHistoryChanged();
            
        } catch (error) {
            console.error('[History] Undo failed:', error);
            // エラー時はindexを戻さない（整合性維持）
        } finally {
            this.isApplying = false;
        }
    }

    /**
     * 1つ先の状態に進む
     */
    redo() {
        if (!this.canRedo() || this.isApplying) {
            return;
        }
        
        try {
            this.isApplying = true;
            
            this.index++;
            const command = this.stack[this.index];
            command.do();
            
            this._notifyHistoryChanged();
            
        } catch (error) {
            console.error('[History] Redo failed:', error);
            this.index--; // 失敗したら戻す
        } finally {
            this.isApplying = false;
        }
    }

    /**
     * Undo可能か判定
     */
    canUndo() {
        return this.index >= 0;
    }

    /**
     * Redo可能か判定
     */
    canRedo() {
        return this.index < this.stack.length - 1;
    }

    /**
     * 履歴をクリア
     */
    clear() {
        this.stack = [];
        this.index = -1;
        this._notifyHistoryChanged();
    }

    /**
     * 複合コマンド生成（複数操作を1つのUndoにまとめる）
     * @param {Array} commands - コマンド配列
     * @param {String} name - 複合コマンド名
     */
    createComposite(commands, name = 'composite') {
        return {
            name: name,
            do: () => {
                commands.forEach(cmd => cmd.do());
            },
            undo: () => {
                // 逆順でundo（後入れ先出し）
                commands.slice().reverse().forEach(cmd => cmd.undo());
            },
            meta: {
                type: 'composite',
                count: commands.length
            }
        };
    }

    /**
     * コマンド構造の検証
     * @private
     */
    _validateCommand(command) {
        return (
            command &&
            typeof command.name === 'string' &&
            typeof command.do === 'function' &&
            typeof command.undo === 'function'
        );
    }

    /**
     * 履歴変更イベント発火
     * @private
     */
    _notifyHistoryChanged() {
        if (window.EventBus) {
            EventBus.emit('history:changed', {
                canUndo: this.canUndo(),
                canRedo: this.canRedo(),
                stackSize: this.stack.length,
                currentIndex: this.index
            });
        }
    }

    /**
     * デバッグ用: 履歴スタックの状態表示
     */
    debug() {
        console.log('[History] Stack:', this.stack.map(cmd => cmd.name));
        console.log('[History] Index:', this.index);
        console.log('[History] Can Undo:', this.canUndo());
        console.log('[History] Can Redo:', this.canRedo());
    }
}

// グローバルインスタンス生成
const History = new History();
window.History = History;

【削除するAPI】
❌ saveState() - 完全削除
❌ restoreState() - 完全削除
❌ window.History._manager - 存在しないプロパティへの参照削除

【追加するAPI】
✅ push(command) - コマンド記録と実行
✅ undo() - 1つ戻る
✅ redo() - 1つ進む
✅ canUndo() - Undo可能か
✅ canRedo() - Redo可能か
✅ clear() - 履歴クリア
✅ createComposite(commands, name) - 複合コマンド生成
✅ debug() - デバッグ出力

【コマンド構造の例】

// 例1: ストローク描画
const drawCommand = {
    name: 'draw-stroke',
    do: () => {
        // 既にpaths配列に追加済みなので何もしない
    },
    undo: () => {
        const layer = getLayerById(layerId);
        const strokeIndex = layer.strokes.findIndex(s => s.id === strokeId);
        if (strokeIndex !== -1) {
            layer.strokes.splice(strokeIndex, 1);
            // PixiJSグラフィックスを削除
            destroyStrokeGraphics(strokeId);
        }
    },
    meta: { type: 'stroke', layerId, strokeId }
};

// 例2: レイヤー作成
const createLayerCommand = {
    name: 'create-layer',
    do: () => {
        const layer = createNewLayer(layerId, layerName);
        state.timeline.frames[0].layers.push(layer);
        renderLayer(layer);
    },
    undo: () => {
        const layerIndex = findLayerIndexById(layerId);
        state.timeline.frames[0].layers.splice(layerIndex, 1);
        destroyLayerGraphics(layerId);
    },
    meta: { type: 'layer', layerId }
};

// 例3: 複合コマンド（複数ストロークを1度にUndo）
const compositeCommand = History.createComposite([
    drawCommand1,
    drawCommand2,
    drawCommand3
], 'multi-stroke');

【テスト項目】
□ push → canUndo() が true になる
□ push → undo → canRedo() が true になる
□ push → undo → redo → 元に戻る
□ 連続push → undo複数回 → 順番に戻る
□ push → undo → 新しいpush → 分岐履歴が破棄される
□ 再入防止: undo中にpush → 無視される
□ 上限超過: maxSize+1個push → 古い履歴が削除される
□ 例外発生: command.do()でエラー → 履歴に追加されない
□ 複合コマンド: composite → undo → 全て戻る


================================================================================
■ Phase 2: system/state-manager.js - 階層構造導入
================================================================================

【目的】
- State構造を timeline → frames → layers → strokes に階層化
- 全stateを一元管理してデータ散在を防ぐ
- PixiJSオブジェクトとstateを分離

【現状の問題】
問題1: 状態が各ファイルに散在
  → LayerSystem.layers, DrawingEngine.currentPath など
  → 整合性の保証が困難

問題2: PixiJSオブジェクトがstate扱い
  → PIXI.Container を直接参照して状態取得
  → JSONシリアライズ不可能

問題3: 単一フレーム構造
  → アニメーション対応が困難

【改修内容】

class StateManager {
    constructor() {
        this.state = this._createInitialState();
        this._nextId = {
            frame: 1,
            layer: 1,
            stroke: 1
        };
    }

    /**
     * 初期state生成
     * @private
     */
    _createInitialState() {
        const initialFrameId = this._generateId('frame');
        const initialLayerId = this._generateId('layer');
        
        return {
            timeline: {
                currentFrameId: initialFrameId,
                frames: [
                    {
                        id: initialFrameId,
                        name: 'Frame 1',
                        duration: 1,
                        layers: [
                            {
                                id: initialLayerId,
                                name: 'Layer 1',
                                type: 'vector',
                                visible: true,
                                opacity: 1.0,
                                locked: false,
                                transform: {
                                    x: 0,
                                    y: 0,
                                    scaleX: 1.0,
                                    scaleY: 1.0,
                                    rotation: 0
                                },
                                strokes: [],
                                bitmap: null
                            }
                        ]
                    }
                ]
            },
            ui: {
                activeLayerIndex: 0,
                selectedTool: 'pen',
                brushSize: 2,
                brushColor: '#000000',
                brushOpacity: 1.0
            }
        };
    }

    /**
     * 現在のフレームを取得
     */
    getCurrentFrame() {
        return this.state.timeline.frames.find(
            f => f.id === this.state.timeline.currentFrameId
        );
    }

    /**
     * 現在のレイヤーを取得
     */
    getCurrentLayer() {
        const frame = this.getCurrentFrame();
        if (!frame) return null;
        return frame.layers[this.state.ui.activeLayerIndex];
    }

    /**
     * IDでレイヤーを検索
     */
    getLayerById(layerId) {
        for (const frame of this.state.timeline.frames) {
            const layer = frame.layers.find(l => l.id === layerId);
            if (layer) return layer;
        }
        return null;
    }

    /**
     * IDでストロークを検索
     */
    getStrokeById(strokeId) {
        for (const frame of this.state.timeline.frames) {
            for (const layer of frame.layers) {
                const stroke = layer.strokes.find(s => s.id === strokeId);
                if (stroke) return stroke;
            }
        }
        return null;
    }

    /**
     * ストロークを追加（履歴記録付き）
     */
    addStroke(strokeData) {
        const layer = this.getCurrentLayer();
        if (!layer) {
            console.error('[StateManager] No active layer');
            return null;
        }

        const strokeId = this._generateId('stroke');
        const stroke = {
            id: strokeId,
            ...strokeData
        };

        const command = {
            name: 'draw-stroke',
            do: () => {
                layer.strokes.push(stroke);
                EventBus.emit('stroke:added', { layerId: layer.id, stroke });
            },
            undo: () => {
                const index = layer.strokes.findIndex(s => s.id === strokeId);
                if (index !== -1) {
                    layer.strokes.splice(index, 1);
                    EventBus.emit('stroke:removed', { layerId: layer.id, strokeId });
                }
            },
            meta: { type: 'stroke', layerId: layer.id, strokeId }
        };

        History.push(command);
        return stroke;
    }

    /**
     * レイヤーを追加（履歴記録付き）
     */
    addLayer(name = null) {
        const frame = this.getCurrentFrame();
        if (!frame) return null;

        const layerId = this._generateId('layer');
        const layerName = name || `Layer ${this._nextId.layer}`;
        
        const layer = {
            id: layerId,
            name: layerName,
            type: 'vector',
            visible: true,
            opacity: 1.0,
            locked: false,
            transform: { x: 0, y: 0, scaleX: 1.0, scaleY: 1.0, rotation: 0 },
            strokes: [],
            bitmap: null
        };

        const command = {
            name: 'create-layer',
            do: () => {
                frame.layers.push(layer);
                this.state.ui.activeLayerIndex = frame.layers.length - 1;
                EventBus.emit('layer:created', { frameId: frame.id, layer });
            },
            undo: () => {
                const index = frame.layers.findIndex(l => l.id === layerId);
                if (index !== -1) {
                    frame.layers.splice(index, 1);
                    this.state.ui.activeLayerIndex = Math.min(
                        this.state.ui.activeLayerIndex,
                        frame.layers.length - 1
                    );
                    EventBus.emit('layer:removed', { frameId: frame.id, layerId });
                }
            },
            meta: { type: 'layer', layerId }
        };

        History.push(command);
        return layer;
    }

    /**
     * レイヤーを削除（履歴記録付き）
     */
    removeLayer(layerId) {
        const frame = this.getCurrentFrame();
        if (!frame || frame.layers.length <= 1) return false;

        const layerIndex = frame.layers.findIndex(l => l.id === layerId);
        if (layerIndex === -1) return false;

        const layerSnapshot = structuredClone(frame.layers[layerIndex]);

        const command = {
            name: 'delete-layer',
            do: () => {
                frame.layers.splice(layerIndex, 1);
                this.state.ui.activeLayerIndex = Math.min(
                    this.state.ui.activeLayerIndex,
                    frame.layers.length - 1
                );
                EventBus.emit('layer:removed', { frameId: frame.id, layerId });
            },
            undo: () => {
                frame.layers.splice(layerIndex, 0, layerSnapshot);
                this.state.ui.activeLayerIndex = layerIndex;
                EventBus.emit('layer:restored', { frameId: frame.id, layer: layerSnapshot });
            },
            meta: { type: 'layer-delete', layerId }
        };

        History.push(command);
        return true;
    }

    /**
     * UIプロパティを更新（履歴記録なし）
     */
    setUIProperty(key, value) {
        this.state.ui[key] = value;
        EventBus.emit('ui:property-changed', { key, value });
    }

    /**
     * アクティブレイヤーを変更（履歴記録なし）
     */
    setActiveLayerIndex(index) {
        const frame = this.getCurrentFrame();
        if (!frame || index < 0 || index >= frame.layers.length) {
            return false;
        }
        this.state.ui.activeLayerIndex = index;
        EventBus.emit('layer:active-changed', { index });
        return true;
    }

    /**
     * State全体を取得（読み取り専用）
     */
    getState() {
        return this.state;
    }

    /**
     * State全体を置き換え（JSON読み込み用）
     */
    setState(newState) {
        this.state = structuredClone(newState);
        EventBus.emit('state:replaced', this.state);
    }

    /**
     * ID生成
     * @private
     */
    _generateId(type) {
        const id = `${type}_${String(this._nextId[type]).padStart(3, '0')}`;
        this._nextId[type]++;
        return id;
    }

    /**
     * デバッグ用
     */
    debug() {
        console.log('[StateManager] State:', this.state);
        console.log('[StateManager] Current Frame:', this.getCurrentFrame());
        console.log('[StateManager] Current Layer:', this.getCurrentLayer());
    }
}

// グローバルインスタンス生成
const StateManager = new StateManager();
window.StateManager = StateManager;

【追加するAPI】
✅ getCurrentFrame() - 現在のフレーム取得
✅ getCurrentLayer() - 現在のレイヤー取得
✅ getLayerById(layerId) - IDでレイヤー検索
✅ getStrokeById(strokeId) - IDでストローク検索
✅ addStroke(strokeData) - ストローク追加（履歴付き）
✅ addLayer(name) - レイヤー追加（履歴付き）
✅ removeLayer(layerId) - レイヤー削除（履歴付き）
✅ setUIProperty(key, value) - UI状態更新（履歴なし）
✅ setActiveLayerIndex(index) - アクティブレイヤー変更（履歴なし）
✅ getState() - State全体取得
✅ setState(newState) - State全体置き換え

【イベント定義】
stroke:added - { layerId, stroke }
stroke:removed - { layerId, strokeId }
layer:created - { frameId, layer }
layer:removed - { frameId, layerId }
layer:restored - { frameId, layer }
layer:active-changed - { index }
ui:property-changed - { key, value }
state:replaced - state全体

【テスト項目】
□ 初期state生成 → frame 1個、layer 1個が存在
□ getCurrentFrame() → 正しいフレーム取得
□ getCurrentLayer() → 正しいレイヤー取得
□ addStroke() → layer.strokes に追加される
□ addStroke() → undo → strokes から削除される
□ addLayer() → layers に追加される
□ addLayer() → undo → layers から削除される
□ removeLayer() → layers から削除される
□ removeLayer() → undo → 元の位置に復元される


================================================================================
■ Phase 3: system/layer-system.js - 既存機能の階層State対応
================================================================================

【目的】
- 既存のlayer-system.jsをStateManager連携に改修
- PixiJSオブジェクト管理は維持、stateと同期
- 最小限の変更で互換性維持

【改修方針】
1. layers配列をStateManager.state.timeline.frames[0].layers に統合
2. 既存のPixiJS操作コードは維持
3. レイヤー操作時にStateManager経由でHistory記録

【改修対象メソッド】
createLayer() - StateManager.addLayer() を呼ぶように変更
deleteLayer() - StateManager.removeLayer() を呼ぶように変更
getActiveLayer() - StateManager.getCurrentLayer() を呼ぶように変更
reorderLayers() - コマンドパターン対応

【詳細は次Phase提出時に記載】


================================================================================
■ Phase 4: core-engine.js - 描画コマンド化
================================================================================

【目的】
- 描画完了時にStateManager.addStroke()を呼ぶ
- 既存のsaveState()呼び出しを削除

【改修対象】
DrawingEngine.stopDrawing() - StateManager連携
CoreEngine.setupSystemEventIntegration() - layer:clear-active 対応

【詳細は次Phase提出時に記載】


================================================================================
■ Phase 5: Timeline機能追加（将来実装）
================================================================================

【目的】
- 複数フレーム管理機能の追加
- フレーム切り替えでアニメーション表示

【追加機能】
StateManager.addFrame() - フレーム追加
StateManager.removeFrame() - フレーム削除
StateManager.setCurrentFrame(frameId) - フレーム切り替え

【詳細は将来フェーズで計画】


================================================================================
■ Phase 6: 統合テスト + 最適化
================================================================================

【テストシナリオ】
1. 描画→Undo→Redo の完全動作確認
2. レイヤー操作の全パターン確認
3. 複合操作（描画+レイヤー移動+削除）の整合性確認
4. パフォーマンス測定（メモリ使用量、応答速度）

【詳細は全Phase完了後に実施】




- stateが正


================================================================================
■ 改修時の注意事項
================================================================================

【PixiJSオブジェクトとstateの関係】
state.timeline.frames[0].layers[0].strokes[0]  ← データ（Source of Truth）
     ↓ 同期
PIXI.Graphics                                  ← 描画オブジェクト（再構築可能）

重要原則:
✓ stateが常に正（Single Source of Truth）
✓ PixiJSオブジェクトはstateから再構築可能
✓ stateにPixiJSオブジェクト参照を含めない（JSONシリアライズ可能に保つ）
✓ Undo/Redo時はstateを変更 → PixiJS同期（逆はダメ）

【コマンド設計のベストプラクティス】
1. do()とundo()は対称に設計
   do() で追加したものは undo() で削除
   do() で削除したものは undo() で復元

2. 冪等性を保つ
   do() → undo() → do() を何度繰り返しても同じ結果

3. 例外安全性
   do() 内で例外が発生しても state が破壊されない設計

4. メタ情報を記録
   meta: { type, layerId, strokeId } でデバッグが容易に

【悪い例】
const badCommand = {
    name: 'bad-example',
    do: () => {
        // PixiJSオブジェクトを直接操作（stateと同期しない）
        container.addChild(graphics);
    },
    undo: () => {
        // 何を削除すべきか不明
        container.removeChild(???);
    }
};

【良い例】
const goodCommand = {
    name: 'good-example',
    do: () => {
        // 1. stateを更新
        layer.strokes.push(stroke);
        // 2. PixiJSを同期
        const graphics = createGraphicsFromStroke(stroke);
        container.addChild(graphics);
        // 3. 参照を保持（undo用）
        stroke._graphics = graphics;
    },
    undo: () => {
        // 1. stateから削除
        const index = layer.strokes.findIndex(s => s.id === strokeId);
        layer.strokes.splice(index, 1);
        // 2. PixiJSを同期
        container.removeChild(stroke._graphics);
        stroke._graphics.destroy();
    },
    meta: { type: 'stroke', strokeId }
};


【イベント駆動設計】
EventBus.emit() のタイミング:
✓ state変更後に発火（変更前ではない）
✓ PixiJS更新後に発火（更新前ではない）
✓ History.push() 内では発火しない（再入防止）

イベント命名規則:
<対象>:<動作>  例: "stroke:added", "layer:removed"

イベントペイロード:
{
    layerId: "layer_001",    // どのレイヤーか
    strokeId: "stroke_001",  // どのストロークか
    stroke: { ... }          // 必要ならデータ全体
}


【再入防止の重要性】
History.isApplying = true の間は:
✓ History.push() を呼んでも無視される
✓ StateManager経由の操作も履歴記録されない
✓ イベント発火は許可（UI更新は必要）

悪い例:
EventBus.on('stroke:added', (data) => {
    // Undo/Redo中に新しい履歴が作られてしまう
    History.push(someCommand);
});

良い例:
EventBus.on('stroke:added', (data) => {
    // 再入チェック
    if (History.isApplying) return;
    // 通常操作のみ履歴記録
    History.push(someCommand);
});


【メモリ管理】
structuredClone() の使用:
✓ レイヤー削除時のスナップショット保存に使用
✓ 大きなデータ（数千ストローク）には注意
✓ 必要最小限のデータのみclone

PixiJSオブジェクトの破棄:
graphics.destroy({ children: true, texture: true, baseTexture: true });

✓ removeChild() だけでは不十分
✓ destroy() で完全にメモリ解放
✓ 参照が残っているとメモリリーク


【パフォーマンス最適化指針】
1. 全再描画を避ける
   ❌ Undo → 全レイヤーを破棄して再構築
   ✅ Undo → 変更されたストロークのみ削除

2. 差分更新
   ❌ state変更 → 全てのPixiJSオブジェクト再構築
   ✅ state変更 → 変更箇所のみ更新

3. バッチ処理
   複数ストローク追加時:
   ❌ 各ストロークでEventBus.emit()
   ✅ History.createComposite() で1つのコマンドにまとめる

4. サムネイル更新の遅延
   連続描画中: サムネイル更新を遅延
   描画完了時: まとめて1回更新


================================================================================
■ 段階的統合手順
================================================================================

【Phase 1 完了後の確認】
1. History.push() が正常動作
   □ コマンド実行 → stack に追加
   □ canUndo() が true
   
2. Undo/Redo が正常動作
   □ undo() → index が減る
   □ redo() → index が増る
   □ 循環テスト: push → undo → redo → 元に戻る

3. 再入防止
   □ undo中にpush → 無視される
   □ History.isApplying が正しく動作

4. 分岐履歴の破棄
   □ push → undo → 新しいpush → 未来の履歴が消える

確認方法:
History.debug();  // コンソールで状態表示

統合前の既存機能テスト:
□ 描画できる（History連携前の動作確認）
□ レイヤー操作できる
□ 既存のUndo/Redoは動かなくてOK（後で置き換え）


【Phase 2 完了後の確認】
1. State構造が階層化
   □ StateManager.getState() で確認
   □ timeline.frames[0].layers[0] が存在

2. APIが正常動作
   □ getCurrentFrame() が正しいフレーム返す
   □ getCurrentLayer() が正しいレイヤー返す
   □ getLayerById() で検索できる

3. 履歴記録付きメソッド
   □ addStroke() → History.canUndo() が true
   □ addStroke() → undo → stroke が削除される
   □ addLayer() → undo → layer が削除される

確認方法:
StateManager.debug();  // State構造確認
History.debug();       // 履歴確認

統合テスト:
□ Phase 1 のテストが全て成功（History機能保持）
□ StateManager経由の操作が履歴記録される


【Phase 3 完了後の確認】
1. 既存機能との互換性
   □ レイヤー作成・削除が動作
   □ レイヤー順序変更が動作
   □ レイヤー変形が動作

2. 履歴記録
   □ 各操作で History.canUndo() が true
   □ Undo で正しく戻る
   □ Redo で正しく進む

3. UI更新
   □ レイヤーリストUIが正しく更新
   □ サムネイルが正しく生成

統合テスト:
□ Phase 1-2 のテストが全て成功
□ レイヤー操作 → Undo → Redo の完全動作


【Phase 4 完了後の確認】
1. 描画の履歴記録
   □ 1ストローク描画 → History.canUndo() が true
   □ Undo → ストロークが消える
   □ Redo → ストロークが復活

2. 連続描画
   □ 複数ストローク → 各々が独立して記録
   □ Undo → 1ストロークずつ戻る

3. レイヤークリア
   □ クリア → Undo → 全ストローク復活
   □ Redo → 再度クリア

統合テスト:
□ Phase 1-3 のテストが全て成功
□ 描画 + レイヤー操作の組み合わせが正常動作


【Phase 5 完了後の確認】
（将来実装）
□ フレーム追加・削除
□ フレーム切り替え
□ 各フレーム独立した履歴管理


【Phase 6: 最終統合テスト】
総合シナリオ:
1. レイヤー作成 → 描画 → レイヤー追加 → 描画 → Undo×4 → Redo×4
2. 描画 → コピー → ペースト → Undo×2 → Redo×2
3. レイヤー変形 → 描画 → レイヤー削除 → Undo×3 → Redo×3
4. 大量描画（100ストローク） → Undo×100 → Redo×100
5. 複合操作（描画+レイヤー移動を10回） → Undo×10 → Redo×10

パフォーマンステスト:
□ 100ストローク描画時のメモリ使用量
□ Undo/Redoの応答速度（目標: 16ms以内）
□ 1000回Undo時の履歴スタックサイズ

バグ再現テスト:
□ 描画直後Undo → 正常に戻る（現状の不具合）
□ Undo 1回目の無反応 → 解消（現状の不具合）
□ Redo誤動作 → 解消（現状の不具合）


================================================================================
■ トラブルシューティング
================================================================================

【問題: Undoしても何も起きない】
原因候補:
1. History.index が -1 のまま
   → History.push() が呼ばれていない
   → コマンドのdo()内でstate更新を確認

2. command.undo() が空実装
   → undo()内にconsole.log()を入れて実行確認

3. History.isApplying が true のまま
   → finally節でfalseに戻されているか確認

デバッグ:
History.debug();  // index, stack確認
command.undo();   // undo()を直接呼んで動作確認


【問題: Redoで違う状態に戻る】
原因候補:
1. command.do() と undo() が非対称
   → do()で追加したものをundo()で削除していない

2. IDが一致しない
   → strokeId, layerId が正しく保持されているか確認

3. 参照が壊れている
   → structuredClone() で独立したデータになっているか

デバッグ:
console.log('do:', command.do.toString());
console.log('undo:', command.undo.toString());
// do/undoの実装を確認


【問題: 履歴が破損する】
原因候補:
1. Undo/Redo中に新しいコマンドが追加
   → History.isApplying チェックが漏れている
   → EventBusリスナー内で再入チェック追加

2. 例外が発生してもindexが進む
   → try-catch-finally が正しく実装されているか

3. 分岐履歴の破棄が不完全
   → splice(this.index + 1) が正しく動作しているか

デバッグ:
EventBus.emit() 直前に History.isApplying をチェック
try-catch でエラーログ出力


【問題: メモリリーク】
原因候補:
1. PixiJSオブジェクトが destroy() されていない
   → removeChild() だけでは不十分
   → graphics.destroy() を呼ぶ

2. イベントリスナーが解除されていない
   → EventBus.off() を忘れている

3. 循環参照
   → stroke._graphics = graphics のような相互参照
   → WeakMap 使用を検討

デバッグ:
Chrome DevTools → Memory → Heap Snapshot
PIXI.Graphics のインスタンス数を確認


【問題: パフォーマンスが悪い】
原因候補:
1. 全再描画が発生している
   → EventBus.on('state:updated') が全体を再構築
   → 差分更新に変更

2. structuredClone() が重い
   → 大きなデータ（数千ストローク）をclone
   → 必要最小限のデータのみclone

3. サムネイル生成が頻繁
   → 描画中に毎フレーム生成
   → 描画完了時のみ生成に変更

デバッグ:
Chrome DevTools → Performance
フレームレート、関数実行時間を測定


================================================================================
■ 将来拡張の設計方針
================================================================================

【ラスターレイヤー追加時】
layer.type = "raster" の場合:

1. State構造
layer.bitmap = {
    width: 1920,
    height: 1080,
    data: ImageBitmap  // または base64
};

2. コマンド設計
const rasterCommand = {
    name: 'raster-paint',
    do: () => {
        // RenderTexture に描画
        const texture = createRenderTexture(layer.bitmap);
        sprite.texture = texture;
    },
    undo: () => {
        // 前のテクスチャに戻す
        sprite.texture = previousTexture;
    },
    meta: { type: 'raster', layerId }
};

3. 履歴最適化
- ピクセルデータは差分のみ記録
- または ImageBitmap への参照のみ保持


【アニメーション機能追加時】
1. State構造
timeline.frames = [
    { id: "frame_001", layers: [...] },
    { id: "frame_002", layers: [...] },
    { id: "frame_003", layers: [...] }
];

2. フレーム切り替え
StateManager.setCurrentFrame("frame_002");
→ PixiJS全体を frame_002 の内容で再構築

3. オニオンスキン
前後フレームを半透明で重ねて表示
state.ui.onionSkin = { prev: 1, next: 1, opacity: 0.3 };

4. 履歴管理
各フレームごとに独立した履歴スタック
または グローバル履歴に frameId を記録


【AviUtl連携時】
1. .aup 出力（独自バイナリ形式）
- 仕様が非公開のため実装困難
- 代替: .exo 出力（テキスト形式）

2. .exo 出力
[0]
_name=画像ファイル
_layer=1
file=frame_001.png
再生位置=1
再生速度=100.0

3. 画像シーケンス出力
各フレームを PNG で保存
frame_001.png, frame_002.png, ...
AviUtl で連番画像として読み込み

4. State → .exo 変換
function exportToExo(state) {
    let exo = "";
    state.timeline.frames.forEach((frame, i) => {
        exo += `[${i}]\n`;
        exo += `_name=画像ファイル\n`;
        exo += `file=frame_${String(i+1).padStart(3, '0')}.png\n`;
        exo += `再生位置=${i*1}\n`;
        exo += `再生速度=100.0\n\n`;
    });
    return exo;
}


【SPINE/Live2D連携時】
1. ボーン構造の追加
layer.bones = [
    { id: "bone_001", parent: null, x: 0, y: 0, rotation: 0 },
    { id: "bone_002", parent: "bone_001", x: 50, y: 0, rotation: 0 }
];

2. メッシュ変形
layer.mesh = {
    vertices: [...],  // 頂点座標
    uvs: [...],       // テクスチャ座標
    indices: [...]    // 三角形インデックス
};

3. 物理演算
PixiJS の物理エンジンライブラリを統合
または SPINE/Live2D のランタイムを直接使用


================================================================================
■ Claude向け改修依頼テンプレート
================================================================================

他のClaudeに改修を依頼する際は、以下のフォーマットで指示してください:

【テンプレート】
Phase X の改修を行ってください。

改修対象ファイル: system/xxxxx.js

改修内容:
1. メソッド名.メソッド名() の XXX 部分を変更
2. YYY の追加

改修箇所:
- L123-L145: 既存の処理を削除
- L150: 新しい処理を追加

期待動作:
□ テストケース1
□ テストケース2

提出形式:
- ファイル全体を提示
- 改修箇所に // ========== Phase X: 改修 START/END ========== を明記
- 改修理由をコメントで説明

【具体例】
Phase 2 の改修を行ってください。

改修対象ファイル: system/state-manager.js

改修内容:
1. StateManager クラスの実装
2. 階層的state構造の導入

期待動作:
□ getCurrentFrame() で現在のフレーム取得
□ getCurrentLayer() で現在のレイヤー取得
□ addStroke() で履歴記録付きストローク追加

提出形式:
- ファイル全体（既存コードは削除せず、新規追加または置き換え）
- 改修箇所を明示


================================================================================
■ まとめ
================================================================================

【改修の本質】
従来: PixiJSオブジェクト = 状態 → 全体スナップショット → 重い
改修: State = 状態、PixiJS = 表示 → 差分コマンド → 軽い

【段階的改修の利点】
✓ 各Phase完了ごとにテスト可能
✓ 既存機能を破壊しない
✓ 問題発生時に前Phaseに戻れる
✓ Claude が理解しやすい明確なスコープ

【成功の指標】
Phase 1完了: History単体テスト成功
Phase 2完了: State構造テスト成功
Phase 3完了: レイヤー操作 + Undo/Redo 成功
Phase 4完了: 描画 + Undo/Redo 成功
Phase 5完了: フレーム管理成功（将来）
Phase 6完了: 全機能統合テスト成功

【最終目標】
✓ 描画直後Undo → 正常に戻る
✓ Undo 1回目 → 即座に反応
✓ Redo → 正しい状態に進む
✓ 連続100回Undo/Redo → 破綻しない
✓ メモリ使用量 → 従来の 1/10 以下
✓ 応答速度 → 60fps維持

【次のアクション】
このアーキテクチャ計画書に同意いただけましたら、
Phase 1 の完全実装ファイル（system/history.js）を提出します。

承認いただけますか？


================================================================================
【付録】用語集
================================================================================

Command Pattern: 操作を「コマンドオブジェクト」として記録する設計パターン
                 do/undo メソッドで操作を実行・取り消し可能

Source of Truth: 唯一の正しいデータソース
                 本設計では state が Source of Truth

Idempotent: 冪等性。同じ操作を何度実行しても結果が同じ
            do() → undo() → do() が安全

Reentrancy: 再入。処理中に同じ処理が呼ばれること
            History.isApplying で再入を防止

Structured Clone: オブジェクトの完全なコピー
                  循環参照も含めて複製可能

Differential Update: 差分更新。変更箇所のみ更新する方式
                     全再描画より高速

Composite Command: 複数のコマンドを1つにまとめたコマンド
                   History.createComposite() で生成

Event-Driven: イベント駆動。状態変化をイベントで通知
              EventBus.emit() / EventBus.on()

Hierarchical State: 階層的状態管理
                    timeline → frames → layers → strokes

================================================================================