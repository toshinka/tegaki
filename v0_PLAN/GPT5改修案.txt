è¦ç‚¹ã¾ã¨ã‚ï¼ˆå…ˆã«èª­ã‚€ç”¨ï¼‰

ã€ŒVã‚­ãƒ¼ã®å¤‰å½¢ãƒ¢ãƒ¼ãƒ‰ã€ã§ç§»å‹•å¾Œã§ã‚‚å›è»¢ï¼æ‹¡ç¸®ï¼åè»¢ã®åŸºæº–ã‚’ã‚«ãƒ¡ãƒ©ãƒ•ãƒ¬ãƒ¼ãƒ ä¸­å¿ƒï¼ˆã¾ãŸã¯é¸æŠç¯„å›²ä¸­å¿ƒï¼‰ã«å›ºå®šã™ã‚‹ã«ã¯ã€è¡¨ç¤ºã‚³ãƒ³ãƒ†ãƒŠã® transform ã‚’ç›´æ¥ä½¿ã†ã®ã§ã¯ãªãã€â€œãƒ‘ã‚¹åº§æ¨™ãã®ã‚‚ã®â€ã‚’ã‚«ãƒ¡ãƒ©ä¸­å¿ƒï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³ä¸­å¿ƒï¼‰ã‚’åŸºæº–ã«å¤‰æ›ã™ã‚‹æ–¹å¼ãŒå®‰å…¨ã§ã™ã€‚ã“ã‚Œã§ã‚«ãƒ¡ãƒ©ãƒªã‚µã‚¤ã‚ºï¼ã‚¢ã‚¹ãƒšã‚¯ãƒˆå¤‰æ›´ã«ã‚‚è€ãˆã¾ã™ã€‚

ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆãŒã€Œæ–°è¦ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½œæˆã ã‘ã§ä¸­èº«ãŒã‚³ãƒ”ãƒ¼ã•ã‚Œãªã„ã€å•é¡Œã¯ã€ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼ˆãƒ©ã‚¹ã‚¿ï¼‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã„ã‚‹ï¼ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¦ã„ãªã„ã“ã¨ãŒåŸå› ã®å¯èƒ½æ€§ãŒé«˜ã„ã€‚è§£æ±ºã¯ã€Œãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ï¼ˆéç ´å£Šãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼‰ã‚’æ·±ãã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦æ–°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç§»ã™ã€ã“ã¨ã§ã™ã€‚

core-engine.js ã®è‚¥å¤§åŒ–ã¯ã€é–¢å¿ƒäº‹ï¼ˆcamera / layer / drawing / clipboard / uiï¼‰ã”ã¨ã«è²¬å‹™ã‚’åˆ†é›¢ã™ã‚‹ã®ãŒæ­£æ”»æ³•ã€‚ãŸã ã—åˆ†å‰²æ™‚ã¯ API å¢ƒç•Œã‚’æ˜ç¢ºã«ã—ã¦ã‚¤ãƒ™ãƒ³ãƒˆãƒ™ãƒ¼ã‚¹ã§é€£æºï¼ˆpublic API + ã‚¤ãƒ™ãƒ³ãƒˆï¼‰ã™ã‚Œã°ã€Œãƒ•ã‚¡ã‚¤ãƒ«è·¨ã‚Šã®é‡è¤‡ã€ã‚„ã€Œæ¶ç©ºãƒ¡ã‚½ãƒƒãƒ‰ã€ãƒªã‚¹ã‚¯ã‚’æŠ‘ãˆã‚‰ã‚Œã¾ã™ã€‚

ã¾ãšã¯ã€Œéç ´å£ŠåŒ–ã€ã€Œã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆä¿®æ­£ã€ã€Œã‚«ãƒ¡ãƒ©ä¸­å¿ƒåŸºæº–ã§ã®å¤‰å½¢ã€ã®é †ã§æ®µéšå®Ÿæ–½ã™ã‚‹ã®ãŒä½ãƒªã‚¹ã‚¯ã‹ã¤åŠ¹æœå¤§ã§ã™ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯ã«ã‚ã‚‹æ–¹é‡ã¨ã‚‚æ•´åˆï¼‰ã€‚


1) å•é¡Œ1ï¼šã‚«ãƒ¡ãƒ©ä¸­å¿ƒï¼ˆã¾ãŸã¯é¸æŠä¸­å¿ƒï¼‰ã‚’åŸºæº–ã«å›è»¢ãƒ»æ‹¡ç¸®ãƒ»åè»¢ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ â€” æ–¹é‡ã¨å®Ÿè£…æ¦‚è¦
æ ¹æœ¬æ–¹é‡ï¼ˆè¦ç‚¹ï¼‰

ã€ŒUIä¸Šã§è¦‹ãˆã¦ã„ã‚‹å¤‰å½¢ã€ã¯ è¦‹ã‹ã‘ä¸Šã¯ container.transform ã§è¡Œã„ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ ç¢ºå®šï¼ˆapply/enter or confirmï¼‰ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ãƒ‘ã‚¹åº§æ¨™è‡ªä½“ã«å¤‰æ›ã‚’ç„¼ãä»˜ã‘ã‚‹ï¼ˆéç ´å£Šçš„ã«æ›´æ–°ï¼‰ã€‚

ã“ã‚Œã«ã‚ˆã‚Š â€œç§»å‹•ã—ãŸå¾Œã‚‚ã„ã¤ã§ã‚‚åŒã˜åŸºæº–ï¼ˆã‚«ãƒ¡ãƒ©ä¸­å¿ƒã¾ãŸã¯é¸æŠç¯„å›²ä¸­å¿ƒï¼‰ã§å›è»¢ãƒ»æ‹¡ç¸®ã§ãã‚‹â€ ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

ã‚«ãƒ¡ãƒ©ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’åŸºæº–ã«ã™ã‚‹ãªã‚‰ã€å¤‰å½¢æ“ä½œæ™‚ã®åŸºæº–ç‚¹ï¼ˆpivotï¼‰ã‚’å¸¸ã« ç”»é¢ä¸­å¿ƒï¼ˆrenderer.screen ã®ä¸­å¿ƒï¼‰ ã«ãƒãƒƒãƒ—ã—ã¦ã‹ã‚‰è¨ˆç®—ã™ã‚‹ã€‚ã‚«ãƒ¡ãƒ©ãƒªã‚µã‚¤ã‚ºã‚„ã‚¢ã‚¹ãƒšã‚¯ãƒˆå¤‰æ›´ã¯ã€ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ -> ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã®å¤‰æ›ã‚’æ¯å›è¡Œãˆã°è€ãˆã‚‰ã‚Œã¾ã™ã€‚

ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆç°¡æ½”ï¼‰

å¤‰å½¢ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã£ãŸæ™‚ï¼ˆVæŠ¼ä¸‹ï¼‰ã«ã€åŸºæº–ç‚¹ã‚’æ±ºã‚ã‚‹ï¼š

ã‚«ãƒ¡ãƒ©ä¸­å¿ƒï¼ˆç”»é¢ä¸­å¿ƒï¼‰ã‚’ä½¿ã†ã‹ã€é¸æŠç¯„å›²ä¸­å¿ƒã‚’ä½¿ã†ã‹ã¯ãƒ„ãƒ¼ãƒ«è¨­å®šã§åˆ‡æ›¿å¯ã€‚

ç”»é¢ä¸­å¿ƒï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ï¼‰ â†’ ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«å¤‰æ›ï¼ˆrenderer ã® interaction/mapPositionToPoint ã‚’ä½¿ã†ç­‰ï¼‰ã€‚

å®Ÿéš›ã®å¤‰å½¢ï¼ˆå›è»¢/ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ã‚’ã€Œä¸€æ™‚çš„ã« container ã® transform ã§è¡¨ç¾ã€ã™ã‚‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã®é€£ç¶šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ç”¨ï¼‰ã€‚

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç¢ºå®šï¼ˆenter/confirmï¼‰ã—ãŸã‚‰ã€å…¨ãƒ‘ã‚¹ã®ç‚¹ã‚’åŸºæº–ç‚¹ã¾ã‚ã‚Šã«åº§æ¨™å¤‰æ›ã—ã¦ãƒ‘ã‚¹ãã®ã‚‚ã®ã«ç„¼ãä»˜ã‘ã€container ã® transform ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆposition=0, scale=1, rotation=0ï¼‰ã—ã¦å†æç”»ã€‚

ã“ã®ã¨ãã€å„ãƒ‘ã‚¹ã® pointsï¼ˆ{x,y}ï¼‰ã‚’å€‹åˆ¥ã«å¤‰æ›ã™ã‚‹ï¼ˆéç ´å£Šï¼‰ â†’ ã‚³ãƒ”ãƒ¼ï¼ãƒšãƒ¼ã‚¹ãƒˆã§åŠ£åŒ–ã—ãªã„ã€‚

å®Ÿè£…ã‚¹ãƒ‹ãƒšãƒƒãƒˆï¼ˆçµ±åˆHTMLå†…ã«è¿½åŠ ã™ã‚‹æƒ³å®šï¼‰

ä»¥ä¸‹ã¯ index.html ã® JavaScript éƒ¨åˆ†ã«å…¥ã‚Œã‚‹ï¼ˆwindow.TegakiCore ã®æŒ™å‹•ã‚’ãƒ‘ãƒƒãƒã™ã‚‹å½¢å¼ãŒãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯æ–¹é‡ã«åˆã†ã¯ãšã§ã™ï¼‰ã€‚ã‚³ãƒ¡ãƒ³ãƒˆå¤šã‚ã«ã—ã¦ã„ã¾ã™ã€‚

// --- ãƒ˜ãƒ«ãƒ‘: ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ -> ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼ˆstage ç©ºé–“ï¼‰ ---
// app ã¯ PIXI.Application ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
function screenToWorld(app, screenX, screenY) {
  // interaction ã‚’åˆ©ç”¨ã—ã¦ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ä½ç½®ã‚’ã‚¹ãƒ†ãƒ¼ã‚¸ä¸Šã®Pointã«ãƒãƒƒãƒ—
  const p = app.renderer.plugins.interaction.mapPositionToPoint(new PIXI.Point(), screenX, screenY);
  return p; // æ—¢ã«ã‚¹ãƒ†ãƒ¼ã‚¸åº§æ¨™ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰ï¼‰ã¨ã—ã¦æ‰±ãˆã‚‹
}

// --- ç‚¹ã‚’ pivot (world) ã‚’åŸºæº–ã«å›è»¢ãƒ»æ‹¡ç¸®ã—ã¦ world ã§è¿”ã™ ---
function transformPointAroundPivot_world(ptWorld, pivotWorld, transform) {
  const dx = ptWorld.x - pivotWorld.x;
  const dy = ptWorld.y - pivotWorld.y;
  // scale then rotate (order: translate -> scale -> rotate -> translate back)
  const sx = transform.scaleX ?? transform.scale ?? 1;
  const sy = transform.scaleY ?? transform.scale ?? sx;
  const angle = (transform.rotationDeg ?? 0) * Math.PI/180;
  // scale
  let nx = dx * sx;
  let ny = dy * sy;
  // rotate
  const cos = Math.cos(angle), sin = Math.sin(angle);
  const rx = nx * cos - ny * sin;
  const ry = nx * sin + ny * cos;
  return { x: pivotWorld.x + rx + (transform.tx ?? 0), y: pivotWorld.y + ry + (transform.ty ?? 0) };
}

// --- ãƒ‘ã‚¹å…¨ç‚¹ã«é©ç”¨ã—ã¦ layer ã®ãƒ‘ã‚¹ã‚’æ›´æ–°ã™ã‚‹ï¼ˆéç ´å£Šï¼‰ ---
function applyTransformToPathsNonDestructive(app, layerContainer, transform, pivotScreen) {
  // 1) pivotScreen: {x,y} in screen coords (e.g. screen center)
  const pivotWorld = screenToWorld(app, pivotScreen.x, pivotScreen.y);
  for (const path of layerContainer.layerData.paths) {
    // path.points is array of {x,y} in layer-local coords (where they were originally stored)
    for (let i=0;i<path.points.length;i++){
      const localPt = path.points[i];
      // local -> world
      const worldPt = layerContainer.toGlobal(new PIXI.Point(localPt.x, localPt.y));
      // apply transform around pivot (in world)
      const newWorld = transformPointAroundPivot_world(worldPt, pivotWorld, transform);
      // convert back to layer-local
      const newLocal = layerContainer.toLocal(new PIXI.Point(newWorld.x, newWorld.y));
      path.points[i].x = newLocal.x;
      path.points[i].y = newLocal.y;
    }
    // å†ä½œç”»: rebuild graphics from path.points
    rebuildPathGraphicsFromPoints(layerContainer, path);
  }
  // 2) reset visual transform on container
  layerContainer.position.set(0,0);
  layerContainer.rotation = 0;
  layerContainer.scale.set(1,1);
}


è£œè¶³ï¼šrebuildPathGraphicsFromPoints() ã¯æ—¢å­˜ã®ã€Œãƒ‘ã‚¹â†’Graphicsã‚’æãã€å‡¦ç†ã‚’å‘¼ã¶ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã§ã™ã€‚ãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯ã®ã€Œéç ´å£ŠåŒ–ã€æ–¹é‡ã¨ä¸€è‡´ã—ã¾ã™ï¼ˆæœ€çµ‚çš„ã«ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿å„ªå…ˆï¼‰ã€‚
GitHub

2) å•é¡Œ2ï¼šã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆãŒãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­èº«ã‚’ä¿æŒã—ãªã„ â€” åŸå› ã¨è§£æ±ºç­–
åŸå› ï¼ˆæƒ³å®šï¼‰

å®Ÿè£…ãŒã€Œãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼ˆç”»åƒï¼‰ã¨ã—ã¦ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¤‡è£½ã€ã—ãŸã‚Šã€å˜ã«ç©ºã®æ–°è¦ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ä½œã£ã¦ã„ã‚‹ã€‚

ã‚ã‚‹ã„ã¯ transform ã‚’ç¢ºå®šã—ã¦ãƒ‘ã‚¹ã‚’æ¨ã¦ã€ãƒ©ã‚¹ã‚¿åŒ–ã—ãŸã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ã¿ã‚’ä¿å­˜ã—ã¦ã„ã‚‹ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯ã« 'confirmLayerTransform' ã®ç ´å£Šçš„å®Ÿè£…ãŒç¤ºã•ã‚Œã¦ã„ã‚‹ï¼‰ã€‚
GitHub

è§£æ±ºæ–¹é‡

ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ï¼ˆã‚³ãƒ”ãƒ¼ã®ä¸­é–“ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã«ã¯ å¿…ãšãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ï¼ˆlayer.layerData.pathsï¼‰ã‚’ç¬¬ä¸€å„ªå…ˆã§ä¿æŒã™ã‚‹ã€‚

ã‚¯ãƒªãƒƒãƒ—æ™‚ã¯ deep cloneï¼ˆIDã¯æ–°è¦ç”Ÿæˆï¼‰ã—ã¦ã€è²¼ã‚Šä»˜ã‘æ™‚ã¯ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å†æ§‹ç¯‰ã™ã‚‹ï¼ˆGraphics ã‚’ rebuildï¼‰ã€‚

ã‚‚ã—ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ãªã„ï¼ˆãƒ©ã‚¹ã‚¿ã®ã¿ã®å¤ã„ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰å ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ RenderTexture ã‚’ä½¿ã†ãŒã€å‡ºæ¥ã‚‹é™ã‚Šãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ã‚’å¾©å…ƒå¯èƒ½ã«ã™ã‚‹ã€‚

å®Ÿè£…ä¾‹ï¼ˆæ¦‚å¿µã‚³ãƒ¼ãƒ‰ï¼‰
function deepCloneLayerData(layer) {
  // layer.layerData ã‚’ JSON ç³»ã§ç°¡ä¾¿ã«è¤‡è£½ï¼ˆæ³¨æ„: functions ã‚„ Graphics ã¯å«ã‚ãªã„ï¼‰
  const clone = JSON.parse(JSON.stringify(layer.layerData));
  // æ–°ã—ã„IDã‚’æŒ¯ã‚‹
  clone.id = generateNewLayerId();
  // paths ã® id ã‚‚æ›´æ–°
  clone.paths = clone.paths.map(p => ({ ...p, id: generateNewPathId(), points: p.points.map(pt=>({x:pt.x,y:pt.y})) }));
  return clone;
}

// copy handler
function copyActiveLayerToClipboard(activeLayer) {
  if (!activeLayer || !activeLayer.layerData) return;
  window._TegakiClipboard = {
    layerData: deepCloneLayerData(activeLayer),
    copiedAt: Date.now()
  };
}

// paste handler
function pasteClipboardAsLayer(app, layerManager) {
  if (!window._TegakiClipboard) return;
  const newLayerData = window._TegakiClipboard.layerData;
  // create new layer container
  const newLayerContainer = layerManager.createLayerFromData(newLayerData); // implement this to rebuild graphics
  layerManager.addLayer(newLayerContainer);
}


é‡è¦ï¼šcreateLayerFromData() ã¯ ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ Graphics ã‚’ä½œã‚‹å‡¦ç† ã‚’å‘¼ã¶ã“ã¨ã€‚ã“ã‚Œã§ã€Œæ–°è¦ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã§ãã‚‹ã ã‘ã§ä¸­èº«ãŒãªã„ã€äº‹è±¡ã¯è§£æ¶ˆã—ã¾ã™ã€‚

3) ç¾è¡Œæ§‹é€ ã®ç„¡é§„ãƒ»æ”¹å–„ä½™åœ°ï¼ˆPixiJS v8.13 ã‚’è¸ã¾ãˆã¦ï¼‰
æ°—ã¥ãï¼ˆãƒªãƒã‚¸ãƒˆãƒªãƒ»ãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯ã‹ã‚‰ï¼‰

ãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯è‡ªä½“ã¯ã€Œçµ±åˆHTMLä¸­å¿ƒã§ä¿®æ­£ã™ã‚‹ã€æ–¹é‡ãŒå¼·ãã€ã‚µãƒ†ãƒ©ã‚¤ãƒˆã‚’å‚ç…§ã«ã—ã¦ã„ã‚‹ã€‚ã“ã‚Œã¯ Claudeï¼ˆã‚ãªãŸï¼‰ã«ã¨ã£ã¦ä¾¿åˆ©ã ãŒã€core-engine.js ã®ä¸­ã§è²¬å‹™ãŒæ··åœ¨ã—ã¦ã„ã‚‹ã¨ãã¯ä¿®æ­£ã‚³ã‚¹ãƒˆãŒé«˜ã„ã€‚
GitHub

PixiJS v8.13 ã® APIï¼ˆtoLocal/toGlobalãƒ»RenderTexture.create ç­‰ï¼‰ã‚’æ­£ã—ãä½¿ã†ã“ã¨ã§ã€åº§æ¨™å¤‰æ›ã‚„é«˜è§£åƒåº¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚¹ãƒãƒ¼ãƒˆã«æ›¸ã‘ã‚‹ï¼ˆç¾çŠ¶ãã‚Œã‚’éƒ¨åˆ†çš„ã«ä½¿ã£ã¦ã„ã‚‹æ§˜å­ï¼‰ã€‚
GitHub

ã‚¹ãƒãƒ¼ãƒˆåŒ–ã®ä½™åœ°ï¼ˆå…·ä½“ï¼‰

éç ´å£Šãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ + ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆå†æ§‹ç¯‰å¯èƒ½ãª RenderTextureï¼‰ ã®äºŒå±¤ã«åˆ†ã‘ã‚‹ã€‚

ç”»é¢è¡¨ç¤ºã¯ RenderTexture ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆå¿…è¦æ™‚ã«å†ç”Ÿæˆï¼‰ã€‚å†…éƒ¨ãƒ‡ãƒ¼ã‚¿ã¯å¸¸ã«ãƒ™ã‚¯ã‚¿ï¼ˆãƒ‘ã‚¹ï¼‰ã€‚

åº§æ¨™ç³»ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ã‚’å…±é€šåŒ–ï¼šscreenToWorld, worldToScreen, applyMatrixToPoint ãªã©ã€‚ã“ã‚Œã§åº§æ¨™ãƒã‚°ãŒå¤§ããæ¸›ã‚‹ã€‚

ã‚¤ãƒ™ãƒ³ãƒˆ/ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒã‚¹ ã‚’å°å…¥ã—ã¦ subsystems ã®ä¾å­˜ã‚’ç·©ã‚ã‚‹ï¼ˆä¾‹ï¼šlayer:transform:confirmed ã‚’ publish -> camera/thumbnail/drawing ãŒ subscribeï¼‰ã€‚

ClipboardSystem ã‚’ç‹¬ç«‹ã•ã›ã€deep-clone / import-export / historyï¼ˆundoï¼‰ã‚’æ‹…å½“ã•ã›ã‚‹ã€‚

4) core-engine.js ã‚’ã©ã†åˆ†é›¢ã™ã¹ãã‹ï¼ˆå®Ÿå‹™çš„ãªåˆ†å‰²æ¡ˆï¼‰
åŸºæœ¬ãƒ«ãƒ¼ãƒ«ï¼ˆåˆ†å‰²æ™‚ã®æŒ‡é‡ï¼‰

è²¬å‹™å˜ä½ã§åˆ†ã‘ã‚‹ãŒã€API å¢ƒç•Œã¯æ˜ç¢ºã«ï¼ˆé–¢æ•°åãƒ»ã‚¤ãƒ™ãƒ³ãƒˆåãƒ»æˆ»ã‚Šå€¤ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ãã¡ã‚“ã¨å®šç¾©ï¼‰ã€‚

åŒæœŸãƒã‚¤ãƒ³ãƒˆï¼ˆåŒæœŸçš„ã«å€¤ã‚’å‚ç…§ã™ã‚‹ç®‡æ‰€ï¼‰ã‚’æœ€å°åŒ–ã—ã€å¿…ãš public API ã‹ã‚¤ãƒ™ãƒ³ãƒˆçµŒç”±ã§ã‚„ã‚Šå–ã‚Šã™ã‚‹ã€‚

ã¾ãšã¯ã€Œè«–ç†çš„åˆ†å‰²ï¼ˆã‚³ãƒ¼ãƒ‰ã®æŠ½å‡ºï¼‰ã€ã ã‘ã‚’è¡Œã„ã€å¤–éƒ¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯å¤‰ãˆãªã„ï¼ˆå†…éƒ¨å®Ÿè£…ã‚’åˆ‡ã‚Šå‡ºã™ã ã‘ï¼‰ â†’ ãƒªãƒ•ã‚¡ã‚¯ã‚¿ã§ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®‰å®šã•ã›ã‚‹ã€‚

æ¨å¥¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆè²¬å‹™ï¼‰

camera-system.js

ã‚«ãƒ¡ãƒ© transformï¼ˆpan/zoom/viewportï¼‰ãƒ»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³â†”ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã€‚

APIä¾‹ï¼šcamera.screenToWorld(point), camera.worldToScreen(point), camera.getViewportBounds()ã€‚

layer-manager.js

ãƒ¬ã‚¤ãƒ¤åˆ—ç®¡ç†ã€è¿½åŠ /å‰Šé™¤/é †åºå¤‰æ›´ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¬ã‚¤ãƒ¤å–å¾—ã€ã‚µãƒ ãƒã‚¤ãƒ«æ›´æ–°ãƒˆãƒªã‚¬ãƒ¼ã€‚

drawing-engine.js

ãƒ‘ã‚¹ã®ç¢ºå®šãƒ»å†æç”»ãƒ»Graphicsæ§‹ç¯‰ã€‚ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã®å…¥å‡ºåŠ›ã‚’æ‹…å½“ã€‚

transform-system.jsï¼ˆã¾ãŸã¯ transform-utilsï¼‰

transform ã® applyãƒ»åˆæˆãƒ»éç ´å£Šå¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆapplyTransformToPathsNonDestructive ç­‰ï¼‰ã€‚

clipboard-system.js

ã‚³ãƒ”ãƒ¼ãƒ»ã‚«ãƒƒãƒˆãƒ»ãƒšãƒ¼ã‚¹ãƒˆã€‚deep-cloneãƒ­ã‚¸ãƒƒã‚¯ã€‚undo/redo é€£æºã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã€‚

ui-panels.jsï¼ˆæ—¢å­˜ã®ã¾ã¾ UI æ‹…å½“ï¼‰

UI è¡¨ç¤ºãƒ»ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆã“ã‚Œã¯å‚ç…§å°‚ç”¨ã®æ–¹é‡ã‚’å°Šé‡ï¼‰ã€‚

core-engine.jsï¼ˆè–„ã„ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ï¼‰

å„ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦çµåˆã™ã‚‹ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã€‚public API ã‚’æä¾›ã€‚

åˆ†å‰²ã®ãƒ¡ãƒªãƒƒãƒˆ / ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ

ãƒ¡ãƒªãƒƒãƒˆï¼šå„ãƒ‘ãƒ¼ãƒ„ã‚’å€‹åˆ¥ã«ãƒ†ã‚¹ãƒˆã—ã‚„ã™ãã€å¯èª­æ€§ãŒä¸ŠãŒã‚‹ã€‚

ãƒ‡ãƒ¡ãƒªãƒƒãƒˆï¼šè¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¾ãŸãŒã‚‹ä¿®æ­£æ™‚ã«ã€Œã©ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ä½•ã‚’å®Ÿè£…ã™ã‚‹ã‹ã€ã®åŒæœŸãŒå¿…è¦ï¼ˆâ†’ API å¥‘ç´„ã‚’ docs ã«æ®‹ã™ã“ã¨ã§å¯¾ç­–ï¼‰ã€‚
â†’ è§£æ±ºç­–ï¼šåˆ†å‰²ç›´å¾Œã¯ (1) API å¥‘ç´„ã‚’ã‚³ãƒ¡ãƒ³ãƒˆåŒ–ã€(2) å„ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ã® public API ã‚’ core-engine çµŒç”±ã§éœ²å‡ºã—ã€äºŒé‡å®Ÿè£…ã‚’é¿ã‘ã‚‹ã€‚

å®Ÿè¡Œãƒ—ãƒ©ãƒ³ï¼ˆæ®µéšçš„ãƒ»å„ªå…ˆé †ä½ä»˜ãï¼‰
Phase A â€” ç·Šæ€¥ï¼ˆ1ã€œ3æ—¥ã§è©¦ã›ã‚‹å˜ä½ï¼‰

A1. confirmLayerTransform() ã‚’ éç ´å£Šã«æ›¸ãæ›ãˆï¼ˆãƒ‘ã‚¹ã«å¤‰å½¢ã‚’ç„¼ãä»˜ã‘ã‚‹ï¼‰â†’ ã“ã‚Œã§ã€Œã‚³ãƒ”ãƒ¼ãŒåŠ£åŒ–ã™ã‚‹ã€å•é¡Œã‚’æ­¢ã‚ã‚‹ã€‚

ãƒ†ã‚¹ãƒˆï¼šè¤‡æ•°å›ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ã‚‚åŠ£åŒ–ãƒ»ãƒ©ã‚¹ã‚¿åŒ–ã—ãªã„ã“ã¨ã‚’ç¢ºèªã€‚

A2. ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚’ãƒ‘ã‚¹ãƒ™ãƒ¼ã‚¹ã«åˆ‡æ›¿ï¼ˆdeep cloneï¼‰ã—ã€paste ãŒãƒ‘ã‚¹â†’Graphics ã‚’å†æ§‹ç¯‰ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚

A3. Vãƒ¢ãƒ¼ãƒ‰ã®å¤‰å½¢ã§ã€Œå›è»¢/æ‹¡ç¸®ã®åŸºæº–ã€ã‚’ç”»é¢ä¸­å¿ƒã«å›ºå®šã™ã‚‹ UI ãƒ‘ãƒƒãƒï¼ˆä¸Šè¨˜ applyTransformToPathsNonDestructive ã‚’çµ±åˆHTMLã«è²¼ã‚‹ï¼‰ã€‚

Phase B â€” ä¸­æœŸï¼ˆ1ã€œ2 é€±é–“ï¼‰

B1. camera-system æŠ½å‡ºï¼ˆscreenâ†”world utility ã‚’ centralizeï¼‰ã€‚

B2. transform-systemï¼ˆpivot å‘¨ã‚Šã®å¤‰æ›é–¢æ•°ç¾¤ï¼‰ã‚’ä½œæˆã—ã€drawing-engine ã‹ã‚‰å‚ç…§ã™ã‚‹ã€‚

B3. å˜ä½“ãƒ†ã‚¹ãƒˆç¾¤ï¼ˆç°¡æ˜“ï¼‰ã‚’ä½œã‚‹ï¼šå¤‰æ›ãŒæ­£ã—ããƒ‘ã‚¹ã«é©ç”¨ã•ã‚Œã‚‹ã‹ç­‰ã€‚

Phase C â€” é•·æœŸï¼ˆæ•°é€±é–“ã€œï¼‰

C1. layer-manager, clipboard-system, drawing-engine ã‚’ãƒ•ã‚¡ã‚¤ãƒ«åˆ†é›¢ã—ã€core-engine ã‚’è–„ã„ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã«ã™ã‚‹ã€‚

C2. ã‚­ãƒ£ãƒƒã‚·ãƒ¥/ã‚µãƒ ãƒã‚¤ãƒ«æœ€é©åŒ–ï¼ˆRenderTextureå†ç”Ÿæˆãƒãƒªã‚·ãƒ¼ï¼‰ã€‚

C3. GIF æ©Ÿèƒ½ãªã©è¿½åŠ ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯ã§æƒ³å®šã•ã‚Œã¦ã„ã‚‹é †ï¼‰ã€‚

å…·ä½“ãƒ‘ãƒƒãƒä¾‹ï¼ˆã™ãä½¿ãˆã‚‹çŸ­ã„æ‰‹é †ï¼‰

index.html å†…ã® DOMContentLoaded ã‚¤ãƒ™ãƒ³ãƒˆã§æ—¢å­˜ã® confirmLayerTransform ã‚’ä¸Šæ›¸ãï¼ˆwrapï¼‰ã™ã‚‹ã€‚ãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯æ–¹é‡ã«æ²¿ã„ã€çµ±åˆHTMLå†…ã ã‘ã§å®Œçµã§ãã¾ã™ã€‚
GitHub

åŒã˜ã index.html ã« copyActiveLayerToClipboard / pasteClipboardAsLayer ã‚’è¿½åŠ ã—ã¦ clipboard ã‚’ path-first ã«ã™ã‚‹ã€‚

Vã‚­ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®å¤‰å½¢å‡¦ç†ã§ã€å¤‰å½¢ã‚’ã€Œä¸€æ™‚ transformï¼ˆè¦‹ãŸç›®ï¼‰ã€â†’ã€Œç¢ºå®šã§ path ã«ç„¼ãä»˜ã‘ã€ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã€‚

å¿…è¦ãªã‚‰ã€ã“ã®å ´ã§ index.html ã«ãã®ã¾ã¾è²¼ã‚Œã‚‹å®Ÿéš›ã®å·®åˆ†ï¼ˆç´„100ã€œ200è¡Œï¼‰ ã‚’ä½œæˆã—ã¦æç¤ºã—ã¾ã™ã€‚ã©ã®ç¯„å›²ã§å·®åˆ†ã‚’å‡ºã™ã‹ï¼ˆæœ€å°ãƒ‘ãƒƒãƒï¼šconfirmLayerTransform ã®éç ´å£ŠåŒ–ã®ã¿ã€ã‚ã‚‹ã„ã¯åŒ…æ‹¬çš„ãƒ‘ãƒƒãƒï¼šconfirm + clipboard + pivot utilsï¼‰ã‚’æŒ‡ç¤ºã„ãŸã ã‘ã‚Œã°ã€å³åº§ã«ãƒ‘ãƒƒãƒæ¡ˆï¼ˆå…·ä½“ã‚³ãƒ¼ãƒ‰ï¼‰ã‚’æ›¸ãã¾ã™ â€” ãŸã ã—ãƒ«ãƒ¼ãƒ«ãƒ–ãƒƒã‚¯æ–¹é‡ã«å¾“ã„ã€Œçµ±åˆHTML ã® JavaScript éƒ¨åˆ†ã§å®Œçµã™ã‚‹å½¢ã€ã§å‡ºã—ã¾ã™ã€‚

ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆï¼ˆå„ªå…ˆåº¦é †ï¼‰

 confirmLayerTransform ãŒãƒ‘ã‚¹å˜ä½ã§éç ´å£Šã«å‡¦ç†ã™ã‚‹ã€‚
GitHub

 ã‚³ãƒ”ãƒ¼ã¯ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ deep-cloneã€ãƒšãƒ¼ã‚¹ãƒˆã¯ pathâ†’Graphics ã®å†æ§‹ç¯‰ã€‚

 Vãƒ¢ãƒ¼ãƒ‰ã®å›è»¢/æ‹¡ç¸®/åè»¢ã¯å¸¸ã«ã‚«ãƒ¡ãƒ©ï¼ˆç”»é¢ï¼‰ä¸­å¿ƒã¾ãŸã¯é¸æŠä¸­å¿ƒã‚’åŸºæº–ã«å‹•ä½œã€‚

 camera utilsï¼ˆscreenâ†”worldï¼‰ã‚’ä¸€ç®‡æ‰€ã«ã¾ã¨ã‚ã‚‹ã€‚

 core-engine ã¯è–„ã„ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã«ã—ã€camera/layer/drawing/clipboard ã‚’åˆ†é›¢ã™ã‚‹æ–¹é‡ã‚’æ–‡æ›¸åŒ–ã€‚

ä»˜éŒ²ï¼šã‚ˆãã‚ã‚‹è½ã¨ã—ç©´ï¼ˆçµŒé¨“å‰‡ï¼‰

container.toLocal / toGlobal ã®å‘¼ã³å‡ºã—ã¯ from å¼•æ•°ï¼ˆã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŸºæº–ã‹ï¼‰ã«æ•æ„Ÿ â†’ ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã§ãƒ©ãƒƒãƒ—ã—ã¦ãŠãã€‚

RenderTexture ã«é ¼ã‚Šã™ãã‚‹ã¨ã€ŒåŠ£åŒ–ã®é€£é–ï¼undo ãŒé›£ã—ã„ã€â†’ åŸºæœ¬ã¯ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ¬¡ã‚½ãƒ¼ã‚¹ã«ã€‚

ãƒ•ã‚¡ã‚¤ãƒ«åˆ†å‰²æ™‚ã¯ã€ã¾ãšã€Œå†…éƒ¨å®Ÿè£…ã‚’æŠ½å‡ºã€â†’ å‹•ä½œã«å½±éŸ¿ãªã„ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‹ã‚‰ refactor ã™ã‚‹ï¼ˆbig-bang åˆ†å‰²ã¯å±é™ºï¼‰ã€‚


ğŸ“Œ ãƒ‘ãƒƒãƒã‚³ãƒ¼ãƒ‰ (Bæ¡ˆ)

ä»¥ä¸‹ã‚’ index.html ã® JavaScript éƒ¨åˆ†ï¼ˆDOMContentLoaded å¾Œã«æ—¢å­˜ã®é–¢æ•°ã‚„ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¸Šæ›¸ãã—ã¦ã„ã‚‹ç®‡æ‰€ä»˜è¿‘ï¼‰ã«è¿½åŠ ã—ã¦ãã ã•ã„ã€‚

<script>
// ===============================
//  Transform Utilities
// ===============================

// ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ â†’ ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™
function screenToWorld(app, screenX, screenY) {
  const p = app.renderer.plugins.interaction.mapPositionToPoint(new PIXI.Point(), screenX, screenY);
  return p;
}

// pivotã‚’ä¸­å¿ƒã«å›è»¢ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«ãƒ»å¹³è¡Œç§»å‹•
function transformPointAroundPivot_world(ptWorld, pivotWorld, transform) {
  const dx = ptWorld.x - pivotWorld.x;
  const dy = ptWorld.y - pivotWorld.y;

  const sx = transform.scaleX ?? transform.scale ?? 1;
  const sy = transform.scaleY ?? transform.scale ?? sx;
  const angle = (transform.rotationDeg ?? 0) * Math.PI / 180;

  // scale
  let nx = dx * sx;
  let ny = dy * sy;

  // rotate
  const cos = Math.cos(angle), sin = Math.sin(angle);
  const rx = nx * cos - ny * sin;
  const ry = nx * sin + ny * cos;

  return { x: pivotWorld.x + rx + (transform.tx ?? 0), y: pivotWorld.y + ry + (transform.ty ?? 0) };
}

// ãƒ‘ã‚¹å…¨ç‚¹ã«éç ´å£Šå¤‰æ›ã‚’é©ç”¨
function applyTransformToPathsNonDestructive(app, layerContainer, transform, pivotScreen) {
  const pivotWorld = screenToWorld(app, pivotScreen.x, pivotScreen.y);
  for (const path of layerContainer.layerData.paths) {
    for (let i = 0; i < path.points.length; i++) {
      const localPt = path.points[i];
      const worldPt = layerContainer.toGlobal(new PIXI.Point(localPt.x, localPt.y));
      const newWorld = transformPointAroundPivot_world(worldPt, pivotWorld, transform);
      const newLocal = layerContainer.toLocal(new PIXI.Point(newWorld.x, newWorld.y));
      path.points[i].x = newLocal.x;
      path.points[i].y = newLocal.y;
    }
    if (window.rebuildPathGraphicsFromPoints) {
      rebuildPathGraphicsFromPoints(layerContainer, path);
    }
  }
  // container ã®è¦‹ãŸç›®ã‚’ãƒªã‚»ãƒƒãƒˆ
  layerContainer.position.set(0, 0);
  layerContainer.rotation = 0;
  layerContainer.scale.set(1, 1);
}

// ===============================
//  confirmLayerTransform (éç ´å£Šç‰ˆ)
// ===============================
if (window.confirmLayerTransform_original === undefined) {
  window.confirmLayerTransform_original = window.confirmLayerTransform;
}

window.confirmLayerTransform = function(app, activeLayer, transform, pivotMode = "camera") {
  if (!activeLayer) return;
  const screenCenter = {
    x: app.renderer.screen.width / 2,
    y: app.renderer.screen.height / 2
  };
  const pivotScreen = (pivotMode === "camera")
    ? screenCenter
    : { x: activeLayer.width / 2, y: activeLayer.height / 2 };

  applyTransformToPathsNonDestructive(app, activeLayer, transform, pivotScreen);
};

// ===============================
//  Clipboard Deep Clone
// ===============================
function generateNewId(prefix="id") {
  return prefix + "_" + Math.random().toString(36).substr(2, 9);
}

function deepCloneLayerData(layer) {
  const clone = JSON.parse(JSON.stringify(layer.layerData));
  clone.id = generateNewId("layer");
  clone.paths = clone.paths.map(p => ({
    ...p,
    id: generateNewId("path"),
    points: p.points.map(pt => ({ x: pt.x, y: pt.y }))
  }));
  return clone;
}

// copy
window.copyActiveLayerToClipboard = function(activeLayer) {
  if (!activeLayer || !activeLayer.layerData) return;
  window._TegakiClipboard = {
    layerData: deepCloneLayerData(activeLayer),
    copiedAt: Date.now()
  };
  console.log("Layer copied:", window._TegakiClipboard.layerData.id);
};

// paste
window.pasteClipboardAsLayer = function(app, layerManager) {
  if (!window._TegakiClipboard) return;
  const newLayerData = window._TegakiClipboard.layerData;

  // createLayerFromData: layerDataã‹ã‚‰ãƒ¬ã‚¤ãƒ¤ãƒ¼Containerã‚’å†æ§‹ç¯‰
  if (layerManager.createLayerFromData) {
    const newLayerContainer = layerManager.createLayerFromData(newLayerData);
    layerManager.addLayer(newLayerContainer);
    console.log("Layer pasted:", newLayerData.id);
    return newLayerContainer;
  } else {
    console.warn("layerManager.createLayerFromData æœªå®Ÿè£…ã§ã™ã€‚");
  }
};

// ===============================
//  Key bindings (ä¾‹: Ctrl+C / Ctrl+V)
// ===============================
window.addEventListener("keydown", (e) => {
  const app = window._TegakiApp;
  const layerManager = window._LayerManager;
  const activeLayer = layerManager?.getActiveLayer?.();

  if (e.ctrlKey && e.key === "c") {
    copyActiveLayerToClipboard(activeLayer);
    e.preventDefault();
  }
  if (e.ctrlKey && e.key === "v") {
    pasteClipboardAsLayer(app, layerManager);
    e.preventDefault();
  }
});
</script>

ğŸ“Œ å‹•ä½œä»•æ§˜

Vãƒ¢ãƒ¼ãƒ‰ã§ã®å¤‰å½¢

è¦‹ãŸç›®ã¯å¾“æ¥é€šã‚Š container.transform ã§å‹•ä½œã€‚

ç¢ºå®šæ™‚ (confirmLayerTransform) ã« å…¨ãƒ‘ã‚¹ã®ç‚¹ã‚’ pivot å‘¨ã‚Šã«å¤‰æ›ã—ã¦ã€Œéç ´å£Šçš„ã€ã«åº§æ¨™æ›´æ–° â†’ container ã¯ãƒªã‚»ãƒƒãƒˆã€‚

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ pivot ã¯ã€Œç”»é¢ä¸­å¿ƒï¼ˆã‚«ãƒ¡ãƒ©ä¸­å¿ƒï¼‰ã€ã€‚

ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆ

ã‚³ãƒ”ãƒ¼æ™‚ã¯ layer.layerData ã‚’ deep-cloneï¼ˆIDå†ç”Ÿæˆï¼‰ã€‚

ãƒšãƒ¼ã‚¹ãƒˆæ™‚ã¯ createLayerFromData() ã‚’å‘¼ã‚“ã§ Graphics ã‚’å†æ§‹ç¯‰ã€‚

Ctrl+C / Ctrl+V ã§ãƒ†ã‚¹ãƒˆå¯èƒ½ã€‚

æ”¹ä¿®ç¯„å›²

æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã«ã¯ã»ã¼å½±éŸ¿ã‚’ä¸ãˆãšã€ã€Œè¿½åŠ ï¼ä¸Šæ›¸ãã€æ–¹å¼ã€‚

å…ƒã® confirmLayerTransform ã¯ confirmLayerTransform_original ã«é€€é¿ã—ã¦ã‚ã‚‹ãŸã‚ã€å¿…è¦ãªã‚‰å¾©å¸°å¯èƒ½ã€‚

