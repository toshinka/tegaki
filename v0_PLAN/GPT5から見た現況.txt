改修計画書（分割版 → 元ファイル継承チェック＋是正案）

以下は、提示された 問題箇所.txt の指摘内容を踏まえ、分割版（v8.13_SatellitePlan_phase2b4）が 元の動作（v8.13_SatellitePlan_phase1b4）を正しく継承しているかを探索し、発見した問題点とそれを是正するための具体的実装手順・優先度付きタスク一覧 です。出所ファイルは検査済みです（主な参照：問題一覧、分割版の config.js と core-engine 等／元版 core-engine）。

問題箇所

 
GitHub
 
GitHub
 
GitHub
 
GitHub

要約（短く）

根本原因は「分割により責務・API・座標基準（screen/world/local）とイベント伝播の契約が壊れた」ことに起因します（描画不具合、サムネイル比率崩れ、レイヤー操作での座標ズレ等）。

問題箇所

分割版の config.js はグローバル定義の整理が入っており良い改善が見られる一方、coordinate/camera/drawing/layer の各ファイルが空/未実装あるいは API 互換を保てていない箇所が散見されます（実ファイルの中身がほぼ空・最小化されている箇所あり）。これは「継承されているはずの機能が切り離された」主因です。
GitHub
+2
GitHub
+2

優先度付き改修フェーズ（実施順）
Phase 1 — 緊急（最優先）：描画機能復旧（ペンが描けない問題）

目的：ペン描画（ポインター→DrawingSystem→レイヤーへの転写）が最低限動作すること。
対象ファイル（優先確認順）：core-engine.js（イベント統合）、core-runtime.js（ループ/初期化）、engine/camera-system.js（座標変換）、engine/drawing-engine.js（描画ロジック）
GitHub
+2
GitHub
+2

検査チェックリスト（必ず実行）

ポインターイベントの到達確認

window / canvas 上の pointerdown/pointermove/pointerup が CoreEngine に届いているかログ（最小限）で確認。届いていなければ addEventListener の対象や capture/ passive オプションを確認。

イベントハンドラのチェーン

CoreEngine → UIController → CameraSystem → DrawingSystem（もしくは EventBus 経由）の伝播順を確認。途中で stopPropagation() 相当をしていないか確認。

座標系の明確化（最重要）

入力：スクリーン（DOMピクセル）座標

CameraSystem：スクリーン ⇄ ワールド（キャンバス内部）変換を一意に持たせる（screenToWorld(point) / worldToScreen(point)）。DrawingSystem と LayerSystem は常にワールド座標で動くことを契約にする。

DrawingSystem の受け口を検証

DrawingSystem が受け取るのは point（ワールド座標） + pressure + toolState であることを保証する。もし分割で API が変わっていたら「ラッパー関数」で互換性を戻す。

具体的修正コード例（概念・差分）

（実装ファイルに直接貼る形で）スクリーン→ワールド変換ユーティリティ例：

// CameraSystem に追加（もしくは既存の命名に合わせる）
CameraSystem.screenToWorld = function(screenPoint) {
  // screenPoint: {x,y} in DOM pixel relative to canvas top-left
  const canvas = this.app.view; // PIXI view
  const rect = canvas.getBoundingClientRect();
  const localX = (screenPoint.x - rect.left) * (canvas.width / rect.width);
  const localY = (screenPoint.y - rect.top)  * (canvas.height / rect.height);
  // apply inverse camera transform (scale/rotation/translation)
  const world = this._inverseTransformPoint({x: localX, y: localY});
  return world; // {x,y} in world/canvas coords
};


イベントの受け渡し（CoreEngine 側）：

canvas.addEventListener('pointerdown', e => {
  const screen = { x: e.clientX, y: e.clientY };
  const world = CameraSystem.screenToWorld(screen);
  EventBus.emit('pointer.down', { screen, world, originalEvent: e });
});


DrawingSystem は EventBus.on('pointer.move', handler) で world を受けるだけで済むようにします。

Phase 2 — 高（重要）：レイヤーシステムの API 互換化とサムネイル修正

目的：既存（元版）の Layer API を分割版で壊さない。サムネイルがキャンバスのアスペクト比に応じて正しく更新されること。
対象ファイル：engine/layer-system.js, ui/ui-core.js（サムネイル描画ロジック）
GitHub
+1

主な問題想定と是正方針

問題：Layer が PIXI.Container ベースになった際、古い API（createLayer(id), moveLayer(indexFrom,indexTo), getLayerBounds(id) 等）が消えている。→ 互換レイヤーラッパ を作る。

サムネイル比率崩れ：サムネイル生成に canvas.width/height ではなく DOM の CSS サイズや DPR を混用している。
対処：

サムネイル生成は PIXI.RenderTexture に R = thumbnail.SIZE * RENDER_SCALE でレンダリングし、レイヤーの内容のローカルバウンズ（container.getLocalBounds()) を基に縦横比を維持してリサイズする。

DPR（devicePixelRatio）を考慮して app.renderer.resize(width * DPR, height * DPR) を一時的に行い、戻す。

互換ラッパのサンプル（擬似）
// LayerSystem 内
createLayerLegacy(id, opts = {}) {
  const container = this._createPixiContainer(opts);
  container._legacyId = id;
  this.layers.push(container);
  return {
    id,
    container,
    moveTo: (index) => this.moveLayerTo(container, index),
    getBounds: () => container.getLocalBounds()
  };
}

Phase 3 — 中（拡張）：UI とイベントの一元化 / State 管理

目的：UI 側のイベントが二重処理／欠落を起こさないようにし、ツール切替・ショートカットが安定して動くこと。
対象：ui/ui-core.js, ui/ui-state.js, core-engine.js
GitHub
+2
GitHub
+2

要点

EventBus（軽量）を CoreEngine の中央に置く。UI はイベントを直接処理するのではなく EventBus を経由する（テストしやすく、AI 自動改修しやすい）。

ショートカットマッピング は config.js（既に統一済み）から読み、ui-state.js は TEGAKI_SHORTCUTS を参照する。
GitHub

UI 側は state -> view の単方向フローを維持（副作用は最小化）。

Phase 4 — 低（最適化）：サムネイル描画最適化、レンダリングパフォーマンス

目的：サムネイル更新時やキャンバスリサイズ時の余計な再レンダリングを減らす。
対処：

サムネイルは「差分更新」：レイヤーが変化したレイヤーのみ再生成。

サムネイルレンダリングは RENDER_SCALE を使うが、QUALITY が 'high' でも一時的に app.renderer.plugins.extract.canvas() を使い GPU→CPU転送頻度を下げる。

検証（テスト）プラン

手動受け入れテスト（最低限）

キャンバスを開き、ペンで描画できるか（pointerdown/move/upで線形が描ける）。

レイヤーを追加→移動（index入替）→内容がついてくるか（座標ズレ確認）。

サムネイルがキャンバスサイズ変更で縦横比を保って更新されるか。

自動単体テスト（可能なら）

CameraSystem の screenToWorld と逆変換の単体テスト（座標を round-trip で比較）。

LayerSystem の moveLayer と getLayerBounds の結果整合性テスト。

差分パッチ（作業者向け具体指示）

まず core-engine.js に EventBus を追加（軽量 Pub/Sub）。既存ハンドラの addEventListener を EventBus 経由に移行する。

CameraSystem に screenToWorld / worldToScreen を必ず公開する。これを DrawingSystem と LayerSystem が使うように差し替え。

DrawingSystem は絶対に DOM 座標を直接処理しない。受け取るのは world 座標のみ。もし既に DOM 座標で処理している箇所があればラッパーで変換。

LayerSystem に旧 API ラッパー（createLayer, moveLayer, getLayerById, serialize）を実装。内部は PIXI.Container を使って良いが API は安定させる。

UI（ui-core.js） はサムネイル更新ロジックを LayerSystem.createThumbnail(layerId, size, scale) の呼び出しに切り出す（責務分離）。

config.js の設定（TEGAKI_CONFIG, TEGAKI_SHORTCUTS）を参照する箇所をすべて確認し、参照名が変わっている箇所を修正。
GitHub

ロールバックとリスク管理

ロールバック方法：分割前の v8.13_SatellitePlan_phase1b4 を Git ブランチ／zipで即座に復元可能にする（作業前に snapshot を取得）。現在の phase2b4 は分割検証ブランチで作業すること。
GitHub

リスク：分割ファイルの「空ファイル／未実装」が存在するため、まずは「ファイル存在と中身の検証」を自動化（スクリプト）してから手直しすることを推奨。

具体的な作業スコープ（チェックリスト形式）

 CoreEngine: EventBus 実装 & 全イベントの集約。
GitHub

 CameraSystem: screenToWorld / worldToScreen 実装と unit test。
GitHub

 DrawingSystem: world 座標入力化。ペンツールの pressure/size を流す確約。

 LayerSystem: 旧 API 互換ラッパー + thumbnail generator（aspect/DPR 対応）。
GitHub

 UI: サムネイル更新を LayerSystem API 呼び出しに差替え、ショートカットを TEGAKI_SHORTCUTS で統一。
GitHub
+1

 回帰テスト（手動・自動）実行、ログは TEGAKI_UTILS.log を用い最小限に出力。
GitHub