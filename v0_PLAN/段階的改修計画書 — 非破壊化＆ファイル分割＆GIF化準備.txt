# 段階的改修計画書 — 非破壊化＆ファイル分割＆GIF化準備

**狙い**
- 現状：レイヤー確定時に`RenderTexture`へベイクしてしまい、破壊的にラスター化される
- 目的：**非破壊性を担保しつつ実用的な描画体験**を維持し、ファイル分割でClaude改修効率を向上させ、その上で将来のGIF化→LIVE2D/SPINE化へスムーズに移行できる土台を作る

---

## 現状分析（Phase1分割版の状況）

### 現在のファイル構成
```
index.html        # UIの土台、DOM要素、Canvas配置、スクリプト読込
main.js          # 全JavaScript機能（約800行、肥大化）
config.js        # 設定値（実装されているが活用不十分）
ui-panels.js     # UI制御（実装済み）
```

### 現在の問題点
1. **main.js が肥大化（800行）** → Claude改修時の見通しが悪化
2. **破壊的確定処理** → レイヤー変形時にベクターデータが失われる
3. **GIF化準備不足** → アニメーション機能への拡張が困難
4. **機能境界が曖昧** → 関係ない部分への影響リスク

---

## 要件（高レベル）
1. **非破壊性**：描画操作（移動／拡縮／回転）を確定しても、元の描画データ（パス／ストローク／メタ情報）を失わない
2. **実用パフォーマンス**：画面レスポンスは犠牲にしない。重い場合はキャッシュ（ラスタ）を使うが、キャッシュは **再生成可能**
3. **Claude改修効率**：関連機能は同一ファイルに集約、無関係な機能は分離
4. **互換性**：既存UI・操作感を大きく壊さない
5. **将来の拡張（GIF化・2窓化・LIVE2D化）を見据えたファイル構造**

---

## 段階（フェーズ）一覧

### フェーズ0 — 安全対策（小変更）
目的：現在の破壊的挙動を即時に軽減

**実装内容**：
- `confirmLayerTransform()` を **非破壊的な論理確定版** に差し替え
- デフォルトでは「確定」は**論理的確定（transformを layerData にコピーして保持）**
- 実際の子要素（Graphics）はそのまま保持、RenderTextureへの強制ベイクを停止

**ファイル変更**：main.js のみ（LayerManager.confirmLayerTransform 周辺）

**成果物**：ユーザ操作で即座に破壊が減る。回帰リスク小。

### フェーズ1 — main.js分割・Claude改修効率化（必須）
目的：肥大化したmain.jsを機能別に分割し、Claude改修時の負荷を軽減

**分割戦略**：
```
index.html           # 変更なし
config.js           # 設定値強化（キャンバスサイズ、DPR、ツール設定等）
ui-panels.js        # UI制御（既存、若干拡張）
camera-system.js    # カメラ・座標変換・キャンバス操作（main.jsから分離）
layer-manager.js    # レイヤー管理・変形・サムネイル（main.jsから分離）
drawing-engine.js   # 描画エンジン・ペン・消しゴム（main.jsから分離）
animation-core.js   # 【新規】フレーム管理・タイムライン（GIF化準備）
main.js             # エントリーポイント・統合制御・相互連携（大幅縮小）
```

**Claude改修最適化**：
- 描画機能改修時 → `drawing-engine.js` のみ修正
- レイヤー機能改修時 → `layer-manager.js` のみ修正
- カメラ機能改修時 → `camera-system.js` のみ修正
- アニメ機能追加時 → `animation-core.js` のみ修正
- main.js は極力触らず、各モジュールの組み合わせのみ調整

**API境界の厳格化**：
```javascript
// 明確なAPI境界設定
window.TegakiModules = {
    CameraSystem: class CameraSystem { ... },
    LayerManager: class LayerManager { ... },
    DrawingEngine: class DrawingEngine { ... },
    AnimationCore: class AnimationCore { ... }
};
```

**成果物**：Claude改修時の作業量大幅削減、機能追加時の影響範囲明確化

### フェーズ2 — パスデータを第一級市民に（必須）
目的：描画データ（ベクター）を構造化して保持する

**実装内容**：
- `layer.layerData.paths` を正式仕様化
- 各 path オブジェクトに下記情報を持たせる：
```javascript
{
  id: 'p123',
  type: 'stroke'|'fill'|'shape',
  commands: [ {cmd:'moveTo', x, y}, {cmd:'bezierCurveTo', ...}, ... ],
  style: { width, cap, join, color, opacity },
  createdAt, updatedAt,
  frameStart: 0,  // GIF化準備：このパスが開始するフレーム
  frameEnd: -1    // GIF化準備：このパスが終了するフレーム（-1=永続）
}
```

**レンダリング関数整備**：
- `addPathToLayer()` を path オブジェクト受け渡しに統一
- 描画は `path.graphics` に依存せず、「**path → Graphics** のレンダリング関数」を通す
- 常にこの関数でCanvasを更新する

**ファイル変更**：`drawing-engine.js`, `layer-manager.js`

**成果物**：いつでもパス再描画が可能。焼き込み不要。GIF化のフレーム情報準備完了。

### フェーズ3 — レンダリングパイプラインの分離（描画とキャッシュの明確化）
目的：パスベースで正確に描画し、かつ描画パフォーマンスを担保する

**分離戦略**：
* レイヤーは**論理層（データ）**と**表示層（表示キャッシュ）**に分ける：
  * `layer.layerData`（paths, metadata, pivot, animation）
  * `layer.view`（PIXI.Container） - 実際に画面に付与される表示用Container

**描画フロー**：
1. 通常フレームは `renderLayerViewFromLayerData(layer, currentFrame)` を呼び出し
2. フレーム指定により、該当フレームで表示されるパスのみを描画（GIF化準備）
3. 大きなキャンバス変更・編集時は **キャッシュ無効化フラグ** を立てて再生成

**キャッシュ仕様**: `layer.cache` { texture, scaleAtCreation, rotationAtCreation, dpr, frame } を持つ
- キャッシュ作成は `createLayerCache(layer, frame, options)` を呼ぶ
- 重要：キャッシュは破壊的ではなく、**再生成可能な派生物**として扱う

**ファイル変更**：`layer-manager.js`, `animation-core.js`（新規）

**成果物**：パスを常に保持しつつ、速さも確保。フレーム別レンダリング準備完了。

### フェーズ4 — 確定操作の変更（UI/UX）
目的：ユーザに「確定」の意味を明確化し、選択可能にする

**UI改修**：
* 「確定」ボタンを2種類にする：
  * **論理確定（推奨デフォルト）**：transform を layer metadata に書き込み、パスはそのまま。キャッシュは無効化して再生成
  * **焼き込み確定（オプション／高解像度）**：レンダーテクスチャに焼き込んでSpriteへ置換（ただし元の path データはバックアップとして保存）

* UI: 履歴（Undo）で論理状態に戻せるようにする

**ファイル変更**：`ui-panels.js`, `layer-manager.js`

**成果物**：ユーザは誤ってベクターを破壊しなくなる。

### フェーズ5 — GIF化機能実装（アニメツール化）
目的：パーツ化されたデータを使ってGIFアニメーション機能を実装

**アニメーション機能**：
- **フレーム管理**：各フレームでの各レイヤーの状態を記録
- **タイムライン UI**：フレーム別のレイヤー表示/非表示、transform設定
- **GIF 書き出し**：フレームごとに高解像度でレンダリングしてGIF合成

**フレーム構造**：
```javascript
{
  frame: 0,
  duration: 100, // ms
  layers: [
    {
      layerId: 'layer_1',
      visible: true,
      opacity: 1.0,
      transform: { x: 0, y: 0, scale: 1, rotation: 0 },
      pathsFilter: ['p123', 'p456'] // このフレームで表示するパスID
    }
  ]
}
```

**新規UI**：
- フレームリスト表示
- 再生/停止ボタン
- フレーム追加/削除
- GIF書き出し設定（解像度、FPS、ループ設定）

**ファイル変更**：`animation-core.js`（新規）, `ui-panels.js`（タイムライン追加）, index.html（UI要素追加）

**成果物**：本格的なGIFアニメーションツール化完了。

### フェーズ6 — 2窓化・LIVE2D/SPINE準備（将来拡張）
目的：描画窓とアニメ窓の分離、外部アニメツール連携準備

**2窓化**：
- `draw.html` + `main-draw.js`：描画専用（現在の機能を継承）
- `animate.html` + `main-animate.js`：アニメーション専用
- `network.js`：2窓間でのJSONデータ共有

**LIVE2D/SPINE準備**：
- 各レイヤーを**パーツ単位（パス群）**で分離し、pivot（変形中心）を持たせる
- 各パーツにIDを付与し、JSONエクスポート可能にする（paths + pivot + initial transform）
- メッシュ変形・ボーン階層のメタデータ追加

**ファイル変更**：全体的なリファクタリング

**成果物**：複数窓での本格的なアニメーション制作環境。外部ツール連携基盤。

---

## ファイル分割の具体的設計

### config.js 強化案
```javascript
window.TEGAKI_CONFIG = {
  // キャンバス設定
  canvas: { width: 400, height: 400 },
  
  // 描画設定
  pen: { size: 16, color: 0x000000, opacity: 0.85 },
  
  // アニメーション設定（新規）
  animation: {
    defaultFPS: 12,
    maxFrames: 120,
    exportFormats: ['GIF', 'PNG_SEQUENCE', 'JSON']
  },
  
  // 2窓設定（将来）
  multiWindow: {
    enabled: false,
    syncMethod: 'localStorage', // or 'websocket'
    drawWindowSize: { width: 1200, height: 800 },
    animateWindowSize: { width: 1000, height: 600 }
  }
};
```

### camera-system.js 分離案
```javascript
// main.jsから分離
class CameraSystem {
  constructor(app) { ... }
  
  // 座標変換API
  screenToCanvasForDrawing(screenX, screenY) { ... }
  screenToCanvas(screenX, screenY) { ... }
  canvasToScreen(canvasX, canvasY) { ... }
  
  // カメラ操作API
  resetCanvas() { ... }
  updateTransformDisplay() { ... }
  
  // ガイドライン制御
  showGuideLines() { ... }
  hideGuideLines() { ... }
  
  // キャンバスリサイズ
  resizeCanvas(newWidth, newHeight) { ... }
}

window.TegakiModules.CameraSystem = CameraSystem;
```

### layer-manager.js 分離案
```javascript
// main.jsから分離
class LayerManager {
  constructor(canvasContainer, app, cameraSystem) { ... }
  
  // 非破壊変形API
  confirmLayerTransform() { ... }           // 論理確定
  bakeLayerTransform() { ... }              // 焼き込み確定（オプション）
  
  // パス管理API
  addPathToLayer(layerIndex, pathObj) { ... }
  rebuildLayerFromPaths(layer) { ... }
  
  // フレーム対応API（GIF化準備）
  renderLayerAtFrame(layer, frameIndex) { ... }
  getLayerPathsAtFrame(layer, frameIndex) { ... }
}

window.TegakiModules.LayerManager = LayerManager;
```

### animation-core.js 新規作成案
```javascript
// 新規作成
class AnimationCore {
  constructor(layerManager) {
    this.layerManager = layerManager;
    this.frames = [];
    this.currentFrame = 0;
    this.isPlaying = false;
    this.fps = 12;
  }
  
  // フレーム管理
  addFrame(atIndex = -1) { ... }
  removeFrame(index) { ... }
  duplicateFrame(index) { ... }
  
  // 再生制御
  play() { ... }
  pause() { ... }
  goToFrame(index) { ... }
  
  // GIF出力
  exportGIF(options = {}) { ... }
  exportPNGSequence() { ... }
  exportJSON() { ... }
}

window.TegakiModules.AnimationCore = AnimationCore;
```

### main.js 縮小版（統合制御のみ）
```javascript
// 大幅縮小：各モジュールの初期化と統合のみ
(function() {
  'use strict';
  
  const { CameraSystem, LayerManager, DrawingEngine, AnimationCore } = window.TegakiModules;
  
  class DrawingApp {
    constructor() {
      this.pixiApp = null;
      this.cameraSystem = null;
      this.layerManager = null;
      this.drawingEngine = null;
      this.animationCore = null;
    }
    
    async initialize() {
      // 各モジュールの初期化と相互連携のみ
      this.pixiApp = new PIXI.Application();
      this.cameraSystem = new CameraSystem(this.pixiApp);
      this.layerManager = new LayerManager(...);
      this.drawingEngine = new DrawingEngine(...);
      this.animationCore = new AnimationCore(this.layerManager);
      
      // 相互参照設定
      this.setupModuleReferences();
    }
  }
  
  // アプリケーション起動（変更なし）
  window.addEventListener('DOMContentLoaded', async () => { ... });
})();
```

---

## 改修時のClaude作業最適化

### 改修パターン別ファイル対応表
| 改修内容 | 主要変更ファイル | 参照のみファイル |
|----------|------------------|-------------------|
| ペン描画改良 | `drawing-engine.js` | `config.js` |
| レイヤー変形修正 | `layer-manager.js` | - |
| カメラ操作改善 | `camera-system.js` | - |
| UI追加/修正 | `ui-panels.js`, `index.html` | - |
| アニメ機能追加 | `animation-core.js` | `config.js` |
| 全体統合調整 | `main.js` | 全てのファイル |

### 改修手順テンプレート
1. **要求分析**：どの機能領域の改修か特定
2. **ファイル特定**：上記表に基づいて主要変更ファイルを特定
3. **API確認**：`window.TegakiModules` の該当クラスのメソッドを確認
4. **改修実装**：特定されたファイルのみ修正
5. **動作検証**：該当機能の動作確認

---

## テスト項目（QA）

### 非破壊性テスト
1. レイヤー移動 → 確定（論理）後にパスデータが保持されているか
2. 拡縮・回転を複数回行ってもジャギーが発生しないか（再生成でシャープ）
3. キャッシュ無効化時に描画が正しく再生成されるか

### ファイル分割テスト
4. 各モジュールが独立して動作するか
5. API境界で意図しない相互依存が発生していないか
6. Claude改修時に無関係なファイルを触る必要がないか

### GIF化準備テスト
7. フレーム別レンダリングが正常動作するか
8. パス情報にフレーム範囲が正しく記録されるか
9. 大きなDPR（2〜3）のモニタでGIF出力がぼやけないか

### パフォーマンステスト
10. 60fps維持でUI応答性確保されているか
11. メモリ使用量が適切な範囲に収まっているか
12. 長時間使用でメモリリークが発生しないか

---

## 優先度 / 実装順（推奨）

1. **フェーズ0（即時低リスク）** - 破壊的確定の停止
2. **フェーズ1（Claude改修効率化）** - main.js分割によるモジュール化
3. **フェーズ2（データ構造）** - パスデータの第一級市民化
4. **フェーズ3（レンダーパイプライン）** - キャッシュシステム分離
5. **フェーズ4（UI改修）** - 確定モードの明確化
6. **フェーズ5（GIF化）** - アニメーション機能実装
7. **フェーズ6（将来拡張）** - 2窓化・LIVE2D準備

---

## マイグレーション注意点

### 既存データ互換性
* 既存レイヤーで `children` に Graphics しか持たない場合、単純に `paths` に変換するスクリプトを用意
* 古い "焼き込み済み" スプライトは `layer.layerData.paths == [] && cache.texture != null` の形で互換扱い

### API変更への対応
* `window.TegakiModules` 導入により、既存の直接参照は段階的に移行
* 後方互換性のため、移行期間中は旧APIも併存可能にする

### パフォーマンス影響
* ファイル分割により初期ロード時間が若干増加する可能性
* ただし、開発効率向上とのトレードオフとして許容範囲内

---

## 短期実装メモ（Claude指示用）

### config.js活用促進
* `TEGAKI_CONFIG` から値を取得する箇所を増やす
* ハードコードされた数値を設定値に移行

### API境界の明確化
* 各クラス間の依存関係を明示的にする
* 循環参照の回避

### エラーハンドリング統一
* 各モジュールで一貫したエラーハンドリング方式を採用
* デバッグ情報の出力レベル統一

---

## 将来拡張メモ

### WebWorker活用
* 重い処理（GIF生成、大量パスの描画）をWebWorkerで並列化
* UI応答性の更なる向上

### WebGL活用
* PixiJS WebGLレンダラーの高度活用
* カスタムシェーダーによる特殊効果

### クラウド連携
* ファイル保存・共有機能
* リアルタイム協作機能

---

## 付録：重要なファイル分割原則

1. **単一責任の原則**：各ファイルは一つの機能領域のみを担当
2. **依存関係の最小化**：ファイル間の依存を可能な限り減らす
3. **API設計の一貫性**：全モジュールで統一されたAPI設計
4. **Claude最適化**：改修時に触るべきファイル数を最小化
5. **将来拡張性**：新機能追加時にファイル構造を大きく変えずに済む設計

これらの原則に基づいて、Claude改修効率を最大化しつつ、将来のGIF化・2窓化・LIVE2D化へのスムーズな移行を実現する。