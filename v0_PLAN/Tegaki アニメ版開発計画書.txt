================================================================================
Tegaki アニメ版開発計画書
npm ライブラリ統合によるCSP対策実装ガイド
================================================================================

Document Version: 1.0
Last Updated: 2025-10-11
Target: 後続Claude / 開発者向け技術仕様書

================================================================================
目次
================================================================================

1. プロジェクト概要
2. アーキテクチャ設計
3. Phase 1: 環境構築
4. Phase 2: ライブラリ統合
5. Phase 3: コア機能実装
6. Phase 4: ローダー実装
7. Phase 5: テスト・デプロイ
8. 換骨奪胎ガイド（既存ツールからの移行）

================================================================================
1. プロジェクト概要
================================================================================

■ 1.1 目的
  - めぶきちゃんねるでAPNG/GIF投稿可能なお絵かきツール構築
  - CSP制約下でも動作する外部依存なしの単一ファイル構成
  - 既存のルール（bundler不使用、ESM不使用）を維持

■ 1.2 技術制約
  【遵守事項】
    - Canvas2D使用禁止（サムネイルのみ許可）
    - TypeScript使用禁止
    - Vite使用禁止
    - ESM使用禁止
    - bundler（webpack/rollup）使用禁止
    - Babel使用禁止
  
  【許可事項】
    - npm（ライブラリダウンロードのみ）
    - Node.js（ファイル結合スクリプトのみ）
    - ES2023構文（IIFEラップ必須）
    - fetch API
    - CDN（PixiJSのみ、アニメ版では不要）

■ 1.3 成果物
  tegaki_anime_test/
  ├── dist/tegaki_anime.js          # 統合済みコアファイル
  ├── tegaki-loader_anime.js        # ローダー（変更なし）
  └── TegakiAniTest.html            # ローカルテスト用HTML

================================================================================
2. アーキテクチャ設計
================================================================================

■ 2.1 全体フロー

  [ユーザー]
     ↓ ブックマークレット実行
  [tegaki-loader_anime.js] ← めぶきちゃんねる上で動作
     ↓ scriptタグで読み込み
  [tegaki_anime.js] ← UPNG/pako/GIF.js統合済み
     ↓ インスタンス化
  [TegakiAnimeCore] ← 描画・アニメーション・エクスポート
     ↓ Blob生成
  [めぶきちゃんねる投稿フォーム] ← File注入

■ 2.2 ファイル構成と役割

  【既存ファイル（参考用）】
    - tegaki_basic.js           : 静止画版コア
    - tegaki-loader_basic.js    : 静止画版ローダー
    - TegakiTest.html           : 静止画版テスト
    - tegaki_anime.js（既存）   : アニメ版コア（CDN依存版・動作不良）
    - tegaki-loader_anime.js    : アニメ版ローダー（CDN依存版・動作不良）
    - TegakiAniTest.html        : アニメ版テスト

  【新規作成ファイル】
    - package.json              : npm依存管理
    - build.js                  : ライブラリ結合スクリプト
    - libs/upng.js              : npmからコピーしたUPNG.js
    - libs/pako.js              : npmからコピーしたpako.js
    - libs/gif.js               : npmからコピーしたgif.js
    - libs/gif.worker.js        : npmからコピーしたgif.worker.js
    - src/tegaki_anime_core.js  : 既存tegaki_anime.jsを改修したもの
    - dist/tegaki_anime.js      : ビルド後の統合ファイル（最終成果物）

■ 2.3 依存関係マップ

  package.json
    └─> npm install
          ├─> upng-js@2.1.0
          ├─> pako@2.1.0
          └─> gif.js@0.2.0
                └─> gif.worker.js（別ファイル）

  build.js
    ├─ 読み込み: libs/upng.js
    ├─ 読み込み: libs/pako.js
    ├─ 読み込み: libs/gif.js
    ├─ 読み込み: libs/gif.worker.js（Base64化）
    └─ 読み込み: src/tegaki_anime_core.js
         ↓
    出力: dist/tegaki_anime.js（統合済み）

  TegakiAniTest.html
    └─ 読み込み: dist/tegaki_anime.js
         └─> window.TegakiAnimeCore をインスタンス化

  tegaki-loader_anime.js（めぶきちゃんねる用）
    └─ 読み込み: https://[GitHub Pages]/dist/tegaki_anime.js
         └─> window.TegakiAnimeCore をインスタンス化

================================================================================
Phase 1: 環境構築
================================================================================

■ 目的
  - npmプロジェクトの初期化
  - ライブラリのダウンロード
  - ディレクトリ構造の作成

■ 作業ファイル
  【新規作成】
    - package.json
    - build.js
    - ディレクトリ構造

■ 参考ファイル
  - なし（新規プロジェクト）

■ 処理フロー
  [コマンドライン操作]
    ↓
  プロジェクトフォルダ作成
    ↓
  npm init -y
    ↓
  npm install upng-js pako gif.js
    ↓
  ディレクトリ作成（libs, src, dist）

■ 実装手順

【手順1-1】プロジェクトフォルダ作成
  
  コマンド:
    cd tegaki
    mkdir tegaki_anime_test
    cd tegaki_anime_test

  確認:
    pwd
    # 出力: /path/to/tegaki/tegaki_anime_test

【手順1-2】package.json作成

  コマンド:
    npm init -y

  生成されるファイル: package.json
  
  内容（自動生成後に編集）:
    {
      "name": "tegaki_anime_test",
      "version": "1.0.0",
      "description": "Animation drawing tool for Mebuki channel",
      "main": "dist/tegaki_anime.js",
      "scripts": {
        "build": "node build.js"
      },
      "dependencies": {
        "upng-js": "^2.1.0",
        "pako": "^2.1.0",
        "gif.js": "^0.2.0"
      },
      "keywords": ["canvas", "animation", "apng", "gif"],
      "author": "",
      "license": "MIT"
    }

  使用メソッド:
    - npm init: package.jsonの対話的生成
    - -y フラグ: デフォルト値で自動生成

【手順1-3】ライブラリインストール

  コマンド:
    npm install

  処理内容:
    - package.jsonのdependenciesを読み込み
    - node_modules/フォルダにライブラリをダウンロード
    - package-lock.jsonを生成（バージョン固定）

  確認:
    ls node_modules/
    # 出力例: upng-js  pako  gif.js

【手順1-4】ディレクトリ構造作成

  コマンド:
    mkdir libs src dist

  最終的なディレクトリ構造:
    tegaki_anime_test/
    ├── node_modules/          # npm管理（Gitには含めない）
    ├── libs/                  # ライブラリコピー先
    ├── src/                   # ソースコード
    ├── dist/                  # ビルド出力
    ├── package.json
    ├── package-lock.json
    └── build.js               # 次のPhaseで作成

【手順1-5】ライブラリファイルのコピー

  コマンド:
    cp node_modules/upng-js/UPNG.js libs/upng.js
    cp node_modules/pako/dist/pako.min.js libs/pako.js
    cp node_modules/gif.js/dist/gif.js libs/gif.js
    cp node_modules/gif.js/dist/gif.worker.js libs/gif.worker.js

  確認:
    ls -lh libs/
    # 出力例:
    # upng.js      (約50KB)
    # pako.js      (約45KB)
    # gif.js       (約30KB)
    # gif.worker.js (約10KB)

  理由:
    - node_modules/は容量が大きくGitに含めない
    - libs/に必要なファイルのみコピーすることでバージョン管理を容易に

■ チェックポイント
  ✓ package.jsonが存在し、dependenciesに3つのライブラリが記載されている
  ✓ node_modules/に3つのライブラリフォルダが存在する
  ✓ libs/に4つのファイルがコピーされている
  ✓ src/, dist/ディレクトリが作成されている

================================================================================
Phase 2: ライブラリ統合
================================================================================

■ 目的
  - 複数のライブラリを単一ファイルに結合
  - GIF.jsのWorkerをBase64埋め込みでインライン化
  - CSP制約を回避できる形式に変換

■ 作業ファイル
  【新規作成】
    - build.js

■ 参考ファイル
  - libs/upng.js
  - libs/pako.js
  - libs/gif.js
  - libs/gif.worker.js

■ 処理フロー
  [build.js実行]
    ↓
  libs/内のファイルを読み込み
    ↓
  gif.worker.jsをBase64に変換
    ↓
  全ファイルを文字列結合
    ↓
  Workerインライン化コードを追加
    ↓
  グローバル変数公開コードを追加
    ↓
  dist/tegaki_anime.js に出力

■ 実装手順

【手順2-1】build.js作成（基本構造）

  ファイル: build.js
  
  内容:
    const fs = require('fs');
    const path = require('path');

    console.log('🔨 Building tegaki_anime.js with inline Worker...');

    // 出力ファイルのヘッダー
    let output = `// ========================================
    // Tegaki Anime Bundle
    // UPNG.js + pako.js + GIF.js + TegakiAnimeCore
    // Build: ${new Date().toISOString()}
    // ========================================
    
    `;

    // 次の手順に続く...

  使用メソッド:
    - require('fs'): Node.jsのファイルシステムモジュール
    - require('path'): パス操作モジュール
    - console.log(): ビルド状況の表示

【手順2-2】ライブラリファイルの読み込みと結合

  build.js に追加:

    // 結合するライブラリファイルのリスト
    const libraryFiles = [
        'libs/upng.js',
        'libs/pako.js',
        'libs/gif.js'
    ];

    // ライブラリを順次読み込んで結合
    libraryFiles.forEach(file => {
        console.log(`📦 Reading: ${file}`);
        const content = fs.readFileSync(path.join(__dirname, file), 'utf8');
        output += `\n// ========== ${file} ==========\n`;
        output += content + '\n';
    });

  使用メソッド:
    - fs.readFileSync(path, encoding): ファイルを同期的に読み込み
      - 引数1: ファイルパス
      - 引数2: 'utf8' = テキストとして読み込み
      - 戻り値: ファイル内容（文字列）
    - path.join(...paths): パスを結合（OS依存の区切り文字を自動処理）
    - __dirname: 実行中のスクリプトのディレクトリパス

【手順2-3】GIF.jsのWorkerをBase64化

  build.js に追加:

    // Worker ファイルをBase64に変換
    console.log('🔧 Encoding gif.worker.js to Base64...');
    const workerCode = fs.readFileSync(
        path.join(__dirname, 'libs/gif.worker.js'), 
        'utf8'
    );
    const workerBase64 = Buffer.from(workerCode).toString('base64');
    console.log(`✓ Worker size: ${workerCode.length} bytes`);
    console.log(`✓ Base64 size: ${workerBase64.length} bytes`);

  使用メソッド:
    - Buffer.from(string): 文字列をバッファに変換
    - Buffer.toString('base64'): バッファをBase64文字列に変換
    
  処理内容:
    - gif.worker.js の内容を文字列として読み込み
    - Base64エンコードして埋め込み可能な形式に変換
    - これによりWorkerを外部ファイルとして読み込む必要がなくなる

【手順2-4】Workerインライン化コードをIIFEで追加

  build.js に追加:

    // Worker をインライン化するコード
    output += `
    // ========== GIF.js Worker Inline ==========
    (function() {
        'use strict';
        
        // GIFライブラリが読み込まれているか確認
        if (typeof window === 'undefined' || !window.GIF) {
            console.warn('GIF.js not loaded, skipping Worker inline');
            return;
        }
        
        // Base64からWorkerコードをデコード
        const workerCodeBase64 = '${workerBase64}';
        const workerCode = atob(workerCodeBase64);
        
        // Blob URL を生成
        const blob = new Blob([workerCode], { 
            type: 'application/javascript' 
        });
        const workerUrl = URL.createObjectURL(blob);
        
        // GIF.js のデフォルト Worker を上書き
        if (window.GIF.prototype) {
            window.GIF.prototype.options = window.GIF.prototype.options || {};
            window.GIF.prototype.options.workerScript = workerUrl;
            console.log('✅ GIF.js Worker inlined successfully');
        }
    })();
    `;

  使用メソッド:
    - atob(base64String): Base64文字列をデコード（ブラウザのグローバル関数）
    - new Blob(array, options): バイナリデータを作成
      - 引数1: データ配列
      - 引数2: { type: MIMEタイプ }
    - URL.createObjectURL(blob): BlobからURL文字列を生成
      - 戻り値: 'blob:...' 形式のURL
    
  重要ポイント:
    - IIFE（即時実行関数式）でラップすることでスコープを分離
    - Blob URLを使うことでCSPの worker-src 制約を回避

【手順2-5】グローバル変数の公開

  build.js に追加:

    // ライブラリをグローバルに公開
    output += `
    // ========== Global Exports ==========
    (function() {
        'use strict';
        
        if (typeof window !== 'undefined') {
            // UPNG.js の公開
            if (typeof UPNG !== 'undefined') {
                window.UPNG = UPNG;
            }
            
            // pako.js の公開
            if (typeof pako !== 'undefined') {
                window.pako = pako;
                window.Zlib = pako;  // UPNG.jsが期待する名前
            }
            
            // GIF.js の公開
            if (typeof GIF !== 'undefined') {
                window.GIF = GIF;
            }
            
            console.log('✅ Libraries exposed to window:', {
                UPNG: !!window.UPNG,
                pako: !!window.pako,
                Zlib: !!window.Zlib,
                GIF: !!window.GIF
            });
        }
    })();
    `;

  使用メソッド:
    - typeof variable: 変数の型を文字列で返す
      - 未定義の場合: 'undefined'
    - !!value: 二重否定で真偽値に変換
      - 存在チェック用

  重要ポイント:
    - window.Zlib = pako の設定が必須
    - UPNG.jsは内部で window.Zlib.deflate() を呼び出すため

【手順2-6】ファイル出力

  build.js に追加:

    // dist フォルダが存在しない場合は作成
    const distDir = path.join(__dirname, 'dist');
    if (!fs.existsSync(distDir)) {
        fs.mkdirSync(distDir, { recursive: true });
        console.log('📁 Created dist/ directory');
    }

    // ファイル出力
    const outputPath = path.join(distDir, 'tegaki_anime.js');
    fs.writeFileSync(outputPath, output, 'utf8');

    // 統計情報の表示
    const stats = fs.statSync(outputPath);
    console.log('✅ Build complete!');
    console.log(`📄 Output: ${outputPath}`);
    console.log(`📦 Size: ${(stats.size / 1024).toFixed(2)} KB`);
    console.log(`📦 Lines: ${output.split('\n').length}`);

  使用メソッド:
    - fs.existsSync(path): ファイル/ディレクトリの存在確認
    - fs.mkdirSync(path, options): ディレクトリ作成
      - { recursive: true }: 親ディレクトリも自動作成
    - fs.writeFileSync(path, data, encoding): ファイルに書き込み
    - fs.statSync(path): ファイル情報の取得
      - 戻り値.size: ファイルサイズ（バイト）

【手順2-7】ビルド実行

  コマンド:
    npm run build

  期待される出力:
    🔨 Building tegaki_anime.js with inline Worker...
    📦 Reading: libs/upng.js
    📦 Reading: libs/pako.js
    📦 Reading: libs/gif.js
    🔧 Encoding gif.worker.js to Base64...
    ✓ Worker size: 10234 bytes
    ✓ Base64 size: 13648 bytes
    📁 Created dist/ directory
    ✅ Build complete!
    📄 Output: /path/to/dist/tegaki_anime.js
    📦 Size: 145.23 KB
    📦 Lines: 3542

  確認:
    ls -lh dist/
    # 出力: tegaki_anime.js (約145KB)

■ チェックポイント
  ✓ build.jsが作成され、npm run buildで実行できる
  ✓ dist/tegaki_anime.jsが生成される
  ✓ ファイルサイズが100KB以上ある（ライブラリが統合されている証拠）
  ✓ ファイル内にBase64文字列が含まれている（Worker埋め込み確認）

================================================================================
Phase 3: コア機能実装
================================================================================

■ 目的
  - TegakiAnimeCoreクラスの実装
  - アニメーション描画機能
  - APNG/GIFエクスポート機能

■ 作業ファイル
  【新規作成】
    - src/tegaki_anime_core.js

■ 参考ファイル
  - tegaki_basic.js（静止画版コア）
  - tegaki_anime.js（既存のアニメ版・修正前）

■ 処理フロー
  [TegakiAnimeCore インスタンス化]
    ↓
  UIの構築（キャンバス、サムネイル）
    ↓
  イベントリスナー設定（描画、レイヤー切替）
    ↓
  描画処理（各フレームに保存）
    ↓
  エクスポート（APNG/GIF生成）

■ クラス設計

  class TegakiAnimeCore {
    constructor(container)          // 初期化
    init()                          // 内部初期化処理
    createUI()                      // UI要素の生成
    setupCanvas()                   // Canvas設定
    initLayersAndHistory()          // レイヤー・履歴の初期化
    attachEvents()                  // イベントリスナー設定
    
    // 描画関連
    startDrawing(e)                 // 描画開始
    draw(e)                         // 描画処理
    stopDrawing()                   // 描画終了
    
    // レイヤー管理
    switchLayer(index)              // レイヤー切替
    updateThumbnail()               // サムネイル更新
    
    // Undo/Redo
    pushHistory()                   // 履歴に追加
    undo()                          // 元に戻す
    redo()                          // やり直し
    handleKeyDown(e)                // キーボードショートカット
    
    // エクスポート
    prepareExport()                 // エクスポート前処理
    exportAsApng()                  // APNG生成
    exportAsGif(onProgress)         // GIF生成
    
    // クリーンアップ
    destroy()                       // インスタンス破棄
  }

■ 実装手順

【手順3-1】既存ファイルのコピーと配置

  コマンド:
    cp ../docs/tegaki_anime.js src/tegaki_anime_core.js

  編集:
    - ファイルを開き、IIFE構造を確認
    - 最終的にbuild.jsで結合するため、IIFEは維持

【手順3-2】コンストラクタとプロパティ定義

  ファイル: src/tegaki_anime_core.js
  
  該当部分（11行目〜45行目付近）:

    window.TegakiAnimeCore = class TegakiAnimeCore {
        constructor(container) {
            // DOM要素
            this.container = container;
            this.wrapper = null;
            this.canvas = null;              // 描画用メインキャンバス
            this.ctx = null;                 // 描画コンテキスト
            this.bgCanvas = null;            // 背景表示用キャンバス
            
            // 描画状態
            this.isDrawing = false;
            this.lastX = 0;
            this.lastY = 0;
            
            // 固定ツール設定
            this.color = '#800000';          // ふたば maroon
            this.size = 2;                   // ブラシサイズ
            
            // アニメーション設定
            this.frameCount = 5;             // フレーム数
            this.frameDelay = 200;           // フレーム間隔（ミリ秒）
            this.layers = [];                // ImageData配列
            this.thumbnailContainer = null;  // サムネイル表示領域
            this.activeLayerIndex = 0;       // 現在編集中のレイヤー
            
            // Undo/Redo履歴
            this.history = [];               // [layer0: [state0, state1, ...], layer1: [...]]
            this.historyIndex = [];          // [layer0: index, layer1: index, ...]
            
            // イベントリスナー保持（メモリリーク対策）
            this.boundHandleKeyDown = this.handleKeyDown.bind(this);
            
            this.init();
        }
    }

  重要ポイント:
    - this.layers: 各フレームの描画内容をImageDataで保持
    - this.history: 2次元配列でレイヤーごとのUndoスタックを管理
    - this.boundHandleKeyDown: bind()したメソッドを保持してremoveEventListenerで使用

  使用メソッド:
    - Function.prototype.bind(thisArg): メソッドのthisを固定
      - 戻り値: 新しい関数（thisが束縛済み）

【手順3-3】UI生成（createUI）

  該当部分（src/tegaki_anime_core.js 52行目〜135行目付近）:

    createUI() {
        // ラッパー作成
        this.wrapper = document.createElement('div');
        this.wrapper.style.cssText = `
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background: #ffffee;
            padding: 10px 0 20px 0;
        `;
        
        // キャンバスエリア作成
        const canvasArea = document.createElement('div');
        canvasArea.style.cssText = `
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        `;
        
        // キャンバスコンテナ（背景+描画の2層構造）
        const canvasContainer = document.createElement('div');
        canvasContainer.style.cssText = `
            position: relative;
            width: 400px;
            height: 400px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        `;
        
        // 背景キャンバス（レイヤー0）
        this.bgCanvas = document.createElement('canvas');
        this.bgCanvas.width = 400;
        this.bgCanvas.height = 400;
        const bgCtx = this.bgCanvas.getContext('2d');
        bgCtx.fillStyle = '#f0e0d6';
        bgCtx.fillRect(0, 0, 400, 400);
        this.bgCanvas.style.cssText = `
            position: absolute; 
            top: 0; 
            left: 0;
        `;
        
        // 描画キャンバス（レイヤー1・透明）
        this.canvas = document.createElement('canvas');
        this.canvas.width = 400;
        this.canvas.height = 400;
        this.canvas.style.cssText = `
            position: absolute; 
            top: 0; 
            left: 0; 
            cursor: crosshair;
        `;
        
        // 組み立て
        canvasContainer.appendChild(this.bgCanvas);
        canvasContainer.appendChild(this.canvas);
        canvasArea.appendChild(canvasContainer);
        
        // サムネイルエリア作成
        this.thumbnailContainer = document.createElement('div');
        this.thumbnailContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 5px 0;
        `;
        
        // サムネイル個別作成（フレーム数分）
        for (let i = 0; i < this.frameCount; i++) {
            const thumb = document.createElement('canvas');
            thumb.width = 60;
            thumb.height = 60;
            thumb.style.cssText = `
                border: 3px solid #aa5a56;
                border-radius: 2px;
                background: #f0e0d6;
                cursor: pointer;
                transition: all 0.2s;
            `;
            thumb.title = `レイヤー ${i + 1}`;
            thumb.onclick = () => this.switchLayer(i);
            this.thumbnailContainer.appendChild(thumb);
        }
        
        // DOMに追加
        this.wrapper.appendChild(canvasArea);
        this.wrapper.appendChild(this.thumbnailContainer);
        this.container.appendChild(this.wrapper);
    }

  使用メソッド:
    - document.createElement(tagName): HTML要素を作成
    - element.style.cssText: インラインスタイルを一括設定
    - element.appendChild(child): 子要素を追加
    - canvas.getContext('2d'): 2D描画コンテキストを取得
    - ctx.fillRect(x, y, width, height): 矩形を塗りつぶし

  重要ポイント:
    - 2層構造（背景+描画）により、背景を消さずに透明レイヤーで描画
    - position: absolute で重ね合わせ
    - サムネイルは Canvas2D

【手順3-4】キャンバス設定（setupCanvas）

  該当部分（src/tegaki_anime_core.js 140行目〜147行目付近）:

    setupCanvas() {
        this.ctx = this.canvas.getContext('2d');
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.size;
    }

  使用メソッド:
    - canvas.getContext('2d'): CanvasRenderingContext2D オブジェクトを取得
    - ctx.lineCap: 線の端の形状（'butt' | 'round' | 'square'）
    - ctx.lineJoin: 線の接合部の形状（'round' | 'bevel' | 'miter'）
    - ctx.strokeStyle: 線の色（CSS色文字列）
    - ctx.lineWidth: 線の太さ（ピクセル）

  重要ポイント:
    - lineCap/lineJoin を 'round' にすることで滑らかな線を描画
    - 初期値として color と size を設定

【手順3-5】レイヤーと履歴の初期化（initLayersAndHistory）

  該当部分（src/tegaki_anime_core.js 150行目〜157行目付近）:

    initLayersAndHistory() {
        for (let i = 0; i < this.frameCount; i++) {
            // 透明な ImageData を作成
            const initialImageData = this.ctx.createImageData(
                this.canvas.width, 
                this.canvas.height
            );
            
            this.layers.push(initialImageData);
            this.history.push([initialImageData]);  // 履歴の最初に追加
            this.historyIndex.push(0);
        }
    }

  使用メソッド:
    - ctx.createImageData(width, height): 空の ImageData を作成
      - 戻り値: ImageData オブジェクト
        - .data: Uint8ClampedArray（RGBA値の配列）
        - .width: 幅
        - .height: 高さ

  重要ポイント:
    - ImageData は Canvas の生ピクセルデータを保持
    - 各レイヤーごとに独立した履歴スタックを持つ
    - 初期状態（空の ImageData）を履歴の最初に追加

【手順3-6】イベントリスナー設定（attachEvents）

  該当部分（src/tegaki_anime_core.js 162行目〜197行目付近）:

    attachEvents() {
        // マウスイベント
        this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', (e) => this.draw(e));
        this.canvas.addEventListener('mouseup', () => this.stopDrawing());
        this.canvas.addEventListener('mouseleave', () => this.stopDrawing());
        
        // タッチイベント（モバイル対応）
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            this.canvas.dispatchEvent(mouseEvent);
        });
        
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            this.canvas.dispatchEvent(mouseEvent);
        });
        
        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            this.canvas.dispatchEvent(mouseEvent);
        });

        // キーボードイベント（Undo/Redo）
        document.addEventListener('keydown', this.boundHandleKeyDown);
    }

  使用メソッド:
    - element.addEventListener(type, listener): イベントリスナーを登録
      - 引数1: イベントタイプ（'mousedown', 'touchstart' など）
      - 引数2: コールバック関数
    - Event.preventDefault(): デフォルト動作をキャンセル
    - TouchEvent.touches: タッチポイントの配列
      - touches[0]: 最初のタッチポイント
    - new MouseEvent(type, options): マウスイベントを生成
    - element.dispatchEvent(event): イベントを発火

  重要ポイント:
    - タッチイベントをマウスイベントに変換してコードを共通化
    - preventDefault() でスクロール防止
    - boundHandleKeyDown を使用（後で removeEventListener するため）

【手順3-7】描画処理（startDrawing / draw / stopDrawing）

  該当部分（src/tegaki_anime_core.js 202行目〜237行目付近）:

    startDrawing(e) {
        this.isDrawing = true;
        const rect = this.canvas.getBoundingClientRect();
        this.lastX = e.clientX - rect.left;
        this.lastY = e.clientY - rect.top;
    }
    
    draw(e) {
        if (!this.isDrawing) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        this.ctx.beginPath();
        this.ctx.moveTo(this.lastX, this.lastY);
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
        
        this.lastX = x;
        this.lastY = y;
    }
    
    stopDrawing() {
        if (!this.isDrawing) return;
        this.isDrawing = false;
        this.ctx.beginPath();
        this.pushHistory();
        this.updateThumbnail();
    }

  使用メソッド:
    - element.getBoundingClientRect(): 要素の位置とサイズを取得
      - 戻り値: DOMRect { left, top, width, height, ... }
    - MouseEvent.clientX/clientY: ビューポート座標
    - ctx.beginPath(): 新しいパスを開始
    - ctx.moveTo(x, y): パスの開始位置を設定
    - ctx.lineTo(x, y): 現在位置から指定位置まで線を描画
    - ctx.stroke(): 現在のパスを描画

  重要ポイント:
    - getBoundingClientRect() で Canvas の画面上の位置を取得
    - clientX/Y から rect.left/top を引いて Canvas 内の座標に変換
    - lastX/Y を保持して連続した線を描画
    - stopDrawing() で履歴保存とサムネイル更新

【手順3-8】レイヤー管理（switchLayer / updateThumbnail）

  該当部分（src/tegaki_anime_core.js 242行目〜274行目付近）:

    switchLayer(index) {
        if (index === this.activeLayerIndex) return;
        
        // 現在のレイヤーの描画内容を保存
        this.layers[this.activeLayerIndex] = this.ctx.getImageData(
            0, 0, 
            this.canvas.width, 
            this.canvas.height
        );
        
        // 新しいレイヤーに切り替え
        this.activeLayerIndex = index;
        this.ctx.putImageData(this.layers[index], 0, 0);
        
        // サムネイルのハイライトを更新
        this.thumbnailContainer.childNodes.forEach((thumb, i) => {
            thumb.style.borderColor = (i === index) ? '#800000' : '#aa5a56';
            thumb.style.transform = (i === index) ? 'scale(1.1)' : 'scale(1)';
        });
    }
    
    updateThumbnail() {
        const thumbCanvas = this.thumbnailContainer.childNodes[this.activeLayerIndex];
        if (!thumbCanvas) return;
        const thumbCtx = thumbCanvas.getContext('2d');
        thumbCtx.clearRect(0, 0, thumbCanvas.width, thumbCanvas.height);

        // サムネイルには背景も合成して表示
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.canvas.width;
        tempCanvas.height = this.canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(this.bgCanvas, 0, 0);
        tempCtx.drawImage(this.canvas, 0, 0);
        
        thumbCtx.drawImage(
            tempCanvas, 
            0, 0, 
            thumbCanvas.width, 
            thumbCanvas.height
        );
    }

  使用メソッド:
    - ctx.getImageData(x, y, width, height): Canvas からピクセルデータを取得
      - 戻り値: ImageData オブジェクト
    - ctx.putImageData(imageData, x, y): ピクセルデータを Canvas に描画
    - ctx.clearRect(x, y, width, height): 指定領域をクリア
    - ctx.drawImage(source, dx, dy): 画像を描画
    - ctx.drawImage(source, dx, dy, dWidth, dHeight): リサイズして描画

  重要ポイント:
    - switchLayer() でレイヤー間の切り替え時に ImageData を保存/復元
    - updateThumbnail() で背景と描画を合成した状態でサムネイル表示
    - 一時的な tempCanvas を使って合成（元のキャンバスを汚さない）

【手順3-9】Undo/Redo 機能（pushHistory / undo / redo / handleKeyDown）

  該当部分（src/tegaki_anime_core.js 279行目〜318行目付近）:

    handleKeyDown(e) {
        // UIが存在しない場合は処理しない（メモリリーク対策）
        if (!this.wrapper || !this.wrapper.isConnected) return;
        
        if (e.ctrlKey && e.key.toLowerCase() === 'z') {
            e.preventDefault();
            this.undo();
        }
        if (e.ctrlKey && e.key.toLowerCase() === 'y') {
            e.preventDefault();
            this.redo();
        }
    }

    pushHistory() {
        const history = this.history[this.activeLayerIndex];
        let index = this.historyIndex[this.activeLayerIndex];
        
        // 現在位置より後の履歴を削除（分岐を防ぐ）
        if (index < history.length - 1) {
            this.history[this.activeLayerIndex] = history.slice(0, index + 1);
        }
        
        // 現在の状態を履歴に追加
        const imageData = this.ctx.getImageData(
            0, 0, 
            this.canvas.width, 
            this.canvas.height
        );
        this.history[this.activeLayerIndex].push(imageData);
        this.historyIndex[this.activeLayerIndex]++;
    }

    undo() {
        let index = this.historyIndex[this.activeLayerIndex];
        if (index > 0) {
            index--;
            this.historyIndex[this.activeLayerIndex] = index;
            const imageData = this.history[this.activeLayerIndex][index];
            this.ctx.putImageData(imageData, 0, 0);
            this.updateThumbnail();
        }
    }
    
    redo() {
        const history = this.history[this.activeLayerIndex];
        let index = this.historyIndex[this.activeLayerIndex];
        if (index < history.length - 1) {
            index++;
            this.historyIndex[this.activeLayerIndex] = index;
            const imageData = this.history[this.activeLayerIndex][index];
            this.ctx.putImageData(imageData, 0, 0);
            this.updateThumbnail();
        }
    }

  使用メソッド:
    - KeyboardEvent.ctrlKey: Ctrl キーが押されているか
    - KeyboardEvent.key: 押されたキーの文字列
    - String.toLowerCase(): 小文字に変換
    - Array.slice(start, end): 配列の一部を取得
      - 引数1: 開始インデックス（含む）
      - 引数2: 終了インデックス（含まない）
    - Node.isConnected: ノードが DOM に接続されているか

  重要ポイント:
    - レイヤーごとに独立した履歴を管理
    - pushHistory() で分岐履歴を削除（リニア履歴を維持）
    - isConnected チェックでメモリリーク防止

【手順3-10】エクスポート前処理（prepareExport）

  該当部分（src/tegaki_anime_core.js 323行目〜327行目付近）:

    prepareExport() {
        // 現在編集中のレイヤーの内容を保存
        this.layers[this.activeLayerIndex] = this.ctx.getImageData(
            0, 0, 
            this.canvas.width, 
            this.canvas.height
        );
    }

  重要ポイント:
    - エクスポート直前に現在のレイヤーを保存
    - これにより未保存の描画内容も確実にエクスポートされる

【手順3-11】APNGエクスポート（exportAsApng）

  該当部分（src/tegaki_anime_core.js 330行目〜358行目付近）:

    async exportAsApng() {
        this.prepareExport();
        
        // ライブラリの存在確認
        if (!window.UPNG || !window.Zlib) {
            alert('APNG生成ライブラリ(UPNG.js/pako.js)が読み込まれていません。');
            return null;
        }
        
        const frames = [];
        
        // 各レイヤーを背景と合成してフレーム化
        for (const layerData of this.layers) {
            const frameCanvas = document.createElement('canvas');
            frameCanvas.width = this.canvas.width;
            frameCanvas.height = this.canvas.height;
            const frameCtx = frameCanvas.getContext('2d');
            
            // 背景を描画
            frameCtx.drawImage(this.bgCanvas, 0, 0);
            
            // レイヤーを重ねる
            frameCtx.putImageData(layerData, 0, 0);
            
            // ImageData の data プロパティ（Uint8ClampedArray）を取得
            const imageData = frameCtx.getImageData(
                0, 0, 
                frameCanvas.width, 
                frameCanvas.height
            );
            
            // ArrayBuffer に変換して frames 配列に追加
            frames.push(imageData.data.buffer);
        }
        
        // 各フレームの表示時間（ミリ秒）
        const delays = Array(this.frameCount).fill(this.frameDelay);
        
        // UPNG.encode でAPNGバイナリを生成
        const apngData = UPNG.encode(
            frames,                    // ArrayBuffer[]
            this.canvas.width,         // 幅
            this.canvas.height,        // 高さ
            0,                         // 圧縮レベル（0=無圧縮）
            delays                     // 各フレームの遅延時間
        );
        
        // Blob に変換して返す
        return new Blob([apngData], {type: 'image/png'});
    }

  使用メソッド:
    - UPNG.encode(frames, width, height, cnum, delays): APNGバイナリを生成
      - 引数1: ArrayBuffer[] - 各フレームのRGBAデータ
      - 引数2: 幅（ピクセル）
      - 引数3: 高さ（ピクセル）
      - 引数4: 色数（0=自動、256=8bit）
      - 引数5: number[] - 各フレームの遅延（ミリ秒）
      - 戻り値: ArrayBuffer - APNGバイナリ
    - Array(length).fill(value): 指定値で埋めた配列を生成
    - new Blob(array, options): バイナリデータを作成
      - 引数1: ArrayBuffer や文字列の配列
      - 引数2: { type: MIMEタイプ }

  重要ポイント:
    - MIMEタイプは 'image/png' を使用（'image/apng' ではない）
    - APNG は PNG の拡張なので標準の PNG MIMEタイプで扱う
    - imageData.data.buffer で Uint8ClampedArray から ArrayBuffer を取得

【手順3-12】GIFエクスポート（exportAsGif）

  該当部分（src/tegaki_anime_core.js 361行目〜410行目付近）:

    async exportAsGif(onProgress) {
        this.prepareExport();
        
        // ライブラリの存在確認
        if (!window.GIF) {
            alert('GIF生成ライブラリが読み込まれていません。');
            return null;
        }

        return new Promise((resolve) => {
            // GIF.js インスタンスを作成
            const gif = new GIF({
                workers: 2,            // Worker数
                quality: 10,           // 品質（1-30、低いほど高品質）
                width: this.canvas.width,
                height: this.canvas.height
            });
            
            // 進捗コールバックを登録
            if (onProgress && typeof onProgress === 'function') {
                gif.on('progress', onProgress);
            }

            // 各レイヤーを背景と合成してフレーム追加
            for (const layerData of this.layers) {
                const frameCanvas = document.createElement('canvas');
                frameCanvas.width = this.canvas.width;
                frameCanvas.height = this.canvas.height;
                const frameCtx = frameCanvas.getContext('2d');
                
                // 背景を描画
                frameCtx.drawImage(this.bgCanvas, 0, 0);
                
                // レイヤーを重ねる
                frameCtx.putImageData(layerData, 0, 0);
                
                // GIF にフレームを追加
                gif.addFrame(frameCanvas, { 
                    delay: this.frameDelay 
                });
            }

            // 生成完了イベント
            gif.on('finished', (blob) => {
                // 進捗コールバックを解除（メモリリーク対策）
                if (onProgress) {
                    gif.off('progress', onProgress);
                }
                resolve(blob);
            });
            
            // GIF生成を開始
            gif.render();
        });
    }

  使用メソッド:
    - new GIF(options): GIF.js インスタンスを作成
      - options.workers: 使用するWorker数
      - options.quality: エンコード品質（1-30）
      - options.width/height: GIFサイズ
    - gif.addFrame(canvas, options): フレームを追加
      - 引数1: Canvas要素 または ImageData
      - 引数2: { delay: ミリ秒, copy: boolean }
    - gif.on(event, callback): イベントリスナー登録
      - 'progress': 進捗更新（引数: 0.0-1.0）
      - 'finished': 生成完了（引数: Blob）
    - gif.off(event, callback): イベントリスナー解除
    - gif.render(): GIF生成を開始
    - new Promise(executor): Promise を作成
      - executor: (resolve, reject) => void

  重要ポイント:
    - 非同期処理のため Promise でラップ
    - Worker が内部で動作（build.js で埋め込み済み）
    - 進捗コールバックで UI 更新が可能
    - gif.off() でリスナー解除してメモリリーク防止

【手順3-13】クリーンアップ（destroy）

  該当部分（src/tegaki_anime_core.js 415行目〜424行目付近）:

    destroy() {
        // イベントリスナーを解除（メモリリーク対策）
        document.removeEventListener('keydown', this.boundHandleKeyDown);
        
        // DOM要素を削除
        if (this.wrapper && this.wrapper.parentNode) {
            this.wrapper.remove();
        }
        
        // 参照をクリア
        this.canvas = null;
        this.ctx = null;
        this.bgCanvas = null;
        this.layers = null;
        this.history = null;
    }

  使用メソッド:
    - element.removeEventListener(type, listener): イベントリスナーを解除
    - Node.parentNode: 親ノードを取得
    - Node.remove(): DOMから自身を削除

  重要ポイント:
    - removeEventListener には addEventListener と同じ関数を渡す必要
    - そのため boundHandleKeyDown を使用
    - 参照を null にしてガベージコレクションを促進

【手順3-14】build.js にコアファイルを追加

  ファイル: build.js
  
  該当部分の修正（libraryFiles 配列に追加）:

    const libraryFiles = [
        'libs/upng.js',
        'libs/pako.js',
        'libs/gif.js',
        'src/tegaki_anime_core.js'  // ← 追加
    ];

  これにより、ビルド時にコアファイルも統合される。

【手順3-15】ビルドと動作確認

  コマンド:
    npm run build

  確認:
    cat dist/tegaki_anime.js | grep "TegakiAnimeCore"
    # 出力: window.TegakiAnimeCore = class TegakiAnimeCore { が見つかればOK

■ チェックポイント
  ✓ src/tegaki_anime_core.js が作成されている
  ✓ TegakiAnimeCore クラスがすべてのメソッドを実装している
  ✓ build.js に src/tegaki_anime_core.js が追加されている
  ✓ npm run build で dist/tegaki_anime.js にクラスが含まれる
  ✓ ファイルサイズが 150KB 以上ある

================================================================================
Phase 4: ローダー実装
================================================================================

■ 目的
  - めぶきちゃんねる上で動作するローダー実装
  - 統合済み tegaki_anime.js の読み込み
  - UI表示とエクスポート処理

■ 作業ファイル
  【修正】
    - tegaki-loader_anime.js

■ 参考ファイル
  - tegaki-loader_basic.js（静止画版ローダー）

■ 処理フロー
  [ブックマークレット実行]
    ↓
  window.tegakiAnimeStart() 呼び出し
    ↓
  TegakiLoaderAnime.start()
    ↓
  掲示板判定 → 要素検出
    ↓
  tegaki_anime.js を読み込み
    ↓
  TegakiAnimeCore をインスタンス化
    ↓
  ユーザーが描画
    ↓
  exportAndAttach() でBlob生成
    ↓
  injectToBoard() でフォームに注入

■ クラス設計

  class TegakiLoaderAnime {
    constructor()                       // 初期化
    start()                             // エントリーポイント
    detectBoard()                       // 掲示板判定
    findTargetElements()                // 要素検出
    createUI()                          // UI作成
    exportAndAttach(type)               // エクスポート+添付
    injectToBoard(blob, type)           // フォームに注入
    cancel()                            // キャンセル
    cleanup()                           // クリーンアップ
    wait(ms)                            // 待機
    waitFor(condition, timeout)         // 条件待機
  }

■ 実装手順

【手順4-1】既存ファイルのコピー

  コマンド:
    # 既存のローダーをプロジェクトにコピー
    cp ../docs/tegaki-loader_anime.js ./

  編集方針:
    - 基本構造はそのまま（動作実績あり）
    - SCRIPT_URLS を修正
    - APNG の MIMEタイプを修正

【手順4-2】SCRIPT_URLS の修正

  ファイル: tegaki-loader_anime.js
  
  該当部分（17行目〜24行目付近）:

  修正前:
    const SCRIPT_URLS = {
        tegaki: 'https://cdn.jsdelivr.net/gh/toshinka/tegaki/docs/tegaki_anime.js',
        upng: 'https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js',
        pako: 'https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js',
        gif: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js',
        gifWorker: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
    };

  修正後:
    const SCRIPT_URLS = {
        // 統合済みファイルのみ読み込む（他は不要）
        tegaki: 'https://toshinka.github.io/tegaki/tegaki_anime_test/dist/tegaki_anime.js'
    };

  理由:
    - 統合ビルドにより、UPNG/pako/GIF.js は tegaki_anime.js に含まれる
    - 外部CDNへの依存をすべて排除

【手順4-3】start() メソッドの修正

  ファイル: tegaki-loader_anime.js
  
  該当部分（92行目〜143行目付近）:

  修正前のライブラリ読み込み部分:
    await Promise.all([
        loadScript(SCRIPT_URLS.upng),
        loadScript(SCRIPT_URLS.pako),
        loadScript(SCRIPT_URLS.gif),
        loadScript(SCRIPT_URLS.tegaki)
    ]);

  修正後:
    // 統合済みファイルのみ読み込み
    await loadScript(SCRIPT_URLS.tegaki);

  修正前のWorker設定部分を削除:
    if (window.GIF && window.GIF.prototype) {
        if (typeof window.GIF.prototype.options === 'undefined') {
            window.GIF.prototype.options = {};
        }
        window.GIF.prototype.options.workerScript = SCRIPT_URLS.gifWorker;
    }

  理由:
    - Worker は build.js でインライン化済み
    - 外部URLを設定する必要がない

【手順4-4】injectToBoard() の MIMEタイプ修正

  ファイル: tegaki-loader_anime.js
  
  該当部分（267行目〜284行目付近）:

  修正前:
    const mimeType = type === 'apng' ? 'image/apng' : 'image/gif';
    const filename = `tegaki_anime_${Date.now()}.${type}`;

  修正後:
    // APNG は標準の image/png を使用
    const mimeType = type === 'apng' ? 'image/png' : 'image/gif';
    
    // 拡張子も .png に統一
    const ext = type === 'apng' ? 'png' : 'gif';
    const filename = `tegaki_anime_${Date.now()}.${ext}`;

  理由:
    - APNG は PNG の拡張なので 'image/png' が正しい
    - めぶきちゃんねるは 'image/apng' を受け付けない可能性

【手順4-5】進捗表示の改善（既存コードの確認）

  該当部分（207行目〜240行目付近）:

  既存コード（変更不要）:
    async exportAndAttach(type) {
        if (!this.core) {
            alert('お絵かきツールが初期化されていません');
            return;
        }
        
        try {
            // ローディング表示
            this.loadingEl = this.loadingEl || document.createElement('div');
            this.loadingEl.textContent = `${type.toUpperCase()}を生成中...`;
            this.loadingEl.style.cssText = '...';
            document.body.appendChild(this.loadingEl);

            let blob;
            
            const progressCallback = (p) => {
                const percent = Math.floor(p * 100);
                this.loadingEl.textContent = `${type.toUpperCase()}を生成中... (${percent}%)`;
            };

            if (type === 'apng') {
                blob = await this.core.exportAsApng();
} else if (type === 'gif') {
                // GIF生成時に進捗コールバックを渡す
                blob = await this.core.exportAsGif(progressCallback);
            } else {
                throw new Error('無効なエクスポートタイプです。');
            }
            
            this.loadingEl.remove();

            if (!blob) {
                alert(`${type.toUpperCase()}の生成に失敗しました。`);
                return;
            }
            
            console.log(`[Tegaki Anime Loader] ✓ ${type.toUpperCase()} Blob created:`, blob.size, 'bytes');
            
            // 掲示板に注入
            await this.injectToBoard(blob, type);
            console.log('[Tegaki Anime Loader] ✓ Image injected to board');
            
            alert(`画像を添付しました！投稿ボタンを押してください。\n(ファイル形式: ${type.toUpperCase()})`);
            this.cleanup();
            
        } catch (error) {
            console.error('[Tegaki Anime Loader] エクスポート失敗:', error);
            if (this.loadingEl) this.loadingEl.remove();
            alert(`画像の出力に失敗しました\n${error.message}`);
        }
    }

  使用メソッド:
    - async/await: 非同期処理の順次実行
    - try/catch: エラーハンドリング
    - console.log/error: デバッグログ出力
    - alert(): ユーザーへの通知

  重要ポイント:
    - progressCallback を GIF生成のみに渡す（APNGは進捗なし）
    - エラー時にローディング表示を確実に削除

【手順4-6】createUI() メソッドの確認

  該当部分（147行目〜204行目付近）:

  既存コード（変更不要）:
    createUI() {
        // フルスクリーンコンテナ
        this.container = document.createElement('div');
        this.container.id = 'tegaki-anime-container';
        this.container.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #f0e0d6; z-index: 10000;
            display: flex; flex-direction: column;
        `;

        // トップバー（ふたば風カラー）
        const topBar = document.createElement('div');
        topBar.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background: #e9c2ba;
            border-bottom: 2px solid #cf9c97;
            gap: 8px;
        `;
        
        // 左側：タイトル
        const title = document.createElement('div');
        title.textContent = 'アニメお絵かきツール';
        title.style.cssText = `
            color: #800000;
            font-size: 14px;
            font-weight: bold;
        `;
        
        // 右側：ボタングループ
        const buttonGroup = document.createElement('div');
        buttonGroup.style.cssText = `display: flex; gap: 8px;`;

        // APNG投稿ボタン
        const postApngBtn = createButton('APNG投稿', () => this.exportAndAttach('apng'), true);
        postApngBtn.title = 'APNGを生成して掲示板に添付';
        
        // GIF投稿ボタン
        const postGifBtn = createButton('GIF投稿', () => this.exportAndAttach('gif'), true);
        postGifBtn.title = 'GIFを生成して掲示板に添付';

        // 閉じるボタン
        const closeBtn = createButton('✕ 閉じる', () => this.cancel());
        closeBtn.title = '破棄して閉じる';
        
        buttonGroup.appendChild(postApngBtn);
        buttonGroup.appendChild(postGifBtn);
        buttonGroup.appendChild(closeBtn);
        topBar.appendChild(title);
        topBar.appendChild(buttonGroup);
        this.container.appendChild(topBar);

        // キャンバスエリア（Tegakiコアが使用）
        const canvasArea = document.createElement('div');
        canvasArea.id = 'tegaki-canvas-area-anime';
        canvasArea.style.cssText = `
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #ffffee;
        `;
        this.container.appendChild(canvasArea);
        
        document.body.appendChild(this.container);
        
        // スクロール防止
        this.originalBodyOverflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
    }

  使用メソッド:
    - document.createElement(tagName): DOM要素を作成
    - element.appendChild(child): 子要素を追加
    - document.body.style.overflow: ページのスクロール制御

  重要ポイント:
    - z-index: 10000 で最前面に表示
    - position: fixed で画面全体をカバー
    - overflow: hidden でページスクロールを無効化

【手順4-7】createButton() ヘルパー関数の確認

  該当部分（39行目〜67行目付近）:

  既存コード（変更不要）:
    function createButton(text, onClick, isPrimary = false) {
        const btn = document.createElement('button');
        btn.innerHTML = text;
        
        const primaryBg = '#4ade80'; // 緑系
        const primaryHover = '#22c55e';
        const primaryBorder = '#22c55e';

        const secondaryBg = '#f87171'; // 朱色系
        const secondaryHover = '#ef4444';
        const secondaryBorder = '#ef4444';

        btn.style.cssText = `
            padding: 8px 16px;
            background: ${isPrimary ? primaryBg : secondaryBg};
            color: white;
            border: 2px solid ${isPrimary ? primaryBorder : secondaryBorder};
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        `;
        btn.onmouseover = () => btn.style.background = isPrimary ? primaryHover : secondaryHover;
        btn.onmouseout = () => btn.style.background = isPrimary ? primaryBg : secondaryBg;
        btn.onclick = onClick;
        return btn;
    }

  使用メソッド:
    - element.onmouseover/onmouseout: マウスイベントハンドラー
    - element.onclick: クリックイベントハンドラー
    - テンプレートリテラル: `${変数}` で文字列埋め込み

  重要ポイント:
    - isPrimary で投稿ボタン（緑）と閉じるボタン（赤）を区別
    - transition で滑らかなホバーエフェクト

【手順4-8】cleanup() メソッドの確認

  該当部分（300行目〜326行目付近）:

  既存コード（変更不要）:
    cleanup() {
        console.log('[Tegaki Anime Loader] Cleaning up...');
        
        if (this.core && this.core.destroy) {
            this.core.destroy();
            this.core = null;
            window.tegakiAnimeCore = null;
        }
        
        if (this.container) {
            this.container.remove();
            this.container = null;
        }
        
        if (this.originalBodyOverflow !== null) {
            document.body.style.overflow = this.originalBodyOverflow;
            this.originalBodyOverflow = null;
        }
        
        if (this.loadingEl) {
            this.loadingEl.remove();
        }
        
        console.log('[Tegaki Anime Loader] ✓ Cleanup complete');
    }

  重要ポイント:
    - core.destroy() でイベントリスナーを解除
    - container.remove() で DOM を削除
    - overflow を元に戻してスクロールを復元
    - すべての参照を null にしてメモリ解放

【手順4-9】グローバル登録とエントリーポイント

  該当部分（357行目〜367行目付近）:

  既存コード（変更不要）:
    // ===== グローバル登録 =====
    window.tegakiAnimeStart = function() {
        if (!window.tegakiAnimeInstance) {
            window.tegakiAnimeInstance = new TegakiLoaderAnime();
        }
        window.tegakiAnimeInstance.start();
    };
    
    // 初回実行
    // window.tegakiAnimeStart(); // ブックマークレット発火の場合はローダー側で自動起動させない

  重要ポイント:
    - window.tegakiAnimeStart をグローバル関数として公開
    - シングルトンパターンで複数回実行を防止
    - 最終行はコメントアウト（ブックマークレット側で呼び出す）

【手順4-10】ブックマークレットの作成

  作成ファイル: bookmarklet.js（参考用）

  内容:
    javascript:(function(){
        if(!window.tegakiAnimeStart){
            var s=document.createElement('script');
            s.charset='UTF-8';
            s.src='https://toshinka.github.io/tegaki/tegaki_anime_test/tegaki-loader_anime.js';
            document.body.appendChild(s);
        } else {
            window.tegakiAnimeStart();
        }
    })();

  使用方法:
    1. 上記コードを1行にまとめる
    2. ブラウザのブックマークに登録
    3. めぶきちゃんねるで実行

  処理フロー:
    window.tegakiAnimeStart が存在しない
      → tegaki-loader_anime.js を読み込み
      → 読み込み完了後、自動的に window.tegakiAnimeStart が定義される
      → （初回は手動で再クリックが必要）
    
    window.tegakiAnimeStart が存在する
      → 直接実行

【手順4-11】最終確認用の修正リスト

  tegaki-loader_anime.js で修正した箇所:
  
  1. SCRIPT_URLS の簡略化（17-24行目）
     修正前: 5つのURL
     修正後: tegaki のみ
  
  2. start() メソッドのライブラリ読み込み（120-130行目）
     修正前: Promise.all で4つ読み込み
     修正後: loadScript で1つのみ読み込み
  
  3. GIF Worker設定の削除（132-139行目）
     削除: window.GIF.prototype.options.workerScript の設定
  
  4. injectToBoard() の MIMEタイプ修正（267-271行目）
     修正前: 'image/apng'
     修正後: 'image/png'
  
  5. ファイル名の拡張子修正（270-271行目）
     修正前: `tegaki_anime_${Date.now()}.${type}`
     修正後: `tegaki_anime_${Date.now()}.${ext}` (ext = type === 'apng' ? 'png' : 'gif')

■ チェックポイント
  ✓ tegaki-loader_anime.js が修正されている
  ✓ SCRIPT_URLS が統合ファイルのみを指している
  ✓ APNG の MIMEタイプが 'image/png' になっている
  ✓ 不要な Worker 設定コードが削除されている
  ✓ ブックマークレットのURLが正しい

================================================================================
Phase 5: テスト・デプロイ
================================================================================

■ 目的
  - ローカル環境でのテスト
  - GitHub Pages へのデプロイ
  - 本番環境（めぶきちゃんねる）での動作確認

■ 作業ファイル
  【新規作成】
    - TegakiAniTest.html

■ 参考ファイル
  - TegakiAniTest.html（既存）
  - TegakiTest.html

■ 処理フロー
  [ローカルテスト]
    ↓
  TegakiAniTest.html を開く
    ↓
  dist/tegaki_anime.js を読み込み
    ↓
  TegakiAnimeCore が正常動作するか確認
    ↓
  [デプロイ]
    ↓
  GitHub リポジトリにプッシュ
    ↓
  GitHub Pages で公開
    ↓
  [本番テスト]
    ↓
  めぶきちゃんねるでブックマークレット実行
    ↓
  APNG/GIF を投稿

■ 実装手順

【手順5-1】TegakiAniTest.html の作成

  ファイル: TegakiAniTest.html
  
  内容:
    <!DOCTYPE html>
    <html lang="ja">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Tegaki.js アニメ対応版 ローカルテスト環境</title>
        <style>
            html, body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                background-color: #ffffee;
            }
            #app-container {
                display: flex;
                flex-direction: column;
                width: 100%;
                height: 100%;
            }
            #top-bar {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 16px;
                background-color: #f0e0d6;
                border-bottom: 2px solid #cf9c97;
                color: #800000;
            }
            #top-bar h1 {
                font-size: 18px;
                margin: 0;
            }
            #main-content {
                flex-grow: 1;
                position: relative;
            }
            #tegaki-app-container {
                width: 100%;
                height: 100%;
            }
            .test-buttons {
                display: flex;
                gap: 8px;
            }
            .test-btn {
                padding: 6px 12px;
                background: #4ade80;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
            }
            .test-btn:hover {
                background: #22c55e;
            }
        </style>
    </head>
    <body>
        <div id="app-container">
            <header id="top-bar">
                <h1>🌱めぶきちゃんねる APNG/GIF アニメ投稿テスト</h1>
                <div class="test-buttons">
                    <button class="test-btn" onclick="testApng()">APNG テスト</button>
                    <button class="test-btn" onclick="testGif()">GIF テスト</button>
                </div>
            </header>
            <main id="main-content">
                <div id="tegaki-app-container"></div>
            </main>
        </div>

        <!-- 統合済みファイルを読み込み -->
        <script src="dist/tegaki_anime.js"></script>

        <script>
            let coreInstance = null;

            document.addEventListener('DOMContentLoaded', () => {
                const container = document.getElementById('tegaki-app-container');

                if (container && window.TegakiAnimeCore) {
                    coreInstance = new window.TegakiAnimeCore(container);
                    console.log('[Test] TegakiAnimeCore initialized');
                } else {
                    console.error('[Test] TegakiAnimeCore not found');
                }
            });

            async function testApng() {
                if (!coreInstance) {
                    alert('コアが初期化されていません');
                    return;
                }
                
                console.log('[Test] Exporting APNG...');
                const blob = await coreInstance.exportAsApng();
                
                if (blob) {
                    console.log('[Test] APNG Blob size:', blob.size);
                    downloadBlob(blob, 'test.png');
                } else {
                    alert('APNG生成に失敗しました');
                }
            }

            async function testGif() {
                if (!coreInstance) {
                    alert('コアが初期化されていません');
                    return;
                }
                
                console.log('[Test] Exporting GIF...');
                const blob = await coreInstance.exportAsGif((progress) => {
                    console.log('[Test] GIF progress:', Math.floor(progress * 100) + '%');
                });
                
                if (blob) {
                    console.log('[Test] GIF Blob size:', blob.size);
                    downloadBlob(blob, 'test.gif');
                } else {
                    alert('GIF生成に失敗しました');
                }
            }

            function downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                console.log('[Test] Download triggered:', filename);
            }
        </script>
    </body>
    </html>

  使用メソッド:
    - URL.createObjectURL(blob): Blob から一時URLを生成
    - URL.revokeObjectURL(url): 一時URLを解放
    - a.click(): プログラムでリンクをクリック（ダウンロード開始）

  重要ポイント:
    - テストボタンで APNG/GIF をダウンロードして検証
    - コンソールでログを確認してデバッグ

【手順5-2】ローカルテストの実行

  コマンド:
    # ビルド
    npm run build
    
    # ローカルサーバー起動（Python 3の場合）
    python -m http.server 8000
    
    # または Node.js の http-server
    npx http-server -p 8000

  ブラウザで開く:
    http://localhost:8000/TegakiAniTest.html

  テスト手順:
    1. ページが開いたら、各フレームに描画
    2. レイヤー切替ボタン（サムネイル）をクリックして5フレーム描画
    3. "APNG テスト" ボタンをクリック
       → test.png がダウンロードされる
       → ファイルを開いてアニメーションするか確認
    4. "GIF テスト" ボタンをクリック
       → test.gif がダウンロードされる
       → ファイルを開いてアニメーションするか確認
    5. ブラウザコンソールでエラーがないか確認

  期待される結果:
    ✓ 描画が正常に動作
    ✓ レイヤー切替が正常に動作
    ✓ Undo/Redo（Ctrl+Z/Y）が正常に動作
    ✓ APNG ファイルがダウンロードされ、アニメーションする
    ✓ GIF ファイルがダウンロードされ、アニメーションする
    ✓ コンソールにエラーが出ない

【手順5-3】GitHub へのプッシュ

  コマンド:
    cd tegaki_anime_test
    
    # Git 初期化（まだの場合）
    git init
    
    # .gitignore 作成
    echo "node_modules/" > .gitignore
    echo "package-lock.json" >> .gitignore
    
    # ステージング
    git add .
    
    # コミット
    git commit -m "Add anime version with bundled libraries"
    
    # リモートリポジトリに追加（既存リポジトリの場合）
    git remote add origin https://github.com/[username]/tegaki.git
    
    # プッシュ
    git push origin main

  または、親ディレクトリ (tegaki/) からプッシュ:
    cd ..
    git add tegaki_anime_test/
    git commit -m "Add tegaki_anime_test with npm build system"
    git push origin main

【手順5-4】GitHub Pages の設定

  GitHub リポジトリページで:
    1. Settings → Pages
    2. Source: Deploy from a branch
    3. Branch: main / root (または docs)
    4. Save
    
  または、tegaki_anime_test/dist/ を docs/ にコピー:
    cp -r dist ../docs/anime/
    git add ../docs/anime/
    git commit -m "Deploy anime version to GitHub Pages"
    git push

  公開URL:
    https://[username].github.io/tegaki/tegaki_anime_test/dist/tegaki_anime.js
    https://[username].github.io/tegaki/tegaki_anime_test/tegaki-loader_anime.js

【手順5-5】ブックマークレットの最終版

  最終的なブックマークレットコード:
    javascript:(function(){if(!window.tegakiAnimeStart){var s=document.createElement('script');s.charset='UTF-8';s.src='https://toshinka.github.io/tegaki/tegaki_anime_test/tegaki-loader_anime.js';document.body.appendChild(s)}else{window.tegakiAnimeStart()}})();

  登録方法:
    1. ブラウザのブックマークバーを表示
    2. 新しいブックマークを作成
    3. 名前: Tegaki Anime
    4. URL: 上記のコード（javascript:...）を貼り付け
    5. 保存

【手順5-6】本番環境（めぶきちゃんねる）でのテスト

  テスト手順:
    1. めぶきちゃんねるのスレッドを開く
       https://mebuki.moe/app/t/[スレッドID]
    
    2. ブックマークレット実行
       - 初回: ローダーが読み込まれる（画面は変わらない）
       - 2回目: お絵かきUIが表示される
    
    3. 各レイヤーに描画
       - サムネイルをクリックしてレイヤー切替
       - 5フレーム分描画
    
    4. APNG投稿ボタンをクリック
       - "APNGを生成中..." と表示される
       - "画像を添付しました！" と表示される
       - レス投稿フォームに画像が添付される
    
    5. 投稿ボタンを押す
       - レスが投稿される
       - 画像が表示される
       - 画像がアニメーションするか確認
    
    6. GIF投稿も同様にテスト

  チェック項目:
    ✓ UI が正常に表示される
    ✓ 描画が正常に動作する
    ✓ レイヤー切替が正常に動作する
    ✓ APNG生成が完了する（エラーが出ない）
    ✓ GIF生成が完了する（進捗が表示される）
    ✓ 画像がフォームに添付される
    ✓ 投稿後、画像がアニメーションする

【手順5-7】トラブルシューティング

  問題1: ブックマークレットが動作しない
    原因: CSP が script タグの動的追加をブロック
    対策: ブラウザの開発者ツールでエラーを確認
          別のブラウザで試す（Chrome, Firefox, Safari）

  問題2: APNG がアニメーションしない
    原因: ブラウザが APNG 未対応
          MIMEタイプが間違っている
    対策: Firefox または Chrome で確認
          ファイルを hex エディタで開き、PNG ヘッダーを確認
          
  問題3: GIF 生成が完了しない
    原因: Worker の読み込み失敗
    対策: build.js の Worker インライン化を確認
          コンソールで GIF.js のログを確認

  問題4: 投稿後、画像が表示されない
    原因: Blob サイズが大きすぎる
          めぶきちゃんねるのファイルサイズ制限
    対策: フレーム数を減らす（5→3）
          品質を下げる（GIF の quality を上げる）

  デバッグ用コード:
    // ブラウザコンソールで実行
    console.log('UPNG:', typeof window.UPNG);
    console.log('pako:', typeof window.pako);
    console.log('Zlib:', typeof window.Zlib);
    console.log('GIF:', typeof window.GIF);
    console.log('TegakiAnimeCore:', typeof window.TegakiAnimeCore);

  期待される出力:
    UPNG: function
    pako: object
    Zlib: object
    GIF: function
    TegakiAnimeCore: function

■ チェックポイント
  ✓ TegakiAniTest.html で正常に動作する
  ✓ APNG/GIF が正しく生成される
  ✓ GitHub Pages にデプロイされている
  ✓ ブックマークレットが正しいURLを指している
  ✓ めぶきちゃんねるで投稿できる
  ✓ 投稿した画像がアニメーションする

================================================================================
8. 換骨奪胎ガイド（既存ツールからの移行）
================================================================================

■ 目的
  - 別のお絵かきツールを今回の構成に移行
  - index.html を loader.html と test.html に分割
  - CDN 依存を npm 管理に変更

■ 前提条件
  既存ツールが以下の構成である場合:
    project/
    ├── index.html          # すべてを含む単一HTML
    ├── script.js           # メインロジック
    └── style.css           # スタイル

  index.html の構造:
    <script src="https://cdn.example.com/library1.js"></script>
    <script src="https://cdn.example.com/library2.js"></script>
    <script src="script.js"></script>

■ 移行手順

【移行手順1】プロジェクト構造の再編成

  新しい構造:
    project/
    ├── package.json
    ├── build.js
    ├── libs/
    │   ├── library1.js         # CDNからコピー
    │   └── library2.js         # CDNからコピー
    ├── src/
    │   └── core.js             # script.js をリネーム
    ├── dist/
    │   └── bundle.js           # ビルド出力
    ├── loader.html             # めぶきちゃんねる用ローダー
    └── test.html               # ローカルテスト用

【移行手順2】index.html の分割

  元の index.html:
    <!DOCTYPE html>
    <html>
    <head>
        <script src="https://cdn.example.com/library1.js"></script>
        <script src="https://cdn.example.com/library2.js"></script>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <div id="app"></div>
        <script src="script.js"></script>
        <script>
            // 初期化コード
            new MyApp(document.getElementById('app'));
        </script>
    </body>
    </html>

  分割後の test.html:
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>ローカルテスト</title>
        <style>
            /* style.css の内容をここに貼り付け */
        </style>
    </head>
    <body>
        <div id="app"></div>
        
        <!-- ビルド済みファイルを読み込み -->
        <script src="dist/bundle.js"></script>
        
        <script>
            // 初期化コード
            document.addEventListener('DOMContentLoaded', () => {
                if (window.MyApp) {
                    new window.MyApp(document.getElementById('app'));
                }
            });
        </script>
    </body>
    </html>

  loader.html（めぶきちゃんねる用）:
    (function() {
        'use strict';
        
        window.myAppStart = function() {
            // 既存のインスタンスがあれば削除
if (window.myAppInstance) {
                window.myAppInstance.destroy();
                window.myAppInstance = null;
            }
            
            // UIコンテナを作成
            const container = document.createElement('div');
            container.id = 'myapp-container';
            container.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: 10000;
                background: white;
            `;
            document.body.appendChild(container);
            
            // スクロール防止
            document.body.style.overflow = 'hidden';
            
            // バンドルされたスクリプトを読み込み
            const script = document.createElement('script');
            script.src = 'https://[username].github.io/[repo]/dist/bundle.js';
            script.onload = function() {
                if (window.MyApp) {
                    window.myAppInstance = new window.MyApp(container);
                    console.log('[Loader] MyApp initialized');
                }
            };
            script.onerror = function() {
                alert('スクリプトの読み込みに失敗しました');
                container.remove();
                document.body.style.overflow = '';
            };
            document.head.appendChild(script);
        };
        
        // 自動起動（ブックマークレットの場合はコメントアウト）
        // window.myAppStart();
    })();

【移行手順3】script.js をコアファイルに変換

  元の script.js:
    class MyApp {
        constructor(container) {
            this.container = container;
            this.canvas = document.createElement('canvas');
            // ...
        }
        
        // メソッド群
    }

  変換後の src/core.js:
    (function() {
        'use strict';
        
        // グローバルに公開（重要）
        window.MyApp = class MyApp {
            constructor(container) {
                this.container = container;
                this.canvas = document.createElement('canvas');
                // ...
            }
            
            // メソッド群
            
            // クリーンアップメソッドを追加（必須）
            destroy() {
                // イベントリスナーを解除
                // DOM要素を削除
                // 参照をクリア
            }
        };
        
        console.log('✅ MyApp loaded');
    })();

  重要な変更点:
    1. IIFE でラップ
    2. window.MyApp として公開
    3. destroy() メソッドを追加（クリーンアップ用）

【移行手順4】package.json の作成

  内容:
    {
      "name": "my-drawing-app",
      "version": "1.0.0",
      "description": "Drawing app for Mebuki channel",
      "scripts": {
        "build": "node build.js"
      },
      "dependencies": {
        "library1": "^1.0.0",
        "library2": "^2.0.0"
      }
    }

  コマンド:
    npm install

【移行手順5】build.js の作成

  基本テンプレート（Tegaki Anime版をベースに）:
    const fs = require('fs');
    const path = require('path');

    console.log('🔨 Building bundle.js...');

    // 結合するファイルのリスト
    const files = [
        'libs/library1.js',
        'libs/library2.js',
        'src/core.js'
    ];

    // ヘッダー
    let output = `// Bundle built at ${new Date().toISOString()}\n\n`;

    // ファイルを順次読み込んで結合
    files.forEach(file => {
        console.log(`📦 Reading: ${file}`);
        const content = fs.readFileSync(path.join(__dirname, file), 'utf8');
        output += `\n// ========== ${file} ==========\n`;
        output += content + '\n';
    });

    // グローバル公開コードを追加
    output += `
    // ========== Global Exports ==========
    (function() {
        'use strict';
        
        if (typeof window !== 'undefined') {
            // 必要に応じてライブラリをグローバルに公開
            console.log('✅ Bundle loaded successfully');
        }
    })();
    `;

    // 出力
    fs.mkdirSync('dist', { recursive: true });
    fs.writeFileSync('dist/bundle.js', output);

    console.log('✅ Build complete: dist/bundle.js');
    console.log(`📦 Size: ${(output.length / 1024).toFixed(2)} KB`);

【移行手順6】CDN依存の排除

  元のHTML:
    <script src="https://cdn.example.com/pixijs/pixi.min.js"></script>

  ステップA: npm でライブラリをインストール
    npm install pixi.js

  ステップB: libs/ にコピー
    cp node_modules/pixi.js/dist/pixi.min.js libs/pixi.js

  ステップC: build.js のファイルリストに追加
    const files = [
        'libs/pixi.js',        // ← 追加
        'libs/library1.js',
        'libs/library2.js',
        'src/core.js'
    ];

  ステップD: グローバル公開を確認
    // pixi.js は自動的に window.PIXI を公開するため追加コード不要
    // ライブラリによっては手動で公開が必要
    
    output += `
    if (typeof PIXI !== 'undefined') {
        window.PIXI = PIXI;
    }
    `;

【移行手順7】Worker のインライン化（必要な場合）

  元のコード:
    const worker = new Worker('https://cdn.example.com/worker.js');

  ステップA: worker.js をダウンロード
    curl -o libs/worker.js https://cdn.example.com/worker.js

  ステップB: build.js で Base64 化
    // Worker を Base64 に変換
    const workerCode = fs.readFileSync(path.join(__dirname, 'libs/worker.js'), 'utf8');
    const workerBase64 = Buffer.from(workerCode).toString('base64');

    // インライン化コードを追加
    output += `
    // ========== Worker Inline ==========
    (function() {
        const workerCode = atob('${workerBase64}');
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        window.__workerUrl = URL.createObjectURL(blob);
        console.log('✅ Worker inlined');
    })();
    `;

  ステップC: コア側で Blob URL を使用
    // src/core.js 内
    const worker = new Worker(window.__workerUrl);

【移行手順8】スタイルの埋め込み

  元の構成:
    index.html: <link rel="stylesheet" href="style.css">

  方法A: インラインスタイル（推奨）
    // src/core.js 内で動的に追加
    const style = document.createElement('style');
    style.textContent = `
        #myapp-container {
            background: #f0f0f0;
            /* ... */
        }
    `;
    document.head.appendChild(style);

  方法B: build.js でCSSを統合
    const cssContent = fs.readFileSync('style.css', 'utf8');
    output += `
    (function() {
        const style = document.createElement('style');
        style.textContent = \`${cssContent}\`;
        document.head.appendChild(style);
    })();
    `;

【移行手順9】ブックマークレットの作成

  loader.js をブックマークレット用に最小化:
    javascript:(function(){if(!window.myAppStart){var s=document.createElement('script');s.src='https://[username].github.io/[repo]/loader.js';document.body.appendChild(s)}else{window.myAppStart()}})();

【移行手順10】テストとデプロイ

  ローカルテスト:
    npm run build
    python -m http.server 8000
    # http://localhost:8000/test.html を開く

  GitHub へプッシュ:
    git add .
    git commit -m "Migrate to bundled architecture"
    git push

  GitHub Pages で公開:
    Settings → Pages → Branch: main → Save

■ 移行時のチェックリスト

  □ package.json が作成されている
  □ すべてのCDN依存がnpmに置き換えられている
  □ libs/ にライブラリがコピーされている
  □ build.js が正常に動作する
  □ dist/bundle.js が生成される
  □ test.html で正常に動作する
  □ loader.js がブックマークレットから呼び出せる
  □ めぶきちゃんねるで正常に動作する
  □ メモリリークがない（destroy() 実装済み）
  □ CSPエラーが出ない

■ よくある移行パターン

  パターン1: PixiJS + カスタムコード
    依存: PixiJS (CDN)
    対応: npm install pixi.js → libs/pixi.js にコピー
    注意: PixiJS は自動で window.PIXI を公開

  パターン2: Three.js + OrbitControls
    依存: Three.js (CDN), OrbitControls (別ファイル)
    対応: npm install three
          cp node_modules/three/build/three.min.js libs/
          cp node_modules/three/examples/jsm/controls/OrbitControls.js libs/
    注意: OrbitControls は ESM なので、IIFE版を探すか、手動で変換

  パターン3: アニメーション + エンコーダー
    依存: GIF.js, APNG.js (Worker含む)
    対応: npm install gif.js upng-js pako
          Worker を Base64 化してインライン（Tegaki Anime版と同じ）

  パターン4: UI ライブラリ + コア
    依存: React/Vue (CDN), カスタムコンポーネント
    対応: npm install react react-dom
          Babel を使わない場合は React.createElement() で記述
          または、Preact など軽量代替を検討

■ トラブルシューティング

  問題: ライブラリが window に公開されない
    原因: ライブラリが ESM で書かれている
    対策: UMD版 または IIFE版 をダウンロード
          package.json の "browser" フィールドを確認

  問題: ビルド後のファイルサイズが大きすぎる
    原因: 圧縮されていない
    対策: 事前に .min.js 版を使用
          terser などで圧縮（npm install --save-dev terser）
          build.js に圧縮処理を追加

  問題: 複数のライブラリが競合する
    原因: グローバル変数の衝突
    対策: IIFE でラップして名前空間を分離
          window.MyApp.dependencies = { lib1, lib2 } のように管理

  問題: Worker が動作しない
    原因: CSP の worker-src 制約
    対策: Blob URL でインライン化（必須）
          build.js で Base64 変換

================================================================================
9. ファイル一覧と役割サマリー
================================================================================

■ 最終的なファイル構成

  tegaki_anime_test/
  │
  ├── package.json                  # npm 依存管理
  ├── package-lock.json             # バージョンロック
  ├── build.js                      # ビルドスクリプト
  │
  ├── node_modules/                 # npm インストール先（Gitに含めない）
  │   ├── upng-js/
  │   ├── pako/
  │   └── gif.js/
  │
  ├── libs/                         # ライブラリコピー先
  │   ├── upng.js                   # APNG エンコーダー
  │   ├── pako.js                   # 圧縮ライブラリ
  │   ├── gif.js                    # GIF エンコーダー
  │   └── gif.worker.js             # GIF Worker
  │
  ├── src/                          # ソースコード
  │   └── tegaki_anime_core.js      # コアロジック
  │
  ├── dist/                         # ビルド出力
  │   └── tegaki_anime.js           # 統合済みファイル（最終成果物）
  │
  ├── tegaki-loader_anime.js        # ローダー（めぶきちゃんねる用）
  ├── TegakiAniTest.html            # ローカルテスト用HTML
  └── README.md                     # ドキュメント

■ 各ファイルの役割

  【設定ファイル】
    package.json          : npm 依存関係の定義
    build.js              : ライブラリ統合スクリプト
    .gitignore            : Git管理対象外ファイルの指定

  【ライブラリ（libs/）】
    upng.js               : APNG バイナリ生成（UPNG.encode）
    pako.js               : Deflate圧縮（UPNG が内部で使用）
    gif.js                : GIF バイナリ生成（new GIF, addFrame, render）
    gif.worker.js         : GIF エンコード処理を別スレッドで実行

  【ソースコード（src/）】
    tegaki_anime_core.js  : TegakiAnimeCoreクラス定義
                            - UI生成
                            - 描画処理
                            - レイヤー管理
                            - Undo/Redo
                            - エクスポート

  【ビルド出力（dist/）】
    tegaki_anime.js       : upng + pako + gif + core の統合ファイル
                            - Worker が Base64 で埋め込まれている
                            - window.UPNG, pako, GIF, TegakiAnimeCore を公開

  【ローダー】
    tegaki-loader_anime.js: めぶきちゃんねる用エントリーポイント
                            - 掲示板判定
                            - 要素検出
                            - UI生成
                            - エクスポート＋添付処理

  【テスト】
    TegakiAniTest.html    : ローカル動作確認用
                            - dist/tegaki_anime.js を直接読み込み
                            - APNG/GIF ダウンロードボタン付き

■ データフロー図

  [開発時]
    package.json → npm install → node_modules/
                                       ↓
                               libs/ へコピー
                                       ↓
    build.js → libs/*.js + src/*.js を結合 → dist/tegaki_anime.js

  [ローカルテスト時]
    TegakiAniTest.html
      ↓ script src
    dist/tegaki_anime.js
      ↓ インスタンス化
    TegakiAnimeCore
      ↓ 描画
    Canvas
      ↓ エクスポート
    Blob → ダウンロード

  [本番（めぶきちゃんねる）時]
    ブックマークレット
      ↓ script 挿入
    tegaki-loader_anime.js
      ↓ script 挿入
    dist/tegaki_anime.js
      ↓ インスタンス化
    TegakiAnimeCore
      ↓ 描画
    Canvas
      ↓ エクスポート
    Blob
      ↓ File 変換
    input[type="file"]
      ↓ 投稿
    めぶきちゃんねる

================================================================================
10. 開発・保守のベストプラクティス
================================================================================

■ コーディング規約

  【必須】
    - すべてのJSファイルを IIFE でラップ
    - 'use strict' を宣言
    - グローバルに公開するものは window.* に明示的に代入
    - イベントリスナーは必ず解除（メモリリーク防止）

  【推奨】
    - 変数名はキャメルケース（frameCount, activeLayerIndex）
    - プライベートメソッドにアンダースコアは不要（IIFE内で閉じるため）
    - async/await を使用（Promise.then より可読性が高い）
    - コンソールログに接頭辞をつける（例: '[Tegaki] ...'）

  【禁止】
    - var の使用（let/const を使用）
    - グローバル変数の無秩序な追加
    - 外部CDNへの依存（すべて npm 経由）

■ バージョン管理

  【Git コミットメッセージ】
    feat: 新機能追加
    fix: バグ修正
    refactor: リファクタリング
    docs: ドキュメント更新
    build: ビルドシステム変更
    
    例:
      feat: Add GIF export with progress callback
      fix: Fix APNG MIME type to image/png
      refactor: Extract button creation to helper function

  【ブランチ戦略】
    main        : 安定版
    develop     : 開発版
    feature/*   : 機能追加
    fix/*       : バグ修正

  【タグ付け】
    v1.0.0: 初回リリース
    v1.1.0: APNG対応
    v1.2.0: GIF対応
    v1.2.1: MIMEタイプ修正

■ テスト戦略

  【ローカルテスト】
    1. npm run build
    2. TegakiAniTest.html で動作確認
    3. 各ブラウザで確認（Chrome, Firefox, Safari）

  【本番テスト】
    1. GitHub Pages にデプロイ
    2. めぶきちゃんねるでブックマークレット実行
    3. 実際に投稿してアニメーション確認

  【リグレッションテスト】
    - 既存機能が壊れていないか確認
    - 特に静止画版との互換性

■ パフォーマンス最適化

  【ファイルサイズ削減】
    - ライブラリの .min.js 版を使用
    - 不要なコメントを削除
    - terser で圧縮（オプション）

  【実行速度改善】
    - ImageData の使い回し
    - 不要な再描画を避ける
    - Worker を活用（GIF生成）

  【メモリリーク対策】
    - destroy() で必ずリスナー解除
    - Blob URL は revokeObjectURL で解放
    - 大きな配列は null 代入でクリア

■ デバッグ方法

  【ブラウザコンソールでの確認】
    // ライブラリの読み込み確認
    console.log(typeof window.UPNG);     // "object" または "function"
    console.log(typeof window.pako);     // "object"
    console.log(typeof window.GIF);      // "function"
    
    // インスタンスの確認
    console.log(window.tegakiAnimeCore);
    
    // エクスポートテスト
    const blob = await window.tegakiAnimeCore.exportAsApng();
    console.log('Blob size:', blob.size);

  【エラー発生時の対応】
    1. ブラウザのコンソールを開く
    2. エラーメッセージと行番号を確認
    3. ソースマップがない場合、dist/tegaki_anime.js を直接確認
    4. 問題のある関数を特定
    5. src/*.js を修正
    6. npm run build で再ビルド

  【CSPエラーの確認】
    // コンソールで CSP ポリシーを表示
    console.log(document.querySelector('meta[http-equiv="Content-Security-Policy"]')?.content);
    
    // ネットワークタブで blocked リクエストを確認

================================================================================
11. FAQ
================================================================================

Q1: なぜ webpack や Rollup を使わないのか？
A1: プロジェクトのルールで bundler 使用が禁止されているため。
    Node.js の fs モジュールを使った単純な文字列結合で代替。

Q2: ESM を使いたい場合は？
A2: ルール上禁止。すべてのコードを IIFE でラップし、
    window オブジェクト経由でモジュール間通信を行う。

Q3: TypeScript は使えないか？
A3: ルール上禁止。型チェックが必要な場合は、
    JSDoc コメントで型情報を記述し、VSCode の型チェックを活用。

Q4: PixiJS も統合できるか？
A4: 可能。ただし PixiJS は大きいため（500KB以上）、
    本当に必要か検討すること。アニメ版では Canvas2D のみで実装。

Q5: フレーム数を増やせるか？
A5: 可能。this.frameCount を変更すればOK。
    ただしファイルサイズが大きくなるため、5フレーム程度が推奨。

Q6: めぶきちゃんねる以外の掲示板に対応できるか？
A6: 可能。detectBoard() と findTargetElements() を修正。
    各掲示板のHTML構造に合わせてセレクタを調整。

Q7: ビルドを自動化できるか？
A7: 可能。package.json の scripts に watch コマンドを追加:
    "watch": "nodemon --watch src --watch libs --exec 'npm run build'"
    npm install --save-dev nodemon

Q8: 本番環境で動かないが、ローカルでは動く
A8: GitHub Pages のURLが正しいか確認。
    CORS エラーが出ていないか確認（通常は出ない）。
    ブラウザのキャッシュをクリアして再試行。

================================================================================
12. まとめ
================================================================================

本計画書では、以下の手順でアニメーション対応お絵かきツールを構築しました:

【Phase 1】環境構築
  - npm プロジェクトの初期化
  - 必要なライブラリのインストール

【Phase 2】ライブラリ統合
  - build.js による複数ファイルの結合
  - Worker の Base64 埋め込みで CSP 回避

【Phase 3】コア機能実装
  - TegakiAnimeCore クラスの実装
  - APNG/GIF エクスポート機能

【Phase 4】ローダー実装
  - めぶきちゃんねる用ローダーの実装
  - 掲示板へのファイル注入

【Phase 5】テスト・デプロイ
  - ローカルテスト環境の構築
  - GitHub Pages へのデプロイ

【換骨奪胎ガイド】
  - 既存ツールを今回の構成に移行する手順
  - CDN 依存の排除方法

この構成により、以下を達成しました:

✅ CSP 制約下でも動作（外部依存なし）
✅ ルール遵守（bundler/ESM/TypeScript不使用）
✅ npm によるライブラリ管理（バージョン固定）
✅ ローカルテスト環境（TegakiAniTest.html）
✅ 本番環境対応（めぶきちゃんねる）

後続の開発者は、この計画書を参照することで:
- プロジェクトの全体像を把握
- 各ファイルの役割を理解
- 新機能の追加方法を習得
- トラブルシューティングを実施

できるようになります。

================================================================================
END OF DOCUMENT
================================================================================

