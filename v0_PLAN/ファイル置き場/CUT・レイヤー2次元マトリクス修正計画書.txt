# CUT・レイヤー2次元マトリクス修正計画書

## 🚨 問題診断

### 現状の重大問題
1. **方向キー左右逆転問題**: ←→が期待と逆の動作
2. **CUT-レイヤー独立性破綻**: 新規CUT作成後、全CUTに描画が反映される
3. **サムネイル生成未動作**: CUT毎のキャンバス合成画像が表示されない
4. **再生時画面未更新**: タイムライン再生でキャンバス描画が切り替わらない

### 根本原因分析
- **レイヤーシステムの二重管理**: LayerSystem ⇔ AnimationSystem間でレイヤー状態の同期不整合
- **CUTデータ構造の不完全性**: 各CUTが独立したレイヤー状態を保持していない
- **描画エンジン連携不備**: 描画時にアクティブCUTへの反映が全CUTに波及
- **サムネイル生成タイミング問題**: レイヤー合成→PIXIレンダリング→Canvas変換の処理フロー不備

## 🎯 目標アーキテクチャ

### CUT-レイヤー2次元マトリクス構造
```
CUT軸（横軸・時間軸）
├─ CUT1 ├─ レイヤー1 ├─ パスデータ配列 
│         ├─ レイヤー2 ├─ パスデータ配列  
│         └─ 背景     └─ パスデータ配列
├─ CUT2 ├─ レイヤー1 ├─ パスデータ配列
│         ├─ レイヤー2 ├─ パスデータ配列
│         └─ 背景     └─ パスデータ配列
└─ CUT3...
```

### データフロー設計
```mermaid
graph TD
    A[描画操作] --> B[LayerSystem]
    B --> C[アクティブCUTのレイヤーのみ更新]
    C --> D[AnimationSystem.updateCurrentCutLayer]
    D --> E[CUTデータ保存]
    E --> F[サムネイル生成トリガー]
    F --> G[PIXIレンダラー合成]
    G --> H[Canvas変換]
    H --> I[UI更新]
```

## 📋 改修フェーズ計画

### Phase 1: 基盤修正（最優先・即時対応）
**対象ファイル**: `animation-system.js`
- **CUT独立性確保**: レイヤー状態の完全分離
- **描画反映ロジック修正**: アクティブCUTのみへの反映制御
- **方向キー修正**: 左右ナビゲーション正常化

### Phase 2: サムネイル生成修正（高優先）
**対象ファイル**: `animation-system.js`, `timeline-ui.js`
- **PIXIレンダリング改善**: レイヤー合成処理修正
- **Canvas変換最適化**: サムネイル画像生成フロー確立
- **非同期処理制御**: サムネイル生成タイミング調整

### Phase 3: 再生システム修正（中優先）
**対象ファイル**: `animation-system.js`, `timeline-ui.js`
- **CUT切り替え描画更新**: 再生時のキャンバス表示同期
- **LayerSystem連携強化**: 描画エンジンとの統合改善
- **パフォーマンス最適化**: 高速CUT切り替え実現

### Phase 4: UI統合・最終調整（低優先）
**対象ファイル**: `timeline-ui.js`, `ui/ui-panels.js`
- **操作体験統一**: 一貫した操作フロー確立
- **エラー処理強化**: 例外状況での安定動作
- **デバッグ情報拡充**: 開発効率向上

## 🔧 技術仕様詳細

### Phase 1: 基盤修正仕様

#### 1.1 CUT独立レイヤー管理システム
```javascript
// animation-system.js 修正対象
class AnimationSystem {
    constructor() {
        // CUT毎の完全独立レイヤー状態管理
        this.cutLayerStates = new Map(); // cutId -> layerStateSnapshot
        this.activeLayerSync = false; // 同期制御フラグ
    }
    
    // 【新規実装】アクティブCUTのみにレイヤー変更を反映
    syncLayerToActiveCutOnly(layerId, layerData) {
        const activeCut = this.getCurrentCut();
        if (!activeCut) return;
        
        // アクティブCUTのレイヤーデータのみ更新
        const layerIndex = activeCut.layers.findIndex(l => l.id === layerId);
        if (layerIndex !== -1) {
            activeCut.layers[layerIndex] = { ...layerData };
            this.generateCutThumbnail(this.getCurrentCutIndex());
        }
    }
    
    // 【修正実装】方向キー正常化
    goToPreviousFrame() {
        // 右キー → 次のCUTに変更
        let newIndex = this.animationData.playback.currentCutIndex + 1;
        // ... 実装
    }
    
    goToNextFrame() {
        // 左キー → 前のCUTに変更  
        let newIndex = this.animationData.playback.currentCutIndex - 1;
        // ... 実装
    }
}
```

#### 1.2 LayerSystem描画制御修正
```javascript
// layer-system.js 連携仕様
class LayerSystem {
    // 【修正実装】描画時にアクティブCUTのみ更新
    updateLayerPaths(layerIndex, pathData) {
        // 従来: 全レイヤー状態を更新
        // 修正後: アクティブCUTのみ AnimationSystem 経由で更新
        
        if (this.animationSystem) {
            this.animationSystem.syncLayerToActiveCutOnly(
                this.layers[layerIndex].layerData.id, 
                pathData
            );
        }
    }
}
```

### Phase 2: サムネイル生成修正仕様

#### 2.1 PIXIレンダリング最適化
```javascript
// animation-system.js サムネイル生成改善
async generateCutThumbnail(cutIndex) {
    const cut = this.animationData.cuts[cutIndex];
    if (!cut) return;
    
    try {
        // 【修正】一時的レイヤー状態適用
        const originalState = this.captureCurrentLayerState();
        await this.temporarilyApplyCutState(cutIndex);
        
        // 【改善】高品質レンダリング
        const renderTexture = PIXI.RenderTexture.create({
            width: this.layerSystem.config.canvas.width,
            height: this.layerSystem.config.canvas.height,
            resolution: 2, // 高解像度対応
            antialias: true
        });
        
        // 【修正】全レイヤー合成レンダリング
        this.app.renderer.render(this.layerSystem.layersContainer, {
            renderTexture,
            clear: true
        });
        
        // 【改善】Canvas変換最適化
        const canvas = this.app.renderer.extract.canvas(renderTexture);
        
        // サムネイル生成 & UI更新
        cut.thumbnail = PIXI.Texture.from(canvas);
        this.eventBus.emit('animation:thumbnail-generated', { cutIndex });
        
        // 元の状態に復元
        await this.restoreLayerState(originalState);
        
    } catch (error) {
        console.error('Thumbnail generation failed:', error);
    }
}
```

#### 2.2 UI更新フロー
```javascript
// timeline-ui.js サムネイル表示修正
updateSingleCutThumbnail(cutIndex) {
    const cutItem = this.cutsContainer.querySelector(`[data-cut-index="${cutIndex}"]`);
    const thumbnail = cutItem?.querySelector('.cut-thumbnail');
    
    if (thumbnail && this.animationSystem) {
        const cut = this.animationSystem.getAnimationData().cuts[cutIndex];
        
        if (cut?.thumbnail) {
            // 【修正】Texture → Canvas URL変換
            const canvas = this.app.renderer.extract.canvas(cut.thumbnail);
            thumbnail.innerHTML = `<img src="${canvas.toDataURL()}" alt="CUT${cutIndex + 1}" />`;
        }
    }
}
```

### Phase 3: 再生システム修正仕様

#### 3.1 CUT切り替え描画同期
```javascript
// animation-system.js 再生時描画更新
updatePlayback() {
    // ... 既存の時間管理処理
    
    if (elapsed >= currentCut.duration) {
        this.animationData.playback.currentCutIndex++;
        
        // 【修正】CUT切り替え時に描画を更新
        await this.switchToActiveCutWithRender(this.animationData.playback.currentCutIndex);
        
        this.animationData.playback.startTime = Date.now();
        
        // UI同期更新
        this.eventBus.emit('animation:cut-changed', { 
            cutIndex: this.animationData.playback.currentCutIndex,
            renderUpdated: true
        });
    }
}

// 【新規実装】描画更新付きCUT切り替え
async switchToActiveCutWithRender(cutIndex) {
    // CUTデータ適用
    this.setActiveCut(cutIndex);
    
    // LayerSystem描画状態を強制更新
    if (this.layerSystem) {
        this.layerSystem.forceRedrawAllLayers();
    }
    
    // 描画エンジンに再描画要求
    if (this.app) {
        this.app.renderer.render(this.layerSystem.layersContainer);
    }
}
```

### Phase 4: 最終統合仕様

#### 4.1 操作統一・エラー処理
```javascript
// 全ファイル共通: エラー処理パターン
const safeAsyncOperation = async (operation, fallback) => {
    try {
        return await operation();
    } catch (error) {
        console.error(`Operation failed:`, error);
        return fallback?.() || null;
    }
};
```

## 🛠️ PIXIプラグイン・ライブラリ推奨採用

### 高優先採用候補

#### 1. **PIXI-Spine** (アニメーション最適化)
```javascript
// スプライトアニメーション高速化
import 'pixi-spine';
// レイヤー変形アニメーションの最適化に使用
```

#### 2. **PIXI-Graphics-Smooth** (描画品質向上)
```javascript
// アンチエイリアス描画改善
import '@pixi/graphics-smooth';
// ペン描画の品質向上・サムネイル生成の高品質化
```

#### 3. **PIXI-Tilemap** (大量オブジェクト最適化)
```javascript
// 大量パスオブジェクトの描画最適化
import '@pixi/tilemap';
// 複数レイヤー・多数パスの高速描画
```

### 中優先採用候補

#### 4. **PIXI-Filters** (視覚効果)
```javascript
// レイヤー効果・サムネイル生成効果
import '@pixi/filter-blur';
import '@pixi/filter-glow';
// 将来の機能拡張に備えたフィルター系統
```

#### 5. **PIXI-Compressed-Textures** (メモリ最適化)
```javascript
// サムネイル画像の圧縮最適化
import '@pixi/compressed-textures';
// 大量CUTのメモリ使用量削減
```

## 📅 実装スケジュール

### Week 1: Phase 1 実装
- Day 1-2: `animation-system.js` CUT独立性修正
- Day 3: `layer-system.js` 描画制御修正  
- Day 4: 方向キー修正・統合テスト
- Day 5: Phase 1 完成・検証

### Week 2: Phase 2 実装
- Day 1-2: PIXIレンダリング改善・サムネイル生成修正
- Day 3: `timeline-ui.js` サムネイル表示修正
- Day 4: 非同期処理最適化
- Day 5: Phase 2 完成・検証

### Week 3: Phase 3-4 実装
- Day 1-2: CUT切り替え描画同期修正
- Day 3: 再生システム最適化
- Day 4: UI統合・最終調整
- Day 5: 全Phase完成・統合テスト

## 🧪 テスト計画

### Phase 1 検証項目
- [ ] 新規CUT作成後、各CUTが独立したレイヤー状態を保持
- [ ] 描画操作がアクティブCUTのみに反映される
- [ ] 左右キーが正常方向でCUT移動する
- [ ] CUT切り替え時にレイヤーが消失しない

### Phase 2 検証項目  
- [ ] CUT毎にレイヤー合成画像のサムネイルが生成される
- [ ] サムネイルがタイムラインUIに正常表示される
- [ ] 描画変更時にサムネイルが自動更新される
- [ ] 高解像度でも性能劣化しない

### Phase 3 検証項目
- [ ] タイムライン再生時にキャンバス描画がCUT毎に切り替わる
- [ ] 再生速度に関係なく描画が正常更新される  
- [ ] 停止・再開時の描画状態が一貫している
- [ ] 大量CUT・長時間再生でも安定動作する

### 統合検証項目
- [ ] 全ての操作パターンで安定動作
- [ ] メモリリークが発生しない
- [ ] エラー発生時の適切な復旧動作
- [ ] 後続Claude開発者による理解・改修容易性

## 💡 後続Claude開発者向けガイド

### 改修時の注意点
1. **レイヤー状態の同期**: `AnimationSystem.syncLayerToActiveCutOnly()` を必ず経由する
2. **サムネイル生成**: 非同期処理のため `await` を適切に使用する
3. **CUT切り替え**: `switchToActiveCutWithRender()` でレンダリング更新も実行する
4. **方向キー**: `goToPreviousFrame()` が実際は次へ、`goToNextFrame()` が前へ移動する（命名注意）

### デバッグ情報活用
```javascript
// デバッグ用: CUT-レイヤー状態確認
console.log(animationSystem.debugCutLayerMatrix());

// デバッグ用: サムネイル生成状況確認  
console.log(animationSystem.debugThumbnailStatus());

// デバッグ用: 描画同期状況確認
console.log(layerSystem.debugRenderSyncStatus());
```

### 拡張開発指針
- 新機能追加時は必ず2次元マトリクス構造を維持する
- PIXIプラグイン追加時は既存の描画フローとの整合性を確認する
- 大量データ処理時はメモリ効率を最優先に設計する

---

**改修完了基準**: 全検証項目がパスし、後続開発者が容易に理解・改修可能な状態