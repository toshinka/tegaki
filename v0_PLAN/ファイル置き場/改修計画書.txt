ã€æ”¹ä¿®è¨ˆç”»æ›¸ã€‘vector_drawing_tool_v8rev6.html ã‚«ãƒ¡ãƒ©æ“ä½œå¯¾å¿œç‰ˆ
ï¼ˆé€šç§°ï¼šãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ“ãƒ¥ãƒ¼æ‹¡å¼µï¼‰

---

â–  æ”¹ä¿®ç›®çš„
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚­ãƒ£ãƒ³ãƒã‚¹å…¨ä½“ã‚’ã€Œæ´ã‚“ã§å‹•ã‹ã™ã€ã€Œæ‹¡å¤§ãƒ»ç¸®å°ã™ã‚‹ã€ã€Œå›è»¢ã•ã›ã‚‹ã€ã€Œåè»¢ã™ã‚‹ã€ã“ã¨ã‚’å¯èƒ½ã«ã™ã‚‹ã€‚
- å¾“æ¥ã€Œã‚­ãƒ£ãƒ³ãƒã‚¹ç§»å‹•ã€ã¨å‘¼ã‚“ã§ã„ãŸãŒã€æ­£ç¢ºã«ã¯ã€Œã‚«ãƒ¡ãƒ©ï¼ˆè¦–ç‚¹ï¼‰ã®ç§»å‹•ãƒ»æ“ä½œã€ã§ã‚ã‚Šã€æç”»ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚„èƒŒæ™¯ã‚’å«ã‚€ world å…¨ä½“ã‚’ä¸€æ‹¬ã§å‹•ã‹ã™ã€‚
- ãƒšãƒ³æç”»ã‚„ã‚«ãƒ¼ã‚½ãƒ«æ“ä½œã®åº§æ¨™ã¯ camera ã‚’çµŒç”±ã—ã¦æ­£ã—ã world åº§æ¨™ã«å¤‰æ›ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã€è¡¨ç¤ºç¯„å›²å¤–ã§ã®æç”»ã‚‚ä¿æŒã•ã‚Œã‚‹ã€‚

---

â–  å®Ÿè£…æ–¹é‡
1. **worldContainer å°å…¥**
   - `backgroundLayer`, `drawingLayer` ãªã©ã™ã¹ã¦ã®æç”»å¯¾è±¡ã‚’ `worldContainer` ã«ã¾ã¨ã‚ã‚‹ã€‚
   - ã‚«ãƒ¡ãƒ©ç§»å‹•ãƒ»æ‹¡ç¸®ãƒ»å›è»¢ãƒ»åè»¢ã¯ `worldContainer.transform` ã«å¯¾ã—ã¦è¡Œã†ã€‚
   - UI è¦ç´ ï¼ˆãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚„ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤ºãªã©ï¼‰ã¯ `app.stage` ã«ç›´ä»˜ã‘ã—ã¦ã‚«ãƒ¡ãƒ©ã®å½±éŸ¿ã‚’å—ã‘ãªã„ã€‚

2. **ã‚«ãƒ¡ãƒ©åº§æ¨™åˆ¶å¾¡**
   - `worldContainer.position` â€¦ ã‚«ãƒ¡ãƒ©ã®ç§»å‹•ã«å¯¾å¿œ
   - `worldContainer.scale` â€¦ ã‚«ãƒ¡ãƒ©ã®æ‹¡ç¸®ã«å¯¾å¿œï¼ˆæ¯”ç‡ã§ï¼‰
   - `worldContainer.rotation` â€¦ ã‚«ãƒ¡ãƒ©ã®å›è»¢ã«å¯¾å¿œï¼ˆãƒ©ã‚¸ã‚¢ãƒ³å€¤ï¼‰
   - åè»¢ã¯ scale.x *= -1 / scale.y *= -1 ã«ã‚ˆã£ã¦å®Ÿç¾ï¼ˆé«˜é€Ÿå‡¦ç†ï¼‰

3. **å…¥åŠ›å‡¦ç†**
   - ã‚­ãƒ¼ï¼‹ãƒã‚¦ã‚¹ï¼ã‚­ãƒ¼ï¼‹ãƒ‰ãƒ©ãƒƒã‚°ã«ã‚ˆã£ã¦ã‚«ãƒ¡ãƒ©æ“ä½œã‚’ãƒˆãƒªã‚¬ãƒ¼ã™ã‚‹ã€‚
   - æ“ä½œé–‹å§‹æ™‚ã«ã€Œç¸¦ç§»å‹•ã‹æ¨ªç§»å‹•ã‹ã€ã‚’åˆ¤å®šã—ã€æ‹¡ç¸®ã¨å›è»¢ã‚’åŒæ™‚ã«èµ·ã“ã•ãªã„ã€‚
   - æç”»ç³»ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã¨ã¯è¡çªã—ãªã„ã‚ˆã†ã€Space ã‚­ãƒ¼ãŒæŠ¼ä¸‹ã•ã‚Œã¦ã„ã‚‹é–“ã¯ãƒšãƒ³ãƒ„ãƒ¼ãƒ«ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ã€‚

---

â–  ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆä»•æ§˜
- **ç§»å‹•**: `Space + ãƒ‰ãƒ©ãƒƒã‚°` | `Space + æ–¹å‘ã‚­ãƒ¼`
- **æ‹¡ç¸®ãƒ»å›è»¢**: `Shift + Space + ãƒ‰ãƒ©ãƒƒã‚°` | `Shift + æ–¹å‘ã‚­ãƒ¼`
- **æ‹¡ç¸®ãƒ»å›è»¢ï¼ˆãƒã‚¦ã‚¹ï¼‰**: `ãƒ›ã‚¤ãƒ¼ãƒ«å›è»¢` | `Shift + ãƒ›ã‚¤ãƒ¼ãƒ«å›è»¢`
- **åè»¢**: `H`ï¼ˆå·¦å³ï¼‰ | `Shift + H`ï¼ˆä¸Šä¸‹ï¼‰

â€»æ‹¡ç¸®ï¼å›è»¢ã®æ–¹å‘æ±ºå®šãƒ«ãƒ¼ãƒ«  
ã€€- æœ€åˆã«ç¸¦æ–¹å‘å…¥åŠ› â†’ æ‹¡ç¸®ãƒ¢ãƒ¼ãƒ‰  
ã€€- æœ€åˆã«æ¨ªæ–¹å‘å…¥åŠ› â†’ å›è»¢ãƒ¢ãƒ¼ãƒ‰  
ã€€- ä¸€åº¦ãƒšãƒ³ã‚’é›¢ã—ã¦å†æ“ä½œã—ãªã„é™ã‚Šã€åŒä¸€ãƒ¢ãƒ¼ãƒ‰ã‚’ç¶­æŒã™ã‚‹ã€‚

---

â–  åº§æ¨™ç³»ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
- ã™ã¹ã¦ã®æç”»ã¯ world åº§æ¨™ã§è¨˜éŒ²ãƒ»å¾©å…ƒã™ã‚‹ï¼ˆã‚«ãƒ¡ãƒ©ã«ä¾å­˜ã—ãªã„ï¼‰ã€‚
- UI è¦ç´ ã¯ stage ã«ç½®ã„ã¦ã‚«ãƒ¡ãƒ©ã®å½±éŸ¿ã‚’å—ã‘ãªã„ã€‚
- `toLocal()` / `toGlobal()` ã‚’çµ±ä¸€ã—ã¦åˆ©ç”¨ã—ã€pointer åº§æ¨™ã¯å¿…ãš worldContainer ã«å¤‰æ›ã—ã¦ã‹ã‚‰å‡¦ç†ã™ã‚‹ã€‚
- ã‚«ãƒ¡ãƒ©ä¸­å¿ƒã‚’åŸºç‚¹ã«æ‹¡ç¸®ãƒ»å›è»¢ã™ã‚‹ãŸã‚ã€`worldContainer.pivot` ã‚’ç”»é¢ä¸­å¿ƒã«è¨­å®šã™ã‚‹ã€‚

---

â–  ä¸å…·åˆé˜²æ­¢ã®ãƒã‚¤ãƒ³ãƒˆ
- Undo/Redo ã§ã¯ world åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹ãŸã‚ã€ã‚«ãƒ¡ãƒ©æ“ä½œå¾Œã‚‚ç·šãŒæ­£ã—ã„ä½ç½®ã«å†ç¾ã•ã‚Œã‚‹ã€‚
- ç”»é¢å¤–ã‹ã‚‰ã®æç”»ã‚‚ world ã«ä¿æŒã•ã‚Œã‚‹ãŸã‚æ¶ˆãˆãªã„ã€‚
- å¾®å°ãªå…¥åŠ›ã§æ‹¡ç¸®ï¼‹å›è»¢ãŒåŒæ™‚ã«å…¥ã‚‰ãªã„ã‚ˆã†ã€æ“ä½œé–‹å§‹æ–¹å‘ã®åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã‚’å¿…é ˆã¨ã™ã‚‹ã€‚

---

â–  ç°¡æ˜“ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ï¼ˆãŠæ‰‹æœ¬æŠœç²‹ï¼‰

```js
// ãƒ¯ãƒ¼ãƒ«ãƒ‰ã‚³ãƒ³ãƒ†ãƒŠä½œæˆ
const worldContainer = new PIXI.Container();
app.stage.addChild(worldContainer);

// ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ ¼ç´
worldContainer.addChild(backgroundLayer);
worldContainer.addChild(drawingLayer);

// ãƒ”ãƒœãƒƒãƒˆã‚’ç”»é¢ä¸­å¿ƒã«è¨­å®š
worldContainer.pivot.set(app.renderer.width / 2, app.renderer.height / 2);
worldContainer.position.set(app.renderer.width / 2, app.renderer.height / 2);

// ãƒã‚¤ãƒ³ã‚¿åº§æ¨™ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰ç³»ã«å¤‰æ›
function pointerToWorld(e) {
  const global = new PIXI.Point();
  app.renderer.plugins.interaction.mapPositionToPoint(global, e.clientX, e.clientY);
  return worldContainer.toLocal(global);
}

// ã‚«ãƒ¡ãƒ©æ“ä½œï¼ˆä¾‹: Space+ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ï¼‰
function moveCamera(dx, dy) {
  worldContainer.position.x += dx;
  worldContainer.position.y += dy;
}

// ã‚«ãƒ¡ãƒ©æ“ä½œï¼ˆä¾‹: æ‹¡ç¸®ï¼‰
function zoomCamera(scaleDelta) {
  worldContainer.scale.x *= scaleDelta;
  worldContainer.scale.y *= scaleDelta;
}

â–  ä»Šå¾Œã®ç™ºå±•

æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ»ã‚¹ãƒŠãƒƒãƒ—ãªã©ã®è¿½åŠ 

pixi-viewport ã¸ã®ç½®æ›ã«ã‚ˆã‚‹é«˜åº¦ãªã‚«ãƒ¡ãƒ©åˆ¶å¾¡ï¼ˆå¿…è¦ã§ã‚ã‚Œã°ï¼‰

Spine å°å…¥æ™‚ã«ã‚‚åŒã˜ worldContainer ä¸Šã§ä¸€è²«ã—ã¦ç®¡ç†å¯èƒ½


---

ğŸ‘‰ ã“ã®æ”¹ä¿®è¨ˆç”»æ›¸ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚Œã°ã€**ã€Œã‚«ãƒ¡ãƒ©çª“ãŒå‹•ã‹ãªã„ã€å•é¡Œã‚’å›é¿ã—ã¤ã¤ã€world å…¨ä½“ã‚’ä¸€æ‹¬ã§ç§»å‹•ãƒ»å›è»¢ãƒ»æ‹¡ç¸®ãƒ»åè»¢ã§ãã‚‹å®Ÿè£…**ã«é€²ã‚ã¾ã™ã€‚  

â€»ä¸‹è¨˜ã¯ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚å‚è€ƒã«ã—ã¦ãã ã•ã„



<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<title>v8rev6 â€” WorldView Camera + Pen (single layer)</title>
<script src="https://pixijs.download/release/pixi.min.js"></script>
<style> body{margin:0;overflow:hidden;background:#222;} canvas{display:block;} </style>
</head>
<body>
<script>
/*
  WorldView camera + pen sample
  - worldContainer: all drawing objects go here
  - pen points saved in layer-local coords (here single layer -> world-local)
  - Space + drag -> pan
  - Shift + Space + drag -> vertical -> zoom, horizontal -> rotate (mode decided at start)
  - Wheel -> zoom, Shift+Wheel -> rotate
  - H / Shift+H -> flip (scale.x *= -1 / scale.y *= -1)
  - Home -> reset camera
  - Undo: Ctrl+Z, Redo: Ctrl+Y
*/

const app = new PIXI.Application({
  resizeTo: window,
  backgroundColor: 0x1e1e1e,
  antialias: true,
});
document.body.appendChild(app.view);

// ---------- world & layers ----------
const worldContainer = new PIXI.Container();
worldContainer.name = 'worldContainer';
app.stage.addChild(worldContainer);

// background (grid) and drawing layer inside worldContainer
const backgroundLayer = new PIXI.Container();
const drawingLayer = new PIXI.Container();
worldContainer.addChild(backgroundLayer);
worldContainer.addChild(drawingLayer);

// cursor/UI layer not affected by camera
const uiLayer = new PIXI.Container();
app.stage.addChild(uiLayer);

// sample grid (background)
const grid = new PIXI.Graphics();
grid.clear();
grid.lineStyle(1, 0x333333);
const G = 2000;
for (let x=0; x<=G; x += 50) { grid.moveTo(x,0); grid.lineTo(x,G); }
for (let y=0; y<=G; y += 50) { grid.moveTo(0,y); grid.lineTo(G,y); }
backgroundLayer.addChild(grid);

// ---------- camera init (center pivot) ----------
function resetCamera() {
  const cx = app.renderer.width / 2;
  const cy = app.renderer.height / 2;
  // pivot at center so rotate/scale around screen center
  worldContainer.pivot.set(cx, cy);
  worldContainer.position.set(cx, cy);
  worldContainer.scale.set(1, 1);
  worldContainer.rotation = 0;
}
resetCamera();

// ---------- utility: map pointer -> world-local position ----------
function getWorldPositionFromEvent(e) {
  // mapPositionToPoint maps CSS client coords into renderer coordinate space
  const gp = new PIXI.Point();
  app.renderer.plugins.interaction.mapPositionToPoint(gp, e.clientX, e.clientY);
  // convert global point into world-local coordinates (drawingLayer uses that space)
  return worldContainer.toLocal(gp);
}

// ---------- drawing state & undo/redo ----------
let strokes = []; // stack of strokes (each stroke = array of points [{x,y},...])
let redoStack = [];

let currentStroke = null;
let drawing = false;

// quick function to draw a stroke object onto drawingLayer (Graphics)
function drawStrokeToGraphics(stroke) {
  const g = new PIXI.Graphics();
  g.lineStyle(stroke.width || 2, stroke.color || 0xff0000, 1);
  if (stroke.points.length > 0) {
    g.moveTo(stroke.points[0].x, stroke.points[0].y);
    for (let i=1; i<stroke.points.length; i++) {
      g.lineTo(stroke.points[i].x, stroke.points[i].y);
    }
  }
  // store a ref for undo (attach stroke id)
  g._strokeId = stroke.id;
  drawingLayer.addChild(g);
  stroke._graphic = g;
}

// redraw all strokes (clear and re-add) â€” use when necessary
function redrawAllStrokes() {
  drawingLayer.removeChildren();
  for (const s of strokes) {
    drawStrokeToGraphics(s);
  }
}

// ---------- pen input (single-layer) ----------
function startStroke(worldPos) {
  // create stroke with world-local coords
  const s = {
    id: Date.now() + Math.random(),
    points: [ {x: worldPos.x, y: worldPos.y} ],
    color: 0xff0000,
    width: 2,
    _graphic: null
  };
  strokes.push(s);
  // draw incremental
  drawStrokeToGraphics(s);
  currentStroke = s;
  // clear redo stack on new action
  redoStack = [];
}

function extendStroke(worldPos) {
  if (!currentStroke) return;
  currentStroke.points.push({x: worldPos.x, y: worldPos.y});
  // update graphic in-place
  const g = currentStroke._graphic;
  g.lineTo(worldPos.x, worldPos.y);
}

function endStroke() {
  currentStroke = null;
}

// ---------- Pointer handling with camera vs draw modes ----------
let cameraMode = false; // true when Space pressed (camera manipulation)
let shiftPressed = false;

// camera drag state
let camDrag = { active:false, startX:0, startY:0, mode:null /* move|scale|rotate */, threshold:6 };

// pointerdown
app.view.addEventListener('pointerdown', (e) => {
  // left button only
  if (e.button !== 0) return;

  // if Space held -> camera manipulation
  if (cameraMode) {
    camDrag.active = true;
    camDrag.startX = e.clientX;
    camDrag.startY = e.clientY;
    camDrag.mode = null; // undecided until movement > threshold
    return;
  }

  // otherwise start drawing
  const worldP = getWorldPositionFromEvent(e);
  drawing = true;
  startStroke(worldP);
});

// pointermove
app.view.addEventListener('pointermove', (e) => {
  if (camDrag.active) {
    const dx = e.clientX - camDrag.startX;
    const dy = e.clientY - camDrag.startY;
    // decide mode on first significant move
    if (!camDrag.mode) {
      if (Math.abs(dx) > camDrag.threshold || Math.abs(dy) > camDrag.threshold) {
        camDrag.mode = (shiftPressed ? (Math.abs(dy) > Math.abs(dx) ? 'scale' : 'rotate') : 'move');
      } else {
        return; // still within jitter threshold
      }
    }
    if (camDrag.mode === 'move') {
      worldContainer.position.x += dx;
      worldContainer.position.y += dy;
    } else if (camDrag.mode === 'scale') {
      const factor = 1 + dy * 0.002; // tweak sensitivity
      // limit scale to reasonable range
      const newScaleX = worldContainer.scale.x * factor;
      const newScaleY = worldContainer.scale.y * factor;
      if (newScaleX > 0.05 && newScaleX < 20) {
        worldContainer.scale.x = newScaleX;
        worldContainer.scale.y = newScaleY;
      }
    } else if (camDrag.mode === 'rotate') {
      worldContainer.rotation += dx * 0.005;
    }
    camDrag.startX = e.clientX;
    camDrag.startY = e.clientY;
    return;
  }

  if (!drawing) return;
  const worldP = getWorldPositionFromEvent(e);
  extendStroke(worldP);
});

// pointerup / pointercancel
function pointerEndHandler(e) {
  if (camDrag.active) {
    camDrag.active = false;
    camDrag.mode = null;
    return;
  }
  if (drawing) {
    endStroke();
    drawing = false;
  }
}
app.view.addEventListener('pointerup', pointerEndHandler);
app.view.addEventListener('pointercancel', pointerEndHandler);
app.view.addEventListener('pointerleave', pointerEndHandler);

// ---------- wheel: zoom / rotate ----------
app.view.addEventListener('wheel', (e) => {
  e.preventDefault();
  const amp = Math.abs(e.deltaY);
  if (shiftPressed) {
    worldContainer.rotation += e.deltaY * 0.0015;
  } else {
    const factor = 1 - e.deltaY * 0.001;
    const newScale = worldContainer.scale.x * factor;
    if (newScale > 0.05 && newScale < 20) {
      worldContainer.scale.x = newScale;
      worldContainer.scale.y = newScale;
    }
  }
}, {passive:false});

// ---------- keyboard: Space, Shift, H, Home, Arrow keys, Undo/Redo ----------
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    cameraMode = true;
    // when cameraMode active we should prevent page scroll
    e.preventDefault();
  }
  if (e.shiftKey) shiftPressed = true;

  // arrow keys for nudging camera when space held
  if (cameraMode) {
    const step = e.shiftKey ? 50 : 10;
    if (e.code === 'ArrowUp') { worldContainer.position.y -= step; e.preventDefault(); }
    if (e.code === 'ArrowDown') { worldContainer.position.y += step; e.preventDefault(); }
    if (e.code === 'ArrowLeft') { worldContainer.position.x -= step; e.preventDefault(); }
    if (e.code === 'ArrowRight') { worldContainer.position.x += step; e.preventDefault(); }
  }

  // flip
  if (e.code === 'KeyH') {
    if (e.shiftKey) worldContainer.scale.y *= -1;
    else worldContainer.scale.x *= -1;
  }

  // Home: reset camera
  if (e.code === 'Home') {
    resetCamera();
  }

  // Undo/Redo
  if (e.ctrlKey && e.code === 'KeyZ') {
    // Undo
    if (strokes.length > 0) {
      const s = strokes.pop();
      redoStack.push(s);
      // remove graphic if exists
      if (s._graphic) drawingLayer.removeChild(s._graphic);
    }
  }
  if (e.ctrlKey && e.code === 'KeyY') {
    // Redo
    if (redoStack.length > 0) {
      const s = redoStack.pop();
      strokes.push(s);
      drawStrokeToGraphics(s);
    }
  }
});

window.addEventListener('keyup', (e) => {
  if (e.code === 'Space') cameraMode = false;
  if (!e.shiftKey) shiftPressed = false;
});

// ---------- debug helper: show current camera transform ----------
const debugText = new PIXI.Text('', {fontFamily:'monospace', fontSize:12, fill:0xFFFFFF});
debugText.x = 8; debugText.y = 8;
uiLayer.addChild(debugText);
app.ticker.add(() => {
  debugText.text = `cam pos: ${worldContainer.position.x.toFixed(1)}, ${worldContainer.position.y.toFixed(1)}  scale: ${worldContainer.scale.x.toFixed(3)} rot: ${worldContainer.rotation.toFixed(3)}`;
});

// ensure drawing still visible after resize: re-center pivot if viewport size changed
let lastW = app.renderer.width, lastH = app.renderer.height;
window.addEventListener('resize', () => {
  const cx = app.renderer.width / 2;
  const cy = app.renderer.height / 2;
  // preserve visual center: if pivot was centered previously, keep center
  worldContainer.pivot.set(cx, cy);
  // when pivot moves, set position to pivot to keep view consistent
  worldContainer.position.set(cx, cy);
  lastW = app.renderer.width; lastH = app.renderer.height;
});

</script>
</body>
</html>

1.å¿…ãš getWorldPositionFromEvent(e) ã‚’ä½¿ã£ã¦æç”»ç‚¹ã‚’å¾—ã‚‹ï¼ˆæ—¢å­˜ã® offsetX/Y ã‚’ä½¿ã‚ãªã„ï¼‰

ã“ã‚ŒãŒã€Œã‚«ãƒ¡ãƒ©ç§»å‹•ã—ã¦ã‚‚æã„ãŸå ´æ‰€ãŒã‚ºãƒ¬ãªã„ã€è‚ã€‚

2.worldContainer ã«å…¨ã¦ã®æç”»ç‰©ï¼ˆèƒŒæ™¯ãƒ»ç·šãƒ»ç”»åƒï¼‰ã‚’å…¥ã‚Œã‚‹

UIï¼ˆãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã€ã‚«ãƒ¼ã‚½ãƒ«ç­‰ï¼‰ã¯ app.stage ã«ç›´ã«ç½®ãã€‚ã“ã‚Œã§ UI ã¯ã‚«ãƒ¡ãƒ©ç§»å‹•ã®å½±éŸ¿ã‚’å—ã‘ãªã„ã€‚

pivot ã¨ position ã®æ‰±ã„

3.pivot ã¯ç”»é¢ä¸­å¿ƒã«è¨­å®šã—ã¦å›è»¢/ã‚¹ã‚±ãƒ¼ãƒ«ã®æ”¯ç‚¹ã¨ã™ã‚‹ï¼ˆpivot = center + position = centerï¼‰ã€‚

ãƒ‘ãƒ³ï¼ˆç§»å‹•ï¼‰ã¯ position.x/y ã®åŠ ç®—ã§è¡Œã†ã€‚pivot ã‚’ã„ã˜ã‚‹ã¨è¦‹ã‹ã‘ãŒãŠã‹ã—ããªã‚‹ã®ã§ã€Œç§»å‹•ã¯ positionã€ã€ã€Œå›è»¢ãƒ»æ‹¡ç¸®ã¯ pivot ã‚’æ”¯ç‚¹ã«ã™ã‚‹ã€ã¨ã„ã†ä½¿ã„åˆ†ã‘ã‚’å®ˆã‚‹ã€‚

4.Undo/Redo

ã“ã“ã§ã¯ç°¡æ˜“ã‚¹ã‚¿ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ã‚ã‚‹ã€‚å®Ÿã‚·ã‚¹ãƒ†ãƒ ã«ç§»ã™éš›ã¯ stroke ã«ãƒ¡ã‚¿æƒ…å ±ï¼ˆlayerId, blendMode ç­‰ï¼‰ã‚’æ·»ä»˜ã™ã‚‹ã“ã¨ã€‚

5.ã—ãã„å€¤ / æ„Ÿåº¦ã®èª¿æ•´

camDrag.threshold / scale sensitivity / rotation sensitivity ã¯ UX ã«åˆã‚ã›å¾®èª¿æ•´ã—ã¦ãã ã•ã„ã€‚

æ¬¡ã«ã‚„ã‚‹ã¨è‰¯ã„ã“ã¨ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ï¼š

æ—¢å­˜ rev6 ã®æç”»ã‚³ãƒ¼ãƒ‰ï¼ˆç‰¹ã« Undo/Redoãƒ»ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ä¿å­˜éƒ¨åˆ†ï¼‰ã‚’ã“ã® strokes æ§‹é€ ã«åˆã‚ã›ã¦ç½®ãæ›ãˆã‚‹

ã‚«ãƒ¡ãƒ©ç§»å‹•æ™‚ã«æ…£æ€§ï¼ˆdecelerationï¼‰ã‚’è¿½åŠ ã™ã‚‹


â€»è³‡æ–™
ãµãŸã°ãƒãƒ£ãƒ³ãƒãƒ«ã‚«ãƒ©ãƒ¼
--futaba-maroon: #800000;     ï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒšãƒ³ã‚«ãƒ©ãƒ¼ï¼šãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒšãƒ³è‰²ï¼‰
--futaba-light-maroon: #aa5a56;
--futaba-medium: #cf9c97;
--futaba-light-medium: #e9c2ba;
--futaba-cream: #f0e0d6;  ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹èƒŒæ™¯ãƒ¬ã‚¤ãƒ¤ãƒ¼0ï¼šãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰²ï¼‰
--futaba-background: #ffffee;
