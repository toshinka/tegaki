# 🎨 消しゴムツール改修計画書 - Phase2対応版

## 📋 現状問題分析

### 🔍 問題1: 消しゴムの透明化処理不完全
**現象**: 消しゴムが透明化ではなく背景色（futaba-cream）で塗り潰し
**根本原因**: `layer-tool-ui.js` Line 612-620付近
```javascript
// 現在のコード（問題あり）
const color = this.currentTool === 'eraser' ? 0xf0e0d6 : this.brushColor; // 背景色で塗り潰し
const alpha = this.currentTool === 'eraser' ? 1.0 : this.opacity;
```

**影響**: Layer2からLayer1のパスが見かけ上消えているが、実際は背景色で隠されているだけ

### 🔍 問題2: PixiJS v8.13の BLEND_MODE 対応不足
**現象**: v8.13のERASE blend mode機能が活用されていない
**根本原因**: 従来の手動消去処理に依存、新機能未対応

### 🔍 問題3: レイヤー分離の不完全性
**現象**: 消しゴムが他のレイヤーに影響を与える可能性
**根本原因**: 消去処理がワールド座標ベースで全パス対象

---

## 🚀 Phase2改修戦略（3段階）

### Stage 1: 基盤安定化（即座実行推奨）
**目標**: Phase1問題をスルーし、基本機能の安定動作確保

#### 1.1 レイヤーパネル初期表示修正
```javascript
// layer-tool-ui.js UIManager.initialize() 修正
initialize() {
    // 既存処理...
    this.setupEventHandlers();
    this.updateCanvasInfo();
    
    // ✅ 追加: 強制初期表示（Phase1問題スルー対応）
    setTimeout(() => {
        this.updateLayerUI();
        // 背景レイヤーとレイヤー1の強制表示確認
        const backgroundLayer = window.LayerManager?.layers?.get(0);
        const layer1 = window.LayerManager?.layers?.get(1);
        if (backgroundLayer) backgroundLayer.container.visible = true;
        if (layer1) layer1.container.visible = true;
    }, 100);
}
```

#### 1.2 描画安定性強化
```javascript
// layer-tool-ui.js DrawingEngine.handleDrawStartRequest() 修正
handleDrawStartRequest(payload) {
    // Phase1問題スルー: より緩やかなレイヤー制限
    const activeLayer = window.LayerManager?.getActiveLayer();
    if (!activeLayer) {
        // アクティブレイヤーが取得できない場合の安全処理
        console.warn('No active layer available, using fallback');
        return;
    }
    
    // 消しゴムツールの安全性確保
    const toolSettings = window.ToolManager?.getCurrentToolSettings();
    if (!toolSettings) return;
    
    // Stage1では従来の描画を維持
    this.createPath(payload.worldX, payload.worldY, toolSettings);
}
```

### Stage 2: 消しゴム機能完全再設計（1-2日後実行）
**目標**: PixiJS v8.13のERASE blend mode活用による真の透明化

#### 2.1 新消しゴムエンジン実装
```javascript
// layer-tool-ui.js に追加
class EraserEngine {
    constructor(drawingEngine) {
        this.drawingEngine = drawingEngine;
        this.eraserContainer = new PIXI.Container();
        this.setupEraseContainer();
    }
    
    setupEraseContainer() {
        // PixiJS v8.13 ERASE blend mode活用
        this.eraserContainer.blendMode = PIXI.BLEND_MODES.ERASE;
        // または新しいAPIを使用
        // this.eraserContainer.blendMode = 'erase';
    }
    
    startErase(worldX, worldY, size, targetLayerId) {
        const targetLayer = window.LayerManager?.getLayer(targetLayerId);
        if (!targetLayer) return null;
        
        // 消去専用グラフィックス作成
        const eraseGraphics = new PIXI.Graphics();
        eraseGraphics.blendMode = PIXI.BLEND_MODES.ERASE;
        
        // 消去範囲描画
        eraseGraphics.circle(worldX, worldY, size / 2);
        eraseGraphics.fill({ color: 0xFFFFFF, alpha: 1.0 }); // 白で消去
        
        // 対象レイヤーにのみ適用
        targetLayer.container.addChild(eraseGraphics);
        
        return {
            id: `erase_${Date.now()}`,
            graphics: eraseGraphics,
            layerId: targetLayerId,
            points: [{ x: worldX, y: worldY, size }]
        };
    }
    
    continueErase(eraseObject, worldX, worldY) {
        if (!eraseObject || !eraseObject.graphics) return;
        
        // 追加の消去ポイント
        eraseObject.graphics.circle(worldX, worldY, eraseObject.points[0].size / 2);
        eraseObject.graphics.fill({ color: 0xFFFFFF, alpha: 1.0 });
        
        eraseObject.points.push({ x: worldX, y: worldY, size: eraseObject.points[0].size });
    }
    
    finalizeErase(eraseObject) {
        if (!eraseObject) return;
        
        // 消去操作記録
        MainController.recordAction('ERASE_OPERATION', {
            eraseId: eraseObject.id,
            layerId: eraseObject.layerId,
            pointCount: eraseObject.points.length,
            bounds: this.calculateEraseBounds(eraseObject)
        });
    }
    
    calculateEraseBounds(eraseObject) {
        if (!eraseObject.points.length) return null;
        
        let minX = eraseObject.points[0].x, maxX = eraseObject.points[0].x;
        let minY = eraseObject.points[0].y, maxY = eraseObject.points[0].y;
        
        eraseObject.points.forEach(point => {
            minX = Math.min(minX, point.x - point.size / 2);
            maxX = Math.max(maxX, point.x + point.size / 2);
            minY = Math.min(minY, point.y - point.size / 2);
            maxY = Math.max(maxY, point.y + point.size / 2);
        });
        
        return { left: minX, top: minY, right: maxX, bottom: maxY };
    }
}
```

#### 2.2 ToolManager消しゴム処理更新
```javascript
// layer-tool-ui.js ToolManager 修正
startDrawing(worldX, worldY, isPanning) {
    if (isPanning) return false;
    
    this.drawing.active = true;
    this.drawing.lastPoint = { x: worldX, y: worldY };
    
    if (this.currentTool === 'eraser') {
        // 新消しゴムエンジン使用
        this.drawing.eraseObject = window.EraserEngine?.startErase(
            worldX, worldY, this.brushSize, MainController.getState('activeLayerId')
        );
    } else {
        // 従来のペン描画
        MainController.emit('draw-start-request', {
            worldX, worldY,
            layerId: MainController.getState('activeLayerId'),
            tool: this.currentTool,
            inCanvas: window.PositionManager?.isPointInCanvas(worldX, worldY) || true
        });
    }
    
    return true;
}

continueDrawing(worldX, worldY, isPanning) {
    if (!this.drawing.active || isPanning) return false;
    
    if (this.currentTool === 'eraser' && this.drawing.eraseObject) {
        // 消しゴム継続
        window.EraserEngine?.continueErase(this.drawing.eraseObject, worldX, worldY);
    } else {
        // 従来の描画継続
        MainController.emit('draw-continue-request', {
            worldX, worldY,
            inCanvas: window.PositionManager?.isPointInCanvas(worldX, worldY) || true
        });
    }
    
    this.drawing.lastPoint = { x: worldX, y: worldY };
    return true;
}

stopDrawing(worldX, worldY) {
    if (!this.drawing.active) return false;
    
    if (this.currentTool === 'eraser' && this.drawing.eraseObject) {
        // 消しゴム終了
        window.EraserEngine?.finalizeErase(this.drawing.eraseObject);
    } else {
        // 従来の描画終了
        MainController.emit('draw-end-request', { worldX, worldY });
    }
    
    this.drawing = { active: false, path: null, lastPoint: null, eraseObject: null };
    return true;
}
```

### Stage 3: 高度機能実装（1週間以内）
**目標**: 消しゴムの高度機能とレイヤー完全分離

#### 3.1 選択的消去機能
```javascript
// パス単位での精密消去
class SelectiveEraser {
    constructor() {
        this.eraseMode = 'BLEND_ERASE'; // or 'PATH_REMOVE'
    }
    
    eraseByCollision(worldX, worldY, size, targetLayerId) {
        const layer = window.LayerManager?.getLayer(targetLayerId);
        if (!layer) return [];
        
        const erasedPaths = [];
        const eraseRadius = size / 2;
        
        layer.paths.forEach(path => {
            const shouldErase = path.points.some(point => {
                const distance = Math.sqrt(
                    (worldX - point.x) ** 2 + (worldY - point.y) ** 2
                );
                return distance <= (eraseRadius + point.size / 2);
            });
            
            if (shouldErase && this.eraseMode === 'PATH_REMOVE') {
                // パス削除モード
                layer.container.removeChild(path.graphics);
                path.graphics.destroy();
                erasedPaths.push(path.id);
            }
        });
        
        // 削除されたパスをレイヤーから除去
        layer.paths = layer.paths.filter(path => !erasedPaths.includes(path.id));
        
        return erasedPaths;
    }
}
```

#### 3.2 消しゴムサイズ可視化
```javascript
// 消しゴムカーソル表示
class EraserCursor {
    constructor(drawingEngine) {
        this.cursor = new PIXI.Graphics();
        this.cursor.alpha = 0.3;
        drawingEngine.containers.ui.addChild(this.cursor);
    }
    
    updateCursor(worldX, worldY, size) {
        this.cursor.clear();
        this.cursor.circle(worldX, worldY, size / 2);
        this.cursor.stroke({ color: 0x800000, width: 2 });
    }
    
    show() { this.cursor.visible = true; }
    hide() { this.cursor.visible = false; }
}
```

---

## 🧪 PixiJS v8.13 検証項目

### BLEND_MODE.ERASE 検証
```javascript
// テストケース1: ERASE blend mode基本動作
const testErase = () => {
    const container = new PIXI.Container();
    const background = new PIXI.Graphics();
    const eraser = new PIXI.Graphics();
    
    background.rect(0, 0, 100, 100);
    background.fill(0xFF0000); // 赤い背景
    
    eraser.circle(50, 50, 20);
    eraser.fill(0xFFFFFF); // 白い円
    eraser.blendMode = PIXI.BLEND_MODES.ERASE; // または 'erase'
    
    container.addChild(background);
    container.addChild(eraser);
    
    // 結果: 赤い背景の中央に透明な穴が開くはず
    return container;
};
```

### マスクベース消去の代替案
```javascript
// BLEND_MODE.ERASEが期待通りに動作しない場合の代替
class MaskBasedEraser {
    constructor() {
        this.maskGraphics = new PIXI.Graphics();
    }
    
    createEraseMask(paths) {
        this.maskGraphics.clear();
        
        // 消去対象外の部分をマスク
        paths.forEach(path => {
            path.points.forEach(point => {
                this.maskGraphics.circle(point.x, point.y, point.size / 2);
                this.maskGraphics.fill(0xFFFFFF);
            });
        });
        
        return this.maskGraphics;
    }
}
```

---

## 🎯 実行手順

### Step 1: 基盤安定化（即座）
1. レイヤーパネル初期表示修正を適用
2. 描画基本機能の安定性確認
3. PixiJS v8.13での基本描画テスト

### Step 2: 消しゴムエンジン実装（1-2日後）
1. EraserEngine クラス実装
2. BLEND_MODES.ERASE の動作検証  
3. ToolManager 消しゴム処理更新
4. レイヤー分離確認テスト

### Step 3: 高度機能追加（1週間以内）
1. 選択的消去機能実装
2. 消しゴムカーソル表示
3. 消去undo/redo対応
4. パフォーマンス最適化

### Step 4: 総合テスト
1. 全ツール動作確認
2. レイヤー間独立性確認  
3. パフォーマンステスト
4. ブラウザ互換性テスト

---

## 🔄 フォールバック戦略

### PixiJS v8.13のERASE blend mode未対応時
1. **マスクベース消去**: Graphics mask を使用した透明化
2. **パス削除方式**: 衝突検出によるパス完全削除
3. **v8.0.5復帰**: 安定動作優先での旧バージョン使用

### 実装困難時の段階的対応
1. **Phase 0**: レイヤー分離のみ実装（他レイヤー干渉防止）
2. **Phase 1**: 背景色消しゴムの改良（視覚的改善）
3. **Phase 2**: 真の透明化実装（完全版）

---

## 📊 期待される成果

### 機能面
- ✅ 真の透明化消しゴム実現
- ✅ 完全なレイヤー分離
- ✅ 高精度な消去制御
- ✅ 消去操作のundo/redo対応

### 技術面  
- ✅ PixiJS v8.13の新機能活用
- ✅ パフォーマンス向上
- ✅ メモリ効率改善
- ✅ 将来拡張への対応力向上

### UX面
- ✅ 直感的な消しゴム操作
- ✅ 視覚的フィードバック向上
- ✅ レスポンシブな描画体験
- ✅ プロ仕様のお絵かきツール実現

この改修計画により、消しゴムツールの根本的な問題を解決し、真のレイヤー型お絵かきツールを実現します。