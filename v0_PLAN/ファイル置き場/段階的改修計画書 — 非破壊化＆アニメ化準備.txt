````markdown
# 段階的改修計画書 — 非破壊化 & アニメツール化準備

**狙い**
- 現状：レイヤー確定時に`RenderTexture`へベイクしてしまい、破壊的にラスター化される。
- 目的：まずは **非破壊性を担保しつつ実用的な描画体験** を維持／改善し、その上で将来のアニメ（GIF → Mesh/ボーン）化へスムーズに移行できる土台を作る。

---

## 要件（高レベル）
1. **非破壊性**：描画操作（移動／拡縮／回転）を確定しても、元の描画データ（パス／ストローク／メタ情報）を失わない。最終的にいつでも再レンダリングが可能。
2. **実用パフォーマンス**：画面レスポンスは犠牲にしない。重い場合はキャッシュ（ラスタ）を使うが、キャッシュは **再生成可能** にする。
3. **互換性**：既存UI・操作感を大きく壊さない。
4. **将来の拡張（アニメ化）を見据えたデータ構造**：パーツ（path / fill / stroke / pivot）とトランスフォームを分離して保存。

---

## 段階（フェーズ）一覧

### フェーズ0 — 安全対策（小変更）
目的：現在の破壊的挙動を即時に軽減。
- `confirmLayerTransform()` を **破壊的な置換を直ちに行わない** 版に差し替える（既存の焼き込みは残すがオプション化）。
- デフォルトでは「確定」は**論理的確定（transformを layerData にコピーして保持）**にして、実際の子要素はそのままにする。

**成果物**：ユーザ操作で即座に破壊が減る。回帰リスク小。

### フェーズ1 — パスデータを第一級市民に（必須）
目的：描画データ（ベクター）を構造化して保持する。

- `layer.layerData.paths` を正式仕様化し、各 path オブジェクトに下記情報を持たせる：
  ```js
  {
    id: 'p123',
    type: 'stroke'|'fill'|'shape',
    commands: [ {cmd:'moveTo', x, y}, {cmd:'bezierCurveTo', ...}, ... ],
    style: { width, cap, join, color, opacity },
    createdAt, updatedAt
  }
````

* `addPathToLayer()` を path オブジェクト受け渡しに統一。
* 描画は `path.graphics` に依存せず、「**path → Graphics** のレンダリング関数」を通す。常にこの関数でCanvasを更新する。

**成果物**：いつでもパス再描画が可能。焼き込み不要。

### フェーズ2 — レンダリングパイプラインの分離（描画とキャッシュの明確化）

目的：パスベースで正確に描画し、かつ描画パフォーマンスを担保する。

* レイヤーは\*\*論理層（データ）**と**表示層（表示キャッシュ）\*\*に分ける：

  * `layer.layerData`（paths, metadata, pivot）
  * `layer.view`（PIXI.Container） - 実際に画面に付与される表示用Container

* 描画フロー：

  1. 通常フレームは `renderLayerViewFromLayerData(layer)` を呼び出す（内部で Graphics を再構築 or キャッシュSpriteを利用）。
  2. 大きなキャンバス変更・編集時は **キャッシュ無効化フラグ** を立てて再生成。

* **キャッシュ仕様**: `layer.cache` { texture, scaleAtCreation, rotationAtCreation, dpr } を持つ。

  * キャッシュ作成は `createLayerCache(layer, options)` を呼ぶ（resolution = DPR × currentScale × safetyMargin）。
  * 重要：キャッシュは破壊的ではなく、**再生成可能な派生物**として扱う。

**成果物**：パスを常に保持しつつ、速さも確保。

### フェーズ3 — 確定操作の変更（UI/UX）

目的：ユーザに「確定」の意味を明確化し、選択可能にする。

* 「確定」ボタンを2種類にする：

  * **論理確定（推奨デフォルト）**：transform を layer metadata に書き込み、パスはそのまま。キャッシュは無効化して再生成。
  * **焼き込み確定（オプション／高解像度）**：レンダーテクスチャに焼き込んでSpriteへ置換（ただし元の path データはバックアップとして保存）。

* UI: 履歴（Undo）で論理状態に戻せるようにする。

**成果物**：ユーザは誤ってベクターを破壊しなくなる。

### フェーズ4 — アニメ準備（パーツ化 & エクスポート）

目的：将来的なメッシュ化／ボーン化へ備えたデータ形状に整える。

* 各レイヤーを\*\*パーツ単位（パス群）\*\*で分離し、pivot（変形中心）を持たせる。
* 各パーツに ID を付与し、JSONエクスポート可能にする（paths + pivot + initial transform）。
* GIF 書き出し機能：現時点では raster（高解像度キャッシュ）を吐いてフレーム合成。

**成果物**：GIFアニメ化が可能になり、以降Mesh/Spine導入のための変換が容易。

---

## 具体的改修タスク（実装指示）

### コアデータ構造変更（例）

```js
// layer.layerData の例
layer.layerData = {
  id: 'layer_1',
  name: 'レイヤー1',
  visible: true,
  opacity: 1.0,
  pivot: {x: CONFIG.canvas.width/2, y: CONFIG.canvas.height/2},
  transform: { x:0, y:0, scale:1, rotation:0 }, // 論理 transform
  paths: [ /* path objects as above */ ],
  cache: { texture: null, scaleAtCreation:1, rotationAtCreation:0, dpr:1 }
};
```

---

### 主要関数（擬似コード）

```js
// path -> PIXI.Graphics を組み立てる（pure function）
function buildGraphicsFromPath(pathObj) {
  const g = new PIXI.Graphics();
  g.lineStyle(pathObj.style.width, pathObj.style.color, pathObj.style.opacity);
  // iterate pathObj.commands and call moveTo/lineTo/bezierCurveTo etc.
  return g;
}

// layer.view（表示用）を layerData から再構築
function renderLayerViewFromLayerData(layer) {
  const view = layer.view; // PIXI.Container
  view.removeChildren();

  // 1) キャッシュが有効で条件に合うなら sprite を使う
  if (layer.layerData.cache.texture && cacheMatches(layer)) {
    const s = new PIXI.Sprite(layer.layerData.cache.texture);
    s.alpha = layer.layerData.opacity;
    view.addChild(s);
    return;
  }

  // 2) paths を再描画
  layer.layerData.paths.forEach(path => {
    const g = buildGraphicsFromPath(path);
    view.addChild(g);
  });
}

// 高解像度キャッシュ作成
function createLayerCache(layer, {dpr = window.devicePixelRatio, extraScale=1.2} = {}) {
  const width = Math.ceil(CONFIG.canvas.width * dpr * extraScale);
  const height = Math.ceil(CONFIG.canvas.height * dpr * extraScale);
  const rt = PIXI.RenderTexture.create({ width, height, resolution: dpr });
  // 一時 container に layer の view を構築してレンダリング
  const tmp = new PIXI.Container();
  // rebuild view at scale=dpr*extraScale if needed
  // ...
  app.renderer.render(tmp, { renderTexture: rt });
  layer.layerData.cache = { texture: rt, scaleAtCreation: layer.transform.scale, rotationAtCreation: layer.transform.rotation, dpr };
}

// 論理確定（非破壊）
function confirmLayerTransformLogical(layer) {
  // 1) layer.layerData.transform に現在の transform を合成
  layer.layerData.transform = composeTransforms(layer.layerData.transform, currentTransformFromContainer(layer));
  // 2) view の transform をリセットして、renderLayerViewFromLayerData() を呼ぶ
  resetViewTransform(layer);
  renderLayerViewFromLayerData(layer);
}

// 焼き込み確定（オプション）
function confirmLayerTransformBake(layer) {
  // 1) バックアップとして path データを保持
  layer.layerData._backupPaths = deepClone(layer.layerData.paths);
  // 2) createLayerCache() で高解像度で焼き込み
  createLayerCache(layer, {dpr: window.devicePixelRatio * 2, extraScale: 1.5});
  // 3) view を cache sprite のみの構成に差し替え（だが paths は保持）
}
```

---

## テスト項目（QA）

1. レイヤー移動 → 確定（論理）後にUndoで戻せるか。
2. 拡縮・回転を複数回行ってもジャギーが発生しないか（再生成でシャープ）。
3. キャッシュ無効化時に描画が正しく再生成されるか。
4. 大きなDPR（2〜3）のモニタでサムネイル／キャンバスがぼやけないか。
5. GIF書き出し：秒間フレーム毎に高解像度ラスタを吐いて結合できるか。

---

## マイグレーション注意点

* 既存レイヤーで `children` に Graphics しか持たない場合、単純に `paths` に変換するスクリプトを用意する（可能なら）。
* 古い "焼き込み済み" スプライトは `layer.layerData.paths == [] && cache.texture != null` の形で互換扱い。

---

## 将来拡張メモ（短く）

* フェーズ4 の上で、各パーツをメッシュ化して頂点ウェイト付き変形に移行可能（Mesh → bone）。
* Live2D/Spine を採用するなら、`layerData` の JSON を変換してアセット化するブリッジを作る。

---

## 優先度 / 実装順（推奨）

1. フェーズ0（即時低リスク）
2. フェーズ1（データ構造）
3. フェーズ2（レンダーパイプライン分離 & キャッシュ）
4. フェーズ3（UI/確定モードの明確化）
5. フェーズ4（アニメ化準備）

---

## 付録：短めの実装メモ（注意点）

* `PIXI.RenderTexture.create()` を使う時は必ず `resolution` に DPR を指定する。
* キャッシュはメモリを食うので、LRUや最大合計サイズを設ける。
* Undo/Redo は layerData のシリアライズを使う。
* Thumbnails は小さいレンダーテクスチャで作るが、元データから再生成可能にする。

```
（以上）
```

短く要点を補足すると：

・当面は パス（ベクターデータ）を常に保持 する方向に移行します。

・パフォーマンスは 再生成可能なラスタキャッシュ で確保（ただし元データは消さない）。

・「確定」はデフォルトで論理確定（非破壊）、必要時にのみ高解像度で焼き込み（バックアップあり）にします。

・その上で GIF 出力 → その後メッシュ／ボーン化へフェーズ移行する流れです。


