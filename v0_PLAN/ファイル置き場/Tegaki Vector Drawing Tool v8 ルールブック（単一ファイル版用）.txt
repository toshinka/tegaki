🚫 原則（フォールバック・フェイルセーフ禁止）  
- フォールバックや多重化で誤魔化さず、エラーは検知した上で隠蔽せず、構造上の責務で対処すること。  
- 構造は剛直かつシンプルに保ち、冗長化を避ける。  
- consoleログは必要最低限とし、肥大化を防ぐ。  
- ES2023+最新chromeAPI使用で、後方互換性は気にしない。
- アニメツール化の為の非破壊レイヤー移動する為、ベクターペンが基本。将来的にはWEBGL2やWEBGPU化予定。 


Tegaki Vector Drawing Tool v8 ルールブック（単一ファイル版用）

序文：PixiJS v8 化を最初にする理由

・最新API利用の安定性確保

v7分割化からPixiJS v8 化すると、互換性や依存修正が複数ファイルにまたがり面倒

まず単一ファイルで v8 化を完了させることで、動作確認が容易

・ライブラリ統合の効率化

@pixi/ui / pixi-svg などの新規ライブラリ導入も v8 化前提で整理

分割後にライブラリ依存関係を修正する必要がなくなる

・UI/ポップアップ整理は後回しで良い

ツールごとのポップアップは v8 化後でも統合可能

一旦 v8 化で描画・座標管理・基本UIが動く状態を作ることが優先


1. 基本理念

ツールは「キャンバス上でベクタ描画」を中心に設計する。

将来の非破壊変形、レイヤー管理、アニメ化を見据えた構造とする。

PixiJS v8 を中心に据え、既存ライブラリの再発明を避ける。

2. ファイル構造方針

現時点では 単一ファイルを前提に改修。

分割は後から v8 動作確認後に実施。

UI と描画処理を同一ファイルに収めるが、関数やクラスで 局所化・モジュール化する。

3. 依存関係

主要ライブラリ（CDN利用）:

PixiJS v8 → 描画・Container管理

@pixi/ui → ボタン・ポップアップなどのUI

pixi-svg → ベクターペン強化、SVGパス描画

Hammer.js → ドラッグ／ズーム／タッチ操作

GSAP → UIアニメーション

lodash-es → 座標計算、ユーティリティ関数

4. 描画ルール

キャンバス

画面座標とキャンバス座標を変換する関数を統一

初期化時に Pixi.Application で Canvas を生成

ベクターペン

パスデータとして保持し、非破壊編集可能

色・太さ・アンカーポイントの変更は再描画で反映

非破壊変形

移動・回転・拡大縮小は Transform マトリクスで管理

レイヤー単位で Container を使い、将来的に統合・分離可能

5. UI ルール

ポップアップ・ボタン

ツールごとに内包

@pixi/ui Button, Panel を利用

アニメーションは GSAP を使い軽量に

ツール選択

ボタン選択でアクティブ化

ポップアップで設定値表示・変更可能

状態表示

レイヤー数・選択中レイヤーなどは UI に表示

詳細ステータスは別モジュール化時に tegaki-b2-status.html へ移行可能

6. 座標・レイヤー管理

画面座標 ↔ キャンバス座標 の変換関数を統一

レイヤー管理は Container 単位で保持

将来的な GIF / タイムライン / アニメ化も考慮して 非破壊・独立保持

7. コンソール・デバッグ

不要ログは削除

エラーは隠さず、構造上で検知

フェイルセーフやフォールバックは原則禁止

8. 拡張性

将来の分割化に備え、関数・クラスごとに局所改修可能な命名と構造

ツール単位、UI単位でモジュール化しておくと分割後も AI による改修が容易

レイヤーや非破壊変形などの高度機能も同様に局所化を意識

9. バージョン管理

現在 v8rev1 をベース

改修・分割化後はバージョン番号を更新

ライブラリバージョンも明示しておくこと

まとめ

単一ファイル状態でも PixiJS v8 + @pixi/ui + pixi-svg に対応

ポップアップ・UI・ベクタペン・キャンバス移動が中心

将来の分割・レイヤー・アニメ化を意識した局所化を徹底

💡 このルールブックは 単一ファイル v8化版専用です。
分割化した際は ヘッダーにルールブックを統合するか、個別の車両にミニルールブックを追記してください。

10. 列車型理念（AI向け補足）

「列車型」は車両（モジュール）が順番に連なって走る構造。

前方の車両にのみ依存するのが原則。横断依存は禁止。

main（統合制御）は station（ヘッダー）を起点に車両を順番に読み込む。

各車両は局所改修可能で、追加・交換・入れ替えが容易。

11. 概略構成図（ASCII）
[station] → [main] → [a1-core] → [a2-integration] → [b1-ui] → [b2-status] → [b3-tools]
   │            │
   └────────────┘  （stationが全体責務の参照）


station: 全体の責務と初期化情報

main: アプリ統合制御、描画ループ

a1/a2: コア・統合処理（描画、座標管理）

b1/b2/b3: UI・ステータス・ツール拡張

12. 作業フロー（簡易）

station を読み込み → 全体ルールとライブラリを初期化

main を起動 → 描画ループ・イベント管理開始

各車両順に読み込み・初期化

追加車両は後方に連結可能（局所改修）

💡 ポイント

ASCII図・フローだけなのでノイズは少ない

作業AIはこの下段を参照して「列車型の順序・依存ルール」を理解できる

単一ファイルでも、後で分割化するときのマニュアル代わりになる

13. 列車型採用理由（補足）

依存関係の明確化

列車型は「前方の車両にのみ依存」するので、改修時に横断的な影響を避けられる

ツリー型だと枝分かれが多く、どのモジュールがどの機能に影響するか追いにくい

局所改修が容易

一つの車両だけを交換・改修しても、全体の安定性を崩さない

AIによる自動改修や追加も安全

改修順序が明確

main が station を起点に車両を順番に読み込むため、初期化順序や依存順序が簡単に把握できる

将来の拡張に柔軟

新しいUIやツールを後方に追加しても、前方の既存モジュールに影響しない

付録：列車型分割原則（フロー重視）
1. 背景

単純に 役割別に分割（DRY/SOLID準拠）だけでは、AIによる改修が危うくなる。

ツリー型で失敗した原因は、処理フローを無視した分割にある。

AIは「モジュールが順序どおり処理される」ことを前提に動作するため、フロー順序を物理的に保つ必要がある。

2. 分割原則

処理フローに沿って車両（モジュール）を並べる

例：

[station] → [main] → [a1-core] → [a2-integration] → [b1-ui] → [b2-status] → [b3-tools]


左から右に進む順序が、そのまま処理の実行順序を示す。

依存関係は前方の車両にのみ

後方や横断への依存は禁止

フローを乱さず、局所改修が可能になる

局所ではDRY/SOLIDを維持

各車両内は関数やクラスで責務を明確化

局所改修・追加は自由だが、全体フローには影響しないようにする

追加・拡張は後方に連結

新しいツールやUI機能を追加する場合、車両を後方に追加

前方の既存モジュールを壊さずに拡張可能

3. 分割ガイドライン（AI向け）

一つの車両は、処理の一段階に対応する

例：描画準備／座標計算／入力処理／描画／UI応答

前後関係を乱さない

車両の順序変更や依存追加は、フローに沿って慎重に

車両内部は局所的に最適化

冗長コードは局所で整理（DRY）

クラス分割・関数整理は局所で完結

4. フロー例（単純）
[station]      → アプリ全体責務・初期化
[main]         → 描画ループ・イベント統合
[a1-core]      → 描画基盤・座標管理
[a2-integration]→ 内部補助・描画補助関数
[b1-ui]        → ボタン・ポップアップ・ツール選択
[b2-status]    → 状態表示・レイヤー管理
[b3-tools]     → 拡張ツール・後方追加可能

5. ポイント

AIはフロー順に従って改修すること

局所の最適化（DRY/SOLID）は許可するが、全体の順序は絶対に崩さない

将来の分割・追加もこの原則に従うことで、安定的なAI改修が可能

💡 この付録をルールブック末尾に置くことで、AIは 「なぜ列車型なのか」「どこまで局所改修できるのか」「フロー順序は絶対」 を理解できるようになります。


