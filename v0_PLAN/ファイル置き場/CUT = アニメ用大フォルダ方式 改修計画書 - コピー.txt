# CUT = アニメ用大フォルダ方式 改修計画書（完全版）

## 🚨 試行錯誤の結論: なぜB案（フォルダ方式）が正解なのか

### 失敗したA案の問題点
```javascript
// ❌ A案: 2次元マトリクス管理の問題
// 1. LayerSystemとAnimationSystemの二重管理が複雑化
// 2. Deep Copyのタイミングで必ず参照漏れが発生
// 3. CUT切替時のsync処理が複雑すぎて破綻
// 4. デバッグが困難（どこで参照が共有されたか追えない）

AnimationSystem.cuts[0].layers ← これとLayerSystem.layersの同期が破綻する
```

### B案が正解である理由
```javascript
// ✅ B案: CUT = フォルダの利点
// 1. LayerSystemは「現在開いているフォルダの中身を見ているだけ」
// 2. フォルダ切替 = 中身を入れ替えるだけ（参照管理不要）
// 3. 将来のレイヤーフォルダとの統一的な扱い
// 4. PixiJSのContainerツリー構造と概念が一致

CUTフォルダ1/
  ├─ 背景Layer (Container)
  ├─ Layer1 (Container)
  └─ Layer2 (Container)

// LayerSystemは「このフォルダの中を表示しているだけ」
```

---

## 🎯 新アーキテクチャ: CUT = PIXI.Container フォルダ

### コアコンセプト
```
【唯一の真実】AnimationSystem.cutsContainer (PIXI.Container)
  │
  ├─ CUT1 (PIXI.Container) ← フォルダ
  │   ├─ 背景Layer (PIXI.Container)
  │   ├─ Layer1 (PIXI.Container)
  │   └─ Layer2 (PIXI.Container)
  │
  ├─ CUT2 (PIXI.Container) ← フォルダ
  │   ├─ 背景Layer (PIXI.Container)
  │   └─ Layer1 (PIXI.Container)
  │
  └─ CUT3 (PIXI.Container) ← フォルダ
      └─ Layer1 (PIXI.Container)

【View】LayerSystem.layersContainer
  ↓
  現在アクティブなCUTコンテナを「参照」するだけ
  （コピー不要、切替 = 参照先変更）
```

---

## 📐 データ構造定義

### AnimationSystem

```javascript
class AnimationSystem {
  constructor() {
    // ★★★ すべてのCUTを保持するコンテナ（PIXI.Container） ★★★
    this.cutsContainer = new PIXI.Container();
    this.cutsContainer.label = 'AnimationSystem_CutsContainer';
    
    // ★★★ CUTメタデータ配列（表示順序・duration管理用） ★★★
    this.cutMetadata = [
      // {
      //   cutId: 'cut_001',
      //   name: 'CUT1',
      //   duration: 0.5,
      //   cutContainer: <PIXI.Container>,  // ← 実体への参照
      //   thumbnailCanvas: <Canvas>,
      //   order: 0  // 表示順序
      // }
    ];
    
    // ★★★ 現在アクティブなCUTのIndex ★★★
    this.activeCutIndex = 0;
    
    // Playback用
    this.playbackState = {
      isPlaying: false,
      startTime: 0,
      loop: true
    };
  }
}
```

### LayerSystem

```javascript
class LayerSystem {
  constructor() {
    // ★★★ LayersContainerは「現在のCUTコンテナ」への参照ポイント ★★★
    this.layersContainer = null;  // ← AnimationSystemのcutContainerを参照
    
    // ★★★ layers配列 = layersContainer.children（getter経由） ★★★
    // this.layers は削除 → getter で this.layersContainer.children を返す
    
    this.activeLayerIndex = -1;
    this.layerTransforms = new Map();  // cutId_layerId → transform
  }
  
  // ★★★ layers は getter で定義（常に最新のchildren） ★★★
  get layers() {
    return this.layersContainer ? Array.from(this.layersContainer.children) : [];
  }
}
```

---

## 🔄 動作フロー詳細

### A. 初期化フロー

```
1. AnimationSystem.init()
   │
   ├─ this.cutsContainer = new PIXI.Container()
   ├─ this.cutsContainer を世界の外（非表示領域）に配置
   │   → app.stage.addChild(this.cutsContainer)
   │   → this.cutsContainer.visible = false  // レンダリング対象外
   │
   └─ 初期CUT作成
       └─ createInitialCut()
           │
           ├─ cutContainer = new PIXI.Container()
           ├─ cutContainer.label = 'cut_001'
           ├─ 背景Layer作成 → cutContainer.addChild(bgLayer)
           ├─ Layer1作成 → cutContainer.addChild(layer1)
           ├─ this.cutsContainer.addChild(cutContainer)
           │
           └─ this.cutMetadata.push({
                 cutId: 'cut_001',
                 name: 'CUT1',
                 duration: 0.5,
                 cutContainer: cutContainer,  // ← 実体参照
                 thumbnailCanvas: null,
                 order: 0
               })

2. LayerSystem.init()
   │
   └─ this.layersContainer = null  // まだ未接続

3. AnimationSystem.setActiveCut(0)
   │
   ├─ const cutData = this.cutMetadata[0]
   ├─ const cutContainer = cutData.cutContainer
   │
   ├─ LayerSystem への接続
   │   └─ this.layerSystem.switchToCutContainer(cutContainer)
   │       │
   │       ├─ 旧 layersContainer を canvasContainer から削除
   │       ├─ this.layersContainer = cutContainer  // ← 参照切替
   │       ├─ this.canvasContainer.addChild(cutContainer)
   │       └─ cutContainer.visible = true
   │
   └─ UI更新
       ├─ this.layerSystem.updateLayerPanelUI()
       └─ eventBus.emit('animation:cut-applied')
```

---

### B. 描画フロー

```
1. ユーザーが描画開始
   │
2. DrawingEngine: マウス座標を取得
   │
3. DrawingEngine: path作成
   │
   const path = {
     id: 'path_xxx',
     points: [],
     graphics: new PIXI.Graphics(),
     ...
   }
   │
4. LayerSystem.addPathToActiveLayer(path)
   │
   ├─ const activeLayer = this.layers[this.activeLayerIndex]
   │   // ★★★ this.layers は getter → this.layersContainer.children[index] ★★★
   │
   ├─ activeLayer.layerData.paths.push(path)
   ├─ activeLayer.addChild(path.graphics)
   │
   └─ ★★★ 何もコピー不要！すでにCUTコンテナ内に存在 ★★★
   
5. 描画完了時
   │
   └─ AnimationSystem.onDrawingComplete()
       │
       └─ const currentCutIndex = this.activeCutIndex
           const cutData = this.cutMetadata[currentCutIndex]
           │
           └─ this.generateCutThumbnail(currentCutIndex)
               // cutData.cutContainer を直接レンダリング
```

**重要ポイント**:
- **コピー不要**: LayerSystem.layersContainer は CUTコンテナそのもの
- **自動保存**: PIXI.Containerツリーに追加した時点で保存完了
- **参照漏れゼロ**: すべてContainerの親子関係で管理

---

### C. CUT切替フロー

```
1. ユーザーがCUT2をクリック
   │
2. TimelineUI: AnimationSystem.switchToActiveCut(1)
   │
3. AnimationSystem.switchToActiveCut(newIndex)
   │
   ├─ if (this.activeCutIndex === newIndex) return  // 同じCUTなら何もしない
   │
   ├─ const oldCutData = this.cutMetadata[this.activeCutIndex]
   ├─ const newCutData = this.cutMetadata[newIndex]
   │
   ├─ ★★★ 旧CUTコンテナを非表示領域へ戻す ★★★
   │   └─ this.canvasContainer.removeChild(oldCutData.cutContainer)
   │       this.cutsContainer.addChild(oldCutData.cutContainer)
   │       oldCutData.cutContainer.visible = false
   │
   ├─ ★★★ 新CUTコンテナを表示領域へ移動 ★★★
   │   └─ this.cutsContainer.removeChild(newCutData.cutContainer)
   │       this.canvasContainer.addChild(newCutData.cutContainer)
   │       newCutData.cutContainer.visible = true
   │
   ├─ ★★★ LayerSystemの参照先を切替 ★★★
   │   └─ this.layerSystem.layersContainer = newCutData.cutContainer
   │
   ├─ this.activeCutIndex = newIndex
   │
   └─ UI更新
       ├─ this.layerSystem.updateLayerPanelUI()
       │   // this.layers getter が新CUTのchildren返す
       │
       └─ eventBus.emit('animation:cut-applied', { 
            cutIndex: newIndex, 
            cutId: newCutData.cutId 
          })
```

**重要ポイント**:
- **コピー不要**: Containerの親子関係を変更するだけ
- **高速**: `removeChild()` と `addChild()` のみ
- **確実**: 参照が明確（cutContainer → canvasContainer or cutsContainer）

---

### D. 新規CUT作成フロー

```
1. ユーザーが「+CUT」ボタンクリック
   │
2. AnimationSystem.createNewCut(sourceType)
   │
   sourceType: 'blank' | 'copy_current'
   │
3. ★★★ Case A: 空CUT作成 ★★★
   │
   if (sourceType === 'blank') {
     │
     ├─ cutContainer = new PIXI.Container()
     ├─ cutContainer.label = 'cut_' + Date.now()
     │
     ├─ 初期Layer構造を作成
     │   │
     │   ├─ bgLayer = new PIXI.Container()
     │   ├─ bgLayer.layerData = { id, name: '背景', paths: [], ... }
     │   ├─ 背景Graphics作成 → bgLayer.addChild(bgGraphics)
     │   ├─ cutContainer.addChild(bgLayer)
     │   │
     │   ├─ layer1 = new PIXI.Container()
     │   ├─ layer1.layerData = { id, name: 'レイヤー1', paths: [], ... }
     │   └─ cutContainer.addChild(layer1)
     │
     ├─ this.cutsContainer.addChild(cutContainer)
     ├─ cutContainer.visible = false  // 非表示領域に保管
     │
     └─ this.cutMetadata.push({
          cutId: cutContainer.label,
          name: 'CUT' + (this.cutMetadata.length + 1),
          duration: 0.5,
          cutContainer: cutContainer,
          thumbnailCanvas: null,
          order: this.cutMetadata.length
        })
   }

4. ★★★ Case B: 現在CUTをコピー ★★★
   │
   if (sourceType === 'copy_current') {
     │
     ├─ const sourceCutData = this.cutMetadata[this.activeCutIndex]
     ├─ const sourceCutContainer = sourceCutData.cutContainer
     │
     ├─ ★★★ PIXI.Containerのディープクローン ★★★
     │   │
     │   └─ cutContainer = this.cloneCutContainer(sourceCutContainer)
     │       │
     │       ├─ const cloned = new PIXI.Container()
     │       ├─ cloned.label = 'cut_' + Date.now()
     │       │
     │       ├─ sourceCutContainer.children.forEach(sourceLayer => {
     │       │     const clonedLayer = this.cloneLayer(sourceLayer)
     │       │     cloned.addChild(clonedLayer)
     │       │   })
     │       │
     │       └─ return cloned
     │
     ├─ this.cutsContainer.addChild(cutContainer)
     ├─ cutContainer.visible = false
     │
     └─ this.cutMetadata.push({
          cutId: cutContainer.label,
          name: sourceCutData.name + '_copy',
          duration: sourceCutData.duration,
          cutContainer: cutContainer,
          thumbnailCanvas: null,
          order: this.cutMetadata.length
        })
   }

5. 新CUTに切替
   │
   └─ this.switchToActiveCut(this.cutMetadata.length - 1)

6. サムネイル生成
   │
   └─ setTimeout(() => {
        this.generateCutThumbnail(this.cutMetadata.length - 1)
      }, 100)
```

**重要ポイント**:
- **明確な所有権**: cutContainer が唯一の実体
- **クローンの簡潔さ**: PIXI.Containerツリーをそのまま複製
- **コピー後の独立性**: 別のContainer = 別のメモリ領域

---

### E. CUT削除フロー

```
1. ユーザーが削除ボタンクリック
   │
2. AnimationSystem.deleteCut(cutIndex)
   │
   ├─ if (this.cutMetadata.length <= 1) return false  // 最後の1つは削除不可
   │
   ├─ const cutData = this.cutMetadata[cutIndex]
   ├─ const cutContainer = cutData.cutContainer
   │
   ├─ ★★★ CUTコンテナを完全破棄 ★★★
   │   │
   │   ├─ cutContainer.children.forEach(layer => {
   │   │     layer.children.forEach(child => {
   │   │       if (child.destroy) child.destroy()
   │   │     })
   │   │     layer.destroy({ children: true })
   │   │   })
   │   │
   │   ├─ cutContainer.destroy({ children: true })
   │   │
   │   └─ this.cutMetadata.splice(cutIndex, 1)
   │
   ├─ アクティブIndex調整
   │   │
   │   └─ if (this.activeCutIndex >= cutIndex) {
          this.activeCutIndex = Math.max(0, this.activeCutIndex - 1)
        }
   │
   └─ 新しいアクティブCUTに切替
       └─ this.switchToActiveCut(this.activeCutIndex)
```

---

### F. サムネイル生成フロー

```
1. AnimationSystem.generateCutThumbnail(cutIndex)
   │
   ├─ const cutData = this.cutMetadata[cutIndex]
   ├─ const cutContainer = cutData.cutContainer
   │
   ├─ ★★★ 一時的に表示可能状態にする ★★★
   │   │
   │   ├─ const wasVisible = cutContainer.visible
   │   ├─ const originalParent = cutContainer.parent
   │   │
   │   ├─ if (!wasVisible) {
   │   │     // サムネイル生成用に一時的にステージへ
   │   │     if (originalParent) originalParent.removeChild(cutContainer)
   │   │     this.app.stage.addChild(cutContainer)
   │   │     cutContainer.visible = true
   │   │     cutContainer.position.set(-10000, -10000)  // 画面外
   │   │   }
   │   │
   │   ├─ await nextFrame()  // レンダリング待機
   │   │
   │   ├─ ★★★ cutContainer全体をレンダリング ★★★
   │   │   │
   │   │   ├─ const renderTexture = PIXI.RenderTexture.create({
   │   │   │     width: canvasWidth,
   │   │   │     height: canvasHeight
   │   │   │   })
   │   │   │
   │   │   ├─ this.app.renderer.render({
   │   │   │     container: cutContainer,
   │   │   │     target: renderTexture
   │   │   │   })
   │   │   │
   │   │   ├─ const canvas = this.app.renderer.extract.canvas(renderTexture)
   │   │   │
   │   │   ├─ ★★★ Canvas2Dでリサイズ（72x54） ★★★
   │   │   │   │
   │   │   │   ├─ const thumbCanvas = document.createElement('canvas')
   │   │   │   ├─ thumbCanvas.width = 72
   │   │   │   ├─ thumbCanvas.height = 54
   │   │   │   │
   │   │   │   ├─ const ctx = thumbCanvas.getContext('2d')
   │   │   │   ├─ ctx.imageSmoothingEnabled = true
   │   │   │   ├─ ctx.imageSmoothingQuality = 'high'
   │   │   │   └─ ctx.drawImage(canvas, 0, 0, 72, 54)
   │   │   │
   │   │   ├─ renderTexture.destroy()
   │   │   │
   │   │   └─ cutData.thumbnailCanvas = thumbCanvas
   │   │
   │   └─ ★★★ 元の状態に戻す ★★★
   │       │
   │       ├─ if (!wasVisible) {
   │       │     this.app.stage.removeChild(cutContainer)
   │       │     if (originalParent) originalParent.addChild(cutContainer)
   │       │     cutContainer.visible = false
   │       │   }
   │       │
   │       └─ cutContainer.position.set(0, 0)
   │
   └─ eventBus.emit('animation:thumbnail-generated', { cutIndex })
```

**重要ポイント**:
- **直接レンダリング**: cutContainer を丸ごとレンダリング
- **状態復元**: 一時的に表示 → レンダリング → 元に戻す
- **高速**: Layerごとではなく、Container全体を1回でレンダリング

---

## 📚 主要メソッド定義辞典

### AnimationSystem

| メソッド名 | 責務 | 引数 | 戻り値 | 詳細 |
|-----------|------|-----|--------|------|
| `init(layerSystem, app)` | システム初期化 | LayerSystem, PIXI.Application | void | cutsContainer作成・初期CUT作成 |
| `createInitialCut()` | 初期CUT作成 | なし | CutMetadata | 背景+Layer1の空CUT作成 |
| `createNewCut(sourceType)` | 新規CUT作成 | 'blank' \| 'copy_current' | CutMetadata | 空 or コピーCUT作成 |
| `cloneCutContainer(sourceCutContainer)` | CUTコンテナの完全複製 | PIXI.Container | PIXI.Container | Containerツリー全体をクローン |
| `cloneLayer(sourceLayer)` | Layer完全複製 | PIXI.Container | PIXI.Container | layerData・paths・graphics全複製 |
| `clonePath(sourcePath)` | Path完全複製 | PathObject | PathObject | points配列・graphics複製 |
| `switchToActiveCut(newIndex)` | アクティブCUT切替 | number | void | Container親子関係変更・LayerSystem参照切替 |
| `deleteCut(cutIndex)` | CUT削除 | number | boolean | Container破棄・metadata削除 |
| `generateCutThumbnail(cutIndex)` | サムネイル生成 | number | Promise\<void\> | cutContainer全体レンダリング |
| `play()` | 再生開始 | なし | void | タイマー起動・CUT自動切替 |
| `stop()` | 再生停止 | なし | void | タイマー停止 |
| `goToNextFrame()` | 次CUTへ | なし | void | activeCutIndex++ → switchToActiveCut() |
| `goToPreviousFrame()` | 前CUTへ | なし | void | activeCutIndex-- → switchToActiveCut() |
| `updateCutDuration(cutIndex, duration)` | CUT継続時間更新 | number, number | void | metadata.duration更新 |
| `reorderCuts(oldIndex, newIndex)` | CUT並び替え | number, number | void | metadata配列並び替え |

---

### LayerSystem

| メソッド名 | 責務 | 引数 | 戻り値 | 詳細 |
|-----------|------|-----|--------|------|
| `get layers()` | レイヤー配列取得 | なし | Array\<PIXI.Container\> | layersContainer.children返却 |
| `switchToCutContainer(cutContainer)` | CUTコンテナ切替 | PIXI.Container | void | layersContainer参照先変更 |
| `createLayer(name, isBackground)` | 新規Layer作成 | string, boolean | {layer, index} | Container作成 → 現在のcutContainerに追加 |
| `deleteLayer(layerIndex)` | Layer削除 | number | boolean | layersContainer.children[index]削除 |
| `addPathToActiveLayer(path)` | アクティブLayerにPath追加 | PathObject | void | layers[activeIndex].addChild(path.graphics) |
| `setActiveLayer(index)` | アクティブLayer切替 | number | void | activeLayerIndex更新・UI更新 |
| `toggleLayerVisibility(layerIndex)` | Layer可視性トグル | number | void | layer.visible切替 |
| `updateActiveLayerTransform(property, value)` | Transform更新 | string, number | void | layerTransforms更新・PIXIに反映 |
| `flipActiveLayer(direction)` | Layer反転 | 'horizontal' \| 'vertical' | void | transform.scaleX/Y *= -1 |
| `confirmLayerTransform()` | Transform確定 | なし | void | pathsにBake・transform初期化 |
| `updateLayerPanelUI()` | LayerパネルUI更新 | なし | void | this.layers getter経由でHTML生成 |
| `updateThumbnail(layerIndex)` | Layer個別サムネイル更新 | number | void | Layer単体レンダリング |

---

### 重要な内部メソッド

#### AnimationSystem.cloneCutContainer()
```javascript
/**
 * CUTコンテナの完全複製
 * ★★★ PIXI.Containerツリー全体を再帰的にクローン ★★★
 */
cloneCutContainer(sourceCutContainer) {
  const cloned = new PIXI.Container();
  cloned.label = 'cut_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  
  // 子Layer全複製
  sourceCutContainer.children.forEach(sourceLayer => {
    const clonedLayer = this.cloneLayer(sourceLayer);
    cloned.addChild(clonedLayer);
  });
  
  return cloned;
}
```

#### AnimationSystem.cloneLayer()
```javascript
/**
 * Layer完全複製
 * ★★★ layerData・paths・graphics全複製 ★★★
 */
cloneLayer(sourceLayer) {
  const clonedLayer = new PIXI.Container();
  clonedLayer.label = sourceLayer.label + '_clone_' + Date.now();
  
  // layerData複製
  clonedLayer.layerData = {
    id: clonedLayer.label,
    name: sourceLayer.layerData.name,
    visible: sourceLayer.layerData.visible,
    opacity: sourceLayer.layerData.opacity,
    isBackground: sourceLayer.layerData.isBackground,
    paths: []  // 後で追加
  };
  
  // Transform複製
  clonedLayer.position.set(sourceLayer.position.x, sourceLayer.position.y);
  clonedLayer.pivot.set(sourceLayer.pivot.x, sourceLayer.pivot.y);
  clonedLayer.rotation = sourceLayer.rotation;
  clonedLayer.scale.set(sourceLayer.scale.x, sourceLayer.scale.y);
  clonedLayer.alpha = sourceLayer.alpha;
  clonedLayer.visible = sourceLayer.visible;
  
  // 背景Graphics複製
  if (sourceLayer.layerData.isBackground && sourceLayer.layerData.backgroundGraphics) {
    const clonedBg = new PIXI.Graphics();
    const canvasWidth = this.layerSystem.config.canvas.width;
    const canvasHeight = this.layerSystem.config.canvas.height;
    const bgColor = this.layerSystem.config.background.color;
    clonedBg.rect(0, 0, canvasWidth, canvasHeight);
    clonedBg.fill(bgColor);
    clonedLayer.addChild(clonedBg);
    clonedLayer.layerData.backgroundGraphics = clonedBg;
  }
  
  // paths複製
  if (sourceLayer.layerData.paths) {
    sourceLayer.layerData.paths.forEach(sourcePath => {
      const clonedPath = this.clonePath(sourcePath);
      clonedLayer.layerData.paths.push(clonedPath);
      clonedLayer.addChild(clonedPath.graphics);
    });
  }
  
  return clonedLayer;
}
```

#### AnimationSystem.clonePath()
```javascript
/**
 * Path完全複製
 * ★★★ points配列・PIXI.Graphics再生成 ★★★
 */
clonePath(sourcePath) {
  const clonedGraphics = new PIXI.Graphics();
  
  // points配列複製
  const clonedPoints = sourcePath.points.map(p => ({
    x: p.x,
    y: p.y
  }));
  
  // Graphics再描画
  clonedPoints.forEach(point => {
    clonedGraphics.circle(point.x, point.y, sourcePath.size / 2);
    clonedGraphics.fill({
      color: sourcePath.color,
      alpha: sourcePath.opacity
    });
  });
  
  return {
    id: 'path_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
    points: clonedPoints,
    size: sourcePath.size,
    color: sourcePath.color,
    opacity: sourcePath.opacity,
    tool: sourcePath.tool,
    graphics: clonedGraphics
  };
}
```

---

## 🔍 デバッグ・検証方法

### CUT独立性の確認

```javascript
// コンソールでの確認コマンド

// 1. CUT構造の確認
console.log('CutsContainer:', animationSystem.cutsContainer);
console.log('CUT数:', animationSystem.cutsContainer.children.length);
console.log('Metadata数:', animationSystem.cutMetadata.length);

// 2. 各CUTの内容確認
animationSystem.cutMetadata.forEach((cutData, i) => {
  console.log(`CUT${i+1}:`, {
    name: cutData.name,
    layerCount: cutData.cutContainer.children.length,
    layers: cutData.cutContainer.children.map(l => ({
      name: l.layerData?.name,
      pathCount: l.layerData?.paths?.length || 0
    }))
  });
});

// 3. アクティブCUTの確認
console.log('Active CUT Index:', animationSystem.activeCutIndex);
console.log('LayerSystem.layersContainer === Active CUT?', 
  layerSystem.layersContainer === animationSystem.cutMetadata[animationSystem.activeCutIndex].cutContainer
);

// 4. 独立性テスト
// CUT1で描画 → CUT2に切替 → CUT1に戻る → 描画が残っているか確認
function testCutIndependence() {
  console.log('=== CUT独立性テスト開始 ===');
  
  // CUT1のLayer1のPath数を記録
  const cut1 = animationSystem.cutMetadata[0];
  const cut1Layer1 = cut1.cutContainer.children[1]; // Layer1
  const initialPathCount = cut1Layer1.layerData.paths.length;
  console.log('CUT1 Layer1 初期Path数:', initialPathCount);
  
  // CUT2に切替
  animationSystem.switchToActiveCut(1);
  console.log('CUT2に切替完了');
  
  // CUT2のLayer1のPath数確認
  const cut2 = animationSystem.cutMetadata[1];
  const cut2Layer1 = cut2.cutContainer.children[1];
  const cut2PathCount = cut2Layer1.layerData.paths.length;
  console.log('CUT2 Layer1 Path数:', cut2PathCount);
  
  // CUT1に戻る
  animationSystem.switchToActiveCut(0);
  console.log('CUT1に戻る');
  
  // CUT1のPath数が変わっていないか確認
  const finalPathCount = cut1Layer1.layerData.paths.length;
  console.log('CUT1 Layer1 最終Path数:', finalPathCount);
  
  if (initialPathCount === finalPathCount) {
    console.log('✅ テスト成功: CUTは独立している');
  } else {
    console.error('❌ テスト失敗: Path数が変化した');
  }
}

// 5. メモリリーク確認
function checkMemoryLeaks() {
  console.log('=== メモリリーク確認 ===');
  
  // CUT削除前のContainer数
  const beforeCount = animationSystem.cutsContainer.children.length;
  console.log('削除前CUT数:', beforeCount);
  
  // CUT削除
  const deletedCutId = animationSystem.cutMetadata[1].cutId;
  animationSystem.deleteCut(1);
  
  // 削除後のContainer数
  const afterCount = animationSystem.cutsContainer.children.length;
  console.log('削除後CUT数:', afterCount);
  
  // cutsContainerに削除したCUTが残っていないか確認
  const leaked = animationSystem.cutsContainer.children.find(c => c.label === deletedCutId);
  
  if (!leaked && afterCount === beforeCount - 1) {
    console.log('✅ メモリリーク無し: CUTは完全に削除された');
  } else {
    console.error('❌ メモリリーク検出: CUTが残っている');
  }
}
```

---

## ⚠️ 重要な実装注意事項

### 1. cutsContainer の配置

```javascript
// ❌ NG: ステージに直接追加すると全CUTがレンダリングされる
app.stage.addChild(this.cutsContainer);
this.cutsContainer.visible = true;  // 全CUT描画でパフォーマンス低下

// ✅ OK: cutsContainerは非表示領域に配置
app.stage.addChild(this.cutsContainer);
this.cutsContainer.visible = false;  // レンダリング対象外
this.cutsContainer.position.set(-999999, -999999);  // 画面外

// ✅ アクティブなCUTのみをcanvasContainerに配置
canvasContainer.addChild(activeCutContainer);
activeCutContainer.visible = true;  // これだけレンダリング
```

**理由**: すべてのCUTを常時レンダリングするとGPUメモリとCPU負荷が増大

---

### 2. LayerSystem.layers getter の実装

```javascript
// ❌ NG: 配列をキャッシュすると参照が古くなる
get layers() {
  if (!this._cachedLayers) {
    this._cachedLayers = Array.from(this.layersContainer.children);
  }
  return this._cachedLayers;
}

// ✅ OK: 常に最新のchildrenを返す
get layers() {
  return this.layersContainer ? Array.from(this.layersContainer.children) : [];
}
```

**理由**: CUT切替時に自動的に新しいchildrenが取得される

---

### 3. Transform情報の管理

```javascript
// ★★★ layerTransforms Mapのキーは「cutId_layerId」★★★
const transformKey = `${cutData.cutId}_${layer.layerData.id}`;
this.layerTransforms.set(transformKey, {
  x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1
});

// CUT切替時、Transform復元
const transform = this.layerTransforms.get(transformKey);
if (transform) {
  layer.position.set(transform.x, transform.y);
  layer.rotation = transform.rotation;
  layer.scale.set(transform.scaleX, transform.scaleY);
}
```

**理由**: 同じLayerでもCUTごとに異なるTransformを持つ可能性がある

---

### 4. サムネイル生成のタイミング

```javascript
// ✅ CUT作成直後
createNewCut(sourceType) {
  // ... CUT作成処理 ...
  
  const newIndex = this.cutMetadata.length - 1;
  
  // 次フレームでサムネイル生成（レンダリング待機）
  requestAnimationFrame(() => {
    this.generateCutThumbnail(newIndex);
  });
}

// ✅ 描画完了後
LayerSystem.addPathToActiveLayer(path) {
  // ... Path追加処理 ...
  
  // AnimationSystemに通知
  if (this.eventBus) {
    this.eventBus.emit('layer:path-added', {
      cutIndex: this.animationSystem.activeCutIndex
    });
  }
}

// AnimationSystemで受信
this.eventBus.on('layer:path-added', (data) => {
  // デバウンス処理（100ms以内の連続描画はまとめる）
  clearTimeout(this.thumbnailDebounceTimer);
  this.thumbnailDebounceTimer = setTimeout(() => {
    this.generateCutThumbnail(data.cutIndex);
  }, 100);
});
```

**理由**: 毎ストロークでサムネイル生成するとパフォーマンス低下

---

### 5. CUT削除時のクリーンアップ

```javascript
deleteCut(cutIndex) {
  const cutData = this.cutMetadata[cutIndex];
  const cutContainer = cutData.cutContainer;
  
  // ★★★ Step 1: 子要素から順に破棄 ★★★
  cutContainer.children.forEach(layer => {
    // Graphics破棄
    layer.children.forEach(child => {
      if (child.destroy) {
        child.destroy({ children: true, texture: false, baseTexture: false });
      }
    });
    
    // Layer破棄
    layer.destroy({ children: true, texture: false, baseTexture: false });
  });
  
  // ★★★ Step 2: Container破棄 ★★★
  if (cutContainer.parent) {
    cutContainer.parent.removeChild(cutContainer);
  }
  cutContainer.destroy({ children: true, texture: false, baseTexture: false });
  
  // ★★★ Step 3: Metadata削除 ★★★
  this.cutMetadata.splice(cutIndex, 1);
  
  // ★★★ Step 4: Transform情報削除 ★★★
  // cutId に紐づく Transform を全削除
  const cutId = cutData.cutId;
  for (let key of this.layerSystem.layerTransforms.keys()) {
    if (key.startsWith(cutId + '_')) {
      this.layerSystem.layerTransforms.delete(key);
    }
  }
  
  // ★★★ Step 5: サムネイルCanvas削除 ★★★
  cutData.thumbnailCanvas = null;
}
```

**理由**: メモリリークを防ぐための完全なクリーンアップ

---

## 📊 パフォーマンス最適化

### 1. レンダリング最適化

```javascript
// ★★★ 非アクティブなCUTはレンダリング対象外 ★★★
switchToActiveCut(newIndex) {
  const oldCutData = this.cutMetadata[this.activeCutIndex];
  const newCutData = this.cutMetadata[newIndex];
  
  // 旧CUTを非表示領域へ（レンダリング停止）
  oldCutData.cutContainer.renderable = false;  // ← 重要
  oldCutData.cutContainer.visible = false;
  
  // 新CUTを表示領域へ（レンダリング開始）
  newCutData.cutContainer.renderable = true;  // ← 重要
  newCutData.cutContainer.visible = true;
}
```

**効果**: レンダリング対象が1 CUT分のみになる

---

### 2. サムネイル生成の最適化

```javascript
// ★★★ 低解像度レンダリング ★★★
generateCutThumbnail(cutIndex) {
  const cutData = this.cutMetadata[cutIndex];
  const cutContainer = cutData.cutContainer;
  
  // サムネイルは72x54の小サイズ
  const thumbScale = 72 / this.config.canvas.width;
  
  const renderTexture = PIXI.RenderTexture.create({
    width: 72,
    height: 54,
    resolution: 1  // 低解像度
  });
  
  // スケール適用してレンダリング
  const tempContainer = new PIXI.Container();
  tempContainer.addChild(cutContainer);
  tempContainer.scale.set(thumbScale);
  
  this.app.renderer.render({
    container: tempContainer,
    target: renderTexture
  });
  
  // ... Canvas抽出 ...
}
```

**効果**: サムネイル生成時間が1/10以下に短縮

---

### 3. イベント駆動型更新

```javascript
// ❌ NG: ポーリング（毎フレームチェック）
app.ticker.add(() => {
  if (needsUpdate) {
    updateUI();
  }
});

// ✅ OK: イベント駆動
eventBus.on('layer:path-added', () => {
  updateUI();
});

eventBus.on('animation:cut-applied', () => {
  updateUI();
});
```

**効果**: 不要な更新処理を削減

---

## 🎨 将来のレイヤーフォルダ実装への拡張

### 現在の構造
```
CUT (PIXI.Container)
├─ Layer1 (PIXI.Container)
├─ Layer2 (PIXI.Container)
└─ Layer3 (PIXI.Container)
```

### フォルダ実装後
```
CUT (PIXI.Container)
├─ Folder1 (PIXI.Container)  ← type: 'folder'
│   ├─ Layer1 (PIXI.Container)
│   └─ Layer2 (PIXI.Container)
├─ Layer3 (PIXI.Container)
└─ Folder2 (PIXI.Container)  ← type: 'folder'
    └─ Layer4 (PIXI.Container)
```

### 実装方法

```javascript
// Container に type を追加
container.containerType = 'folder';  // or 'layer'

// フォルダ判定
function isFolder(container) {
  return container.containerType === 'folder';
}

// 再帰的なレンダリング
function renderLayerTree(container, indent = 0) {
  if (isFolder(container)) {
    console.log('  '.repeat(indent) + '📁 ' + container.layerData.name);
    container.children.forEach(child => {
      renderLayerTree(child, indent + 1);
    });
  } else {
    console.log('  '.repeat(indent) + '📄 ' + container.layerData.name);
  }
}

// フォルダサムネイル = 子Layer合成
function generateFolderThumbnail(folderContainer) {
  // フォルダ全体をレンダリング（子Layerすべて含む）
  const renderTexture = PIXI.RenderTexture.create({...});
  app.renderer.render({
    container: folderContainer,  // フォルダごとレンダリング
    target: renderTexture
  });
  return app.renderer.extract.canvas(renderTexture);
}
```

**利点**: 
- CUTもフォルダも同じContainer構造
- 既存のクローン・削除・レンダリング処理がそのまま使える
- 階層構造が自然に表現される

---

## 🚀 移行ステップ（段階的実装）

### Phase 1: AnimationSystemのContainer化
1. `cutsContainer` を作成
2. `cutMetadata` 配列を実装
3. `createInitialCut()` で初期CUT作成
4. `switchToActiveCut()` でContainer切替実装

**検証**: 
- CUTが cutsContainer.children に存在するか
- 切替で canvasContainer の子が変わるか

---

### Phase 2: LayerSystemのgetter化
1. `this.layers` を削除
2. `get layers()` getter実装
3. `switchToCutContainer()` 実装

**検証**:
- `layerSystem.layers` が動的に変わるか
- CUT切替後、layers配列が新CUTのchildrenか

---

### Phase 3: クローン機能実装
1. `cloneCutContainer()` 実装
2. `cloneLayer()` 実装
3. `clonePath()` 実装
4. `createNewCut('copy_current')` 実装

**検証**:
- コピーしたCUTは完全に独立しているか
- 元CUTに描画してもコピー先は変化しないか

---

### Phase 4: サムネイル生成
1. `generateCutThumbnail()` 実装
2. TimelineUIでサムネイル表示
3. デバウンス処理追加

**検証**:
- サムネイルが正しく表示されるか
- 描画後にサムネイルが更新されるか

---

### Phase 5: プレイバック機能
1. `play()` / `stop()` 実装
2. タイマーでCUT自動切替
3. ループ設定実装

**検証**:
- CUTが順番に切り替わるか
- duration通りに切り替わるか

---

## 📝 完全なコード例（抜粋）

### AnimationSystem.switchToActiveCut()

```javascript
switchToActiveCut(newIndex) {
  // 同じCUTなら何もしない
  if (this.activeCutIndex === newIndex) return;
  
  // 範囲チェック
  if (newIndex < 0 || newIndex >= this.cutMetadata.length) return;
  
  const oldCutData = this.cutMetadata[this.activeCutIndex];
  const newCutData = this.cutMetadata[newIndex];
  
  // ★★★ Step 1: 旧CUTを非表示領域へ戻す ★★★
  if (oldCutData.cutContainer.parent === this.canvasContainer) {
    this.canvasContainer.removeChild(oldCutData.cutContainer);
    this.cutsContainer.addChild(oldCutData.cutContainer);
    oldCutData.cutContainer.visible = false;
    oldCutData.cutContainer.renderable = false;
  }
  
  // ★★★ Step 2: 新CUTを表示領域へ移動 ★★★
  if (newCutData.cutContainer.parent === this.cutsContainer) {
    this.cutsContainer.removeChild(newCutData.cutContainer);
    this.canvasContainer.addChild(newCutData.cutContainer);
    newCutData.cutContainer.visible = true;
    newCutData.cutContainer.renderable = true;
    newCutData.cutContainer.position.set(0, 0);
  }
  
  // ★★★ Step 3: LayerSystemの参照先を切替 ★★★
  this.layerSystem.switchToCutContainer(newCutData.cutContainer);
  
  // ★★★ Step 4: Index更新 ★★★
  this.activeCutIndex = newIndex;
  
  // ★★★ Step 5: UI更新 ★★★
  this.layerSystem.updateLayerPanelUI();
  
  if (this.eventBus) {
    this.eventBus.emit('animation:cut-applied', {
      cutIndex: newIndex,
      cutId: newCutData.cutId
    });
  }
}
```

---

### LayerSystem.switchToCutContainer()

```javascript
switchToCutContainer(newCutContainer) {
  // ★★★ 参照先を切り替えるだけ（コピー不要） ★★★
  this.layersContainer = newCutContainer;
  
  // activeLayerIndex調整
  if (this.activeLayerIndex >= this.layers.length) {
    this.activeLayerIndex = Math.max(0, this.layers.length - 1);
  }
  
  // UI更新
  this.updateLayerPanelUI();
  this.updateStatusDisplay();
  
  if (this.eventBus) {
    this.eventBus.emit('layer:container-switched', {
      layerCount: this.layers.length
    });
  }
}
```

---

### AnimationSystem.cloneCutContainer()

```javascript
cloneCutContainer(sourceCutContainer) {
  const cloned = new PIXI.Container();
  cloned.label = 'cut_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  
  // 子Layer全複製
  sourceCutContainer.children.forEach(sourceLayer => {
    const clonedLayer = this.cloneLayer(sourceLayer);
    cloned.addChild(clonedLayer);
  });
  
  // Transform継承
  cloned.position.set(sourceCutContainer.position.x, sourceCutContainer.position.y);
  cloned.scale.set(sourceCutContainer.scale.x, sourceCutContainer.scale.y);
  cloned.rotation = sourceCutContainer.rotation;
  cloned.alpha = sourceCutContainer.alpha;
  cloned.visible = false;  // 非表示領域で作成
  cloned.renderable = false;
  
  return cloned;
}
```

---

## ✅ 改修完了チェックリスト

### AnimationSystem
- [ ] `cutsContainer` 作成・非表示領域配置
- [ ] `cutMetadata` 配列実装
- [ ] `createInitialCut()` 実装
- [ ] `createNewCut(sourceType)` 実装
- [ ] `cloneCutContainer()` / `cloneLayer()` / `clonePath()` 実装
- [ ] `switchToActiveCut()` 実装（Container親子関係変更）
- [ ] `deleteCut()` 実装（完全クリーンアップ）
- [ ] `generateCutThumbnail()` 実装

### LayerSystem
- [ ] `this.layers` 削除 → `get layers()` getter実装
- [ ] `switchToCutContainer()` 実装
- [ ] `updateLayerPanelUI()` をgetter対応に修正
- [ ] `addPathToActiveLayer()` でEventBus通知

### 統合テスト
- [ ] CUT1で描画 → CUT2で空白 → CUT1に戻ると描画が残る
- [ ] CUTコピーで完全に独立したCUT作成
- [ ] CUT削除でメモリリーク無し
- [ ] サムネイルが正しく表示される
- [ ] プレイバックでCUTが順番に切り替わる

---

## 🎯 まとめ: なぜこのアプローチが成功するのか

### 1. **シンプルさ**
- Container = フォルダという直感的な構造
- 参照管理のみ（コピー処理が最小限）

### 2. **確実性**
- PIXI.Containerの親子関係で管理
- 参照漏れが原理的に発生しない

### 3. **拡張性**
- レイヤーフォルダと統一的な扱い
- 階層構造の自然な表現

### 4. **パフォーマンス**
- アクティブなCUTのみレンダリング
- Container切替は高速

### 5. **デバッグ性**
- Container構造がそのままデータ構造
- Chrome DevToolsで可視化可能

---

**改修方針**: B案（CUT = アニメ用大フォルダ）を採用  
**理由**: A案の二桁の試行錯誤を経て、参照管理の複雑さが本質的な問題と判明  
**コアコンセプト**: Container = 真実、LayerSystem = View  
**成功の鍵**: コピー処理を最小化し、参照の明確化を徹底

---

## 📚 参考: PIXI.Container API要点

```javascript
// 子要素追加
container.addChild(child);

// 子要素削除
container.removeChild(child);

// 子要素配列
container.children  // Array<DisplayObject>

// 親要素
container.parent  // Container | null

// 破棄
container.destroy({
  children: true,      // 子要素も破棄
  texture: false,      // テクスチャは破棄しない
  baseTexture: false   // ベーステクスチャは破棄しない
});

// レンダリング制御
container.visible = false;     // 非表示
container.renderable = false;  // レンダリング対象外
```

---

**作成日**: 2025-09-30  
**対象バージョン**: v8.13_gif_phase2_folder  
**改修担当AI**: Claude Sonnet 4.5