# 🎨 Tegaki Phase1.5 REV系 責任分界改修手順書
## キャンバス表示問題解決 & 責任分界最適化

---

## 📊 改修目的と背景

### 🔴 解決すべき問題
1. **キャンバス非表示問題**: Phase1改修後もキャンバスが表示されない状態が継続
2. **index.html責任集中**: 依存関係管理・インラインスタイル・初期化処理の混在
3. **スクリプト依存関係の複雑化**: PHASE1～9の複雑な読み込み順序による保守困難
4. **スタイル管理の分散**: インラインスタイルとCSSファイルの二重管理

### 🎯 改修後の理想状態
- **確実なキャンバス表示**: CanvasManager初期化時の確実なDOM要素接続
- **責任分界の明確化**: index.html（構造）、bootstrap.js（依存管理）、main.js（初期化）の役割分離
- **保守性向上**: 依存関係とスタイルの一元管理による保守効率化
- **拡張性確保**: 将来のテーマ変更・UI改善への柔軟な対応基盤

---

## 🚀 REV.1: 現状分析と準備作業

### REV.1.1: 現在のindex.html問題分析
```html
<!-- 🔴 現在の問題箇所 -->
1. スクリプト依存関係が複雑（PHASE1～9）
2. インラインスタイル混在
3. キャンバスコンテナの信頼性不足
4. 初期化処理の分散
```

**🔧 分析結果**:
- キャンバス表示問題の根本原因: `CanvasManager.initialize`へのDOM要素渡しが不確実
- 責任境界問題: HTML内でのスクリプト管理・スタイル管理・初期化処理の混在

### REV.1.2: スタイル抽出準備
**📁 作業対象ファイル**: 
- `index.html` (インラインスタイル抽出)
- `css/styles.css` (統合先)

**🔧 抽出対象スタイル**:
```html
<!-- 抽出対象のインラインスタイル -->
<div id="canvas-container" style="width: 400px; height: 400px; margin: 0 auto; display: block; background-color: #ffffee; border: 1px solid #ccc;">
```

**📋 抽出後のCSSクラス設計**:
```css
:root {
  --futaba-maroon: #800000;
  --futaba-bg: #ffffee;
  --canvas-default-size: 400px;
  --border-color: #ccc;
}

.canvas-container {
  width: var(--canvas-default-size);
  height: var(--canvas-default-size);
  margin: 0 auto;
  display: block;
  background-color: var(--futaba-bg);
  border: 1px solid var(--border-color);
}
```

---

## 🚀 REV.2: bootstrap.js 新規作成

### REV.2.1: bootstrap.js基本設計
**📁 新規作成ファイル**: `js/bootstrap.js`

**🎯 設計方針**:
- 依存関係の順序管理を一元化
- 現在のPHASE1～9を統合・最適化
- エラー処理はErrorManagerに委譲
- 読み込み完了後のmain.js初期化トリガー

**🔧 実装内容**:

```javascript
/**
 * 🚀 Tegaki Bootstrap - 依存関係管理・初期化制御
 * 📋 RESPONSIBILITY: スクリプト依存関係の順序管理・読み込み制御
 * 🚫 PROHIBITION: UI処理・初期化ロジック・エラー表示
 * ✅ PERMISSION: 依存関係解決・順序制御・main.js委譲
 * 
 * 📏 DESIGN_PRINCIPLE: 責任分界（依存管理専門）
 * 🔄 INTEGRATION: main.js初期化への確実な委譲
 */

(function() {
    'use strict';
    
    console.log('🚀 Tegaki Bootstrap 開始');
    
    // 依存関係定義（現在のPHASE1～9を統合・最適化）
    const dependencies = [
        // Phase 1: 基盤ユーティリティ（依存なし）
        'js/utils/config-manager.js',
        'js/utils/error-manager.js',
        'js/utils/state-manager.js',
        'js/utils/event-bus.js',
        
        // Phase 2: 座標・境界システム
        'js/utils/coordinate-manager.js',
        
        // Phase 3: 追加ユーティリティ
        'js/utils/performance.js',
        'js/utils/icon-manager.js',
        
        // Phase 4: UI・管理システム
        'js/ui/popup-manager.js',
        'js/ui/slider-manager.js',
        'managers/ui-manager.js',
        'managers/memory-manager.js',
        'managers/settings-manager.js',
        
        // Phase 5: PixiJS拡張
        'libs/pixi-extensions.js',
        
        // Phase 6: Canvas・境界・ツール管理
        'managers/canvas-manager.js',
        'managers/boundary-manager.js',
        'managers/tool-manager.js',
        
        // Phase 7: ツール実装
        'tools/abstract-tool.js',
        'tools/pen-tool.js',
        'tools/eraser-tool.js',
        
        // Phase 8: コアシステム
        'js/app-core.js',
        
        // Phase 9: メインアプリケーション（最終）
        'js/main.js'
    ];
    
    let loadedCount = 0;
    const totalCount = dependencies.length;
    
    // 順序保証読み込み関数
    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.defer = false; // 順序保証
            
            script.onload = () => {
                loadedCount++;
                console.log(`✅ [${loadedCount}/${totalCount}] ${src}`);
                resolve();
            };
            
            script.onerror = (error) => {
                console.error(`❌ Failed to load: ${src}`, error);
                reject(new Error(`Failed to load ${src}`));
            };
            
            document.head.appendChild(script);
        });
    }
    
    // 順次読み込み実行
    async function loadDependencies() {
        try {
            console.log(`📦 ${totalCount}個の依存関係を順次読み込み中...`);
            
            for (const dependency of dependencies) {
                await loadScript(dependency);
            }
            
            console.log('✅ 全依存関係読み込み完了');
            
            // 読み込み完了イベント発火
            window.dispatchEvent(new CustomEvent('tegaki:dependencies:loaded'));
            
        } catch (error) {
            console.error('❌ 依存関係読み込み失敗:', error);
            
            // エラー処理はmain.jsのErrorManager委譲へ
            window.dispatchEvent(new CustomEvent('tegaki:dependencies:error', {
                detail: { error: error.message }
            }));
        }
    }
    
    // PixiJS読み込み確認後に実行
    function checkPixiAndStart() {
        if (window.PIXI) {
            console.log('✅ PIXI.js 読み込み確認');
            loadDependencies();
        } else {
            console.warn('⚠️ PIXI.js 未読み込み - 100ms後に再確認');
            setTimeout(checkPixiAndStart, 100);
        }
    }
    
    // DOM読み込み後に開始
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', checkPixiAndStart);
    } else {
        checkPixiAndStart();
    }
    
})();

console.log('🚀 Bootstrap スクリプト登録完了');
```

### REV.2.2: 依存関係最適化ポイント
**📊 現在のPHASE構造 → Bootstrap統合**:
```javascript
// 現在のPHASE1～9 → 最適化後の依存関係
PHASE 1: 基盤ユーティリティ     → Bootstrap Phase 1
PHASE 2: 座標・境界システム     → Bootstrap Phase 2  
PHASE 3: 追加ユーティリティ     → Bootstrap Phase 3
PHASE 4: UI・管理システム      → Bootstrap Phase 4
PHASE 5: PixiJS拡張統合       → Bootstrap Phase 5
PHASE 6: Canvas・境界・ツール管理 → Bootstrap Phase 6
PHASE 7: ツール実装          → Bootstrap Phase 7
PHASE 8: コアシステム        → Bootstrap Phase 8
PHASE 9: メインアプリケーション  → Bootstrap Phase 9
```

**✅ Bootstrap最適化効果**:
- 読み込み順序の保証（async/defer制御）
- 依存関係エラーの早期発見
- 読み込み進捗の可視化
- main.js初期化への確実な委譲

---

## 🚀 REV.3: スタイル統合とindex.html簡素化

### REV.3.1: styles.css拡張実装

**📁 修正対象ファイル**: `css/styles.css`

**🔧 追加実装内容**:
```css
/* 🎨 REV.3 責任分界対応 - CSS変数・共通クラス統合 */

/* CSS変数定義 */
:root {
  --futaba-maroon: #800000;
  --futaba-bg: #ffffee;
  --canvas-default-size: 400px;
  --border-color: #ccc;
  --tool-button-size: 36px;
  --popup-panel-bg: #ffffff;
  --popup-shadow: rgba(0, 0, 0, 0.15);
}

/* キャンバスコンテナ統合クラス */
.canvas-container {
  width: var(--canvas-default-size);
  height: var(--canvas-default-size);
  margin: 0 auto;
  display: block;
  background-color: var(--futaba-bg);
  border: 1px solid var(--border-color);
  position: relative;
}

/* 動的サイズ変更対応 */
.canvas-container.resizing {
  transition: width 0.3s ease, height 0.3s ease;
}

/* ツールボタン共通クラス */
.tool-button {
  width: var(--tool-button-size);
  height: var(--tool-button-size);
  border-radius: 4px;
  /* 既存スタイルを継承 */
}

/* ふたば☆ちゃんねる風色彩クラス */
.futaba-maroon-bg {
  background-color: var(--futaba-maroon);
}

.futaba-bg {
  background-color: var(--futaba-bg);
}

/* レスポンシブ対応（将来拡張） */
@media (max-width: 768px) {
  .canvas-container {
    width: min(var(--canvas-default-size), 90vw);
    height: min(var(--canvas-default-size), 90vw);
  }
}
```

### REV.3.2: index.html簡素化実装

**📁 修正対象ファイル**: `index.html`

**🔧 簡素化内容**:
```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎨 ふたば☆ちゃんねる風ベクターお絵描きツール v1.0 - REV系</title>
    
    <!-- 🔧 REV.3: CSS統合版 -->
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- ========================================= -->
    <!-- 🎨 メインUI - ふたば☆ちゃんねる風デザイン -->
    <!-- ========================================= -->
    
    <div class="main-layout">
        <div class="sidebar">
            <!-- ツールボタン群 - インラインスタイル削除済み -->
            <div class="tool-button disabled" id="download-tool" title="ダウンロード">
                <!-- SVGアイコン内容は変更なし -->
            </div>
            
            <!-- ... 他のツールボタンも同様にインラインスタイル削除 ... -->
            
        </div>
        
        <div class="canvas-area">
            <!-- 🔧 REV.3: キャンバスコンテナ - 信頼性強化版 -->
            <div id="canvas-container" class="canvas-container">
                <!-- CanvasManagerがPixiJS Applicationをここに配置 -->
            </div>
        </div>
    </div>
    
    <!-- ポップアップパネル群 - インラインスタイル削除済み -->
    <!-- ... 既存パネル内容は保持、スタイルのみクラス化 ... -->
    
    <!-- ステータスパネル - インラインスタイル削除済み -->
    <!-- ... 既存ステータス内容は保持 ... -->

    <!-- ========================================= -->
    <!-- 🔧 REV系 スクリプト読み込み - Bootstrap統合版 -->
    <!-- ========================================= -->
    
    <!-- PixiJS v7 本体 -->
    <script src="./node_modules/pixi.js/dist/pixi.min.js"></script>
    
    <!-- PIXI確実性確保 -->
    <script>
        if (!window.PIXI) {
            console.error('❌ PIXI読み込み失敗 - CDNフォールバック実行');
            document.write('<script src="https://unpkg.com/pixi.js@7/dist/pixi.min.js"><\/script>');
        } else {
            console.log('✅ PIXI読み込み成功');
        }
    </script>
    
    <!-- 依存関係ポリフィル -->
    <script>
        // typedSignals ポリフィル（既存）
        if (typeof window.typedSignals === 'undefined') {
            window.typedSignals = {
                Signal: class {
                    constructor() { this.listeners = []; }
                    connect(listener) { this.listeners.push(listener); }
                    emit(...args) { this.listeners.forEach(listener => listener(...args)); }
                    disconnect(listener) { 
                        const index = this.listeners.indexOf(listener);
                        if (index > -1) this.listeners.splice(index, 1);
                    }
                    disconnectAll() { this.listeners = []; }
                }
            };
        }
    </script>
    
    <!-- 追加ライブラリ（既存） -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    
    <!-- ========================================= -->
    <!-- 🚀 REV系 Bootstrap - 依存関係統合管理 -->
    <!-- ========================================= -->
    
    <script src="js/bootstrap.js"></script>
    
    <!-- ========================================= -->
    <!-- 🔧 REV系 起動完了通知 -->
    <!-- ========================================= -->
    
    <script>
        console.log('🎉 Tegaki REV系 Bootstrap 読み込み完了');
        console.log('🚀 依存関係解決後にmain.js初期化が自動実行されます');
    </script>
</body>
</html>
```

---

## 🚀 REV.4: main.js 初期化強化

### REV.4.1: キャンバス表示問題の根本解決

**📁 修正対象ファイル**: `js/main.js`

**🔧 main.js強化ポイント**:
1. **DOM要素確実性の保証**: `#canvas-container`の存在確認と信頼性確保
2. **CanvasManager初期化引数の修正**: `canvasElement`確実渡し
3. **Bootstrap依存関係完了待機**: 依存関係完了後の確実な初期化実行

**🔧 main.js修正実装**:
```javascript
/**
 * 🎨 Tegaki Project - Main Application Entry Point (REV系・キャンバス表示問題解決版)
 * 🔧 REV系追加修正:
 * 1. Bootstrap依存関係完了待機システム
 * 2. キャンバスコンテナDOM確実性保証
 * 3. CanvasManager初期化引数修正
 * 4. エラー処理完全委譲システム
 */

// Tegaki名前空間初期化（既存）
window.Tegaki = window.Tegaki || {};

class TegakiApplication {
    constructor() {
        this.initialized = false;
        this.appCore = null;
        this.initializationError = null;
        
        // REV系: Bootstrap依存関係待機フラグ
        this.dependenciesLoaded = false;
        this.canvasElementReady = false;
        
        // 基本設定（既存）
        this.config = {
            canvas: {
                width: 400,
                height: 400,
                backgroundColor: '#ffffee',
                antialias: true
            },
            drawing: {
                defaultTool: 'pen'
            }
        };
        
        console.log('🎨 TegakiApplication インスタンス作成完了');
        
        // REV系: Bootstrap依存関係完了待機
        this.setupBootstrapListeners();
    }

    /**
     * REV系: Bootstrap依存関係完了待機システム
     */
    setupBootstrapListeners() {
        window.addEventListener('tegaki:dependencies:loaded', () => {
            console.log('📦 Bootstrap依存関係読み込み完了');
            this.dependenciesLoaded = true;
            this.tryInitialize();
        });

        window.addEventListener('tegaki:dependencies:error', (event) => {
            console.error('❌ Bootstrap依存関係エラー:', event.detail.error);
            this.initializationError = new Error(`Dependencies: ${event.detail.error}`);
            
            if (window.Tegaki?.ErrorManagerInstance) {
                window.Tegaki.ErrorManagerInstance.showError('error', 
                    `依存関係読み込みエラー: ${event.detail.error}`, {
                    context: 'Bootstrap Dependencies',
                    showReload: true
                });
            }
        });
    }

    /**
     * REV系: キャンバスコンテナ確実性チェック
     */
    checkCanvasContainerReady() {
        const container = document.getElementById('canvas-container');
        
        if (!container) {
            console.error('❌ #canvas-container が見つかりません');
            return false;
        }
        
        // DOM要素の基本プロパティ確認
        if (!container.offsetWidth || !container.offsetHeight) {
            console.warn('⚠️ キャンバスコンテナのサイズが0です');
            return false;
        }
        
        console.log(`✅ キャンバスコンテナ確認: ${container.offsetWidth}x${container.offsetHeight}px`);
        this.canvasElementReady = true;
        return true;
    }

    /**
     * REV系: 初期化条件確認・実行システム
     */
    async tryInitialize() {
        if (this.initialized) return;
        
        console.log('🔍 初期化条件確認中...');
        console.log(`  - 依存関係: ${this.dependenciesLoaded}`);
        console.log(`  - DOM準備: ${document.readyState}`);
        console.log(`  - キャンバス要素: ${this.checkCanvasContainerReady()}`);
        
        if (this.dependenciesLoaded && 
            document.readyState === 'complete' && 
            this.canvasElementReady) {
            
            console.log('✅ 全初期化条件満足 - 初期化開始');
            await this.initialize();
        } else {
            console.log('⏳ 初期化条件未満足 - 待機継続');
        }
    }

    /**
     * アプリケーション初期化（REV系・委譲専門版）
     */
    async initialize() {
        try {
            console.log('🎨 Tegaki REV系 初期化開始...');

            if (this.initialized) {
                console.warn('⚠️ TegakiApplication already initialized');
                return true;
            }

            // STEP 1: 初期化レジストリ実行
            this.executeInitializationRegistry();
            
            // STEP 2: AppCore初期化委譲
            await this.initializeAppCore();
            
            // STEP 3: 基本状態設定
            this.initialized = true;
            console.log('✅ Tegaki REV系 初期化完了');
            
            // 初期化完了イベント発火（ErrorManager経由での通知）
            if (window.Tegaki?.EventBusInstance) {
                window.Tegaki.EventBusInstance.safeEmit('app:initialized');
            }
            
            // 成功通知（ErrorManager委譲）
            if (window.Tegaki?.ErrorManagerInstance) {
                window.Tegaki.ErrorManagerInstance.showInfo('Tegakiアプリケーション起動完了', {
                    duration: 3000,
                    autoClose: true
                });
            }
            
            return true;
            
        } catch (error) {
            console.error('❌ Tegaki初期化エラー:', error);
            this.initializationError = error;
            
            // エラー表示（ErrorManager委譲）
            if (window.Tegaki?.ErrorManagerInstance) {
                window.Tegaki.ErrorManagerInstance.showError('error', `初期化エラー: ${error.message}`, {
                    context: 'TegakiApplication.initialize',
                    showReload: true
                });
            }
            
            return false;
        }
    }

    /**
     * STEP 1: 初期化レジストリ実行
     */
    executeInitializationRegistry() {
        console.log('📡 初期化レジストリ実行中...');
        
        if (window.Tegaki?._registry) {
            console.log(`🔧 ${window.Tegaki._registry.length}個の初期化処理を実行`);
            
            window.Tegaki._registry.forEach((initFunc, index) => {
                try {
                    initFunc();
                    console.log(`✅ Registry[${index}] 初期化完了`);
                } catch (error) {
                    console.error(`❌ Registry[${index}] 初期化エラー:`, error);
                    // レジストリエラーは継続（致命的ではない）
                }
            });
            
            // レジストリを削除（一度だけ実行）
            delete window.Tegaki._registry;
            console.log('🗑️ 初期化レジストリ削除完了');
        }
        
        // 根幹Manager確認
        const coreManagers = [
            'ErrorManagerInstance',
            'ConfigManagerInstance', 
            'StateManagerInstance',
            'EventBusInstance'
        ];
        
        const availableManagers = coreManagers.filter(manager => window.Tegaki?.[manager]);
        console.log(`✅ 根幹Manager確認: ${availableManagers.length}/${coreManagers.length}個利用可能`);
        
        if (availableManagers.length < coreManagers.length) {
            console.warn('⚠️ 一部根幹Manager未初期化 - 基本動作で継続');
        }
    }

    /**
     * REV系: AppCore初期化委譲（キャンバス表示問題修正版）
     */
    async initializeAppCore() {
        console.log('🎯 AppCore初期化中...');

        try {
            // REV系: キャンバスコンテナ確実取得
            const canvasContainer = document.getElementById('canvas-container');
            if (!canvasContainer) {
                throw new Error('キャンバスコンテナ#canvas-containerが見つかりません');
            }

            // AppCore取得または作成（既存）
            if (window.Tegaki?.AppCoreInstance) {
                this.appCore = window.Tegaki.AppCoreInstance;
            } else if (window.Tegaki?.AppCore) {
                this.appCore = new window.Tegaki.AppCore();
                window.Tegaki.AppCoreInstance = this.appCore;
            } else if (window.AppCore) {
                this.appCore = new window.AppCore();
                window.Tegaki.AppCoreInstance = this.appCore;
            } else {
                throw new Error('AppCoreが利用できません');
            }

            // REV系: CanvasManager初期化時の確実なDOM要素渡し
            if (this.appCore.canvasManager) {
                console.log('🔧 CanvasManager初期化（キャンバス表示問題修正版）');
                
                const initSuccess = await this.appCore.canvasManager.initialize({
                    appCore: this.appCore,
                    canvasElement: canvasContainer,  // 確実なDOM要素渡し
                    config: {
                        configManager: window.Tegaki.ConfigManagerInstance
                    }
                });
                
                if (!initSuccess) {
                    throw new Error('CanvasManager初期化失敗');
                }
                
                console.log('✅ CanvasManager初期化完了 - キャンバス表示確認');
                
                // キャンバス表示確認
                const canvas = canvasContainer.querySelector('canvas');
                if (canvas) {
                    console.log('🎨 キャンバス要素確認成功:', {
                        width: canvas.width,
                        height: canvas.height,
                        style: canvas.style.cssText
                    });
                } else {
                    console.warn('⚠️ キャンバス要素が見つかりませんが継続します');
                }
            }

            // AppCore初期化実行（既存）
            const success = await this.appCore.initialize();
            
            if (!success) {
                throw new Error('AppCore初期化がfalseを返しました');
            }
            
            console.log('✅ AppCore初期化完了');
            
        } catch (error) {
            console.error('❌ AppCore初期化エラー:', error);
            throw error; // 上位に再スロー
        }
    }

    /**
     * アプリケーション状態取得
     */
    getApplicationStatus() {
        return {
            version: 'Phase1.5-REV',
            initialized: this.initialized,
            dependenciesLoaded: this.dependenciesLoaded,
            canvasElementReady: this.canvasElementReady,
            appCore: this.appCore ? {
                initialized: this.appCore.initialized,
                managers: this.appCore.getManagerStatus ? this.appCore.getManagerStatus() : null
            } : null,
            initializationError: this.initializationError,
            lastCheck: new Date().toISOString()
        };
    }

    /**
     * 座標統合状態取得（診断用）
     */
    getCoordinateIntegrationState() {
        return {
            appInstance: !!this,
            appCore: !!this.appCore,
            appCoreInitialized: !!(this.appCore && this.appCore.initialized),
            coordinateManager: !!(this.appCore?.coordinateManager || window.Tegaki?.CoordinateManagerInstance),
            canvasManager: !!(this.appCore?.canvasManager || window.Tegaki?.CanvasManagerInstance),
            toolManager: !!(this.appCore?.toolManager || window.Tegaki?.ToolManagerInstance),
            pixiAvailable: !!window.PIXI,
            canvasPresent: !!document.querySelector('canvas'),
            initialized: this.initialized,
            initializationError: this.initializationError?.message || null
        };
    }

    /**
     * 健全性チェック
     */
    healthCheck() {
        try {
            const issues = [];
            const warnings = [];
            
            // 基本機能チェック
            if (!this.initialized) issues.push('Application not initialized');
            if (!window.PIXI) issues.push('PIXI.js not available');
            if (!document.querySelector('canvas')) issues.push('Canvas element not present');
            
            // AppCoreチェック
            if (!this.appCore) {
                issues.push('AppCore not available');
            } else if (!this.appCore.initialized) {
                warnings.push('AppCore not initialized');
            }
            
            return {
                healthy: issues.length === 0,
                functional: issues.length === 0 && warnings.length < 3,
                issues,
                warnings,
                score: Math.max(0, 100 - (issues.length * 30) - (warnings.length * 10))
            };
            
        } catch (error) {
            return {
                healthy: false,
                functional: false,
                issues: ['Health check failed'],
                warnings: [],
                error: error.message,
                score: 0
            };
        }
    }
}

// Tegaki名前空間にクラス登録
window.Tegaki.TegakiApplication = TegakiApplication;

/**
 * REV系: DOM完了待機＋Bootstrap連携初期化システム
 */
document.addEventListener("DOMContentLoaded", function() {
    console.log('📋 DOMContentLoaded - REV系初期化開始');
    
    // アプリケーション作成
    const app = new window.Tegaki.TegakiApplication();
    window.Tegaki.AppInstance = app;
    
    // REV系: window load完了待機
    window.addEventListener('load', () => {
        console.log('📋 Window Load完了');
        app.tryInitialize();
    });
});

/**
 * ページ離脱時のクリーンアップ（委譲専門）
 */
window.addEventListener('beforeunload', () => {
    if (window.Tegaki?.AppInstance?.initialized) {
        console.log('🧹 Tegakiクリーンアップ実行');
        
        try {
            // 設定保存委譲
            if (window.Tegaki?.ConfigManagerInstance?.save) {
                window.Tegaki.ConfigManagerInstance.save();
            }
            
            // AppCore破棄委譲
            if (window.Tegaki?.AppInstance?.appCore?.destroy) {
                window.Tegaki.AppInstance.appCore.destroy();
            }
        } catch (error) {
            console.warn('⚠️ クリーンアップエラー:', error);
        }
    }
});

/**
 * グローバルエラーハンドリング（ErrorManager完全委譲版）
 */
window.addEventListener('error', (event) => {
    if (window.Tegaki?.ErrorManagerInstance) {
        window.Tegaki.ErrorManagerInstance.showError('error', 
            `グローバルエラー: ${event.error?.message || event.message}`, {
            context: 'Global Error Handler',
            nonCritical: true
        });
    } else {
        console.error('🆘 Global Error (ErrorManager unavailable):', event.error || event.message);
    }
});

window.addEventListener('unhandledrejection', (event) => {
    if (window.Tegaki?.ErrorManagerInstance) {
        window.Tegaki.ErrorManagerInstance.showError('error', 
            `未処理Promise: ${event.reason?.message || event.reason}`, {
            context: 'Unhandled Promise Rejection',
            nonCritical: true
        });
    } else {
        console.error('🆘 Unhandled Promise (ErrorManager unavailable):', event.reason);
    }
});

console.log('🎨 Tegaki Main (REV系・責任分界・キャンバス表示問題修正版) Loaded');
```

---

## 🚀 REV.5: 動作確認とテスト

### REV.5.1: キャンバス表示確認手順
```javascript
// ブラウザコンソールでの確認手順
console.log('🔍 REV系動作確認開始');

// 1. DOM要素確認
const container = document.getElementById('canvas-container');
console.log('Canvas Container:', container);
console.log('Container Size:', container ? `${container.offsetWidth}x${container.offsetHeight}` : 'Not found');

// 2. Canvas要素確認
const canvas = container?.querySelector('canvas');
console.log('Canvas Element:', canvas);
console.log('Canvas Size:', canvas ? `${canvas.width}x${canvas.height}` : 'Not found');

// 3. CanvasManager状態確認
const cm = window.Tegaki?.CanvasManagerInstance;
console.log('CanvasManager:', cm);
console.log('CanvasManager Initialized:', cm?.initialized);

// 4. アプリ全体状態確認
window.checkTegakiHealth();
```

### REV.5.2: 座標システム動作確認
```javascript
// 座標統合確認
window.checkCoordinateIntegration();

// CanvasManager診断
if (window.Tegaki?.CanvasManagerInstance?.getDiagnosticInfo) {
    console.log('📊 CanvasManager診断:', 
        window.Tegaki.CanvasManagerInstance.getDiagnosticInfo());
}
```

---

## 🚀 REV.6: 品質保証と最終確認

### REV.6.1: 責任分界確認チェックリスト
```markdown
✅ 責任分界確認:
□ index.html: 構造定義のみ（スクリプト・スタイル・初期化処理なし）
□ bootstrap.js: 依存関係管理のみ（UI・エラー・初期化処理なし）
□ main.js: 初期化・統合のみ（UI・直接描画・座標処理なし）
□ styles.css: スタイル統合のみ（JavaScript・初期化処理なし）

✅ キャンバス表示確認:
□ #canvas-container要素の確実な存在
□ CSSクラス適用による適切なスタイル
□ CanvasManager初期化時のDOM要素確実渡し
□ Pixi.Application.view の適切な配置

✅ 統一システム活用確認:
□ ErrorManager経由でのエラー処理
□ EventBus経由でのイベント通信
□ ConfigManager経由での設定管理
□ StateManager経由での状態管理
```

### REV.6.2: パフォーマンス・安定性確認
```javascript
// REV系パフォーマンス確認スクリプト
function checkREVPerformance() {
    console.log('🔍 REV系パフォーマンス確認開始');
    
    const startTime = performance.now();
    
    // 依存関係読み込み時間確認
    const bootTime = window.Tegaki?.AppInstance?.bootTime || 'Unknown';
    console.log(`⏱️ Bootstrap時間: ${bootTime}ms`);
    
    // キャンバス初期化時間確認
    const canvasManager = window.Tegaki?.CanvasManagerInstance;
    if (canvasManager?.initializeTime) {
        console.log(`🎨 CanvasManager初期化時間: ${canvasManager.initializeTime}ms`);
    }
    
    // メモリ使用量確認
    if (performance.memory) {
        console.log('💾 メモリ使用量:', {
            used: `${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1)}MB`,
            total: `${(performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(1)}MB`,
            limit: `${(performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(1)}MB`
        });
    }
    
    // 総合確認時間
    const checkTime = performance.now() - startTime;
    console.log(`✅ 確認完了時間: ${checkTime.toFixed(2)}ms`);
    
    return {
        bootTime,
        canvasManager: !!canvasManager?.initialized,
        memoryHealthy: performance.memory ? 
            (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) < 0.7 : true,
        checkTime
    };
}
```

---

## 🎯 REV.7: 完成版ファイル構成

### REV.7.1: 新規作成ファイル
```markdown
📁 js/bootstrap.js (新規作成)
├── 依存関係順序管理
├── 読み込み進捗確認
└── main.js初期化トリガー
```

### REV.7.2: 修正対象ファイル
```markdown
📁 index.html (大幅簡素化)
├── インラインスタイル削除
├── スクリプト管理をbootstrap.jsに委譲
└── 構造定義に専念

📁 css/styles.css (拡張)
├── CSS変数追加
├── インラインスタイルの統合
└── レスポンシブ対応準備

📁 js/main.js (キャンバス表示問題修正)
├── Bootstrap依存関係待機システム
├── DOM要素確実性保証
└── CanvasManager初期化引数修正
```

---

## 🏆 REV.8: 成功指標と検証基準

### REV.8.1: 成功指標
```markdown
🎯 キャンバス表示問題解決:
✅ 100%の確率でキャンバス表示
✅ CanvasManager初期化成功率100%
✅ 座標変換システム正常動作
✅ 描画処理エラー0件

🎯 責任分界最適化:
✅ index.html行数50%削減
✅ インラインスタイル100%削除
✅ 依存関係管理の一元化
✅ 保守工数30%削減

🎯 システム安定性向上:
✅ 初期化エラー率50%削減
✅ メモリリーク0件
✅ パフォーマンス劣化0%
✅ 拡張性確保100%
```

### REV.8.2: Phase2移行準備度確認
```javascript
// Phase2移行準備度チェック
function checkPhase2Readiness() {
    console.log('🔍 Phase2移行準備度確認');
    
    const checkList = {
        // 基盤システム
        unifiedSystems: !!(
            window.Tegaki?.ConfigManagerInstance && 
            window.Tegaki?.ErrorManagerInstance && 
            window.Tegaki?.StateManagerInstance && 
            window.Tegaki?.EventBusInstance
        ),
        
        // キャンバス・描画システム
        canvasSystem: !!(
            window.Tegaki?.CanvasManagerInstance?.initialized &&
            document.querySelector('canvas')
        ),
        
        // ツール・座標システム
        toolSystem: !!(
            window.Tegaki?.ToolManagerInstance &&
            window.Tegaki?.CoordinateManagerInstance
        ),
        
        // 責任分界
        responsibilitySeparation: {
            htmlStructureOnly: !document.querySelector('style[data-inline]'),
            cssConsolidated: !!document.querySelector('link[href*="styles.css"]'),
            bootstrapDelegation: !!window.Tegaki?.AppInstance?.dependenciesLoaded,
            mainInitialization: !!window.Tegaki?.AppInstance?.initialized
        }
    };
    
    const score = Object.values(checkList).reduce((acc, val) => {
        if (typeof val === 'boolean') return acc + (val ? 25 : 0);
        if (typeof val === 'object') {
            const subScore = Object.values(val).filter(v => v === true).length;
            return acc + (subScore * 6.25);
        }
        return acc;
    }, 0);
    
    console.log('📊 Phase2移行準備度:', `${score.toFixed(1)}%`);
    console.log('📋 詳細:', checkList);
    
    if (score >= 95) {
        console.log('✅ Phase2移行準備完了');
    } else if (score >= 80) {
        console.log('⚠️ Phase2移行準備概ね完了（軽微な課題あり）');
    } else {
        console.log('❌ Phase2移行準備未完了（重要な課題あり）');
    }
    
    return { score, checkList };
}
```

---

## 🛠️ REV.9: 実装時の注意事項

### REV.9.1: 絶対遵守事項
```markdown
🚫 絶対禁止:
❌ 応急処置的なフォールバック構造での肥大化
❌ エラー処理の個別実装（ErrorManager経由必須）
❌ 責務範囲を越えた直接メソッド呼び出し
❌ 座標変換の重複実装

✅ 必須遵守:
✅ シンボル辞典定義への厳密準拠
✅ ルールブックの責務分離原則遵守
✅ 統一システム（4基盤）経由でのアクセス
✅ ES2023モダン構文の積極使用
```

### REV.9.2: デバッグ・トラブルシューティング
```javascript
// REV系統合デバッグ関数
window.debugREVSystem = function() {
    console.log('🔧 REV系統合デバッグ開始');
    
    // 1. Bootstrap状態確認
    console.log('1️⃣ Bootstrap状態:');
    console.log('  - 依存関係完了:', !!window.Tegaki?.AppInstance?.dependenciesLoaded);
    console.log('  - DOM準備完了:', document.readyState);
    console.log('  - キャンバス要素:', !!document.getElementById('canvas-container'));
    
    // 2. 初期化状態確認
    console.log('2️⃣ 初期化状態:');
    console.log('  - アプリ初期化:', !!window.Tegaki?.AppInstance?.initialized);
    console.log('  - AppCore初期化:', !!window.Tegaki?.AppCoreInstance?.initialized);
    console.log('  - CanvasManager:', !!window.Tegaki?.CanvasManagerInstance?.initialized);
    
    // 3. キャンバス表示確認
    console.log('3️⃣ キャンバス表示:');
    const container = document.getElementById('canvas-container');
    const canvas = container?.querySelector('canvas');
    console.log('  - コンテナサイズ:', container ? `${container.offsetWidth}x${container.offsetHeight}` : 'なし');
    console.log('  - キャンバス要素:', !!canvas);
    console.log('  - キャンバスサイズ:', canvas ? `${canvas.width}x${canvas.height}` : 'なし');
    
    // 4. 統一システム確認
    console.log('4️⃣ 統一システム:');
    const systems = ['ConfigManagerInstance', 'ErrorManagerInstance', 'StateManagerInstance', 'EventBusInstance'];
    systems.forEach(system => {
        console.log(`  - ${system}:`, !!window.Tegaki?.[system]);
    });
    
    // 5. 問題診断
    const issues = [];
    if (!window.Tegaki?.AppInstance?.dependenciesLoaded) issues.push('依存関係未完了');
    if (!document.getElementById('canvas-container')) issues.push('キャンバスコンテナなし');
    if (!canvas) issues.push('キャンバス要素なし');
    if (!window.Tegaki?.CanvasManagerInstance?.initialized) issues.push('CanvasManager未初期化');
    
    console.log('5️⃣ 問題診断:', issues.length > 0 ? issues : '問題なし');
    
    return {
        healthy: issues.length === 0,
        issues,
        canvasVisible: !!canvas,
        systemReady: !!window.Tegaki?.AppInstance?.initialized
    };
};
```

---

## 🎉 REV.10: 完了確認とPhase2移行準備

### REV.10.1: 完了確認手順
```markdown
1. 🔧 ファイル実装確認
   □ js/bootstrap.js 作成完了
   □ index.html 簡素化完了  
   □ css/styles.css 統合完了
   □ js/main.js 修正完了

2. 🎨 キャンバス表示確認
   □ ブラウザでindex.html開く
   □ キャンバスが確実に表示される
   □ console.log でエラーなし
   □ window.debugREVSystem() で問題なし

3. 🏗️ 責任分界確認
   □ index.html: 構造のみ
   □ bootstrap.js: 依存管理のみ
   □ main.js: 初期化のみ
   □ styles.css: スタイルのみ

4. 🔍 品質確認
   □ window.checkTegakiHealth() 良好
   □ window.checkCoordinateIntegration() 良好
   □ window.checkPhase2Readiness() 95%以上
```

### REV.10.2: Phase2移行準備完了宣言
```markdown
✅ Phase1.5 REV系改修完了条件:
□ キャンバス表示問題解決（100%表示保証）
□ 責任分界明確化（HTML/Bootstrap/Main/CSS分離）
□ 統一システム活用100%（4基盤システム経由）
□ 保守性向上（依存関係・スタイル一元管理）
□ 拡張性確保（Phase2対応基盤完成）

🎯 Phase2移行可能状態:
✅ 根幹システム安定動作
✅ AbstractTool継承準備完了
✅ レイヤーシステム基盤準備
✅ 責務分離徹底遵守
✅ AI協働開発効率化基盤完成
```

---

## 📋 最終チェックリスト

### 🏆 REV系改修成功の必要十分条件
```markdown
🎨 キャンバス表示問題解決:
✅ #canvas-container DOM要素確実存在
✅ CanvasManager.initialize() 確実成功
✅ Pixi.Application.view 適切配置
✅ 座標変換システム正常動作

🏗️ 責任分界明確化:
✅ index.html: 構造定義専念
✅ bootstrap.js: 依存関係管理専念
✅ main.js: 初期化統合専念
✅ styles.css: スタイル管理専念

🔧 品質・安定性向上:
✅ 統一システム100%活用
✅ エラー処理ErrorManager委譲
✅ 重複コード0件
✅ メモリリーク0件

🚀 Phase2移行準備完了:
✅ AbstractTool継承基盤
✅ レイヤーシステム対応
✅ PixiJS v8対応準備
✅ AI協働開発効率化
```

この手順書に従って実装することで、キャンバス表示問題を根本解決しつつ、責任分界を明確化し、Phase2移行への強固な基盤を構築できます。