
## ğŸš€ Phase4: PixiJS v8ç§»è¡Œï¼ˆæ¬¡ä¸–ä»£ç‰ˆï¼‰

### Phase4.1: v8ç§»è¡Œæº–å‚™ãƒ»äº’æ›æ€§ãƒ¬ã‚¤ãƒ¤ãƒ¼å®Ÿè£…
**æœŸé–“**: 2é€±é–“ãƒ»ç›®æ¨™: v8ç§»è¡ŒåŸºç›¤å®Œæˆãƒ»ç ´å£Šçš„å¤‰æ›´å¯¾å¿œ

#### v8äº’æ›æ€§ãƒ¬ã‚¤ãƒ¤ãƒ¼å®Ÿè£…
```javascript
// js/migration/v8-compatibility.jsï¼ˆ300è¡Œä»¥ä¸‹ï¼‰
/**
 * ğŸ¯ AI_WORK_SCOPE: PixiJS v8ç§»è¡Œå¯¾å¿œãƒ»APIå¤‰æ›´å¸åãƒ»äº’æ›æ€§ç¢ºä¿
 * ğŸ¯ DEPENDENCIES: libs/pixi-extensions.js, js/app-core.js
 * ğŸ¯ NODE_MODULES: pixi.js v8ï¼ˆç§»è¡Œå¾Œï¼‰
 * ğŸ“‹ PHASE_TARGET: Phase4
 * ğŸ“‹ V8_MIGRATION: æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ãŒç§»è¡Œã®ä¸­æ ¸
 */
class V8CompatibilityLayer {
    constructor() {
        this.pixiVersion = PIXI.VERSION;
        this.isV8 = this.pixiVersion.startsWith('8');
        this.migrationLog = [];
    }
    
    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆï¼ˆv7/v8å¯¾å¿œï¼‰
    static async createApplication(options) {
        const compatibility = new V8CompatibilityLayer();
        
        if (compatibility.isV8) {
            // v8: æ–°ã—ã„åˆæœŸåŒ–æ–¹å¼
            console.log('ğŸš€ PixiJS v8ãƒ¢ãƒ¼ãƒ‰ã§ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ');
            
            const app = new PIXI.Application();
            await app.init({
                width: options.width,
                height: options.height,
                background: options.backgroundColor ? 
                    `#${options.backgroundColor.toString(16).padStart(6, '0')}` : 
                    '#f0e0d6',
                antialias: options.antialias,
                preference: options.webgpu ? 'webgpu' : 'webgl'
            });
            
            compatibility.logMigration('Application', 'v8æ–°æ–¹å¼ä½¿ç”¨');
            return app;
            
        } else {
            // v7: å¾“æ¥ã®åˆæœŸåŒ–æ–¹å¼
            console.log('ğŸ“¦ PixiJS v7äº’æ›ãƒ¢ãƒ¼ãƒ‰ã§ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ');
            
            const app = new PIXI.Application({
                width: options.width,
                height: options.height,
                backgroundColor: options.backgroundColor,
                antialias: options.antialias
            });
            
            compatibility.logMigration('Application', 'v7äº’æ›æ–¹å¼ä½¿ç”¨');
            return app;
        }
    }
    
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ä½œæˆï¼ˆv7/v8å¯¾å¿œï¼‰
    static createTexture(source) {
        const compatibility = new V8CompatibilityLayer();
        
        if (compatibility.isV8) {
            // v8: Assets.load æ¨å¥¨
            if (typeof source === 'string') {
                return PIXI.Assets.load(source);
            } else {
                return PIXI.Texture.from(source);
            }
        } else {
            // v7: å¾“æ¥ã®Texture.from
            return PIXI.Texture.from(source);
        }
    }
    
    // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®šï¼ˆv7/v8å¯¾å¿œï¼‰
    setupRenderer(app, options = {}) {
        if (this.isV8) {
            // v8: WebGPU Rendererå¯¾å¿œ
            this.setupV8Renderer(app, options);
        } else {
            // v7: WebGL Renderer
            this.setupV7Renderer(app, options);
        }
    }
    
    setupV8Renderer(app, options) {
        console.log('ğŸ® v8 Rendererè¨­å®šé–‹å§‹');
        
        // WebGPUå„ªå…ˆè¨­å®š
        if (options.preferWebGPU && navigator.gpu) {
            console.log('âœ¨ WebGPU Rendererä½¿ç”¨');
            app.renderer.context.preferredFormat = 'bgra8unorm';
            
            // 120FPSè¨­å®š
            app.ticker.maxFPS = options.targetFPS || 120;
            app.ticker.minFPS = 60; // æœ€ä½å“è³ªä¿è¨¼
            
            this.logMigration('Renderer', 'WebGPUè¨­å®šå®Œäº†');
        } else {
            console.log('ğŸ”§ WebGL2 Rendererä½¿ç”¨');
            app.ticker.maxFPS = 60;
            this.logMigration('Renderer', 'WebGL2ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
        }
        
        // ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–è¨­å®š
        if (app.renderer.context) {
            app.renderer.context.powerPreference = 'high-performance';
        }
    }
    
    setupV7Renderer(app, options) {
        console.log('ğŸ“¦ v7 Rendererè¨­å®š');
        
        // å¾“æ¥ã®è¨­å®š
        app.ticker.maxFPS = 60;
        
        // WebGLè¨­å®š
        if (app.renderer.gl) {
            app.renderer.gl.getExtension('OES_texture_float');
            app.renderer.gl.getExtension('WEBGL_color_buffer_float');
        }
        
        this.logMigration('Renderer', 'v7è¨­å®šå®Œäº†');
    }
    
    // Graphics APIå¤‰æ›´å¯¾å¿œ
    static createGraphics() {
        const compatibility = new V8CompatibilityLayer();
        
        if (compatibility.isV8) {
            // v8: æ–°Graphics API
            const graphics = new PIXI.Graphics();
            
            // v8ã§ã¯ä¸€éƒ¨ãƒ¡ã‚½ãƒƒãƒ‰åå¤‰æ›´ã®å¯èƒ½æ€§
            graphics.beginPath = graphics.beginPath || function() {
                // v8å¯¾å¿œãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                return this;
            };
            
            return graphics;
        } else {
            // v7: å¾“æ¥Graphics
            return new PIXI.Graphics();
        }
    }
    
    // ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿çµ±ä¸€ï¼ˆv7/v8å¯¾å¿œï¼‰
    static async loadAssets(assets) {
        const compatibility = new V8CompatibilityLayer();
        
        if (compatibility.isV8) {
            // v8: Assets APIä½¿ç”¨
            console.log('ğŸ“¦ v8 Assets APIä½¿ç”¨');
            
            if (Array.isArray(assets)) {
                return await PIXI.Assets.load(assets);
            } else {
                return await PIXI.Assets.load([assets]);
            }
        } else {
            // v7: Loaderä½¿ç”¨
            console.log('ğŸ“¦ v7 Loaderä½¿ç”¨');
            
            return new Promise((resolve, reject) => {
                const loader = new PIXI.Loader();
                
                if (Array.isArray(assets)) {
                    assets.forEach(asset => loader.add(asset));
                } else {
                    loader.add(assets);
                }
                
                loader.load((loader, resources) => {
                    resolve(resources);
                });
                
                loader.onError.add(reject);
            });
        }
    }
    
    logMigration(component, action) {
        const logEntry = {
            timestamp: Date.now(),
            component: component,
            action: action,
            version: this.pixiVersion
        };
        
        this.migrationLog.push(logEntry);
        console.log(`ğŸ“ Migration: ${component} - ${action}`);
    }
    
    getMigrationReport() {
        return {
            pixiVersion: this.pixiVersion,
            isV8: this.isV8,
            migrationCount: this.migrationLog.length,
            log: this.migrationLog,
            summary: this.generateMigrationSummary()
        };
    }
    
    generateMigrationSummary() {
        const components = {};
        
        this.migrationLog.forEach(entry => {
            if (!components[entry.component]) {
                components[entry.component] = [];
            }
            components[entry.component].push(entry.action);
        });
        
        return components;
    }
}
```

### Phase4.2: WebGPUãƒ»120FPSå®Ÿè£…
**æœŸé–“**: 3é€±é–“ãƒ»ç›®æ¨™: GPUæ´»ç”¨ãƒ»é«˜é€Ÿæç”»ãƒ»æ€§èƒ½æœ€é©åŒ–

#### WebGPUæç”»æœ€é©åŒ–
```javascript
// js/migration/webgpu-optimizer.jsï¼ˆ400è¡Œä»¥ä¸‹ï¼‰
/**
 * ğŸ¯ AI_WORK_SCOPE: WebGPUæœ€é©åŒ–ãƒ»120FPSæç”»ãƒ»GPUæ´»ç”¨
 * ğŸ¯ DEPENDENCIES: js/migration/v8-compatibility.js
 * ğŸ¯ NODE_MODULES: pixi.js v8ï¼ˆWebGPUå¯¾å¿œï¼‰
 * ğŸ“‹ PHASE_TARGET: Phase4
 * ğŸ“‹ PERFORMANCE_TARGET: 120FPSå®‰å®šãƒ»GPUä½¿ç”¨ç‡æœ€é©åŒ–
 */
class WebGPUDrawingOptimizer {
    constructor(app) {
        this.app = app;
        this.isWebGPUAvailable = this.checkWebGPUSupport();
        this.performanceStats = {
            fps: [],
            gpuUsage: [],
            memoryUsage: []
        };
        
        this.init();
    }
    
    checkWebGPUSupport() {
        const hasWebGPU = 'gpu' in navigator;
        const hasRenderer = this.app.renderer.type === PIXI.RENDERER_TYPE.WEBGPU;
        
        console.log(`ğŸ® WebGPUå¯¾å¿œçŠ¶æ³: ${hasWebGPU ? 'âœ…' : 'âŒ'}`);
        console.log(`ğŸ”§ WebGPU Renderer: ${hasRenderer ? 'âœ…' : 'âŒ'}`);
        
        return hasWebGPU && hasRenderer;
    }
    
    async init() {
        if (!this.isWebGPUAvailable) {
            console.log('ğŸ“¦ WebGLãƒ¢ãƒ¼ãƒ‰ã§å‹•ä½œ');
            this.setupWebGLOptimization();
            return;
        }
        
        console.log('ğŸš€ WebGPUæœ€é©åŒ–é–‹å§‹');
        
        // WebGPU Compute Shaderè¨­å®š
        await this.setupComputeShaders();
        
        // æç”»ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æœ€é©åŒ–
        this.optimizeRenderPipeline();
        
        // ãƒ¡ãƒ¢ãƒªç®¡ç†æœ€é©åŒ–
        this.setupMemoryManagement();
        
        // 120FPSè¨­å®š
        this.enable120FPS();
        
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–é–‹å§‹
        this.startPerformanceMonitoring();
    }
    
    async setupComputeShaders() {
        try {
            const device = this.app.renderer.context.device;
            
            // æç”»æœ€é©åŒ–Compute Shader
            const shaderCode = `
                @group(0) @binding(0) var<storage, read_write> positions: array<vec2<f32>>;
                @group(0) @binding(1) var<uniform> transform: mat3x3<f32>;
                
                @compute @workgroup_size(64)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let index = global_id.x;
                    if (index >= arrayLength(&positions)) {
                        return;
                    }
                    
                    let pos = positions[index];
                    let transformed = transform * vec3<f32>(pos.x, pos.y, 1.0);
                    positions[index] = transformed.xy;
                }
            `;
            
            this.computeShader = device.createShaderModule({
                label: 'Drawing Optimization Compute Shader',
                code: shaderCode
            });
            
            console.log('âœ¨ Compute Shaderè¨­å®šå®Œäº†');
            
        } catch (error) {
            console.warn('âš ï¸ Compute Shaderè¨­å®šå¤±æ•—:', error);
        }
    }
    
    optimizeRenderPipeline() {
        // ãƒãƒƒãƒæç”»æœ€é©åŒ–
        this.app.renderer.batch.setMaxBatchSize(16384); // å¤§ããªãƒãƒƒãƒã‚µã‚¤ã‚º
        
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£æœ€é©åŒ–
        PIXI.settings.ROUND_PIXELS = true;
        PIXI.settings.RESOLUTION = window.devicePixelRatio;
        
        // GPU Bufferæœ€é©åŒ–
        if (this.isWebGPUAvailable) {
            const context = this.app.renderer.context;
            
            // é«˜æ€§èƒ½è¨­å®š
            context.device.queue.writeBuffer = context.device.queue.writeBuffer.bind(
                context.device.queue
            );
            
            console.log('ğŸ”§ WebGPU Render Pipelineæœ€é©åŒ–å®Œäº†');
        }
    }
    
    setupMemoryManagement() {
        // GPU ãƒ¡ãƒ¢ãƒªç®¡ç†
        const memorySettings = {
            maxGPUMemory: 1024 * 1024 * 1024, // 1GB
            textureCache: 512 * 1024 * 1024,   // 512MB
            bufferCache: 256 * 1024 * 1024     // 256MB
        };
        
        // å®šæœŸçš„ãªãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        setInterval(() => {
            this.cleanupGPUMemory();
        }, 30000); // 30ç§’ã”ã¨
        
        console.log('ğŸ§¹ GPU ãƒ¡ãƒ¢ãƒªç®¡ç†è¨­å®šå®Œäº†');
    }
    
    enable120FPS() {
        // 120FPSè¨­å®š
        this.app.ticker.maxFPS = 120;
        this.app.ticker.minFPS = 60; // æœ€ä½å“è³ªä¿è¨¼
        
        // VSyncåˆ¶å¾¡ï¼ˆå¿…è¦æ™‚ï¼‰
        if (this.isWebGPUAvailable) {
            this.setupVSyncControl();
        }
        
        // Chrome Scheduling APIæ´»ç”¨
        if ('scheduler' in window) {
            this.enableHighPriorityRendering();
        }
        
        console.log('ğŸš€ 120FPSè¨­å®šå®Œäº†');
    }
    
    setupVSyncControl() {
        // WebGPU Present Modeè¨­å®š
        const context = this.app.renderer.context;
        
        if (context.canvas && context.canvas.getContext) {
            // 'immediate' ãƒ¢ãƒ¼ãƒ‰ã§ VSyncç„¡åŠ¹åŒ–ï¼ˆå¿…è¦æ™‚ï¼‰
            try {
                context.configure({
                    device: context.device,
                    format: 'bgra8unorm',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT,
                    presentMode: 'mailbox' // ä½é…å»¶ãƒ¢ãƒ¼ãƒ‰
                });
            } catch (error) {
                console.warn('âš ï¸ VSyncåˆ¶å¾¡è¨­å®šå¤±æ•—:', error);
            }
        }
    }
    
    enableHighPriorityRendering() {
        const scheduler = window.scheduler;
        
        // é«˜å„ªå…ˆåº¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¿ã‚¹ã‚¯
        this.app.ticker.add(() => {
            scheduler.postTask(() => {
                this.optimizedRenderFrame();
            }, { priority: 'user-blocking' });
        });
        
        console.log('âš¡ é«˜å„ªå…ˆåº¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æœ‰åŠ¹åŒ–');
    }
    
    optimizedRenderFrame() {
        // ãƒ•ãƒ¬ãƒ¼ãƒ æœ€é©åŒ–å‡¦ç†
        const startTime = performance.now();
        
        // æç”»å‡¦ç†
        this.app.renderer.render(this.app.stage);
        
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬
        const frameTime = performance.now() - startTime;
        const fps = Math.round(1000 / frameTime);
        
        this.recordPerformance(fps, frameTime);
        
        // å‹•çš„å“è³ªèª¿æ•´
        if (fps < 100 && this.isWebGPUAvailable) {
            this.adjustQuality('lower');
        } else if (fps > 115) {
            this.adjustQuality('higher');
        }
    }
    
    adjustQuality(direction) {
        if (direction === 'lower') {
            // å“è³ªã‚’ä¸‹ã’ã¦fpså‘ä¸Š
            this.app.renderer.resolution *= 0.95;
        } else if (direction === 'higher') {
            // å“è³ªã‚’ä¸Šã’ã‚‹
            this.app.renderer.resolution = Math.min(
                this.app.renderer.resolution * 1.05, 
                window.devicePixelRatio * 2
            );
        }
    }
    
    startPerformanceMonitoring() {
        setInterval(() => {
            const stats = this.getPerformanceStats();
            
            console.log(`ğŸ“Š Performance: ${stats.avgFPS}fps, GPU: ${stats.gpuUsage}%`);
            
            // æ€§èƒ½ã‚¢ãƒ©ãƒ¼ãƒˆ
            if (stats.avgFPS < 90) {
                console.warn('âš ï¸ FPSä½ä¸‹æ¤œå‡º: æœ€é©åŒ–ã‚’å®Ÿè¡Œ');
                this.performanceOptimization();
            }
            
        }, 5000); // 5ç§’ã”ã¨
    }
    
    recordPerformance(fps, frameTime) {
        this.performanceStats.fps.push(fps);
        
        // é…åˆ—ã‚µã‚¤ã‚ºåˆ¶é™
        if (this.performanceStats.fps.length > 60) {
            this.performanceStats.fps.shift();
        }
        
        // GPUä½¿ç”¨ç‡æ¨å®šï¼ˆWebGPUç’°å¢ƒï¼‰
        if (this.isWebGPUAvailable) {
            const gpuUsage = Math.min(100, frameTime * 6); // ç°¡æ˜“æ¨å®š
            this.performanceStats.gpuUsage.push(gpuUsage);
            
            if (this.performanceStats.gpuUsage.length > 60) {
                this.performanceStats.gpuUsage.shift();
            }
        }
    }
    
    getPerformanceStats() {
        const fps = this.performanceStats.fps;
        const gpu = this.performanceStats.gpuUsage;
        
        return {
            avgFPS: fps.length > 0 ? Math.round(fps.reduce((a, b) => a + b) / fps.length) : 0,
            minFPS: fps.length > 0 ? Math.min(...fps) : 0,
            maxFPS: fps.length > 0 ? Math.max(...fps) : 0,
            gpuUsage: gpu.length > 0 ? Math.round(gpu.reduce((a, b) => a + b) / gpu.length) : 0,
            isWebGPU: this.isWebGPUAvailable
        };
    }
    
    cleanupGPUMemory() {
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
        PIXI.utils.clearTextureCache();
        
        // æœªä½¿ç”¨ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
        if (this.app.renderer.texture && this.app.renderer.texture.gc) {
            this.app.renderer.texture.gc();
        }
        
        // WebGPU Bufferè§£æ”¾
        if (this.isWebGPUAvailable) {
            // GPU Buffer ã®å¼·åˆ¶è§£æ”¾ï¼ˆå®Ÿè£…ä¾å­˜ï¼‰
            try {
                const device = this.app.renderer.context.device;
                device.pushErrorScope('out-of-memory');
                device.popErrorScope().then(error => {
                    if (error) {
                        console.warn('GPU MemoryçŠ¶æ³:', error);
                    }
                });
            } catch (error) {
                console.warn('GPU Memoryç¢ºèªå¤±æ•—:', error);
            }
        }
        
        console.log('ğŸ§¹ GPU Memory Cleanupå®Ÿè¡Œ');
    }
    
    setupWebGLOptimization() {
        // WebGLæœ€é©åŒ–ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        this.app.ticker.maxFPS = 60;
        
        // WebGLæ‹¡å¼µæ©Ÿèƒ½ä½¿ç”¨
        const gl = this.app.renderer.gl;
        if (gl) {
            gl.getExtension('OES_texture_float');
            gl.getExtension('WEBGL_color_buffer_float');
            gl.getExtension('EXT_color_buffer_float');
        }
        
        console.log('ğŸ”§ WebGLæœ€é©åŒ–å®Œäº†');
    }
}
```

### Phase4.3: SPINEçµ±åˆãƒ»é«˜åº¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
**æœŸé–“**: 3é€±é–“ãƒ»ç›®æ¨™: ãƒœãƒ¼ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»Live2Dæº–å‚™

#### SPINEçµ±åˆå®Ÿè£…
```javascript
// js/animation/spine-integration.jsï¼ˆ400è¡Œä»¥ä¸‹ï¼‰
/**
 * ğŸ¯ AI_WORK_SCOPE: SPINEçµ±åˆãƒ»ãƒœãƒ¼ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»Live2Dæº–å‚™
 * ğŸ¯ DEPENDENCIES: js/animation/frame-manager.js, libs/pixi-extensions.js
 * ğŸ¯ NODE_MODULES: pixi.js v8, pixi-spineï¼ˆè¿½åŠ äºˆå®šï¼‰
 * ğŸ“‹ PHASE_TARGET: Phase4
 * ğŸ“‹ PERFORMANCE_TARGET: 60fps ãƒœãƒ¼ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
 */
class SpineIntegration {
    constructor(animationManager) {
        this.animationManager = animationManager;
        this.spineAssets = new Map();
        this.spineLibraryLoaded = false;
        this.activeSpineObjects = [];
        
        this.init();
    }
    
    async init() {
        console.log('ğŸ¦´ SPINEçµ±åˆåˆæœŸåŒ–é–‹å§‹');
        
        try {
            await this.loadSpineLibrary();
            this.setupSpineRenderer();
            console.log('âœ… SPINEçµ±åˆå®Œäº†');
        } catch (error) {
            console.warn('âš ï¸ SPINEçµ±åˆå¤±æ•—:', error);
        }
    }
    
    async loadSpineLibrary() {
        if (this.spineLibraryLoaded) return;
        
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/pixi-spine@4.0.4/dist/pixi-spine.umd.js';
            
            script.onload = () => {
                if (window.PIXI && window.PIXI.spine) {
                    this.spineLibraryLoaded = true;
                    console.log('ğŸ“¦ pixi-spine ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿å®Œäº†');
                    resolve();
                } else {
                    reject(new Error('PIXI.spine ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'));
                }
            };
            
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    setupSpineRenderer() {
        if (!window.PIXI?.spine) return;
        
        // SPINE ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼æœ€é©åŒ–è¨­å®š
        PIXI.spine.settings.FAIL_ON_NON_EXISTING_SKIN = false;
        PIXI.spine.settings.GLOBAL_AUTO_UPDATE = true;
        PIXI.spine.settings.GLOBAL_DELAY_LIMIT = 0;
        
        console.log('ğŸ® SPINE Rendererè¨­å®šå®Œäº†');
    }
    
    async loadSpineAsset(assetPath, atlasPath = null, jsonPath = null) {
        if (!this.spineLibraryLoaded) {
            await this.loadSpineLibrary();
        }
        
        try {
            console.log(`ğŸ“¦ SPINEã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿: ${assetPath}`);
            
            // ã‚¢ã‚»ãƒƒãƒˆãƒ‘ã‚¹è§£æ
            const basePath = assetPath.replace(/\.[^/.]+$/, '');
            const spineAtlas = atlasPath || `${basePath}.atlas`;
            const spineJson = jsonPath || `${basePath}.json`;
            
            // SPINEãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
            const resources = await this.loadSpineResources(spineJson, spineAtlas, assetPath);
            
            // SPINEã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
            const spine = new PIXI.spine.Spine(resources.spineData);
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
            this.setupSpineAnimation(spine);
            
            // ç®¡ç†å¯¾è±¡ã«è¿½åŠ 
            this.spineAssets.set(assetPath, {
                spine: spine,
                resources: resources,
                animations: spine.spineData.animations.map(anim => anim.name),
                skins: spine.spineData.skins.map(skin => skin.name)
            });
            
            this.activeSpineObjects.push(spine);
            
            console.log(`âœ… SPINEã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿å®Œäº†: ${assetPath}`);
            return spine;
            
        } catch (error) {
            console.error(`âŒ SPINEã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿å¤±æ•—: ${assetPath}`, error);
            throw error;
        }
    }
    
    async loadSpineResources(jsonPath, atlasPath, texturePath) {
        // PixiJS v8ã®Assets APIä½¿ç”¨
        const V8Compatibility = window.V8Compatibility || 
            await import('../migration/v8-compatibility.js').then(m => m.V8CompatibilityLayer);
        
        const resources = await V8Compatibility.loadAssets([
            { alias: 'spineAtlas', src: atlasPath },
            { alias: 'spineJson', src: jsonPath }
        ]);
        
        // SPINEãƒ‡ãƒ¼ã‚¿æ§‹ç¯‰
        const atlas = new PIXI.spine.TextureAtlas(
            resources.spineAtlas.data, 
            (path, callback) => {
                const texture = PIXI.Texture.from(texturePath);
                callback(texture.baseTexture);
            }
        );
        
        const atlasLoader = new PIXI.spine.AtlasAttachmentLoader(atlas);
        const skeletonJson = new PIXI.spine.SkeletonJson(atlasLoader);
        const skeletonData = skeletonJson.readSkeletonData(resources.spineJson.data);
        
        return {
            atlas: atlas,
            spineData: skeletonData,
            resources: resources
        };
    }
    
    setupSpineAnimation(spine) {
        // åŸºæœ¬ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
        if (spine.spineData.animations.length > 0) {
            const firstAnimation = spine.spineData.animations[0].name;
            spine.state.setAnimation(0, firstAnimation, true);
        }
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ãƒªã‚¹ãƒŠãƒ¼
        spine.state.addListener({
            complete: (track) => {
                console.log(`ğŸ¬ SPINEã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†: ${track.animation.name}`);
            },
            
            start: (track) => {
                console.log(`â–¶ï¸ SPINEã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹: ${track.animation.name}`);
            },
            
            interrupt: (track) => {
                console.log(`â¸ï¸ SPINEã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­æ–­: ${track.animation.name}`);
            }
        });
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°æœ€é©åŒ–
        spine.autoUpdate = true;
        spine.updateTransform = spine.updateTransform.bind(spine);
    }
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ãƒ¡ã‚½ãƒƒãƒ‰
    playAnimation(spineAssetPath, animationName, loop = true, trackIndex = 0) {
        const asset = this.spineAssets.get(spineAssetPath);
        if (!asset) {
            console.warn(`SPINEã‚¢ã‚»ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${spineAssetPath}`);
            return false;
        }
        
        const spine = asset.spine;
        
        if (!asset.animations.includes(animationName)) {
            console.warn(`ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${animationName}`);
            return false;
        }
        
        spine.state.setAnimation(trackIndex, animationName, loop);
        console.log(`ğŸ¬ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ: ${animationName}`);
        return true;
    }
    
    addAnimation(spineAssetPath, animationName, loop = true, delay = 0, trackIndex = 0) {
        const asset = this.spineAssets.get(spineAssetPath);
        if (!asset) return false;
        
        const spine = asset.spine;
        spine.state.addAnimation(trackIndex, animationName, loop, delay);
        
        return true;
    }
    
    setSkin(spineAssetPath, skinName) {
        const asset = this.spineAssets.get(spineAssetPath);
        if (!asset) return false;
        
        const spine = asset.spine;
        
        if (!asset.skins.includes(skinName)) {
            console.warn(`ã‚¹ã‚­ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${skinName}`);
            return false;
        }
        
        spine.skeleton.setSkinByName(skinName);
        spine.skeleton.setSlotsToSetupPose();
        
        console.log(`ğŸ‘— ã‚¹ã‚­ãƒ³å¤‰æ›´: ${skinName}`);
        return true;
    }
    
    // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆ
    integrateWithFrameAnimation(frameManager) {
        console.log('ğŸ”— SPINEã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«çµ±åˆ');
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆæ™‚ã«SPINEã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å«ã‚ã‚‹
        const originalCreateFrame = frameManager.createFrame.bind(frameManager);
        
        frameManager.createFrame = (duration) => {
            // é€šå¸¸ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ
            const frame = originalCreateFrame(duration);
            
            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªSPINEã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çŠ¶æ…‹ã‚’ä¿å­˜
            frame.spineStates = this.activeSpineObjects.map(spine => ({
                assetPath: this.findAssetPath(spine),
                currentAnimation: spine.state.getCurrent(0)?.animation.name,
                currentTime: spine.state.getCurrent(0)?.animationTime || 0,
                skinName: spine.skeleton.skin?.name
            }));
            
            return frame;
        };
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ èª­ã¿è¾¼ã¿æ™‚ã«SPINEã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾©å…ƒ
        const originalLoadFrame = frameManager.loadFrameToCanvas.bind(frameManager);
        
        frameManager.loadFrameToCanvas = (frameIndex) => {
            originalLoadFrame(frameIndex);
            
            const frame = frameManager.frames[frameIndex];
            if (frame.spineStates) {
                this.restoreSpineStates(frame.spineStates);
            }
        };
    }
    
    findAssetPath(spine) {
        for (const [path, asset] of this.spineAssets) {
            if (asset.spine === spine) {
                return path;
            }
        }
        return null;
    }
    
    restoreSpineStates(spineStates) {
        spineStates.forEach(state => {
            const asset = this.spineAssets.get(state.assetPath);
            if (!asset) return;
            
            const spine = asset.spine;
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾©å…ƒ
            if (state.currentAnimation) {
                spine.state.setAnimation(0, state.currentAnimation, true);
                spine.state.getCurrent(0).animationTime = state.currentTime;
            }
            
            // ã‚¹ã‚­ãƒ³å¾©å…ƒ
            if (state.skinName) {
                spine.skeleton.setSkinByName(state.skinName);
                spine.skeleton.setSlotsToSetupPose();
            }
        });
    }
    
    // Live2Dæº–å‚™æ©Ÿèƒ½
    prepareLive2DSupport() {
        console.log('ğŸ­ Live2Dæº–å‚™æ©Ÿèƒ½åˆæœŸåŒ–');
        
        // Live2D Cubism SDKæº–å‚™
        this.live2dReady = false;
        
        return {
            loadLive2DModel: async (modelPath) => {
                console.log('ğŸ­ Live2Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æº–å‚™');
                // Phase4å¾ŒæœŸå®Ÿè£…äºˆå®š
                throw new Error('Live2Dæ©Ÿèƒ½ã¯Phase4å¾ŒæœŸå®Ÿè£…äºˆå®š');
            },
            
            setupLive2DPhysics: () => {
                console.log('ğŸ­ Live2Dç‰©ç†æ¼”ç®—æº–å‚™');
                // Phase4å¾ŒæœŸå®Ÿè£…äºˆå®š
            }
        };
    }
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
    getPerformanceStats() {
        const stats = {
            loadedAssets: this.spineAssets.size,
            activeObjects: this.activeSpineObjects.length,
            totalBones: 0,
            totalSlots: 0,
            animationsPlaying: 0
        };
        
        this.activeSpineObjects.forEach(spine => {
            stats.totalBones += spine.skeleton.bones.length;
            stats.totalSlots += spine.skeleton.slots.length;
            
            if (spine.state.getCurrent(0)) {
                stats.animationsPlaying++;
            }
        });
        
        return stats;
    }
    
    // ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–
    cleanup() {
        console.log('ğŸ§¹ SPINE ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—');
        
        // éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªSPINEã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè§£æ”¾
        this.activeSpineObjects.forEach(spine => {
            spine.destroy();
        });
        
        // ã‚¢ã‚»ãƒƒãƒˆè§£æ”¾
        this.spineAssets.forEach((asset, path) => {
            asset.spine.destroy();
            console.log(`ğŸ—‘ï¸ SPINEã‚¢ã‚»ãƒƒãƒˆè§£æ”¾: ${path}`);
        });
        
        this.activeSpineObjects = [];
        this.spineAssets.clear();
    }
}
```

---
## ğŸ“Š Phase4ãƒ†ã‚¹ãƒˆãƒ»å“è³ªä¿è¨¼

### Phase4ãƒ†ã‚¹ãƒˆ: v8ç§»è¡Œãƒ»WebGPU
**åŸºæº–**: v8ç§»è¡Œãƒ»WebGPUãƒ»120FPSãƒ»SPINEçµ±åˆå®Œå…¨å‹•ä½œ

```javascript
class Phase4TestSuite {
    async runTests() {
        console.log('ğŸ§ª Phase4ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–‹å§‹');
        
        await this.testV8Compatibility();
        await this.testWebGPUPerformance();
        await this.testSpineIntegration();
        await this.test120FPS();
        
        console.log('âœ… Phase4ãƒ†ã‚¹ãƒˆå®Œäº†');
    }
    
    async testV8Compatibility() {
        // v8äº’æ›æ€§ãƒ†ã‚¹ãƒˆ
        const app = await V8CompatibilityLayer.createApplication({
            width: 800,
            height: 600,
            backgroundColor: 0xf0e0d6,
            webgpu: true
        });
        
        if (!app || !app.stage) {
            throw new Error('v8ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆå¤±æ•—');
        }
        
        // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ç¢ºèª
        const isWebGPU = navigator.gpu && app.renderer.type === PIXI.RENDERER_TYPE.WEBGPU;
        console.log(`ğŸ® ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼: ${isWebGPU ? 'WebGPU' : 'WebGL'}`);
        
        console.log('âœ… v8äº’æ›æ€§ãƒ†ã‚¹ãƒˆå®Œäº†');
    }
    
    async testWebGPUPerformance() {
        const app = await V8CompatibilityLayer.createApplication({
            width: 800,
            height: 600,
            webgpu: true
        });
        
        const optimizer = new WebGPUDrawingOptimizer(app);
        
        // æ€§èƒ½æ¸¬å®šãƒ†ã‚¹ãƒˆ
        return new Promise((resolve) => {
            setTimeout(() => {
                const stats = optimizer.getPerformanceStats();
                
                if (stats.isWebGPU && stats.avgFPS < 90) {
                    console.warn('âš ï¸ WebGPUæ€§èƒ½ãŒæœŸå¾…å€¤ã‚’ä¸‹å›ã‚Šã¾ã™');
                } else if (!stats.isWebGPU && stats.avgFPS < 50) {
                    console.warn('âš ï¸ WebGLæ€§èƒ½ãŒæœŸå¾…å€¤ã‚’ä¸‹å›ã‚Šã¾ã™');
                }
                
                console.log(`âœ… WebGPUæ€§èƒ½ãƒ†ã‚¹ãƒˆå®Œäº†: ${stats.avgFPS}fps`);
                resolve();
            }, 5000);
        });
    }
    
    async testSpineIntegration() {
        const spineIntegration = new SpineIntegration();
        
        try {
            // SPINEãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆ
            await spineIntegration.loadSpineLibrary();
            
            if (!spineIntegration.spineLibraryLoaded) {
                throw new Error('SPINEãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿å¤±æ•—');
            }
            
            console.log('âœ… SPINEçµ±åˆãƒ†ã‚¹ãƒˆå®Œäº†');
            
        } catch (error) {
            console.warn('âš ï¸ SPINEçµ±åˆãƒ†ã‚¹ãƒˆå¤±æ•—ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ï¼‰:', error);
        }
    }
}
```
## ğŸ¯ æœ€çµ‚æˆæœç‰©ãƒ»æœŸå¾…åŠ¹æœ

### Phase4æˆæœç‰©
- **ğŸš€ PixiJS v8å®Œå…¨ç§»è¡Œ**: ç ´å£Šçš„å¤‰æ›´å¯¾å¿œãƒ»äº’æ›æ€§ãƒ¬ã‚¤ãƒ¤ãƒ¼å®Œæˆ
- **âš¡ WebGPU å¯¾å¿œ**: GPUæ´»ç”¨ãƒ»æç”»æ€§èƒ½å‘ä¸Šãƒ»ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–
- **ğŸƒ 120FPS æç”»**: é«˜å‘¨æ³¢æ•°æç”»ãƒ»å‹•çš„å“è³ªèª¿æ•´ãƒ»VSyncåˆ¶å¾¡
- **ğŸ¦´ SPINE çµ±åˆ**: ãƒœãƒ¼ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»Live2Dæº–å‚™ãƒ»ãƒ•ãƒ¬ãƒ¼ãƒ çµ±åˆ

### æŠ€è¡“çš„æˆæœãƒ»é©æ–°
- **WebGPUæ´»ç”¨**: æ¬¡ä¸–ä»£GPUæç”»ãƒ»Compute Shaderæ´»ç”¨
- **120FPSå®Ÿç¾**: Chrome Scheduling APIãƒ»é«˜å„ªå…ˆåº¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°  
- **ã‚¢ãƒ‹ãƒ¡åˆ¶ä½œç’°å¢ƒ**: ãƒ—ãƒ­ç´šGIFåˆ¶ä½œãƒ»ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³ãƒ»ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³
- **SPINEçµ±åˆ**: ãƒœãƒ¼ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»Live2Då¯¾å¿œæº–å‚™

## ğŸ”§ Phase4å®Ÿè£…é–‹å§‹æ‰‹é †

### Phase4å®Ÿè£…é †åºï¼ˆæ¨å¥¨ï¼‰

**Week 1-2**: v8ç§»è¡Œæº–å‚™ãƒ»äº’æ›æ€§ãƒ¬ã‚¤ãƒ¤ãƒ¼
- [ ] js/migration/v8-compatibility.jsï¼ˆäº’æ›æ€§ï¼‰
- [ ] ç ´å£Šçš„å¤‰æ›´å¯¾å¿œãƒ»APIå¤‰æ›´å¸å
- [ ] ç§»è¡Œãƒ†ã‚¹ãƒˆãƒ»å“è³ªç¢ºèª

**Week 3-5**: WebGPUãƒ»120FPSå®Ÿè£…
- [ ] js/migration/webgpu-optimizer.jsï¼ˆWebGPUæœ€é©åŒ–ï¼‰
- [ ] 120FPSè¨­å®šãƒ»VSyncåˆ¶å¾¡
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ãƒ»å‹•çš„å“è³ªèª¿æ•´

**Week 6-8**: SPINEçµ±åˆãƒ»é«˜åº¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- [ ] js/animation/spine-integration.jsï¼ˆSPINEçµ±åˆï¼‰
- [ ] ãƒœãƒ¼ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œ
- [ ] Live2Dæº–å‚™ãƒ»çµ±åˆãƒ†ã‚¹ãƒˆ

---
