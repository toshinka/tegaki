*🎨 ふたば☆ちゃんねる風お絵描きツール 移行計画書 Phase3-4版*  
*作成日: 2025年8月15日*  
*対応技術: GIFアニメーション→PixiJS v8移行→WebGPU・120FPS*  
*基本方針: プロ級アニメ制作→次世代描画技術実現*# 🎨 ふたば☆ちゃんねる風お絵描きツール 移行計画書 Phase3-4版
## アニメーション機能実装 → PixiJS v8移行戦略

### 📋 計画概要
**前提条件**: Phase1-2完了（node_modules分割・描画機能完成）
**Phase3目標**: GIFアニメ制作環境完成（v7最終版）
**Phase4目標**: PixiJS v8移行・WebGPU・120FPS実現（次世代版）

---

## 🎬 Phase3: アニメーション機能実装（v7最終版）

### Phase3.1: フレーム管理システム実装
**期間**: 3週間・目標: プロ級フレーム管理・タイムライン完成

#### フレーム管理システム構築
```javascript
// js/animation/frame-manager.js（500行以下）
/**
 * 🎯 AI_WORK_SCOPE: フレーム管理・タイムライン制御・サムネイル生成
 * 🎯 DEPENDENCIES: libs/pixi-extensions.js, js/app-core.js, js/layers/layer-manager.js
 * 🎯 NODE_MODULES: pixi.js（Application, RenderTexture）
 * 🎯 PIXI_EXTENSIONS: layers（レイヤー複製用）、lodash（配列処理最適化）
 * 📋 PHASE_TARGET: Phase3
 * 📋 V8_MIGRATION: RenderTexture API変更対応予定
 */
class FrameManager {
    constructor(layerManager) {
        this.layerManager = layerManager;
        this.frames = [];
        this.currentFrame = 0;
        this.frameRate = 12; // デフォルト12fps
        this.maxFrames = 300; // 最大フレーム数制限
        this.hasLodash = window.PixiExtensions.hasFeature('lodash');
    }
    
    createFrame(duration = 83) { // 12fps = 83ms
        if (this.frames.length >= this.maxFrames) {
            throw new Error(`最大フレーム数 ${this.maxFrames} に達しました`);
        }
        
        const frame = {
            id: this.generateFrameId(),
            index: this.frames.length,
            duration: duration,
            layers: this.cloneCurrentLayers(),
            thumbnail: null,
            created: Date.now()
        };
        
        // フレームサムネイル生成
        frame.thumbnail = await this.generateThumbnail(frame);
        
        this.frames.push(frame);
        this.currentFrame = frame.index;
        
        console.log(`📷 フレーム作成: ${frame.index + 1}/${this.maxFrames}`);
        return frame;
    }
    
    cloneCurrentLayers() {
        // 全レイヤーの非破壊複製
        return this.layerManager.layers.map(layer => ({
            ...layer,
            graphics: this.cloneGraphics(layer.graphics),
            transform: layer.transform.clone(),
            id: layer.id + '_frame_' + this.frames.length
        }));
    }
    
    cloneGraphics(graphics) {
        // PIXI.Graphics完全複製
        const cloned = new PIXI.Graphics();
        cloned.geometry = graphics.geometry.clone();
        cloned.shader = graphics.shader;
        cloned.transform.copyFrom(graphics.transform);
        cloned.alpha = graphics.alpha;
        cloned.tint = graphics.tint;
        cloned.blendMode = graphics.blendMode;
        return cloned;
    }
    
    async generateThumbnail(frame, size = 64) {
        // フレーム内容をサムネイル画像として生成
        const tempApp = new PIXI.Application({
            width: size,
            height: size,
            backgroundColor: 0xf0e0d6,
            preserveDrawingBuffer: true
        });
        
        // フレームレイヤーを描画
        frame.layers.forEach(layer => {
            if (layer.visible) {
                tempApp.stage.addChild(layer.graphics);
            }
        });
        
        // レンダリング実行
        tempApp.renderer.render(tempApp.stage);
        
        // サムネイル画像データ取得
        const canvas = tempApp.renderer.extract.canvas(tempApp.stage);
        const thumbnailData = canvas.toDataURL('image/png');
        
        // リソース解放
        tempApp.destroy();
        
        return {
            dataURL: thumbnailData,
            size: size,
            generated: Date.now()
        };
    }
    
    // フレーム操作メソッド
    duplicateFrame(frameIndex) {
        const sourceFrame = this.frames[frameIndex];
        if (!sourceFrame) return null;
        
        const duplicatedFrame = {
            ...sourceFrame,
            id: this.generateFrameId(),
            index: this.frames.length,
            layers: this.cloneLayers(sourceFrame.layers),
            created: Date.now()
        };
        
        this.frames.push(duplicatedFrame);
        return duplicatedFrame;
    }
    
    deleteFrame(frameIndex) {
        if (this.frames.length <= 1) {
            console.warn('最後のフレームは削除できません');
            return false;
        }
        
        this.frames.splice(frameIndex, 1);
        
        // インデックス再構築
        this.frames.forEach((frame, index) => {
            frame.index = index;
        });
        
        // カレントフレーム調整
        if (this.currentFrame >= this.frames.length) {
            this.currentFrame = this.frames.length - 1;
        }
        
        return true;
    }
    
    setCurrentFrame(frameIndex) {
        if (frameIndex >= 0 && frameIndex < this.frames.length) {
            this.currentFrame = frameIndex;
            this.loadFrameToCanvas(frameIndex);
            return true;
        }
        return false;
    }
    
    loadFrameToCanvas(frameIndex) {
        const frame = this.frames[frameIndex];
        if (!frame) return;
        
        // 現在のキャンバスをクリア
        this.layerManager.clearAllLayers();
        
        // フレームレイヤーを復元
        frame.layers.forEach(layer => {
            this.layerManager.addLayer(layer);
        });
    }
}
```

#### タイムラインUI実装
```javascript
// js/animation/timeline-ui.js（400行以下）
/**
 * 🎯 AI_WORK_SCOPE: タイムラインUI・フレーム表示・再生制御
 * 🎯 DEPENDENCIES: js/animation/frame-manager.js, libs/pixi-extensions.js
 * 🎯 PIXI_EXTENSIONS: ui（ボタン・スライダー）、gsap（アニメーション）
 * 📋 PHASE_TARGET: Phase3
 */
class TimelineUI {
    constructor(frameManager) {
        this.frameManager = frameManager;
        this.hasPixiUI = window.PixiExtensions.hasFeature('ui');
        this.hasGSAP = window.PixiExtensions.hasFeature('gsap');
        this.isPlaying = false;
        this.playbackTimer = null;
        
        this.setupTimeline();
    }
    
    setupTimeline() {
        this.timelineContainer = new PIXI.Container();
        
        // 再生制御ボタン群
        this.createPlaybackControls();
        
        // フレーム表示エリア
        this.createFrameDisplay();
        
        // タイムライン設定
        this.createTimelineSettings();
    }
    
    createPlaybackControls() {
        const buttonY = 10;
        let buttonX = 10;
        
        // 再生/一時停止ボタン
        this.playButton = this.createButton('▶', buttonX, buttonY, () => {
            this.togglePlayback();
        });
        buttonX += 50;
        
        // 停止ボタン
        this.stopButton = this.createButton('⏹', buttonX, buttonY, () => {
            this.stopPlayback();
        });
        buttonX += 50;
        
        // 前フレームボタン
        this.prevButton = this.createButton('⏮', buttonX, buttonY, () => {
            this.previousFrame();
        });
        buttonX += 50;
        
        // 次フレームボタン
        this.nextButton = this.createButton('⏭', buttonX, buttonY, () => {
            this.nextFrame();
        });
        buttonX += 50;
        
        // フレーム追加ボタン
        this.addFrameButton = this.createButton('➕', buttonX, buttonY, () => {
            this.frameManager.createFrame();
            this.updateFrameDisplay();
        });
    }
    
    createButton(text, x, y, callback) {
        let button;
        
        if (this.hasPixiUI) {
            // @pixi/ui使用
            const Button = window.PixiExtensions.getComponent('ui', 'Button');
            button = new Button({
                text: text,
                backgroundColor: 0x4CAF50,
                borderColor: 0x2E7D32,
                textStyle: { fontSize: 16, fill: 0xffffff }
            });
            
            button.onPress.connect(callback);
        } else {
            // フォールバック実装
            button = this.createBasicButton(text, callback);
        }
        
        button.x = x;
        button.y = y;
        this.timelineContainer.addChild(button);
        
        return button;
    }
    
    createFrameDisplay() {
        this.frameDisplayContainer = new PIXI.Container();
        this.frameDisplayContainer.y = 60;
        this.timelineContainer.addChild(this.frameDisplayContainer);
        
        this.updateFrameDisplay();
    }
    
    updateFrameDisplay() {
        // 既存フレーム表示をクリア
        this.frameDisplayContainer.removeChildren();
        
        const frameWidth = 80;
        const frameHeight = 60;
        const frameSpacing = 10;
        
        this.frameManager.frames.forEach((frame, index) => {
            const frameItem = this.createFrameItem(frame, index, frameWidth, frameHeight);
            frameItem.x = index * (frameWidth + frameSpacing);
            frameItem.y = 0;
            
            // カレントフレームハイライト
            if (index === this.frameManager.currentFrame) {
                frameItem.tint = 0x2196F3; // 青色ハイライト
            }
            
            this.frameDisplayContainer.addChild(frameItem);
        });
    }
    
    createFrameItem(frame, index, width, height) {
        const frameItem = new PIXI.Container();
        
        // フレーム背景
        const background = new PIXI.Graphics();
        background.beginFill(0xE0E0E0);
        background.lineStyle(2, 0x888888);
        background.drawRect(0, 0, width, height);
        background.endFill();
        frameItem.addChild(background);
        
        // サムネイル表示
        if (frame.thumbnail) {
            const thumbnailTexture = PIXI.Texture.from(frame.thumbnail.dataURL);
            const thumbnail = new PIXI.Sprite(thumbnailTexture);
            thumbnail.width = width - 4;
            thumbnail.height = height - 20;
            thumbnail.x = 2;
            thumbnail.y = 2;
            frameItem.addChild(thumbnail);
        }
        
        // フレーム番号
        const frameNumber = new PIXI.Text(`${index + 1}`, {
            fontSize: 12,
            fill: 0x000000,
            fontFamily: 'monospace'
        });
        frameNumber.x = 2;
        frameNumber.y = height - 16;
        frameItem.addChild(frameNumber);
        
        // フレーム時間
        const frameTime = new PIXI.Text(`${frame.duration}ms`, {
            fontSize: 10,
            fill: 0x666666,
            fontFamily: 'monospace'
        });
        frameTime.x = width - frameTime.width - 2;
        frameTime.y = height - 16;
        frameItem.addChild(frameTime);
        
        // クリックイベント
        frameItem.interactive = true;
        frameItem.buttonMode = true;
        frameItem.on('pointertap', () => {
            this.frameManager.setCurrentFrame(index);
            this.updateFrameDisplay();
        });
        
        return frameItem;
    }
    
    togglePlayback() {
        if (this.isPlaying) {
            this.pausePlayback();
        } else {
            this.startPlayback();
        }
    }
    
    startPlayback() {
        if (this.frameManager.frames.length <= 1) return;
        
        this.isPlaying = true;
        this.playButton.text = '⏸';
        
        const frameInterval = 1000 / this.frameManager.frameRate;
        this.playbackTimer = setInterval(() => {
            let nextFrame = this.frameManager.currentFrame + 1;
            if (nextFrame >= this.frameManager.frames.length) {
                nextFrame = 0; // ループ再生
            }
            
            this.frameManager.setCurrentFrame(nextFrame);
            this.updateFrameDisplay();
        }, frameInterval);
    }
    
    pausePlayback() {
        this.isPlaying = false;
        this.playButton.text = '▶';
        
        if (this.playbackTimer) {
            clearInterval(this.playbackTimer);
            this.playbackTimer = null;
        }
    }
    
    stopPlayback() {
        this.pausePlayback();
        this.frameManager.setCurrentFrame(0);
        this.updateFrameDisplay();
    }
}
```

### Phase3.2: オニオンスキン・GIFエクスポート実装
**期間**: 3週間・目標: アニメーション制作機能完成

#### オニオンスキン実装
```javascript
// js/animation/onion-skin.js（200行以下）
class OnionSkin {
    constructor(frameManager) {
        this.frameManager = frameManager;
        this.enabled = true;
        this.beforeFrames = 2;  // 前フレーム表示数
        this.afterFrames = 2;   // 後フレーム表示数
        this.opacity = 0.3;     // オニオンスキン透明度
        this.beforeColor = 0xFF0000; // 前フレーム色（赤）
        this.afterColor = 0x0000FF;  // 後フレーム色（青）
    }
    
    updateOnionSkin(stage) {
        if (!this.enabled) return
    updateOnionSkin(stage) {
        if (!this.enabled) return;
        
        // 既存オニオンスキンをクリア
        this.clearOnionSkin(stage);
        
        const currentIndex = this.frameManager.currentFrame;
        
        // 前フレーム表示（赤系）
        for (let i = 1; i <= this.beforeFrames; i++) {
            const prevIndex = currentIndex - i;
            if (prevIndex >= 0) {
                const opacity = this.opacity * (1 - (i - 1) * 0.15);
                this.showFrameAsOnion(stage, prevIndex, opacity, this.beforeColor);
            }
        }
        
        // 後フレーム表示（青系）  
        for (let i = 1; i <= this.afterFrames; i++) {
            const nextIndex = currentIndex + i;
            if (nextIndex < this.frameManager.frames.length) {
                const opacity = this.opacity * (1 - (i - 1) * 0.15);
                this.showFrameAsOnion(stage, nextIndex, opacity, this.afterColor);
            }
        }
    }
    
    showFrameAsOnion(stage, frameIndex, opacity, tint) {
        const frame = this.frameManager.frames[frameIndex];
        if (!frame) return;
        
        frame.layers.forEach(layer => {
            if (!layer.visible) return;
            
            // オニオンスキン用コンテナ作成
            const onionContainer = new PIXI.Container();
            onionContainer.name = `onion_skin_${frameIndex}`;
            
            // レイヤーグラフィックス複製
            const onionGraphics = layer.graphics.clone();
            onionGraphics.alpha = opacity;
            onionGraphics.tint = tint;
            
            onionContainer.addChild(onionGraphics);
            stage.addChild(onionContainer);
        });
    }
    
    clearOnionSkin(stage) {
        // オニオンスキンコンテナをすべて削除
        const onionContainers = stage.children.filter(child => 
            child.name && child.name.startsWith('onion_skin_')
        );
        
        onionContainers.forEach(container => {
            stage.removeChild(container);
            container.destroy();
        });
    }
    
    setEnabled(enabled) {
        this.enabled = enabled;
        if (!enabled) {
            // オニオンスキンを完全クリア
            this.clearOnionSkin(this.frameManager.layerManager.app.stage);
        }
    }
}
```

#### GIFエクスポート実装
```javascript
// js/animation/gif-exporter.js（300行以下）
/**
 * 🎯 AI_WORK_SCOPE: GIFアニメーション生成・エクスポート・品質最適化
 * 🎯 DEPENDENCIES: js/animation/frame-manager.js
 * 🎯 NODE_MODULES: pixi.js（Application, RenderTexture）
 * 🎯 PIXI_EXTENSIONS: gif（@pixi/gif使用時）、lodash（データ処理最適化）
 * 📋 PHASE_TARGET: Phase3
 * 📋 PERFORMANCE_TARGET: 1080p/60fps/10MB以下
 */
class GIFExporter {
    constructor(frameManager) {
        this.frameManager = frameManager;
        this.hasPixiGIF = window.PixiExtensions.hasFeature('gif');
        this.hasLodash = window.PixiExtensions.hasFeature('lodash');
        
        // GIF.js ライブラリの動的読み込み準備
        this.gifJSLoaded = false;
    }
    
    async exportGIF(options = {}) {
        const {
            width = 400,
            height = 400,
            quality = 10,    // 1-20 (lower = better)
            repeat = 0,      // 0 = 無限ループ
            frameRate = null, // null = フレーム個別時間使用
            optimize = true   // GIFサイズ最適化
        } = options;
        
        console.log('🎬 GIFエクスポート開始...');
        
        if (this.frameManager.frames.length === 0) {
            throw new Error('エクスポートするフレームがありません');
        }
        
        // エクスポート方式選択
        if (this.hasPixiGIF) {
            return await this.exportWithPixiGIF(options);
        } else {
            return await this.exportWithGIFJS(options);
        }
    }
    
    async exportWithPixiGIF(options) {
        console.log('📦 @pixi/gif使用でのGIF生成...');
        
        try {
            // @pixi/gif使用バージョン（実装予定）
            const AnimatedGIF = window.PixiExtensions.getComponent('gif', 'AnimatedGIF');
            const gifAnimation = new AnimatedGIF();
            
            // フレームを追加
            for (const frame of this.frameManager.frames) {
                const frameCanvas = await this.frameToCanvas(frame, options.width, options.height);
                gifAnimation.addFrame(frameCanvas, frame.duration);
            }
            
            // GIF生成
            const gifBlob = await gifAnimation.export({
                quality: options.quality,
                repeat: options.repeat
            });
            
            return {
                blob: gifBlob,
                size: gifBlob.size,
                frames: this.frameManager.frames.length,
                exportMethod: 'pixi-gif'
            };
            
        } catch (error) {
            console.warn('⚠️ @pixi/gif使用失敗, フォールバックに切り替え:', error);
            return await this.exportWithGIFJS(options);
        }
    }
    
    async exportWithGIFJS(options) {
        console.log('📦 GIF.js使用でのGIF生成...');
        
        // GIF.js の動的読み込み
        if (!this.gifJSLoaded) {
            await this.loadGIFJS();
        }
        
        // GIF.js でのGIF生成
        const gif = new GIF({
            workers: 2,
            quality: options.quality,
            width: options.width,
            height: options.height,
            repeat: options.repeat,
            transparent: 0xf0e0d6 // ふたば背景色を透明として扱う
        });
        
        // プログレス表示
        gif.on('progress', (progress) => {
            console.log(`🔄 GIF生成進捗: ${Math.round(progress * 100)}%`);
        });
        
        // 各フレームをGIFに追加
        for (const frame of this.frameManager.frames) {
            const canvas = await this.frameToCanvas(frame, options.width, options.height);
            const delay = options.frameRate ? (1000 / options.frameRate) : frame.duration;
            gif.addFrame(canvas, { delay: delay });
        }
        
        // GIF生成実行
        return new Promise((resolve, reject) => {
            gif.on('finished', (blob) => {
                console.log(`✅ GIF生成完了: ${Math.round(blob.size / 1024)}KB`);
                resolve({
                    blob: blob,
                    size: blob.size,
                    frames: this.frameManager.frames.length,
                    exportMethod: 'gif-js'
                });
            });
            
            gif.on('error', reject);
            gif.render();
        });
    }
    
    async frameToCanvas(frame, width, height) {
        // フレームを高品質Canvasに変換
        const tempApp = new PIXI.Application({
            width: width,
            height: height,
            backgroundColor: 0xf0e0d6, // ふたば背景色
            preserveDrawingBuffer: true,
            antialias: true
        });
        
        // フレームレイヤーを描画
        frame.layers.forEach(layer => {
            if (layer.visible) {
                const clonedGraphics = layer.graphics.clone();
                clonedGraphics.transform.copyFrom(layer.transform);
                tempApp.stage.addChild(clonedGraphics);
            }
        });
        
        // レンダリング実行
        tempApp.renderer.render(tempApp.stage);
        
        // Canvas要素取得
        const canvas = tempApp.renderer.extract.canvas(tempApp.stage);
        
        // リソース解放
        tempApp.destroy();
        
        return canvas;
    }
    
    async loadGIFJS() {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js';
            script.onload = () => {
                this.gifJSLoaded = true;
                resolve();
            };
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    // プレビュー用ミニGIF生成
    async generatePreview(maxFrames = 10) {
        const previewFrames = this.frameManager.frames.slice(0, maxFrames);
        const tempFrameManager = { frames: previewFrames };
        
        const previewGIF = await this.exportGIF.call(
            { frameManager: tempFrameManager, ...this },
            {
                width: 200,
                height: 200,
                quality: 15, // 低品質でサイズ削減
                frameRate: 8 // 低フレームレート
            }
        );
        
        return previewGIF;
    }
}
```

---

## 🚀 Phase4: PixiJS v8移行（次世代版）
（長いのとpixi,jsV8化移行なので、切り取って別ファイルに移動してます）

---

## 📊 Phase3テスト・品質保証

### Phase3テスト: アニメーション機能
**基準**: GIF制作・フレーム管理・オニオンスキン完全動作

```javascript
class Phase3TestSuite {
    async runTests() {
        console.log('🧪 Phase3テスト実行開始');
        
        await this.testFrameManagement();
        await this.testOnionSkinFunctionality();
        await this.testGIFExport();
        await this.testTimelineUI();
        
        console.log('✅ Phase3テスト完了');
    }
    
    async testFrameManagement() {
        const frameManager = new FrameManager();
        
        // フレーム作成テスト
        const frame1 = await frameManager.createFrame();
        const frame2 = await frameManager.createFrame();
        
        if (frameManager.frames.length !== 2) {
            throw new Error('フレーム作成テスト失敗');
        }
        
        // フレーム複製テスト
        const duplicatedFrame = frameManager.duplicateFrame(0);
        if (!duplicatedFrame || frameManager.frames.length !== 3) {
            throw new Error('フレーム複製テスト失敗');
        }
        
        // フレーム削除テスト
        const deleteResult = frameManager.deleteFrame(1);
        if (!deleteResult || frameManager.frames.length !== 2) {
            throw new Error('フレーム削除テスト失敗');
        }
        
        console.log('✅ フレーム管理機能テスト完了');
    }
    
    async testGIFExport() {
        const frameManager = new FrameManager();
        
        // テスト用フレーム作成
        await frameManager.createFrame();
        await frameManager.createFrame();
        
        const gifExporter = new GIFExporter(frameManager);
        
        // GIFエクスポートテスト
        const gifResult = await gifExporter.exportGIF({
            width: 200,
            height: 200,
            quality: 15
        });
        
        if (!gifResult.blob || !(gifResult.blob instanceof Blob)) {
            throw new Error('GIFエクスポートテスト失敗');
        }
        
        if (gifResult.blob.size === 0) {
            throw new Error('GIFファイルサイズが0');
        }
        
        console.log(`✅ GIFエクスポート完了: ${Math.round(gifResult.blob.size / 1024)}KB`);
    }
}
```

---

## 🎯 最終成果物・期待効果

### Phase3成果物
- **🎬 フレーム管理システム**: 300フレーム対応・サムネイル生成・複製/削除機能
- **⏰ タイムライン UI**: 再生制御・フレーム表示・直感的操作
- **👻 オニオンスキン**: 前後フレーム表示・色分け・透明度制御
- **📦 GIF エクスポート**: 高品質出力・圧縮最適化・プレビュー機能



---

## 🔧 Phase4実装開始手順

### 即時開始可能タスク（Phase3.1）

1. **フレーム管理基盤実装**
   ```javascript
   // js/animation/frame-manager.js作成
   // フレーム作成・複製・削除機能実装
   // サムネイル生成システム構築
   ```

2. **タイムラインUI実装**  
   ```javascript
   // js/animation/timeline-ui.js作成
   // 再生制御ボタン群実装
   // フレーム表示エリア構築
   ```

### Phase3実装順序（推奨）

**Week 1-3**: フレーム管理・タイムライン基盤
- [ ] js/animation/frame-manager.js（フレーム管理）
- [ ] js/animation/timeline-ui.js（タイムライン）
- [ ] フレーム作成・削除・移動機能実装

**Week 4-6**: オニオンスキン・GIFエクスポート
- [ ] js/animation/onion-skin.js（オニオンスキン）
- [ ] js/animation/gif-exporter.js（GIF生成）
- [ ] 品質最適化・性能チューニング

---

