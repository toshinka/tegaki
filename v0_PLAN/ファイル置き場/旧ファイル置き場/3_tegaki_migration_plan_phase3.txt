*ğŸ¨ ãµãŸã°â˜†ã¡ã‚ƒã‚“ã­ã‚‹é¢¨ãŠçµµæããƒ„ãƒ¼ãƒ« ç§»è¡Œè¨ˆç”»æ›¸ Phase3-4ç‰ˆ*  
*ä½œæˆæ—¥: 2025å¹´8æœˆ15æ—¥*  
*å¯¾å¿œæŠ€è¡“: GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³â†’PixiJS v8ç§»è¡Œâ†’WebGPUãƒ»120FPS*  
*åŸºæœ¬æ–¹é‡: ãƒ—ãƒ­ç´šã‚¢ãƒ‹ãƒ¡åˆ¶ä½œâ†’æ¬¡ä¸–ä»£æç”»æŠ€è¡“å®Ÿç¾*# ğŸ¨ ãµãŸã°â˜†ã¡ã‚ƒã‚“ã­ã‚‹é¢¨ãŠçµµæããƒ„ãƒ¼ãƒ« ç§»è¡Œè¨ˆç”»æ›¸ Phase3-4ç‰ˆ
## ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½å®Ÿè£… â†’ PixiJS v8ç§»è¡Œæˆ¦ç•¥

### ğŸ“‹ è¨ˆç”»æ¦‚è¦
**å‰ææ¡ä»¶**: Phase1-2å®Œäº†ï¼ˆnode_modulesåˆ†å‰²ãƒ»æç”»æ©Ÿèƒ½å®Œæˆï¼‰
**Phase3ç›®æ¨™**: GIFã‚¢ãƒ‹ãƒ¡åˆ¶ä½œç’°å¢ƒå®Œæˆï¼ˆv7æœ€çµ‚ç‰ˆï¼‰
**Phase4ç›®æ¨™**: PixiJS v8ç§»è¡Œãƒ»WebGPUãƒ»120FPSå®Ÿç¾ï¼ˆæ¬¡ä¸–ä»£ç‰ˆï¼‰

---

## ğŸ¬ Phase3: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½å®Ÿè£…ï¼ˆv7æœ€çµ‚ç‰ˆï¼‰

### Phase3.1: ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…
**æœŸé–“**: 3é€±é–“ãƒ»ç›®æ¨™: ãƒ—ãƒ­ç´šãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†ãƒ»ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å®Œæˆ

#### ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ æ§‹ç¯‰
```javascript
// js/animation/frame-manager.jsï¼ˆ500è¡Œä»¥ä¸‹ï¼‰
/**
 * ğŸ¯ AI_WORK_SCOPE: ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†ãƒ»ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³åˆ¶å¾¡ãƒ»ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆ
 * ğŸ¯ DEPENDENCIES: libs/pixi-extensions.js, js/app-core.js, js/layers/layer-manager.js
 * ğŸ¯ NODE_MODULES: pixi.jsï¼ˆApplication, RenderTextureï¼‰
 * ğŸ¯ PIXI_EXTENSIONS: layersï¼ˆãƒ¬ã‚¤ãƒ¤ãƒ¼è¤‡è£½ç”¨ï¼‰ã€lodashï¼ˆé…åˆ—å‡¦ç†æœ€é©åŒ–ï¼‰
 * ğŸ“‹ PHASE_TARGET: Phase3
 * ğŸ“‹ V8_MIGRATION: RenderTexture APIå¤‰æ›´å¯¾å¿œäºˆå®š
 */
class FrameManager {
    constructor(layerManager) {
        this.layerManager = layerManager;
        this.frames = [];
        this.currentFrame = 0;
        this.frameRate = 12; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ12fps
        this.maxFrames = 300; // æœ€å¤§ãƒ•ãƒ¬ãƒ¼ãƒ æ•°åˆ¶é™
        this.hasLodash = window.PixiExtensions.hasFeature('lodash');
    }
    
    createFrame(duration = 83) { // 12fps = 83ms
        if (this.frames.length >= this.maxFrames) {
            throw new Error(`æœ€å¤§ãƒ•ãƒ¬ãƒ¼ãƒ æ•° ${this.maxFrames} ã«é”ã—ã¾ã—ãŸ`);
        }
        
        const frame = {
            id: this.generateFrameId(),
            index: this.frames.length,
            duration: duration,
            layers: this.cloneCurrentLayers(),
            thumbnail: null,
            created: Date.now()
        };
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆ
        frame.thumbnail = await this.generateThumbnail(frame);
        
        this.frames.push(frame);
        this.currentFrame = frame.index;
        
        console.log(`ğŸ“· ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ: ${frame.index + 1}/${this.maxFrames}`);
        return frame;
    }
    
    cloneCurrentLayers() {
        // å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®éç ´å£Šè¤‡è£½
        return this.layerManager.layers.map(layer => ({
            ...layer,
            graphics: this.cloneGraphics(layer.graphics),
            transform: layer.transform.clone(),
            id: layer.id + '_frame_' + this.frames.length
        }));
    }
    
    cloneGraphics(graphics) {
        // PIXI.Graphicså®Œå…¨è¤‡è£½
        const cloned = new PIXI.Graphics();
        cloned.geometry = graphics.geometry.clone();
        cloned.shader = graphics.shader;
        cloned.transform.copyFrom(graphics.transform);
        cloned.alpha = graphics.alpha;
        cloned.tint = graphics.tint;
        cloned.blendMode = graphics.blendMode;
        return cloned;
    }
    
    async generateThumbnail(frame, size = 64) {
        // ãƒ•ãƒ¬ãƒ¼ãƒ å†…å®¹ã‚’ã‚µãƒ ãƒã‚¤ãƒ«ç”»åƒã¨ã—ã¦ç”Ÿæˆ
        const tempApp = new PIXI.Application({
            width: size,
            height: size,
            backgroundColor: 0xf0e0d6,
            preserveDrawingBuffer: true
        });
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»
        frame.layers.forEach(layer => {
            if (layer.visible) {
                tempApp.stage.addChild(layer.graphics);
            }
        });
        
        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Ÿè¡Œ
        tempApp.renderer.render(tempApp.stage);
        
        // ã‚µãƒ ãƒã‚¤ãƒ«ç”»åƒãƒ‡ãƒ¼ã‚¿å–å¾—
        const canvas = tempApp.renderer.extract.canvas(tempApp.stage);
        const thumbnailData = canvas.toDataURL('image/png');
        
        // ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
        tempApp.destroy();
        
        return {
            dataURL: thumbnailData,
            size: size,
            generated: Date.now()
        };
    }
    
    // ãƒ•ãƒ¬ãƒ¼ãƒ æ“ä½œãƒ¡ã‚½ãƒƒãƒ‰
    duplicateFrame(frameIndex) {
        const sourceFrame = this.frames[frameIndex];
        if (!sourceFrame) return null;
        
        const duplicatedFrame = {
            ...sourceFrame,
            id: this.generateFrameId(),
            index: this.frames.length,
            layers: this.cloneLayers(sourceFrame.layers),
            created: Date.now()
        };
        
        this.frames.push(duplicatedFrame);
        return duplicatedFrame;
    }
    
    deleteFrame(frameIndex) {
        if (this.frames.length <= 1) {
            console.warn('æœ€å¾Œã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¯å‰Šé™¤ã§ãã¾ã›ã‚“');
            return false;
        }
        
        this.frames.splice(frameIndex, 1);
        
        // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†æ§‹ç¯‰
        this.frames.forEach((frame, index) => {
            frame.index = index;
        });
        
        // ã‚«ãƒ¬ãƒ³ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ èª¿æ•´
        if (this.currentFrame >= this.frames.length) {
            this.currentFrame = this.frames.length - 1;
        }
        
        return true;
    }
    
    setCurrentFrame(frameIndex) {
        if (frameIndex >= 0 && frameIndex < this.frames.length) {
            this.currentFrame = frameIndex;
            this.loadFrameToCanvas(frameIndex);
            return true;
        }
        return false;
    }
    
    loadFrameToCanvas(frameIndex) {
        const frame = this.frames[frameIndex];
        if (!frame) return;
        
        // ç¾åœ¨ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
        this.layerManager.clearAllLayers();
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾©å…ƒ
        frame.layers.forEach(layer => {
            this.layerManager.addLayer(layer);
        });
    }
}
```

#### ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³UIå®Ÿè£…
```javascript
// js/animation/timeline-ui.jsï¼ˆ400è¡Œä»¥ä¸‹ï¼‰
/**
 * ğŸ¯ AI_WORK_SCOPE: ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³UIãƒ»ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºãƒ»å†ç”Ÿåˆ¶å¾¡
 * ğŸ¯ DEPENDENCIES: js/animation/frame-manager.js, libs/pixi-extensions.js
 * ğŸ¯ PIXI_EXTENSIONS: uiï¼ˆãƒœã‚¿ãƒ³ãƒ»ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼‰ã€gsapï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
 * ğŸ“‹ PHASE_TARGET: Phase3
 */
class TimelineUI {
    constructor(frameManager) {
        this.frameManager = frameManager;
        this.hasPixiUI = window.PixiExtensions.hasFeature('ui');
        this.hasGSAP = window.PixiExtensions.hasFeature('gsap');
        this.isPlaying = false;
        this.playbackTimer = null;
        
        this.setupTimeline();
    }
    
    setupTimeline() {
        this.timelineContainer = new PIXI.Container();
        
        // å†ç”Ÿåˆ¶å¾¡ãƒœã‚¿ãƒ³ç¾¤
        this.createPlaybackControls();
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºã‚¨ãƒªã‚¢
        this.createFrameDisplay();
        
        // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¨­å®š
        this.createTimelineSettings();
    }
    
    createPlaybackControls() {
        const buttonY = 10;
        let buttonX = 10;
        
        // å†ç”Ÿ/ä¸€æ™‚åœæ­¢ãƒœã‚¿ãƒ³
        this.playButton = this.createButton('â–¶', buttonX, buttonY, () => {
            this.togglePlayback();
        });
        buttonX += 50;
        
        // åœæ­¢ãƒœã‚¿ãƒ³
        this.stopButton = this.createButton('â¹', buttonX, buttonY, () => {
            this.stopPlayback();
        });
        buttonX += 50;
        
        // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ãƒœã‚¿ãƒ³
        this.prevButton = this.createButton('â®', buttonX, buttonY, () => {
            this.previousFrame();
        });
        buttonX += 50;
        
        // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ãƒœã‚¿ãƒ³
        this.nextButton = this.createButton('â­', buttonX, buttonY, () => {
            this.nextFrame();
        });
        buttonX += 50;
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ è¿½åŠ ãƒœã‚¿ãƒ³
        this.addFrameButton = this.createButton('â•', buttonX, buttonY, () => {
            this.frameManager.createFrame();
            this.updateFrameDisplay();
        });
    }
    
    createButton(text, x, y, callback) {
        let button;
        
        if (this.hasPixiUI) {
            // @pixi/uiä½¿ç”¨
            const Button = window.PixiExtensions.getComponent('ui', 'Button');
            button = new Button({
                text: text,
                backgroundColor: 0x4CAF50,
                borderColor: 0x2E7D32,
                textStyle: { fontSize: 16, fill: 0xffffff }
            });
            
            button.onPress.connect(callback);
        } else {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…
            button = this.createBasicButton(text, callback);
        }
        
        button.x = x;
        button.y = y;
        this.timelineContainer.addChild(button);
        
        return button;
    }
    
    createFrameDisplay() {
        this.frameDisplayContainer = new PIXI.Container();
        this.frameDisplayContainer.y = 60;
        this.timelineContainer.addChild(this.frameDisplayContainer);
        
        this.updateFrameDisplay();
    }
    
    updateFrameDisplay() {
        // æ—¢å­˜ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢
        this.frameDisplayContainer.removeChildren();
        
        const frameWidth = 80;
        const frameHeight = 60;
        const frameSpacing = 10;
        
        this.frameManager.frames.forEach((frame, index) => {
            const frameItem = this.createFrameItem(frame, index, frameWidth, frameHeight);
            frameItem.x = index * (frameWidth + frameSpacing);
            frameItem.y = 0;
            
            // ã‚«ãƒ¬ãƒ³ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            if (index === this.frameManager.currentFrame) {
                frameItem.tint = 0x2196F3; // é’è‰²ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            }
            
            this.frameDisplayContainer.addChild(frameItem);
        });
    }
    
    createFrameItem(frame, index, width, height) {
        const frameItem = new PIXI.Container();
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ èƒŒæ™¯
        const background = new PIXI.Graphics();
        background.beginFill(0xE0E0E0);
        background.lineStyle(2, 0x888888);
        background.drawRect(0, 0, width, height);
        background.endFill();
        frameItem.addChild(background);
        
        // ã‚µãƒ ãƒã‚¤ãƒ«è¡¨ç¤º
        if (frame.thumbnail) {
            const thumbnailTexture = PIXI.Texture.from(frame.thumbnail.dataURL);
            const thumbnail = new PIXI.Sprite(thumbnailTexture);
            thumbnail.width = width - 4;
            thumbnail.height = height - 20;
            thumbnail.x = 2;
            thumbnail.y = 2;
            frameItem.addChild(thumbnail);
        }
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ ç•ªå·
        const frameNumber = new PIXI.Text(`${index + 1}`, {
            fontSize: 12,
            fill: 0x000000,
            fontFamily: 'monospace'
        });
        frameNumber.x = 2;
        frameNumber.y = height - 16;
        frameItem.addChild(frameNumber);
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“
        const frameTime = new PIXI.Text(`${frame.duration}ms`, {
            fontSize: 10,
            fill: 0x666666,
            fontFamily: 'monospace'
        });
        frameTime.x = width - frameTime.width - 2;
        frameTime.y = height - 16;
        frameItem.addChild(frameTime);
        
        // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        frameItem.interactive = true;
        frameItem.buttonMode = true;
        frameItem.on('pointertap', () => {
            this.frameManager.setCurrentFrame(index);
            this.updateFrameDisplay();
        });
        
        return frameItem;
    }
    
    togglePlayback() {
        if (this.isPlaying) {
            this.pausePlayback();
        } else {
            this.startPlayback();
        }
    }
    
    startPlayback() {
        if (this.frameManager.frames.length <= 1) return;
        
        this.isPlaying = true;
        this.playButton.text = 'â¸';
        
        const frameInterval = 1000 / this.frameManager.frameRate;
        this.playbackTimer = setInterval(() => {
            let nextFrame = this.frameManager.currentFrame + 1;
            if (nextFrame >= this.frameManager.frames.length) {
                nextFrame = 0; // ãƒ«ãƒ¼ãƒ—å†ç”Ÿ
            }
            
            this.frameManager.setCurrentFrame(nextFrame);
            this.updateFrameDisplay();
        }, frameInterval);
    }
    
    pausePlayback() {
        this.isPlaying = false;
        this.playButton.text = 'â–¶';
        
        if (this.playbackTimer) {
            clearInterval(this.playbackTimer);
            this.playbackTimer = null;
        }
    }
    
    stopPlayback() {
        this.pausePlayback();
        this.frameManager.setCurrentFrame(0);
        this.updateFrameDisplay();
    }
}
```

### Phase3.2: ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³ãƒ»GIFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè£…
**æœŸé–“**: 3é€±é–“ãƒ»ç›®æ¨™: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶ä½œæ©Ÿèƒ½å®Œæˆ

#### ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³å®Ÿè£…
```javascript
// js/animation/onion-skin.jsï¼ˆ200è¡Œä»¥ä¸‹ï¼‰
class OnionSkin {
    constructor(frameManager) {
        this.frameManager = frameManager;
        this.enabled = true;
        this.beforeFrames = 2;  // å‰ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºæ•°
        this.afterFrames = 2;   // å¾Œãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºæ•°
        this.opacity = 0.3;     // ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³é€æ˜åº¦
        this.beforeColor = 0xFF0000; // å‰ãƒ•ãƒ¬ãƒ¼ãƒ è‰²ï¼ˆèµ¤ï¼‰
        this.afterColor = 0x0000FF;  // å¾Œãƒ•ãƒ¬ãƒ¼ãƒ è‰²ï¼ˆé’ï¼‰
    }
    
    updateOnionSkin(stage) {
        if (!this.enabled) return
    updateOnionSkin(stage) {
        if (!this.enabled) return;
        
        // æ—¢å­˜ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³ã‚’ã‚¯ãƒªã‚¢
        this.clearOnionSkin(stage);
        
        const currentIndex = this.frameManager.currentFrame;
        
        // å‰ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºï¼ˆèµ¤ç³»ï¼‰
        for (let i = 1; i <= this.beforeFrames; i++) {
            const prevIndex = currentIndex - i;
            if (prevIndex >= 0) {
                const opacity = this.opacity * (1 - (i - 1) * 0.15);
                this.showFrameAsOnion(stage, prevIndex, opacity, this.beforeColor);
            }
        }
        
        // å¾Œãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºï¼ˆé’ç³»ï¼‰  
        for (let i = 1; i <= this.afterFrames; i++) {
            const nextIndex = currentIndex + i;
            if (nextIndex < this.frameManager.frames.length) {
                const opacity = this.opacity * (1 - (i - 1) * 0.15);
                this.showFrameAsOnion(stage, nextIndex, opacity, this.afterColor);
            }
        }
    }
    
    showFrameAsOnion(stage, frameIndex, opacity, tint) {
        const frame = this.frameManager.frames[frameIndex];
        if (!frame) return;
        
        frame.layers.forEach(layer => {
            if (!layer.visible) return;
            
            // ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³ç”¨ã‚³ãƒ³ãƒ†ãƒŠä½œæˆ
            const onionContainer = new PIXI.Container();
            onionContainer.name = `onion_skin_${frameIndex}`;
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹è¤‡è£½
            const onionGraphics = layer.graphics.clone();
            onionGraphics.alpha = opacity;
            onionGraphics.tint = tint;
            
            onionContainer.addChild(onionGraphics);
            stage.addChild(onionContainer);
        });
    }
    
    clearOnionSkin(stage) {
        // ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³ã‚³ãƒ³ãƒ†ãƒŠã‚’ã™ã¹ã¦å‰Šé™¤
        const onionContainers = stage.children.filter(child => 
            child.name && child.name.startsWith('onion_skin_')
        );
        
        onionContainers.forEach(container => {
            stage.removeChild(container);
            container.destroy();
        });
    }
    
    setEnabled(enabled) {
        this.enabled = enabled;
        if (!enabled) {
            // ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³ã‚’å®Œå…¨ã‚¯ãƒªã‚¢
            this.clearOnionSkin(this.frameManager.layerManager.app.stage);
        }
    }
}
```

#### GIFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè£…
```javascript
// js/animation/gif-exporter.jsï¼ˆ300è¡Œä»¥ä¸‹ï¼‰
/**
 * ğŸ¯ AI_WORK_SCOPE: GIFã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”Ÿæˆãƒ»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ»å“è³ªæœ€é©åŒ–
 * ğŸ¯ DEPENDENCIES: js/animation/frame-manager.js
 * ğŸ¯ NODE_MODULES: pixi.jsï¼ˆApplication, RenderTextureï¼‰
 * ğŸ¯ PIXI_EXTENSIONS: gifï¼ˆ@pixi/gifä½¿ç”¨æ™‚ï¼‰ã€lodashï¼ˆãƒ‡ãƒ¼ã‚¿å‡¦ç†æœ€é©åŒ–ï¼‰
 * ğŸ“‹ PHASE_TARGET: Phase3
 * ğŸ“‹ PERFORMANCE_TARGET: 1080p/60fps/10MBä»¥ä¸‹
 */
class GIFExporter {
    constructor(frameManager) {
        this.frameManager = frameManager;
        this.hasPixiGIF = window.PixiExtensions.hasFeature('gif');
        this.hasLodash = window.PixiExtensions.hasFeature('lodash');
        
        // GIF.js ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹•çš„èª­ã¿è¾¼ã¿æº–å‚™
        this.gifJSLoaded = false;
    }
    
    async exportGIF(options = {}) {
        const {
            width = 400,
            height = 400,
            quality = 10,    // 1-20 (lower = better)
            repeat = 0,      // 0 = ç„¡é™ãƒ«ãƒ¼ãƒ—
            frameRate = null, // null = ãƒ•ãƒ¬ãƒ¼ãƒ å€‹åˆ¥æ™‚é–“ä½¿ç”¨
            optimize = true   // GIFã‚µã‚¤ã‚ºæœ€é©åŒ–
        } = options;
        
        console.log('ğŸ¬ GIFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆé–‹å§‹...');
        
        if (this.frameManager.frames.length === 0) {
            throw new Error('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãŒã‚ã‚Šã¾ã›ã‚“');
        }
        
        // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ–¹å¼é¸æŠ
        if (this.hasPixiGIF) {
            return await this.exportWithPixiGIF(options);
        } else {
            return await this.exportWithGIFJS(options);
        }
    }
    
    async exportWithPixiGIF(options) {
        console.log('ğŸ“¦ @pixi/gifä½¿ç”¨ã§ã®GIFç”Ÿæˆ...');
        
        try {
            // @pixi/gifä½¿ç”¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆå®Ÿè£…äºˆå®šï¼‰
            const AnimatedGIF = window.PixiExtensions.getComponent('gif', 'AnimatedGIF');
            const gifAnimation = new AnimatedGIF();
            
            // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¿½åŠ 
            for (const frame of this.frameManager.frames) {
                const frameCanvas = await this.frameToCanvas(frame, options.width, options.height);
                gifAnimation.addFrame(frameCanvas, frame.duration);
            }
            
            // GIFç”Ÿæˆ
            const gifBlob = await gifAnimation.export({
                quality: options.quality,
                repeat: options.repeat
            });
            
            return {
                blob: gifBlob,
                size: gifBlob.size,
                frames: this.frameManager.frames.length,
                exportMethod: 'pixi-gif'
            };
            
        } catch (error) {
            console.warn('âš ï¸ @pixi/gifä½¿ç”¨å¤±æ•—, ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã«åˆ‡ã‚Šæ›¿ãˆ:', error);
            return await this.exportWithGIFJS(options);
        }
    }
    
    async exportWithGIFJS(options) {
        console.log('ğŸ“¦ GIF.jsä½¿ç”¨ã§ã®GIFç”Ÿæˆ...');
        
        // GIF.js ã®å‹•çš„èª­ã¿è¾¼ã¿
        if (!this.gifJSLoaded) {
            await this.loadGIFJS();
        }
        
        // GIF.js ã§ã®GIFç”Ÿæˆ
        const gif = new GIF({
            workers: 2,
            quality: options.quality,
            width: options.width,
            height: options.height,
            repeat: options.repeat,
            transparent: 0xf0e0d6 // ãµãŸã°èƒŒæ™¯è‰²ã‚’é€æ˜ã¨ã—ã¦æ‰±ã†
        });
        
        // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤º
        gif.on('progress', (progress) => {
            console.log(`ğŸ”„ GIFç”Ÿæˆé€²æ—: ${Math.round(progress * 100)}%`);
        });
        
        // å„ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’GIFã«è¿½åŠ 
        for (const frame of this.frameManager.frames) {
            const canvas = await this.frameToCanvas(frame, options.width, options.height);
            const delay = options.frameRate ? (1000 / options.frameRate) : frame.duration;
            gif.addFrame(canvas, { delay: delay });
        }
        
        // GIFç”Ÿæˆå®Ÿè¡Œ
        return new Promise((resolve, reject) => {
            gif.on('finished', (blob) => {
                console.log(`âœ… GIFç”Ÿæˆå®Œäº†: ${Math.round(blob.size / 1024)}KB`);
                resolve({
                    blob: blob,
                    size: blob.size,
                    frames: this.frameManager.frames.length,
                    exportMethod: 'gif-js'
                });
            });
            
            gif.on('error', reject);
            gif.render();
        });
    }
    
    async frameToCanvas(frame, width, height) {
        // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é«˜å“è³ªCanvasã«å¤‰æ›
        const tempApp = new PIXI.Application({
            width: width,
            height: height,
            backgroundColor: 0xf0e0d6, // ãµãŸã°èƒŒæ™¯è‰²
            preserveDrawingBuffer: true,
            antialias: true
        });
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æç”»
        frame.layers.forEach(layer => {
            if (layer.visible) {
                const clonedGraphics = layer.graphics.clone();
                clonedGraphics.transform.copyFrom(layer.transform);
                tempApp.stage.addChild(clonedGraphics);
            }
        });
        
        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Ÿè¡Œ
        tempApp.renderer.render(tempApp.stage);
        
        // Canvasè¦ç´ å–å¾—
        const canvas = tempApp.renderer.extract.canvas(tempApp.stage);
        
        // ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
        tempApp.destroy();
        
        return canvas;
    }
    
    async loadGIFJS() {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js';
            script.onload = () => {
                this.gifJSLoaded = true;
                resolve();
            };
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒŸãƒ‹GIFç”Ÿæˆ
    async generatePreview(maxFrames = 10) {
        const previewFrames = this.frameManager.frames.slice(0, maxFrames);
        const tempFrameManager = { frames: previewFrames };
        
        const previewGIF = await this.exportGIF.call(
            { frameManager: tempFrameManager, ...this },
            {
                width: 200,
                height: 200,
                quality: 15, // ä½å“è³ªã§ã‚µã‚¤ã‚ºå‰Šæ¸›
                frameRate: 8 // ä½ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ
            }
        );
        
        return previewGIF;
    }
}
```

---

## ğŸš€ Phase4: PixiJS v8ç§»è¡Œï¼ˆæ¬¡ä¸–ä»£ç‰ˆï¼‰
ï¼ˆé•·ã„ã®ã¨pixi,jsV8åŒ–ç§»è¡Œãªã®ã§ã€åˆ‡ã‚Šå–ã£ã¦åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«ç§»å‹•ã—ã¦ã¾ã™ï¼‰

---

## ğŸ“Š Phase3ãƒ†ã‚¹ãƒˆãƒ»å“è³ªä¿è¨¼

### Phase3ãƒ†ã‚¹ãƒˆ: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½
**åŸºæº–**: GIFåˆ¶ä½œãƒ»ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†ãƒ»ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³å®Œå…¨å‹•ä½œ

```javascript
class Phase3TestSuite {
    async runTests() {
        console.log('ğŸ§ª Phase3ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–‹å§‹');
        
        await this.testFrameManagement();
        await this.testOnionSkinFunctionality();
        await this.testGIFExport();
        await this.testTimelineUI();
        
        console.log('âœ… Phase3ãƒ†ã‚¹ãƒˆå®Œäº†');
    }
    
    async testFrameManagement() {
        const frameManager = new FrameManager();
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆãƒ†ã‚¹ãƒˆ
        const frame1 = await frameManager.createFrame();
        const frame2 = await frameManager.createFrame();
        
        if (frameManager.frames.length !== 2) {
            throw new Error('ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆãƒ†ã‚¹ãƒˆå¤±æ•—');
        }
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ è¤‡è£½ãƒ†ã‚¹ãƒˆ
        const duplicatedFrame = frameManager.duplicateFrame(0);
        if (!duplicatedFrame || frameManager.frames.length !== 3) {
            throw new Error('ãƒ•ãƒ¬ãƒ¼ãƒ è¤‡è£½ãƒ†ã‚¹ãƒˆå¤±æ•—');
        }
        
        // ãƒ•ãƒ¬ãƒ¼ãƒ å‰Šé™¤ãƒ†ã‚¹ãƒˆ
        const deleteResult = frameManager.deleteFrame(1);
        if (!deleteResult || frameManager.frames.length !== 2) {
            throw new Error('ãƒ•ãƒ¬ãƒ¼ãƒ å‰Šé™¤ãƒ†ã‚¹ãƒˆå¤±æ•—');
        }
        
        console.log('âœ… ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†');
    }
    
    async testGIFExport() {
        const frameManager = new FrameManager();
        
        // ãƒ†ã‚¹ãƒˆç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ
        await frameManager.createFrame();
        await frameManager.createFrame();
        
        const gifExporter = new GIFExporter(frameManager);
        
        // GIFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ†ã‚¹ãƒˆ
        const gifResult = await gifExporter.exportGIF({
            width: 200,
            height: 200,
            quality: 15
        });
        
        if (!gifResult.blob || !(gifResult.blob instanceof Blob)) {
            throw new Error('GIFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ†ã‚¹ãƒˆå¤±æ•—');
        }
        
        if (gifResult.blob.size === 0) {
            throw new Error('GIFãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒ0');
        }
        
        console.log(`âœ… GIFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†: ${Math.round(gifResult.blob.size / 1024)}KB`);
    }
}
```

---

## ğŸ¯ æœ€çµ‚æˆæœç‰©ãƒ»æœŸå¾…åŠ¹æœ

### Phase3æˆæœç‰©
- **ğŸ¬ ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ **: 300ãƒ•ãƒ¬ãƒ¼ãƒ å¯¾å¿œãƒ»ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆãƒ»è¤‡è£½/å‰Šé™¤æ©Ÿèƒ½
- **â° ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ UI**: å†ç”Ÿåˆ¶å¾¡ãƒ»ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºãƒ»ç›´æ„Ÿçš„æ“ä½œ
- **ğŸ‘» ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³**: å‰å¾Œãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºãƒ»è‰²åˆ†ã‘ãƒ»é€æ˜åº¦åˆ¶å¾¡
- **ğŸ“¦ GIF ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ**: é«˜å“è³ªå‡ºåŠ›ãƒ»åœ§ç¸®æœ€é©åŒ–ãƒ»ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½



---

## ğŸ”§ Phase4å®Ÿè£…é–‹å§‹æ‰‹é †

### å³æ™‚é–‹å§‹å¯èƒ½ã‚¿ã‚¹ã‚¯ï¼ˆPhase3.1ï¼‰

1. **ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†åŸºç›¤å®Ÿè£…**
   ```javascript
   // js/animation/frame-manager.jsä½œæˆ
   // ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆãƒ»è¤‡è£½ãƒ»å‰Šé™¤æ©Ÿèƒ½å®Ÿè£…
   // ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ æ§‹ç¯‰
   ```

2. **ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³UIå®Ÿè£…**  
   ```javascript
   // js/animation/timeline-ui.jsä½œæˆ
   // å†ç”Ÿåˆ¶å¾¡ãƒœã‚¿ãƒ³ç¾¤å®Ÿè£…
   // ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤ºã‚¨ãƒªã‚¢æ§‹ç¯‰
   ```

### Phase3å®Ÿè£…é †åºï¼ˆæ¨å¥¨ï¼‰

**Week 1-3**: ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†ãƒ»ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³åŸºç›¤
- [ ] js/animation/frame-manager.jsï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†ï¼‰
- [ ] js/animation/timeline-ui.jsï¼ˆã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼‰
- [ ] ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆãƒ»å‰Šé™¤ãƒ»ç§»å‹•æ©Ÿèƒ½å®Ÿè£…

**Week 4-6**: ã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³ãƒ»GIFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
- [ ] js/animation/onion-skin.jsï¼ˆã‚ªãƒ‹ã‚ªãƒ³ã‚¹ã‚­ãƒ³ï¼‰
- [ ] js/animation/gif-exporter.jsï¼ˆGIFç”Ÿæˆï¼‰
- [ ] å“è³ªæœ€é©åŒ–ãƒ»æ€§èƒ½ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°

---

