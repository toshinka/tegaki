# 🎨 Tegaki お絵描きツール 根幹改修 ToDo・作業手順書

## 📊 現状分析と根本的問題

### 🔴 現在の致命的問題
1. **キャンバス不出現**: CanvasManager初期化時の引数エラー
2. **ペン描画時の0,0座標直線**: 座標変換の重複処理
3. **ポップアップ消失**: EventBus/ErrorManagerの統合不備
4. **責務分離の破綻**: 描画ロジックが複数箇所に分散

### 🎯 理想設計との乖離
- **現状**: Tool → CanvasManager → PixiJS (直結合・責務混在)
- **理想**: Tool → EventBus → CanvasManager → StateManager (疎結合・責務分離)

---

## 🚀 Phase 1: 緊急修復（基本動作復旧）

### ステップ1.1: CanvasManager初期化修復
**🎯 目標**: キャンバスを正しく出現させる
過度なフォールバック実装に注意！「4. **責務分離の破綻**: 描画ロジックが複数箇所に分散」になる場合があるので、エラー表示程度で良いです。ある程度整えたらphase2に移行してください。app-core.jsのみでの描画可能状態は禁止します。

**📁 修正ファイル**:
- `managers/canvas-manager.js`
- `js/app-core.js`

**🔧 作業内容**:
1. **CanvasManager.initialize()メソッド修正**
   ```javascript
   // 修正前（エラー原因）
   async initialize(appCore, canvasElement) // 引数順序・型不一致
   
   // 修正後
   async initialize(options) {
     const { appCore, canvasElement } = options;
     // 引数検証・フォールバック処理追加
   }
   ```

2. **AppCore呼び出し修正**
   ```javascript
   // app-core.js修正
   await this.canvasManager.initialize({
     appCore: this,
     canvasElement: this.app.view
   });
   ```

**📋 参考定義**: 
- シンボル辞典：`CanvasManager系API`
- ルールブック：`1.1 責務分離の絶対原則`

---

### ステップ1.2: 座標系統一・重複排除
**🎯 目標**: 0,0座標直線バグの完全解消

**📁 修正ファイル**:
- `js/utils/coordinate-manager.js`
- `tools/pen-tool.js`
- `managers/canvas-manager.js`

**🔧 作業内容**:
1. **CoordinateManager集約化**
   ```javascript
   // すべての座標変換をCoordinateManagerに集約
   extractPointerCoordinates(event, rect, pixiApp) {
     // 統一座標変換ロジック
     // 重複処理完全排除
   }
   ```

2. **PenTool座標処理修正**
   ```javascript
   // tools/pen-tool.js
   onPointerDown(event, canvasManager, coordinateManager) {
     // coordinateManager経由でのみ座標取得
     const coords = coordinateManager.extractPointerCoordinates(event);
     // 直接座標計算を完全排除
   }
   ```

**📋 参考定義**:
- シンボル辞典：`CoordinateManager API`
- ルールブック：`座標変換統一`

---

### ステップ1.3: EventBus・ErrorManager修復
**🎯 目標**: ポップアップ・エラー表示の復旧

**📁 修正ファイル**:
- `js/ui/popup-manager.js`
- `js/utils/error-manager.js`
- `js/utils/event-bus.js`

**🔧 作業内容**:
1. **EventBus安全性強化**
   ```javascript
   // safeEmit実装・エラー連鎖防止
   safeEmit(eventType, data) {
     try {
       this.emit(eventType, data);
     } catch (error) {
       console.error(`EventBus安全発行エラー: ${eventType}`, error);
     }
   }
   ```

2. **PopupManager統合修復**
   ```javascript
   // EventBus経由でのポップアップ表示
   window.EventBus.on('error.show', (errorData) => {
     this.showPopup(errorData);
   });
   ```

**📋 参考定義**:
- シンボル辞典：`EventBus API`
- ルールブック：`統一システム活用規約`

---

## 🎨 Phase 2: 責務分離・理想構造化

### ステップ2.1: 描画フロー理想化
**🎯 目標**: Tool → EventBus → CanvasManager フローの確立

**📁 新規作成/修正ファイル**:
- `tools/abstract-tool.js` (新規作成)
- `tools/pen-tool.js` (大幅修正)
- `managers/canvas-manager.js` (責務分離)

**🔧 作業内容**:
1. **AbstractTool基底クラス作成**
   ```javascript
   // tools/abstract-tool.js (新規)
   class AbstractTool {
     // 統一インターフェース定義
     abstract onPointerDown(event, canvasManager, coordinateManager);
     abstract onPointerMove(event, canvasManager, coordinateManager);
     abstract onPointerUp(event, canvasManager, coordinateManager);
     
     // 共通座標処理
     extractCoordinates(event, coordinateManager) {
       return coordinateManager.extractPointerCoordinates(event);
     }
   }
   ```

2. **PenTool責務集約**
   ```javascript
   // tools/pen-tool.js
   class PenTool extends AbstractTool {
     onPointerDown(event, canvasManager, coordinateManager) {
       // 1. 座標取得（CoordinateManager経由）
       const coords = this.extractCoordinates(event, coordinateManager);
       
       // 2. Graphics生成（Tool責務）
       this.currentGraphics = this.createStrokeGraphics();
       this.currentGraphics.moveTo(coords.x, coords.y);
       
       // 3. CanvasManagerに委譲
       canvasManager.addGraphicsToLayer(this.currentGraphics, 'drawing');
       
       // 4. EventBus通知
       window.EventBus.emit('drawing.started', { coords, tool: 'pen' });
     }
   }
   ```

**📋 参考定義**:
- シンボル辞典：`Tool系API`, `AbstractTool統一インターフェース`
- ルールブック：`Tool群：「筆・消しゴム・スプレー」`
- 理想設計：フローチャート参照

---

### ステップ2.2: CanvasManager責務純化
**🎯 目標**: レイヤー・Graphics配置専門化

**📁 修正ファイル**:
- `managers/canvas-manager.js`

**🔧 作業内容**:
1. **描画処理削除・委譲専門化**
   ```javascript
   // 🚫 削除: 直接描画メソッド
   // startDrawing(), continueDrawing() → Tool委譲
   
   // ✅ 強化: レイヤー管理
   addGraphicsToLayer(graphics, layerId) {
     const layer = this.getOrCreateLayer(layerId);
     layer.addChild(graphics);
   }
   
   // ✅ 強化: Tool統合インターフェース
   attachToolGraphics(tool, graphics) {
     // Tool-Graphics接続専門処理
   }
   ```

**📋 参考定義**:
- ルールブック：`CanvasManager：「紙とレイヤーの管理者」`
- シンボル辞典：`許可されるAPI群`, `禁止されるAPI群`

---

### ステップ2.3: StateManager統合強化
**🎯 目標**: Undo/Redo・履歴管理の基盤構築

**📁 修正ファイル**:
- `js/utils/state-manager.js`
- `managers/canvas-manager.js`
- `tools/pen-tool.js`

**🔧 作業内容**:
1. **描画履歴記録システム**
   ```javascript
   // StateManager拡張
   recordStroke(strokeData) {
     this.updateComponentState('drawing', 'strokeHistory', {
       action: 'addStroke',
       data: strokeData,
       timestamp: Date.now()
     });
   }
   ```

2. **Tool-State連携**
   ```javascript
   // PenTool内
   endStroke() {
     // Graphics完成後にStateManagerに記録
     window.StateManager.recordStroke({
       graphics: this.currentGraphics,
       tool: 'pen',
       coordinates: this.strokeCoordinates
     });
   }
   ```

**📋 参考定義**:
- 理想設計：「状態管理（StateManager）が「履歴の正」となる」
- シンボル辞典：`StateManager API`

---

## 🔧 Phase 3: モダンライブラリ活用・最適化

### ステップ3.1: PixiJS v7最適化
**🎯 目標**: パフォーマンス向上・v8準備

**📁 修正ファイル**:
- `libs/pixi-extensions.js`
- `managers/canvas-manager.js`

**🔧 作業内容**:
1. **Graphics最適化**
   ```javascript
   // Graphics Pool実装
   class GraphicsPool {
     static getGraphics() {
       return this.pool.pop() || new PIXI.Graphics();
     }
     
     static returnGraphics(graphics) {
       graphics.clear();
       this.pool.push(graphics);
     }
   }
   ```

2. **RenderTexture活用**
   ```javascript
   // 描画結果のテクスチャ化
   finalizeStroke() {
     const texture = this.app.renderer.generateTexture(this.currentGraphics);
     return new PIXI.Sprite(texture);
   }
   ```

---

### ステップ3.2: パフォーマンス監視
**🎯 目標**: メモリ・フレームレート最適化

**📁 活用ファイル**:
- `js/utils/performance.js`
- `managers/memory-manager.js`

**🔧 作業内容**:
1. **リアルタイム監視**
   ```javascript
   // パフォーマンス計測
   measureDrawingPerformance() {
     const start = performance.now();
     // 描画処理
     const end = performance.now();
     this.recordMetric('drawing', end - start);
   }
   ```

---

## ✅ Phase 4: 品質保証・テスト

### ステップ4.1: 座標精度テスト
**📁 活用ファイル**: `js/utils/coordinate-manager.js`

**🔧 テスト内容**:
```javascript
// 座標変換精度テスト
runCoordinateTest() {
  const testPoints = [[0,0], [100,100], [399,399]];
  testPoints.forEach(point => {
    const converted = this.screenToCanvas(...point);
    // 精度検証・ログ出力
  });
}
```

### ステップ4.2: 責務分離検証
**🔧 検証内容**:
- CanvasManagerに描画処理が残っていないか
- Tool間の直接通信がないか
- EventBus経由の疎結合が保たれているか

---

## 📋 作業優先順位

### 🔥 最高優先（即時実行）
1. ステップ1.1: CanvasManager初期化修復
2. ステップ1.2: 座標系統一
3. ステップ1.3: EventBus修復

### ⚡ 高優先（1週間以内）
4. ステップ2.1: 描画フロー理想化
5. ステップ2.2: CanvasManager責務純化

### 📈 中優先（2週間以内）
6. ステップ2.3: StateManager統合強化
7. ステップ3.1: PixiJS最適化

### 🔮 低優先（Phase2移行前）
8. ステップ3.2: パフォーマンス監視
9. ステップ4.1-4.2: 品質保証テスト

---

## 🎯 成功指標

### Phase 1完了判定
- ✅ キャンバス正常表示
- ✅ ペン描画（0,0直線なし）
- ✅ ポップアップ正常表示
- ✅ エラー処理正常動作

### Phase 2完了判定
- ✅ AbstractTool継承体系
- ✅ 完全責務分離
- ✅ EventBus疎結合
- ✅ StateManager履歴記録

### Phase 3完了判定
- ✅ 60FPS安定描画
- ✅ メモリリーク0
- ✅ PixiJS v8準備完了

---

## 💡 実装時の重要注意点

### 🚫 絶対禁止
- 既存の統一システム（ConfigManager, ErrorManager, StateManager, EventBus）の迂回
- 責務範囲を越えた直接メソッド呼び出し
- 座標変換の重複実装

### ✅ 必須遵守
- シンボル辞典の定義に厳密準拠
- ヘッダーコメント記載規約の遵守
- ES2023モダン構文の積極使用

### 🔄 各ファイル修正時の確認事項
1. そのファイルの責務範囲内か？
2. 統一システム経由でアクセスしているか？
3. 他ファイルとの依存関係は適切か？
4. PixiJS v8移行に対応しているか？

この手順書に従って段階的に実装することで、安定した理想的なお絵描きツールの根幹構造を構築できます。