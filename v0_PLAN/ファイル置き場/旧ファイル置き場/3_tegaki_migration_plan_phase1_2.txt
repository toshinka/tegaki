# 🎨 ふたば☆ちゃんねる風お絵描きツール 移行計画書 Phase1-2版
## HTML単体 → node_modules分割 → 描画機能完成戦略

### 📋 計画概要
**移行戦略**: HTML単体 → node_modules分割 → v8移行の段階戦略
**基本方針**: ローカル依存・CORS制限回避・AI協働開発最適化・非破壊品質保証
**Phase1-2目標**: 分割基盤構築→描画機能完成（v7完成版）

### 🎯 Phase3-4予告ダイジェスト
- **Phase3**: GIFアニメーション・タイムライン・オニオンスキン（v7最終版）
- **Phase4**: PixiJS v8移行・WebGPU・120FPS・SPINE統合（次世代版）

---

## 🏗️ Phase1: HTML単体→node_modules分割移行

### Phase1.1: 基盤分割（vector-drawing-tool.html → 分割構成）
**期間**: 1-2週間  
**目標**: 既存HTML単体ファイルのnode_modules分割・CORS制限回避

#### 分割対象・手順
**Step1: ディレクトリ構成作成**
```
vector-drawing-tool.html（1000行超）
↓ 分割
├─ index.html（node_modules統合・100行以下）
├─ package.json（依存関係管理）
├─ node_modules/（ローカルライブラリ）
├─ css/styles.css（ふたば風スタイル・300行以下）
├─ libs/pixi-extensions.js（拡張統合・300行以下）
└─ js/main.js（初期化エントリーポイント・100行以下）
```

**Step2: node_modules依存関係構築**
```bash
# package.json作成（既存活用）
npm install

# 依存ライブラリ確認
pixi.js@^7.4.3
@pixi/ui@^1.2.4
@pixi/layers@^2.1.0
@pixi/gif@^2.1.1
gsap@^3.13.0
lodash@^4.17.21
hammerjs@^2.0.8
@tabler/icons-react": "^3.34.1
```

**Step3: HTML分離実装**
```html
<!-- index.html: node_modules統合版 -->
<!DOCTYPE html>
<html lang="ja">
<head>
    <title>🎨 ふたば☆ちゃんねる風ベクターお絵描きツール v1.0</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- node_modules統合・ローカル読み込み -->
    <script src="./node_modules/pixi.js/dist/pixi.js"></script>
    <script src="./node_modules/@pixi/ui/dist/pixi-ui.js"></script>
    <script src="./node_modules/@pixi/layers/dist/pixi-layers.js"></script>
    <script src="./node_modules/@pixi/gif/dist/pixi-gif.js"></script>
    <script src="./node_modules/gsap/dist/gsap.js"></script>
    <script src="./node_modules/lodash/lodash.js"></script>
    <script src="./node_modules/hammerjs/hammer.min.js"></script>
    
    <!-- PixiJS拡張統合ライブラリ -->
    <script src="libs/pixi-extensions.js"></script>
    
    <!-- アプリケーション本体 -->
    <script src="js/main.js"></script>
    
    <div id="app-root"></div>
</body>
</html>
```

**Step4: libs/pixi-extensions.js実装**
```javascript
// libs/pixi-extensions.js - 拡張統合基盤（300行以下）
class PixiExtensionsManager {
    constructor() {
        this.extensions = new Map();
        this.initialized = false;
    }
    
    async initialize() {
        console.log('🔧 PixiJS拡張ライブラリ統合開始...');
        
        // 基本検証
        this.validateCoreLibraries();
        
        // 拡張統合
        this.integrateExtensions();
        
        this.initialized = true;
        console.log('✅ PixiJS拡張ライブラリ統合完了');
    }
    
    validateCoreLibraries() {
        if (!window.PIXI) throw new Error('PixiJS が読み込まれていません');
        console.log(`✅ PixiJS v${PIXI.VERSION} 検出`);
    }
    
    integrateExtensions() {
        // @pixi/ui統合
        if (window.PIXI?.UI) {
            this.extensions.set('ui', { available: true, components: window.PIXI.UI });
            console.log('✅ @pixi/ui 統合完了');
        }
        
        // @pixi/layers統合
        if (window.PIXI?.display) {
            this.extensions.set('layers', { available: true, Layer: window.PIXI.display.Layer });
            console.log('✅ @pixi/layers 統合完了');
        }
        
        // その他ライブラリ統合...
    }
    
    hasFeature(feature) {
        return this.extensions.get(feature)?.available || false;
    }
}

window.PixiExtensions = new PixiExtensionsManager();
```

**Step5: JavaScript機能分割**
```
<script>部分（800行超）
↓ 機能別分割
├─ js/app-core.js（PixiJS基盤・300行以下）
├─ js/managers/（統括管理層）
│  ├─ ui-manager.js（UI統括・400行以下）
│  ├─ tool-manager.js（ツール統括・300行以下）
│  └─ canvas-manager.js（キャンバス制御・300行以下）
├─ js/tools/（ツール群・各300行以下）
│  ├─ pen-tool.js（ペン専用）
│  └─ eraser-tool.js（消しゴム専用）
└─ js/ui/（UI群・各200行以下）
   ├─ popup-manager.js（ポップアップ）
   └─ slider-manager.js（スライダー）
```

#### 移行品質基準
- [ ] 既存HTML機能100%再現
- [ ] node_modulesライブラリ正常動作確認
- [ ] CORS制限回避・ローカル動作確認
- [ ] ファイルサイズ制限遵守（各500行以下）
- [ ] AI分業開発テスト成功

### Phase1.2: AI分業開発基盤構築
**期間**: 1週間  
**目標**: AI協働開発パターン確立・必要最小限ファイル特定

#### 分業パターン実装
**パターンA: ペンツール改修**
```javascript
// 🎯 必要ファイル（AI添付対象）:
files: [
    'libs/pixi-extensions.js',        // 拡張統合基盤
    'js/main.js',                     // 初期化
    'js/app-core.js',                 // PixiJS基盤
    'js/managers/tool-manager.js',    // ツール統括
    'js/tools/pen-tool.js'            // ペン専用（改修対象）
]
// 🎯 除外可能: ui/*.js, layers/*.js, animation/*.js
```

**パターンB: UI改修**
```javascript
// 🎯 必要ファイル（AI添付対象）:
files: [
    'libs/pixi-extensions.js',        // 拡張統合基盤
    'js/main.js',                     // 初期化
    'js/app-core.js',                 // PixiJS基盤
    'js/managers/ui-manager.js',      // UI統括
    'js/ui/popup-manager.js'          // ポップアップ（改修対象）
]
// 🎯 除外可能: tools/*.js, layers/*.js, animation/*.js
```

#### AI分業識別システム
各ファイル先頭に分業情報埋め込み：
```javascript
/**
 * 🎨 ふたば☆ちゃんねる風ベクターお絵描きツール v1.0
 * 🎯 AI_WORK_SCOPE: ペンツール専用ファイル
 * 🎯 DEPENDENCIES: main.js, app-core.js, managers/tool-manager.js
 * 🎯 NODE_MODULES: pixi.js（本体のみ）
 * 🎯 PIXI_EXTENSIONS: なし
 * 🎯 ISOLATION_TEST: ✅ 単体テスト可能
 * 🎯 SPLIT_THRESHOLD: 300行超過時 → pen-settings.js分割
 */
```

### Phase1.3: 非破壊変形基盤実装
**期間**: 2週間  
**目標**: ベクター変形システム・アニメ制作品質保証

#### 非破壊変形システム構築
```javascript
// js/transform/vector-transform.js
class VectorTransform {
    applyTransform(layer, transform) {
        // ✅ ベクター変形（非破壊）
        layer.transform.setFromMatrix(transform);
        
        // ✅ 履歴記録（完全復元可能）
        MemoryManager.record('transform', {
            layerId: layer.id,
            transform: transform.clone(),
            beforeState: layer.getOriginalState()
        });
    }
    
    // 品質保証メソッド
    validateVectorQuality(graphics) {
        return graphics instanceof PIXI.Graphics && 
               graphics.geometry.points.length > 0;
    }
}
```

#### 変形品質保証システム
- **回転品質**: 360度回転後の完全復元確認
- **拡縮品質**: 拡大・縮小での品質劣化防止
- **履歴品質**: アンドゥ・リドゥでの完全復元確認
- **メモリ効率**: 変形履歴のメモリ最適化

---

## 🎨 Phase2: 描画機能完成（v7完成版）

### Phase2.1: レイヤーシステム完全実装
**期間**: 3週間  
**目標**: プロ級レイヤー機能・アニメ制作準備完了

#### レイヤー機能要件
```javascript
// js/layers/layer-manager.js（500行以下）
class LayerManager {
    constructor() {
        this.layers = [];
        this.currentLayer = null;
        this.hasPixiLayers = window.PixiExtensions.hasFeature('layers');
    }
    
    createLayer(options = {}) {
        const layer = {
            id: generateId(),
            name: options.name || `Layer ${this.layers.length + 1}`,
            opacity: options.opacity || 1.0,
            blendMode: options.blendMode || 'normal',
            visible: true,
            locked: false,
            container: this.createLayerContainer()
        };
        
        // 非破壊変形対応
        layer.originalTransform = new PIXI.Matrix();
        this.layers.push(layer);
        return layer;
    }
    
    createLayerContainer() {
        if (this.hasPixiLayers) {
            // @pixi/layers使用
            const Layer = window.PixiExtensions.getComponent('layers', 'Layer');
            return new Layer();
        } else {
            // 基本Container使用
            return new PIXI.Container();
        }
    }
    
    // フォルダ機能
    createLayerFolder(name) {
        return {
            id: generateId(),
            name,
            type: 'folder',
            children: [],
            collapsed: false
        };
    }
    
    moveLayerToFolder(layer, folder) {
        folder.children.push(layer.id);
        layer.parentFolder = folder.id;
    }
    
    setLayerOpacity(layer, opacity) {
        layer.opacity = Math.max(0, Math.min(1, opacity));
        layer.container.alpha = layer.opacity;
    }
}
```

#### レイヤーUI実装
```javascript
// js/layers/layer-ui.js（400行以下）
class LayerUI {
    constructor(layerManager) {
        this.layerManager = layerManager;
        this.hasPixiUI = window.PixiExtensions.hasFeature('ui');
        this.setupUI();
    }
    
    setupUI() {
        if (this.hasPixiUI) {
            // @pixi/ui使用
            this.createPixiUIComponents();
        } else {
            // フォールバック実装
            this.createBasicUIComponents();
        }
    }
    
    createPixiUIComponents() {
        // @pixi/ui.Button活用
        const Button = window.PixiExtensions.getComponent('ui', 'Button');
        
        this.addLayerButton = new Button({
            text: 'レイヤー追加',
            backgroundColor: 0x4CAF50
        });
        
        this.addLayerButton.onPress.connect(() => {
            this.layerManager.createLayer();
        });
    }
    
    createBasicUIComponents() {
        // 基本PIXI.Graphics使用
        this.addLayerButton = new PIXI.Graphics();
        this.addLayerButton.beginFill(0x4CAF50);
        this.addLayerButton.drawRoundedRect(0, 0, 120, 30, 5);
        this.addLayerButton.endFill();
        this.addLayerButton.interactive = true;
        
        this.addLayerButton.on('pointertap', () => {
            this.layerManager.createLayer();
        });
    }
}
```

### Phase2.2: 高度描画ツール実装
**期間**: 3週間  
**目標**: プロ級描画ツール群完成

#### バケツツール実装
```javascript
// js/tools/bucket-tool.js（400行以下）
class BucketTool {
    constructor(toolManager) {
        this.toolManager = toolManager;
        this.tolerance = 32; // 色の許容範囲
        this.hasLodash = window.PixiExtensions.hasFeature('lodash');
    }
    
    async fill(x, y, color) {
        // 対象ピクセル取得
        const targetPixels = await this.getTargetPixels(x, y);
        
        if (this.hasLodash) {
            // Lodash活用でピクセル処理最適化
            const _ = window.PixiExtensions.getComponent('lodash', '_');
            const fillQueue = _.cloneDeep(targetPixels);
            
            // 効率的な重複除去・処理
            const uniquePixels = _.uniqBy(fillQueue, pixel => `${pixel.x}-${pixel.y}`);
            return this.createFillGraphics(uniquePixels, color);
        } else {
            // 基本実装
            return this.basicFill(targetPixels, color);
        }
    }
    
    createFillGraphics(pixels, color) {
        // 非破壊フィル実装
        const fillGraphics = new PIXI.Graphics();
        fillGraphics.beginFill(color);
        
        // フラッドフィル アルゴリズム
        pixels.forEach(pixel => {
            fillGraphics.drawRect(pixel.x, pixel.y, 1, 1);
        });
        
        fillGraphics.endFill();
        return fillGraphics;
    }
}
```

#### 選択ツール実装
```javascript
// js/tools/selection-tool.js（500行以下）
class SelectionTool {
    constructor(toolManager) {
        this.toolManager = toolManager;
        this.selectionType = 'rectangular'; // rectangular, lasso, magic
    }
    
    createRectangularSelection(startX, startY, endX, endY) {
        const selection = {
            type: 'rectangular',
            bounds: new PIXI.Rectangle(startX, startY, endX - startX, endY - startY),
            graphics: this.createSelectionGraphics(startX, startY, endX, endY)
        };
        
        return selection;
    }
    
    createSelectionGraphics(x1, y1, x2, y2) {
        const graphics = new PIXI.Graphics();
        
        // 選択範囲の点線枠描画
        graphics.lineStyle(2, 0x000000, 1);
        graphics.setLineDash([5, 5]);
        graphics.drawRect(x1, y1, x2 - x1, y2 - y1);
        
        return graphics;
    }
    
    // マジック選択（色による自動選択）
    createMagicSelection(x, y, tolerance = 32) {
        const targetColor = this.getPixelColor(x, y);
        const selectedPixels = this.findSimilarPixels(targetColor, tolerance);
        
        return {
            type: 'magic',
            pixels: selectedPixels,
            graphics: this.createMagicSelectionGraphics(selectedPixels)
        };
    }
}
```

### Phase2.3: ショートカット完全実装
**期間**: 1週間  
**目標**: キーボード・タッチ操作完全対応

#### ショートカット実装
```javascript
// js/managers/input-manager.js（400行以下）
class InputManager {
    constructor(appCore) {
        this.appCore = appCore;
        this.hasHammer = window.PixiExtensions.hasFeature('hammer');
        this.setupKeyboardShortcuts();
        this.setupTouchGestures();
    }
    
    setupKeyboardShortcuts() {
        const shortcuts = {
            'Ctrl+Z': () => this.undo(),
            'Ctrl+Y': () => this.redo(),
            'Ctrl+A': () => this.selectAll(),
            '[': () => this.decreaseBrushSize(),
            ']': () => this.increaseBrushSize(),
            'Space': () => this.togglePanMode(),
            'Delete': () => this.deleteSelected(),
            'Ctrl+C': () => this.copy(),
            'Ctrl+V': () => this.paste(),
            'Ctrl+S': () => this.save()
        };
        
        document.addEventListener('keydown', (e) => {
            const key = this.getShortcutKey(e);
            if (shortcuts[key]) {
                e.preventDefault();
                shortcuts[key]();
            }
        });
    }
    
    setupTouchGestures() {
        if (!this.hasHammer) return;
        
        // Hammer.js活用
        const Hammer = window.PixiExtensions.getComponent('hammer', 'Hammer');
        const hammer = new Hammer(this.appCore.app.view);
        
        // ピンチズーム
        hammer.get('pinch').set({ enable: true });
        hammer.on('pinchstart pinch', (e) => {
            this.handlePinchZoom(e);
        });
        
        // 2本指パン
        hammer.get('pan').set({ fingers: 2 });
        hammer.on('panstart pan', (e) => {
            this.handleTwoFingerPan(e);
        });
        
        // ロングタップ（右クリック相当）
        hammer.get('press').set({ time: 500 });
        hammer.on('press', (e) => {
            this.handleContextMenu(e);
        });
    }
    
    handlePinchZoom(e) {
        // キャンバスズーム制御
        const currentScale = this.appCore.viewport?.scale?.x || 1;
        const newScale = currentScale * e.scale;
        
        if (this.appCore.viewport) {
            this.appCore.viewport.scale.set(
                Math.max(0.1, Math.min(5.0, newScale))
            );
        }
    }
    
    handleTwoFingerPan(e) {
        // 2本指パン制御
        if (this.appCore.viewport) {
            this.appCore.viewport.x += e.deltaX;
            this.appCore.viewport.y += e.deltaY;
        }
    }
}
```

---

## 📊 Phase別テスト手順・品質保証

### Phase1テスト: HTML→node_modules分割
**基準**: 既存機能100%再現・拡張統合・AI分業テスト
```javascript
// 自動テスト実装例
class Phase1TestSuite {
    async runTests() {
        console.log('🧪 Phase1テスト実行開始');
        
        // node_modulesライブラリ読み込み確認
        await this.testNodeModulesLoading();
        
        // 拡張ライブラリ統合確認
        await this.testExtensionsIntegration();
        
        // AI分業ファイル単体動作
        await this.testAICollaborationPatterns();
        
        // 既存機能再現確認
        await this.testFeatureReproduction();
        
        console.log('✅ Phase1テスト完了');
    }
    
    async testNodeModulesLoading() {
        const requiredLibraries = [
            'PIXI', 'gsap', '_', 'Hammer'
        ];
        
        for (const lib of requiredLibraries) {
            if (!window[lib]) {
                throw new Error(`node_modules ライブラリ ${lib} が読み込まれていません`);
            }
        }
        
        console.log('✅ node_modules読み込み確認完了');
    }
    
    async testExtensionsIntegration() {
        await window.PixiExtensions.initialize();
        
        const stats = window.PixiExtensions.getStats();
        if (stats.available < 3) {
            throw new Error('拡張ライブラリ統合が不完全です');
        }
        
        console.log(`✅ 拡張統合確認完了: ${stats.available}/${stats.total}`);
    }
    
    async testAICollaborationPatterns() {
        // ペンツール単体テスト
        const minimalFiles = [
            'libs/pixi-extensions.js',
            'js/main.js', 
            'js/app-core.js', 
            'js/managers/tool-manager.js', 
            'js/tools/pen-tool.js'
        ];
        
        const result = await this.runMinimalConfiguration(minimalFiles);
        if (!result.success) {
            throw new Error('AI分業パターンテスト失敗');
        }
        
        console.log('✅ AI分業パターン確認完了');
    }
    
    async testFeatureReproduction() {
        // 描画機能テスト
        const drawingTest = await this.testDrawingFeatures();
        
        // UI機能テスト
        const uiTest = await this.testUIFeatures();
        
        if (!drawingTest || !uiTest) {
            throw new Error('既存機能再現テスト失敗');
        }
        
        console.log('✅ 既存機能再現確認完了');
    }
}
```

### Phase2テスト: 描画機能完成
**基準**: レイヤー機能・描画ツール・ショートカット完全動作
```javascript
class Phase2TestSuite {
    async runTests() {
        console.log('🧪 Phase2テスト実行開始');
        
        // 非破壊変形品質テスト
        await this.testNonDestructiveTransform();
        
        // レイヤー機能完全性テスト
        await this.testLayerFunctionality();
        
        // 描画ツール品質テスト
        await this.testDrawingTools();
        
        // ショートカット動作テスト
        await this.testShortcuts();
        
        console.log('✅ Phase2テスト完了');
    }
    
    async testNonDestructiveTransform() {
        const layer = LayerManager.createLayer();
        const originalPoints = layer.graphics.geometry.points.slice();
        
        // 360度回転テスト
        VectorTransform.rotate(layer, 2 * Math.PI);
        
        // 品質確認
        const currentPoints = layer.graphics.geometry.points;
        if (!this.arraysEqual(originalPoints, currentPoints)) {
            throw new Error('非破壊変形品質テスト失敗');
        }
        
        // アンドゥテスト
        MemoryManager.undo();
        if (layer.transform.rotation !== 0) {
            throw new Error('アンドゥ機能テスト失敗');
        }
        
        console.log('✅ 非破壊変形品質確認完了');
    }
    
    async testLayerFunctionality() {
        const layer1 = LayerManager.createLayer({ name: 'Layer 1' });
        const layer2 = LayerManager.createLayer({ name: 'Layer 2' });
        const folder = LayerManager.createLayerFolder('Folder 1');
        
        // フォルダ機能テスト
        LayerManager.moveLayerToFolder(layer1, folder);
        if (!folder.children.includes(layer1.id)) {
            throw new Error('レイヤーフォルダ機能テスト失敗');
        }
        
        // 透明度機能テスト
        LayerManager.setLayerOpacity(layer2, 0.5);
        if (layer2.opacity !== 0.5) {
            throw new Error('レイヤー透明度機能テスト失敗');
        }
        
        // 可視性制御テスト
        LayerManager.setLayerVisibility(layer1, false);
        if (layer1.visible !== false) {
            throw new Error('レイヤー可視性制御テスト失敗');
        }
        
        console.log('✅ レイヤー機能確認完了');
    }
    
    async testDrawingTools() {
        // ペンツールテスト
        const penTool = new PenTool();
        penTool.startDrawing(100, 100);
        penTool.continueDrawing(150, 150);
        penTool.stopDrawing();
        
        if (!penTool.currentPath || penTool.currentPath.points.length === 0) {
            throw new Error('ペンツールテスト失敗');
        }
        
        // バケツツールテスト
        const bucketTool = new BucketTool();
        const fillResult = await bucketTool.fill(200, 200, 0xFF0000);
        
        if (!fillResult || !(fillResult instanceof PIXI.Graphics)) {
            throw new Error('バケツツールテスト失敗');
        }
        
        // 選択ツールテスト
        const selectionTool = new SelectionTool();
        const selection = selectionTool.createRectangularSelection(0, 0, 100, 100);
        
        if (!selection || !selection.bounds) {
            throw new Error('選択ツールテスト失敗');
        }
        
        console.log('✅ 描画ツール品質確認完了');
    }
    
    async testShortcuts() {
        const inputManager = new InputManager();
        
        // ショートカット登録確認
        const shortcuts = inputManager.getRegisteredShortcuts();
        const expectedShortcuts = ['Ctrl+Z', 'Ctrl+Y', 'Ctrl+A', '[', ']', 'Space'];
        
        for (const shortcut of expectedShortcuts) {
            if (!shortcuts.includes(shortcut)) {
                throw new Error(`ショートカット ${shortcut} が登録されていません`);
            }
        }
        
        // タッチジェスチャー確認（Hammer.js使用時）
        if (window.PixiExtensions.hasFeature('hammer')) {
            const gestures = inputManager.getRegisteredGestures();
            if (!gestures.includes('pinch') || !gestures.includes('pan')) {
                throw new Error('タッチジェスチャー登録失敗');
            }
        }
        
        console.log('✅ ショートカット・ジェスチャー確認完了');
    }
}
```

---

## 🎯 進捗管理・マイルストーン

### Phase1マイルストーン
- **🏗️ 基盤分割完了**: HTML→node_modules分割・CORS制限回避完成
- **🤖 AI分業基盤完成**: 必要最小限ファイル特定・分業パターン確立
- **🔧 拡張統合完了**: libs/pixi-extensions.js統合・フォールバック機能完成

### Phase2マイルストーン  
- **📚 レイヤーシステム完成**: プロ級レイヤー機能・フォルダ・透明度完成
- **🎨 描画ツール完成**: ペン・消しゴム・バケツ・選択ツール完成
- **⌨️ 操作系統完成**: キーボードショートカット・タッチジェスチャー完成

### 品質指標・KPI

**Phase1 KPI**:
- [ ] node_modulesライブラリ統合率: 100%（7/7ライブラリ）
- [ ] AI分業効率: 必要ファイル数50%削減達成
- [ ] ファイルサイズ制限: 500行以下100%遵守
- [ ] 機能再現率: 既存HTML機能100%再現
- [ ] CORS制限回避: ローカル動作100%成功

**Phase2 KPI**:
- [ ] 非破壊変形品質: 360度回転復元率100%
- [ ] レイヤー機能完成度: 15項目機能100%実装
- [ ] ショートカット対応率: 10ショートカット100%対応
- [ ] 描画ツール完成度: 4ツール100%実装
- [ ] 拡張ライブラリ活用率: 80%以上の機能で活用

---

## 🔧 実装ガイド・技術詳細

### node_modules統合実装パターン
```javascript
// 実装確認用チェックリスト
class NodeModulesIntegrationChecker {
    checkIntegration() {
        const results = [];
        
        // 1. PixiJS本体確認
        results.push(this.checkLibrary('PIXI', './node_modules/pixi.js/dist/pixi.min.js'));
        
        // 2. @pixi/ui確認
        results.push(this.checkLibrary('PIXI.UI', './node_modules/@pixi/ui/dist/ui.min.js'));
        
        // 3. @pixi/layers確認
        results.push(this.checkLibrary('PIXI.display', './node_modules/@pixi/layers/dist/layers.min.js'));
        
        // 4. その他ライブラリ確認
        results.push(this.checkLibrary('gsap', './node_modules/gsap/dist/gsap.min.js'));
        results.push(this.checkLibrary('_', './node_modules/lodash/lodash.min.js'));
        results.push(this.checkLibrary('Hammer', './node_modules/hammerjs/hammer.min.js'));
        
        return results;
    }
    
    checkLibrary(globalName, expectedPath) {
        const available = !!window[globalName];
        return {
            name: globalName,
            path: expectedPath,
            available: available,
            version: available ? this.getVersion(globalName) : null
        };
    }
    
    getVersion(globalName) {
        const lib = window[globalName];
        return lib?.VERSION || lib?.version || 'unknown';
    }
}
```

### AI分業開発実装パターン
```javascript
// AI分業情報テンプレート（標準化）
/**
 * 🎨 ふたば☆ちゃんねる風ベクターお絵描きツール v1.0
 * 
 * 🎯 AI_WORK_SCOPE: [具体的機能説明]
 * 🎯 DEPENDENCIES: [必要ファイルリスト] 
 * 🎯 NODE_MODULES: [使用node_modulesライブラリ]
 * 🎯 PIXI_EXTENSIONS: [使用拡張機能]
 * 🎯 ISOLATION_TEST: [単体テスト可否]
 * 🎯 SPLIT_THRESHOLD: [分割基準・分割先]
 * 
 * 📋 PHASE_TARGET: Phase[1|2] 
 * 📋 V8_MIGRATION: [v8移行時の対応内容]
 * 📋 PERFORMANCE_TARGET: [性能目標]
 */

// 使用例：ペンツール
/**
 * 🎯 AI_WORK_SCOPE: ベクターペン描画機能・筆圧対応・設定管理
 * 🎯 DEPENDENCIES: libs/pixi-extensions.js, js/main.js, js/app-core.js, js/managers/tool-manager.js
 * 🎯 NODE_MODULES: pixi.js（Graphics, Container使用）
 * 🎯 PIXI_EXTENSIONS: なし（基本PIXI機能のみ）
 * 🎯 ISOLATION_TEST: ✅ 単体テスト可能
 * 🎯 SPLIT_THRESHOLD: 300行超過時 → pen-settings.js分割
 * 
 * 📋 PHASE_TARGET: Phase1
 * 📋 V8_MIGRATION: Graphics API変更対応予定
 * 📋 PERFORMANCE_TARGET: 60FPS安定描画
 */
```

### 拡張ライブラリ活用パターン
```javascript
// 統一的な拡張ライブラリ使用パターン
class ExtensionUsagePattern {
    constructor() {
        this.extensions = window.PixiExtensions;
    }
    
    // パターン1: 条件付き使用
    createUI() {
        if (this.extensions.hasFeature('ui')) {chrome://vivaldi-webui/startpage?section=Speed-dials&background-color=#f7f7f7
            // @pixi/ui使用
            return this.createPixiUIComponents();
        } else {
            // フォールバック実装
            return this.createBasicUIComponents();
        }
    }
    
    // パターン2: 性能最適化
    optimizeProcessing(data) {
        if (this.extensions.hasFeature('lodash')) {
            // Lodash使用で高速化
            const _ = this.extensions.getComponent('lodash', '_');
            return _.chunk(data, 1000);
        } else {
            // 基本実装
            return this.basicChunk(data, 1000);
        }
    }
    
    // パターン3: アニメーション強化
    createAnimation(target) {
        if (this.extensions.hasFeature('gsap')) {
            // GSAP使用でスムーズアニメーション
            const gsap = this.extensions.getComponent('gsap', 'gsap');
            return gsap.to(target, { duration: 1, alpha: 0 });
        } else {
            // 基本PIXI Tickerアニメーション
            return this.basicAnimation(target);
        }
    }
}
```

---

## 📝 次ステップ・実装開始手順

### 即時開始可能タスク（Phase1.1）

1. **ディレクトリ構成作成**（開始可能）
   ```bash
   # 基本構成作成
   mkdir -p tegaki/{css,libs,js/{managers,tools,ui,utils,transform,layers}}
   
   # package.json確認（既存活用）
   npm install  # 依存関係インストール
   ```

2. **index.html作成**（開始可能）
   ```html
   <!-- node_modules統合版作成 -->
   <!-- CDN→./node_modules/ パス変更 -->
   <!-- libs/pixi-extensions.js追加 -->
   ```

3. **libs/pixi-extensions.js実装**（開始可能）
   ```javascript
   // 拡張統合基盤実装（300行以下）
   // ライブラリ検出・統合・フォールバック機能
   ```

### Phase1実装順序（推奨）

**Week 1**: 基盤分割・node_modules統合
- [ ] ディレクトリ構成作成・package.json活用
- [ ] index.html（node_modules統合版）作成
- [ ] css/styles.css分離・整理
- [ ] libs/pixi-extensions.js（拡張統合基盤）実装

**Week 2**: JavaScript機能分割・Manager階層
- [ ] js/main.js（エントリーポイント）作成
- [ ] js/app-core.js（PixiJS基盤）分離
- [ ] js/managers/ui-manager.js実装
- [ ] js/managers/tool-manager.js実装

**Week 3**: AI分業基盤・テスト実装
- [ ] AI分業パターン実装・テスト
- [ ] js/tools/pen-tool.js分離・拡張統合
- [ ] Phase1品質テスト実装・実行

### 優先度・依存関係

**最優先実装**（Phase1基盤）:
1. package.json活用・node_modules確認
2. libs/pixi-extensions.js（拡張統合基盤）
3. index.html（node_modules統合版）
4. js/main.js（初期化エントリーポイント）

**次優先実装**（Phase1機能）:
1. js/app-core.js（PixiJS基盤）
2. js/managers/（統括管理層）
3. js/tools/pen-tool.js（AI分業テスト対象）

**後続実装**（Phase2準備）:
1. js/layers/layer-manager.js基盤
2. js/transform/vector-transform.js基盤
3. 非破壊変形システム基盤

---

## 🎬 Phase3-4予告ダイジェスト

### Phase3: アニメーション機能（v7最終版）
**期間**: 6週間・目標: GIFアニメ制作環境完成

#### 主要機能
- **フレーム管理システム**: タイムライン・フレーム複製・サムネイル
- **オニオンスキン機能**: 前後フレーム半透明表示・色分け表示
- **GIFエクスポート**: 高品質GIF出力・圧縮最適化・プレビュー機能
- **アニメーションプレビュー**: リアルタイム再生・フレームレート調整

#### 技術要素
- **@pixi/gif活用**: GIFアニメーション統合（利用可能時）
- **GSAP統合**: スムーズなタイムライン操作・イージング機能
- **メモリ最適化**: 大量フレーム処理・ガベージコレクション最適化

### Phase4: PixiJS v8移行（次世代版）
**期間**: 8週間・目標: WebGPU・120FPS・SPINE統合

#### 主要機能
- **v8完全移行**: 新API対応・互換性レイヤー完成
- **WebGPU Renderer**: GPU活用・描画性能向上
- **120FPS描画**: 高周波数描画・VSync制御
- **SPINE統合**: ボーンアニメーション・Live2D準備

#### 技術要素
- **WebGPU最適化**: Compute Shader活用・バッチ処理最適化
- **Chrome Scheduling API**: 高優先度レンダリング・フレーム制御
- **メモリ効率化**: WebGPU Buffer管理・リソース最適化

---

*🎨 ふたば☆ちゃんねる風お絵描きツール 移行計画書 Phase1-2版*  
*作成日: 2025年8月15日*  
*対応技術: HTML単体→node_modules分割→描画機能完成*  
*基本方針: ローカル依存・CORS制限回避・AI協働開発・非破壊品質保証*