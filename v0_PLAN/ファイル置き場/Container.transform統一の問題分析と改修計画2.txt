# Container.transform統一の問題分析と改修計画

## 🔍 問題の詳細分析

### ❌ 失敗した部分

#### 1. カメラ枠が一緒に動かなくなった
**原因**: `canvasContainer.transform` でキャンバスを移動したことで、カメラ枠（UI要素）との連動が切れた
- **期待動作**: キャンバス移動時、カメラ枠は固定位置でキャンバス内容だけが移動
- **実際動作**: キャンバス全体が移動し、カメラ枠との視覚的関係が破綻
- **根本原因**: カメラ（ビューポート）概念とレイヤー変形概念の混同

#### 2. キャンバス外からのペン描写が無くなった
**原因**: `canvasContainer.toLocal()` による座標変換で、キャンバス外の座標が正しく処理されなくなった
- **期待動作**: キャンバス外からでも描画開始可能（Clip Studio風）
- **実際動作**: キャンバス範囲外の描画が受け付けられない
- **根本原因**: キャンバス操作とワールド座標系の混同

#### 3. サムネイル更新のタイミング問題
**原因**: レイヤー変更検知ロジックが `canvasContainer` の変形に対応していない
- **期待動作**: レイヤー内容変更時に即座にサムネイル更新
- **実際動作**: アクティブレイヤーでの描画中のみ更新
- **根本原因**: サムネイル生成の座標系とレンダリング範囲の不整合

### ✅ 成功した部分

#### 1. キーボード・マウス操作の統一
- Space + ドラッグ/方向キー による移動
- Shift + Space による拡縮・回転の操作分岐
- ホイール操作による拡縮・回転

#### 2. レイヤー階層移動
- 方向キー上下でのレイヤー順序変更
- Sortable.jsとの連携

#### 3. 操作モード表示
- 視覚的フィードバックとカーソル変更

---

## 🎯 Container.transform統一の問題点

### 概念的混同が発生した領域

```
❌ 混同した概念:
[キャンバス操作] ≠ [レイヤー変形]
[ビューポート移動] ≠ [Container.transform]
[カメラ座標] ≠ [ワールド座標]
```

### 正しい責務分離

```
✅ 正しい概念分離:
[ビューポート] = カメラの視点移動（画面上での見え方）
[キャンバス変形] = 描画領域全体の変形（コンテンツの変形）
[レイヤー変形] = 個別レイヤーの変形（オブジェクトの変形）
```

---

## 🔄 ロールバック改修計画



```

### Phase1.5-fix: 座標変換の修正

#### 座標変換ルールの再定義
```javascript
// ❌ 現在の問題のある変換
const canvasPoint = this.canvasContainer.toLocal({ x: screenX, y: screenY });

// ✅ 修正版：ワールド座標への変換
const worldPoint = this.viewport.toWorld({ x: screenX, y: screenY });
// または
const worldPoint = this.worldContainer.toLocal({ x: screenX, y: screenY });
```

#### キャンバス外描画の復活
```javascript
// 描画判定を座標制限なしに変更
startDrawing(screenX, screenY) {
  // ✅ キャンバス外でも描画開始を受け付ける
  const worldPoint = this.viewport.toWorld({ x: screenX, y: screenY });
  // 座標制限なしで描画開始
  this.beginPath(worldPoint);
}
```

### Phase1.5-fix: サムネイル生成の修正

#### レンダリング範囲の適正化
```javascript
updateThumbnail(layerIndex, app) {
  const layer = this.layers[layerIndex];
  
  // ✅ レイヤー単体をワールド座標で正しくレンダリング
  const tempContainer = new PIXI.Container();
  tempContainer.addChild(layer);
  
  // レイヤーのバウンディングボックスを取得
  const bounds = layer.getBounds();
  
  const renderTexture = PIXI.RenderTexture.create({
    width: 48, height: 48,
    resolution: 1
  });
  
  // 適切な変形行列でレンダリング
  app.renderer.render(tempContainer, { renderTexture });
  
  tempContainer.removeChild(layer); // 元に戻す
}
```

---

## 📋 改修作業計画

### 優先度1: 緊急修正（即座に実施）
1. **@pixi/viewport の再導入**
   - CDN追加: `<script src="https://cdn.jsdelivr.net/npm/@pixi/viewport@5.0.2/dist/viewport.min.js"></script>`
   - viewport → worldContainer → layersContainer の3階層に修正

2. **座標変換の修正**
   - `canvasContainer.toLocal()` → `viewport.toWorld()` に変更
   - キャンバス外描画の復活

3. **カメラ枠の修正**
   - uiContainer を stage直下に配置
   - cameraFrame を固定位置で描画

### 優先度2: 機能回復（1-2日後）
4. **サムネイル生成の修正**
   - レイヤー単位でのバウンディングボックス計算
   - 適切な変形行列での描画

5. **操作系の調整**
   - ビューポート操作とレイヤー変形の分離
   - キーボードショートカットの再調整

### 優先度3: 拡張準備（Phase2向け）
6. **レイヤー個別変形の基盤**
   - layer.transform による個別変形
   - viewport操作との独立性確保

7. **無限キャンバス対応**
   - worldContainer のサイズ制限解除
   - 動的な背景タイル生成

---

## 🎯 設計指針の見直し

### Container.transform使用ルール

#### ✅ 適用すべき場面
- **レイヤー個別変形**: 選択したレイヤーの移動・回転・拡縮
- **オブジェクト変形**: 図形・テキストなどの個別要素
- **UI要素配置**: ツールバー・パネルなどの固定UI

#### ❌ 適用すべきでない場面
- **ビューポート操作**: カメラ・視点の移動
- **キャンバス全体操作**: 描画領域全体の表示制御
- **座標系の基準変更**: ワールド座標系そのものの変更

### 新しいアーキテクチャ指針

```javascript
// ✅ 責務分離された構造
const ARCHITECTURE = {
  viewport: "カメラ制御・視点操作", 
  worldContainer: "ワールド座標系・無限キャンバス",
  layersContainer: "レイヤー管理・描画順序",
  layer: "個別コンテンツ・変形対象",
  uiContainer: "UI固定要素・カメラ枠"
};
```

---

## 📖 学習ポイント

### Container.transform の適用判断基準
1. **変形対象の性質**
   - コンテンツか？ → ✅ transform適用
   - 視点・カメラか？ → ❌ viewport使用

2. **座標系の影響範囲**
   - 局所的変形か？ → ✅ transform適用  
   - 全体的視点変更か？ → ❌ viewport使用

3. **他要素への影響**
   - 独立変形か？ → ✅ transform適用
   - 連動が必要か？ → ❌ 上位Container使用

### 今後の実装時の注意点
- **ビューポート ≠ コンテンツ変形** の概念分離を厳守
- **座標変換は目的に応じて適切なAPIを選択**
- **UI要素とコンテンツ要素の責務を明確に分離**

この分析を基に、@pixi/viewportを再導入した正しいアーキテクチャに修正することで、キャンバス外描画とカメラ枠固定を両立できます。