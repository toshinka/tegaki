段階的改修計画書 補足版：コピー&ペースト非破壊化編
基盤文書：「段階的改修計画書 — 非破壊化＆ファイル分割＆GIF化準備.txt」
補足対象：フェーズ0〜2の詳細化・前倒し実装
緊急課題：コピー&ペースト機能の非破壊化による劣化防止

🚨 現状の問題詳細分析
コピー&ペースト劣化の仕組み
1. レイヤー作成 → パスデータ保持 ✅
2. レイヤー変形 → transform情報蓄積 ✅
3. V解除時の確定 → RenderTextureベイク 💥 パスデータ消失
4. コピー実行 → 既に劣化済みのSpriteをコピー 💥
5. ペースト → 劣化画像から新レイヤー作成 💥
6. 繰り返すたびに劣化累積 💥💥💥
根本原因

LayerManager.confirmLayerTransform() の破壊的ベイク処理
コピー時にパスデータではなく表示結果をコピーしている
レイヤー変形確定のタイミングでベクターデータが失われる


📋 改修方針（基盤計画書フェーズ0〜2の前倒し詳細版）
フェーズ0-B：緊急非破壊化（即時実装）
目的：現在のコピー&ペースト劣化を即座に停止
フェーズ1-B：パスデータ完全保持（高優先度）
目的：コピー&ペースト時もパスデータを確実に継承
フェーズ2-B：レンダリング分離準備（GIF化土台）
目的：表示とデータの完全分離による将来拡張準備

🔧 フェーズ0-B：緊急非破壊化（即時実装）
実装内容1：confirmLayerTransform の非破壊化
javascript// 修正前（破壊的）：RenderTextureにベイクしてSprite化
confirmLayerTransform() {
    // レイヤー内容をRenderTextureに描画
    const renderTexture = PIXI.RenderTexture.create({...});
    this.app.renderer.render(activeLayer, { renderTexture });
    
    // 💥 既存のコンテンツを削除（パスデータ消失）
    activeLayer.removeChildren();
    
    // 💥 RenderTextureをSpriteとして追加（劣化開始）
    const sprite = new PIXI.Sprite(renderTexture);
    activeLayer.addChild(sprite);
}

// 修正後（非破壊的）：論理的確定のみ
confirmLayerTransform() {
    const activeLayer = this.getActiveLayer();
    if (!activeLayer) return;
    
    const layerId = activeLayer.layerData.id;
    const transform = this.layerTransforms.get(layerId);
    
    if (this.isTransformNonDefault(transform)) {
        // ✅ パスデータにtransformを適用（座標変換）
        this.applyTransformToPaths(activeLayer, transform);
        
        // ✅ 表示transformをリセット（視覚的変化なし）
        activeLayer.position.set(0, 0);
        activeLayer.rotation = 0;
        activeLayer.scale.set(1, 1);
        activeLayer.pivot.set(0, 0);
        
        // ✅ 変形データをクリア（確定完了）
        this.layerTransforms.set(layerId, {
            x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1
        });
        
        // ✅ パスデータは完全保持
        log('Layer transform confirmed non-destructively');
    }
}
実装内容2：applyTransformToPaths 新規実装
javascript// パスの座標に直接transformを適用
applyTransformToPaths(layer, transform) {
    const centerX = CONFIG.canvas.width / 2;
    const centerY = CONFIG.canvas.height / 2;
    
    // 変形行列を作成
    const matrix = new PIXI.Matrix();
    matrix.translate(centerX + transform.x, centerY + transform.y);
    matrix.rotate(transform.rotation);
    matrix.scale(transform.scaleX, transform.scaleY);
    matrix.translate(-centerX, -centerY);
    
    // 各パスの座標点に変形を適用
    layer.layerData.paths.forEach(path => {
        // 座標点を変形
        path.points = path.points.map(point => {
            return matrix.apply(point);
        });
        
        // Graphicsを再生成
        this.rebuildPathGraphics(path);
    });
    
    // レイヤーを再構築
    this.rebuildLayerFromPaths(layer);
}
実装内容3：rebuildPathGraphics & rebuildLayerFromPaths
javascript// パスからGraphicsを再生成
rebuildPathGraphics(path) {
    if (path.graphics) {
        path.graphics.destroy();
    }
    
    path.graphics = new PIXI.Graphics();
    
    // パスの点から描画を再構築
    path.points.forEach(point => {
        path.graphics.circle(point.x, point.y, path.size / 2);
        path.graphics.fill({ color: path.color, alpha: path.opacity });
    });
}

// レイヤー全体をパスから再構築
rebuildLayerFromPaths(layer) {
    // 既存の描画要素をクリア（背景以外）
    const children = [...layer.children];
    children.forEach(child => {
        if (child !== layer.layerData.backgroundGraphics) {
            layer.removeChild(child);
            if (child.destroy) child.destroy();
        }
    });
    
    // パスから再構築
    layer.layerData.paths.forEach(path => {
        if (path.graphics) {
            layer.addChild(path.graphics);
        }
    });
}
ファイル変更

main.js：LayerManager.confirmLayerTransform 周辺の修正のみ
変更行数：約50行（低リスク）

成果物

✅ V解除時の劣化停止
✅ パスデータ完全保持
✅ 既存UI・操作感維持
✅ 回帰リスク最小


🔧 フェーズ1-B：パスデータ完全保持（高優先度）
実装内容1：コピー処理の完全非破壊化
javascript// 修正前：表示結果ベースのコピー（劣化あり）
copyActiveLayer() {
    // 現在の実装：layerData.paths をコピーするが、
    // 既にconfirmLayerTransformでパスが消失している可能性
}

// 修正後：パスデータ第一優先のコピー
copyActiveLayer() {
    const activeLayer = this.getActiveLayer();
    if (!activeLayer) return;

    // ✅ 現在の変形状態を一時確定（非破壊的）
    const layerId = activeLayer.layerData.id;
    const currentTransform = this.layerTransforms.get(layerId);
    
    let pathsToStore;
    
    if (this.isTransformNonDefault(currentTransform)) {
        // 変形中の場合：仮想的に変形適用した座標を生成
        pathsToStore = this.getTransformedPaths(activeLayer, currentTransform);
    } else {
        // 未変形の場合：そのままコピー
        pathsToStore = activeLayer.layerData.paths;
    }
    
    // ✅ 完全なパスデータをクリップボードに保存
    this.clipboardData = {
        layerData: {
            name: activeLayer.layerData.name + '_copy',
            visible: activeLayer.layerData.visible,
            opacity: activeLayer.layerData.opacity,
            paths: this.deepCopyPaths(pathsToStore), // 完全ディープコピー
            isBackground: activeLayer.layerData.isBackground
        },
        // 変形情報はリセット（ペースト時は初期状態）
        transform: { x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1 },
        metadata: {
            originalId: layerId,
            copiedAt: Date.now(),
            pathCount: pathsToStore.length,
            isNonDestructive: true // 非破壊フラグ
        }
    };

    console.log(`Non-destructive copy: ${pathsToStore.length} paths preserved`);
}
実装内容2：getTransformedPaths（仮想変形適用）
javascript// 現在の変形状態を適用した座標を仮想計算
getTransformedPaths(layer, transform) {
    const centerX = CONFIG.canvas.width / 2;
    const centerY = CONFIG.canvas.height / 2;
    
    // 変形行列作成
    const matrix = new PIXI.Matrix();
    matrix.translate(centerX + transform.x, centerY + transform.y);
    matrix.rotate(transform.rotation);
    matrix.scale(transform.scaleX, transform.scaleY);
    matrix.translate(-centerX, -centerY);
    
    // パスに仮想変形を適用（元データは変更しない）
    return layer.layerData.paths.map(path => ({
        ...path,
        id: `${path.id}_transformed_${Date.now()}`,
        points: path.points.map(point => matrix.apply(point))
    }));
}
実装内容3：ペースト処理の強化
javascript// 修正後：パスデータ完全復元ペースト
pasteLayer() {
    if (!this.clipboardData) return;
    
    const clipData = this.clipboardData;
    
    // ✅ 非破壊コピーの検証
    if (!clipData.metadata?.isNonDestructive) {
        console.warn('Pasting potentially degraded data');
    }
    
    // 新レイヤー作成
    const layerName = this.generateUniqueLayerName(clipData.layerData.name);
    const { layer, index } = this.createLayer(layerName, clipData.layerData.isBackground);
    
    // ✅ パスデータ完全復元
    clipData.layerData.paths.forEach(pathData => {
        const newPath = {
            id: `path_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            points: [...pathData.points], // 座標完全コピー
            color: pathData.color,
            size: pathData.size,
            opacity: pathData.opacity,
            isComplete: true,
            graphics: null // 後で生成
        };
        
        // パスGraphicsを生成
        this.rebuildPathGraphics(newPath);
        
        // レイヤーに追加
        layer.layerData.paths.push(newPath);
        layer.addChild(newPath.graphics);
    });
    
    // レイヤー設定復元
    layer.layerData.visible = clipData.layerData.visible;
    layer.layerData.opacity = clipData.layerData.opacity;
    layer.visible = clipData.layerData.visible;
    layer.alpha = clipData.layerData.opacity;
    
    // UI更新
    this.setActiveLayer(index);
    this.updateLayerPanelUI();
    this.requestThumbnailUpdate(index);
    
    console.log(`Non-destructive paste: ${clipData.layerData.paths.length} paths restored`);
}
ファイル変更

main.js：ClipboardSystem クラス全体の強化
変更行数：約100行

成果物

✅ コピーのコピーが正常に動作
✅ 何度コピーしても劣化しない
✅ パスデータ完全継承
✅ メタデータによる品質管理


🔧 フェーズ2-B：レンダリング分離準備（GIF化土台）
実装内容：パスデータ構造化（基盤計画書フェーズ2準備）

javascript// 将来のGIF化・アニメーション対応を見据えたパス構造
const enhancedPathStructure = {
    id: 'path_unique_id',
    type: 'stroke', // 'stroke', 'fill', 'shape'
    
    // 描画データ（既存）
    points: [{x, y}, ...],
    color: 0x000000,
    size: 16,
    opacity: 0.85,
    
    // メタデータ（新規）
    createdAt: timestamp,
    modifiedAt: timestamp,
    tool: 'pen', // 'pen', 'eraser'
    
    // アニメーション準備（新規）
    frameStart: 0,     // このパスが表示開始するフレーム
    frameEnd: -1,      // このパスが非表示になるフレーム（-1=永続）
    
    // 非破壊トレース（新規）
    sourceLayer: 'layer_id',
    transformHistory: [], // 適用された変形履歴
    
    // 品質管理（新規）
    isOriginal: true,     // オリジナルデータかコピーデータか
    copyGeneration: 0,    // コピーの世代数（劣化追跡）
    lastRenderDPR: 1.0   // 最後にレンダリングされたDPR
};
ファイル変更

config.js：パスデータ構造定義追加
main.js：パスデータ生成時の構造対応
変更行数：約30行

成果物

✅ 将来のアニメーション機能への土台
✅ パスデータの完全トレーサビリティ
✅ 品質劣化の定量的追跡


🔄 実装手順（Claude作業最適化）
Step 1：フェーズ0-B実装（約1時間）

confirmLayerTransform の非破壊化
applyTransformToPaths の新規実装
rebuildPathGraphics / rebuildLayerFromPaths の実装
動作検証：V解除後もパスデータ保持確認

Step 2：フェーズ1-B実装（約2時間）

copyActiveLayer の完全非破壊化
getTransformedPaths の実装
pasteLayer の強化
動作検証：コピーのコピーが正常動作確認

Step 3：フェーズ2-B準備（約30分）

パスデータ構造の拡張
将来拡張準備のメタデータ追加
動作検証：既存機能の回帰テスト


✅ 成功指標
非破壊性テスト

 レイヤー変形→V解除後もパスデータが保持される
 10回コピー&ペーストしても画質劣化しない
 パスの座標精度が維持される

機能継承テスト

 既存のレイヤー操作が全て正常動作
 UI・操作感に変化がない
 パフォーマンス劣化がない

将来拡張テスト

 パスデータ構造がアニメーション対応可能
 メタデータが正しく記録される
 GIF化実装時の必要情報が準備されている


📈 この補足版の位置づけ
基盤計画書との関係

フェーズ0の詳細版：破壊的確定の非破壊化
フェーズ1の前倒し：main.js分割前にコピー&ペースト問題を解決
フェーズ2の準備：パスデータ構造化への土台

次のステップ
この補足版完了後、基盤計画書のフェーズ1（main.js分割）→**フェーズ3以降（本格GIF化）**へ進行
Claude改修効率への貢献

コピー&ペースト問題を早期解決
将来の機能追加時の基盤整備
非破壊化による品質向上とアニメーション準備の同時達成


🚀 即時実装推奨
現在のコピー&ペースト劣化問題はユーザー体験に直結するため、この補足版での早急な対応を推奨します。特にフェーズ0-Bは即時実装により、すぐに劣化問題を解決できます。
準備完了しましたら、Step 1から実装を開始いたします。

