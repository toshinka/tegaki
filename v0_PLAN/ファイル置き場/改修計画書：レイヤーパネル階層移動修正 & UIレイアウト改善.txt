📋 現状分析
🔍 問題点1: レイヤーパネルの階層移動不具合
原因特定:

ui-panels.js内のSortableJS統合処理(initializeSortable)にて、レイヤー階層の移動処理が実装されている
onEndイベント内でレイヤー配列とPixi Container階層を両方更新しているが、LayerSystemへの状態反映が不完全
一度移動するとlayerManager.updateLayerPanelUI()が呼ばれるが、その後の再移動時に配列とコンテナの同期が取れなくなる
重要: LayerSystemのupdateLayerPanelUI()メソッドが、SortableJSによる移動を検知して再描画する際、既に移動済みのDOM要素に対して再度Sortableを初期化していない可能性

影響範囲:

ui-panels.js: initializeSortableメソッド
layer-system.js: updateLayerPanelUIメソッド、レイヤー順序管理ロジック

🔍 問題点2: UIレイアウトの位置関係
現状:

レイヤー+ボタン
◀CUT1▶
レイヤー1
背景

要望:

◀CUT1▶
レイヤー+ボタン | フォルダ+ボタン
レイヤー1
背景

🎯 改修計画
Phase 1: レイヤー階層移動の修正
ファイル: ui-panels.js, layer-system.js
修正内容
1. ui-panels.js - SortableJS統合の改善

// 問題: Sortableインスタンスが再初期化されない
// 解決策: updateLayerPanelUI()呼び出し後に再初期化

initializeSortable: function(layerManager) {
    const layerList = document.getElementById('layer-list');
    if (!layerList || typeof Sortable === 'undefined') return;
    
    // 既存インスタンスを破棄
    if (layerList.sortableInstance) {
        layerList.sortableInstance.destroy();
    }
    
    // 新規インスタンス作成
    layerList.sortableInstance = Sortable.create(layerList, {
        animation: 150,
        ghostClass: 'sortable-ghost',
        chosenClass: 'sortable-chosen',
        onEnd: function(evt) {
            const fromIndex = layerManager.layers.length - 1 - evt.oldIndex;
            const toIndex = layerManager.layers.length - 1 - evt.newIndex;
            
            if (fromIndex !== toIndex) {
                // LayerSystemの統一APIを使用
                const success = layerManager.reorderLayers(fromIndex, toIndex);
                
                if (success) {
                    // UI更新
                    layerManager.updateLayerPanelUI();
                    
                    // Sortable再初期化
                    setTimeout(() => {
                        if (window.TegakiUI?.initializeSortable) {
                            window.TegakiUI.initializeSortable(layerManager);
                        }
                    }, 50);
                }
            }
        }
    });
}

2. layer-system.js - レイヤー順序変更APIの追加

// 新規メソッド追加
reorderLayers(fromIndex, toIndex) {
    const layers = this.getLayers();
    
    if (fromIndex < 0 || fromIndex >= layers.length || 
        toIndex < 0 || toIndex >= layers.length || 
        fromIndex === toIndex) {
        return false;
    }
    
    // 配列から移動
    const [movedLayer] = layers.splice(fromIndex, 1);
    layers.splice(toIndex, 0, movedLayer);
    
    // Pixiコンテナの階層も同期
    this.currentCutContainer.removeChild(movedLayer);
    this.currentCutContainer.addChildAt(movedLayer, toIndex);
    
    // アクティブインデックスの調整
    if (this.activeLayerIndex === fromIndex) {
        this.activeLayerIndex = toIndex;
    } else if (this.activeLayerIndex > fromIndex && this.activeLayerIndex <= toIndex) {
        this.activeLayerIndex--;
    } else if (this.activeLayerIndex < fromIndex && this.activeLayerIndex >= toIndex) {
        this.activeLayerIndex++;
    }
    
    // イベント発行
    if (this.eventBus) {
        this.eventBus.emit('layer:reordered', { 
            fromIndex, 
            toIndex, 
            activeIndex: this.activeLayerIndex 
        });
    }
    
    return true;
}

3. layer-system.js - updateLayerPanelUIの改善

updateLayerPanelUI() {
    const layerList = document.getElementById('layer-list');
    if (!layerList) return;

    layerList.innerHTML = '';
    
    const layers = this.getLayers();

    for (let i = layers.length - 1; i >= 0; i--) {
        const layer = layers[i];
        const isActive = (i === this.activeLayerIndex);
        
        const layerItem = document.createElement('div');
        layerItem.className = `layer-item ${isActive ? 'active' : ''}`;
        layerItem.dataset.layerId = layer.layerData.id;
        layerItem.dataset.layerIndex = i;

        // ... 既存のHTML生成コード ...
        
        layerList.appendChild(layerItem);
    }
    
    // サムネイル更新
    for (let i = 0; i < layers.length; i++) {
        this.requestThumbnailUpdate(i);
    }
    
    // ⭐ Sortable再初期化（重要）
    if (window.TegakiUI?.initializeSortable) {
        setTimeout(() => {
            window.TegakiUI.initializeSortable(this);
        }, 50);
    }
}

Phase 2: UIレイアウトの再構築
ファイル: index.html
HTML構造変更

<div class="layer-panel-container" id="layer-panel-container">
    <!-- CUTインジケータ（最上部） -->
    <div class="cut-indicator">
        <div class="cut-nav-btn" id="prev-cut-btn">◀</div>
        <div class="cut-display" id="cut-display">CUT1</div>
        <div class="cut-nav-btn" id="next-cut-btn">▶</div>
    </div>
    
    <!-- ボタン群（横並び） -->
    <div class="layer-controls-row">
        <div class="layer-add-button" id="add-layer-btn" title="レイヤー追加 (Ctrl+L)">
            <svg><!-- layer-plus icon --></svg>
        </div>
        
        <div class="folder-add-button" id="add-folder-btn" title="フォルダ追加（準備中）">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#800000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 10v6"/><path d="M9 13h6"/>
                <path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"/>
            </svg>
        </div>
    </div>
    
    <!-- レイヤーリスト -->
    <div class="layer-panel-items" id="layer-list"></div>
</div>

CSS追加

/* レイヤーコントロール行 */
.layer-controls-row {
    display: flex;
    flex-direction: row;
    gap: 8px;
    background: transparent;
    pointer-events: all;
    justify-content: center;
    padding: 4px 8px;
}

.layer-add-button,
.folder-add-button {
    width: 36px;
    height: 36px;
    background: var(--futaba-cream);
    border: 2px solid var(--futaba-light-medium);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(128, 0, 0, 0.1);
    pointer-events: all;
}

.folder-add-button {
    opacity: 0.6;
    cursor: not-allowed;
}

.folder-add-button:hover {
    opacity: 0.7;
}

.layer-add-button svg,
.folder-add-button svg {
    width: 18px;
    height: 18px;
    stroke: #800000;
}

Phase 3: サイドバーアイコン追加
ファイル: index.html
HTMLへのアイコン追加

<div class="sidebar">
    <!-- 📚 アルバム保管アイコン -->
    <div class="tool-button" id="library-tool" title="アルバム保管 (準備中)">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#800000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <rect width="8" height="18" x="3" y="3" rx="1"/>
            <path d="M7 3v18"/>
            <path d="M20.4 18.9c.2.5-.1 1.1-.6 1.3l-1.9.7c-.5.2-1.1-.1-1.3-.6L11.1 5.1c-.2-.5.1-1.1.6-1.3l1.9-.7c.5-.2 1.1.1 1.3.6Z"/>
        </svg>
    </div>
    
    <!-- 📥 画像・アニメ記録アイコン -->
    <div class="tool-button" id="export-tool" title="画像・アニメ出力 (準備中)">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#800000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M10.3 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10l-3.1-3.1a2 2 0 0 0-2.814.014L6 21"/>
            <path d="m14 19 3 3v-5.5"/>
            <path d="m17 22 3-3"/>
            <circle cx="9" cy="9" r="2"/>
        </svg>
    </div>
    
    <div class="tool-separator"></div>
    
    <!-- 既存のリサイズツール以降 -->
    <!-- ... -->
</div>

イベントハンドラ追加（ui-panels.js）

handleToolClick(button) {
    const toolId = button.id;
    
    const toolMap = {
        'library-tool': () => {
            alert('アルバム保管機能は準備中です');
            // 将来実装: localStorage/IndexedDBによる保存UI
        },
        'export-tool': () => {
            this.showExportPanel();
        },
        // 既存のツール...
    };
    
    const handler = toolMap[toolId];
    if (handler) handler();
}

showExportPanel() {
    // 出力パネル表示（GIF優先実装）
    const exportPanel = document.getElementById('export-panel');
    if (exportPanel) {
        exportPanel.classList.add('show');
    } else {
        // 簡易アラート（パネル未実装時）
        alert('出力形式：PNG, APNG, GIF, WEBP, MP4, PDF\n※GIF出力を優先実装予定');
    }
}


📊 実装優先度
🔴 最優先（Phase 1）

レイヤー階層移動の修正

ui-panels.js SortableJS統合改善
layer-system.js reorderLayersメソッド追加
updateLayerPanelUIでのSortable再初期化



🟡 高優先度（Phase 2）

UIレイアウト変更

CUTインジケータ位置変更
レイヤー+ボタンとフォルダ+ボタン横並び
CSS調整



🟢 中優先度（Phase 3）

サイドバーアイコン追加

library-bigアイコン追加
image-downアイコン追加
プレースホルダーイベント実装



🔵 低優先度（将来実装）

機能実装

アルバム保管機能（localStorage/IndexedDB）
PNG/APNG/GIF/WEBP/MP4/PDF出力
フォルダ機能




🔧 改修ファイル一覧
修正ファイル

ui-panels.js （SortableJS統合改善、ツールハンドラ追加）
layer-system.js （reorderLayersメソッド追加、updateLayerPanelUI改善）
index.html （レイヤーパネルHTML構造変更、サイドバーアイコン追加、CSS追加）

新規ファイル
なし（既存ファイルの改修のみ）

⚠️ 注意事項
互換性維持

既存のLayerSystem APIは全て維持
updateLayerPanelUI()の動作は変更なし（内部でSortable再初期化を追加するのみ）
EventBus経由のイベント名は既存のまま

デバッグポイント

SortableJSのonEndイベントが正しく発火するか
reorderLayers()後のPixi Container階層とレイヤー配列の一致
updateLayerPanelUI()後のSortable再初期化タイミング

テスト項目

レイヤーを上下にドラッグして階層移動
移動後、再度別のレイヤーを移動可能か
アクティブレイヤーが正しく追従するか
CUTインジケータが最上部に表示されるか
レイヤー+ボタンとフォルダ+ボタンが横並びか
サイドバーの新規アイコンがクリック可能か

