サムネイル高品質化改修計画書
改修方針
「PixiJS v8標準機能 + Canvas API」による保守性重視のアプローチ

外部ライブラリ依存なし（保守性向上）
コード変更箇所を最小限に抑制
後続Claude向けコメント完備
高解像度レンダリング + 標準Canvas APIダウンスケール

改修対象ファイル

main.jsのLayerManager.updateThumbnail()メソッドのみ

改修内容詳細
1. 定数定義の追加
javascript// 改修Claude向けコメント：サムネイル品質設定
const THUMBNAIL_CONFIG = {
    SIZE: 48,           // 最終サムネイルサイズ
    RENDER_SCALE: 3,    // 高解像度レンダリング倍率
    QUALITY: 'high'     // Canvas APIスムージング品質
};
2. updateThumbnail()メソッドの置換
現在のコード（約30行）を以下に置き換え：
javascriptupdateThumbnail(layerIndex) {
    if (!this.app?.renderer || layerIndex < 0 || layerIndex >= this.layers.length) return;

    // 改修Claude向けコメント：高品質サムネイル生成ロジック
    const layer = this.layers[layerIndex];
    const layerItems = document.querySelectorAll('.layer-item');
    const panelIndex = this.layers.length - 1 - layerIndex;
    
    if (panelIndex < 0 || panelIndex >= layerItems.length) return;
    
    const thumbnail = layerItems[panelIndex].querySelector('.layer-thumbnail');
    if (!thumbnail) return;

    try {
        // 改修Claude向けコメント：高解像度レンダーテクスチャ作成
        const renderTexture = PIXI.RenderTexture.create({
            width: THUMBNAIL_CONFIG.SIZE * THUMBNAIL_CONFIG.RENDER_SCALE,
            height: THUMBNAIL_CONFIG.SIZE * THUMBNAIL_CONFIG.RENDER_SCALE,
            resolution: THUMBNAIL_CONFIG.RENDER_SCALE,
            multisample: PIXI.MSAA_QUALITY.HIGH
        });
        
        // 改修Claude向けコメント：スケール調整済みコンテナ作成
        const tempContainer = new PIXI.Container();
        const canvasScale = THUMBNAIL_CONFIG.SIZE / CONFIG.canvas.width;
        const renderScale = canvasScale * THUMBNAIL_CONFIG.RENDER_SCALE;
        
        layer.children.forEach(child => {
            if (child instanceof PIXI.Graphics) {
                const clone = child.clone();
                clone.scale.set(renderScale);
                tempContainer.addChild(clone);
            }
        });
        
        // 改修Claude向けコメント：高解像度レンダリング実行
        this.app.renderer.render(tempContainer, { renderTexture });
        
        // 改修Claude向けコメント：Canvas APIで高品質ダウンスケール
        const sourceCanvas = this.app.renderer.extract.canvas(renderTexture);
        const targetCanvas = document.createElement('canvas');
        targetCanvas.width = THUMBNAIL_CONFIG.SIZE;
        targetCanvas.height = THUMBNAIL_CONFIG.SIZE;
        
        const ctx = targetCanvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = THUMBNAIL_CONFIG.QUALITY;
        ctx.drawImage(sourceCanvas, 0, 0, THUMBNAIL_CONFIG.SIZE, THUMBNAIL_CONFIG.SIZE);
        
        // 改修Claude向けコメント：UI更新
        let img = thumbnail.querySelector('img');
        if (!img) {
            img = document.createElement('img');
            thumbnail.innerHTML = '';
            thumbnail.appendChild(img);
        }
        img.src = targetCanvas.toDataURL();
        
        // 改修Claude向けコメント：リソース解放
        renderTexture.destroy();
        tempContainer.destroy();
        
    } catch (error) {
        console.warn('Thumbnail update failed:', error);
    }
}
実装上の利点
保守性

単一メソッド改修：影響範囲が明確
外部依存なし：ライブラリ管理不要
標準API使用：ブラウザ互換性が高い
コメント完備：後続Claudeが理解しやすい

パフォーマンス

レンダリング倍率調整可能：品質vs速度のバランス調整
リソース解放徹底：メモリリーク防止
Canvas API最適化：ブラウザ最適化の恩恵

拡張性

設定の外出し：THUMBNAIL_CONFIGで簡単調整
品質レベル変更：RENDER_SCALEの変更のみ
将来対応：WebGL/Canvas切り替え可能

改修手順

THUMBNAIL_CONFIG定数を追加（CONFIG定義部分）
updateThumbnail()メソッドを置換
動作確認（サムネイル品質向上確認）
必要に応じてRENDER_SCALEを調整（2〜4の範囲）

期待効果

ジャギー大幅軽減（3倍解像度レンダリング）
コード可読性向上（構造化とコメント）
後続改修容易性（明確な責務分離）
パフォーマンス維持（必要最小限の処理）