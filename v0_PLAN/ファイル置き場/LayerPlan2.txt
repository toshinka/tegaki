🎨 Futaba Drawing Tool v8 — Pixi UI + Layers 実装計画（改訂版）
1. 目的

@pixi/ui でレイヤーパネルを構築（＋／削除のみの最小UI）

@pixi/layers で背景＋描画レイヤーを管理

デフォルトで 背景レイヤー（Layer 0）＋透明レイヤー（Layer 1） を用意し、Layer 1 をアクティブ化

レイヤー階層のドラッグ操作で順序変更を可能に（余裕があれば実装）

2. 構造設計
2.1 Pixi Application 階層
PIXI.Application
 ├─ Stage (root)
 │   ├─ UILayer (@pixi/ui)
 │   └─ DrawingLayerGroup (@pixi/layers)
 │        ├─ Layer 0: 背景   ← 色 #f0e0d6 固定
 │        └─ Layer 1: 描画   ← 無色透明、デフォルトアクティブ

2.2 UI構造（Pixi UI）

レイヤーパネル

リスト形式で Layer 0, 1 を表示

各項目は：

🗂 レイヤー名（ラベル）

➕ 新規追加ボタン（末尾に Layer n を追加）

🗑 削除ボタン（Layer 0 は削除不可）

並べ替え：UIDraggable を使ってドラッグ順序をサポート（余裕があれば導入）

3. 機能別計画
3.1 レイヤー管理（@pixi/layers）

初期化

Layer 0 = 背景（PIXI.Graphics で塗り #f0e0d6、一切削除不可）

Layer 1 = 無色透明、デフォルトの描画対象

追加

＋ボタン → new Layer() で生成し、リストと DrawingLayerGroup に同期

削除

🗑ボタン → 対象 Layer を削除（Layer 0 は対象外）

順序変更

UIリストの並べ替え → LayerGroup 内のインデックスを再設定

3.2 レイヤーパネル（@pixi/ui）

シンプル構成（負担を減らすため機能を最小化）

各レイヤー項目は UICard として構築し、以下を配置：

UILabel (Layer name: "背景", "レイヤー1", …)

UIButton ➕（新規作成）

UIButton 🗑（削除）

選択したレイヤーは highlight 表示 → currentLayer を更新

3.3 イベント制御

描画ツール → currentLayer の Container に追加

UI操作

stopPropagation() でキャンバス操作と競合させない

Space+Drag = カメラ移動（既存仕様維持）

4. 実装ステップ
Step 1: 下準備

npm install @pixi/ui @pixi/layers

Pixi Application 作成時に UILayer と DrawingLayerGroup を構築

Step 2: レイヤー初期化

Layer 0 を Graphics 塗りで #f0e0d6 固定背景

Layer 1 を透明レイヤーとして作成、アクティブ設定

Step 3: パネル UI

レイヤーリストを UIList で実装

項目に「ラベル・追加ボタン・削除ボタン」配置

削除時は背景以外のみ対象

Step 4: 操作ロジック

➕ → addLayer()

🗑 → removeLayer(layerId)

ドラッグ並べ替え → LayerGroup のインデックスを更新（可能なら）

Step 5: 統合テスト

背景が常に残っているか確認

アクティブレイヤーが正しく描画対象になるか確認

追加・削除・並べ替えが UI とレイヤー管理に同期するか確認

5. 今後の拡張

レイヤー名の編集（ダブルクリックで入力）

レイヤーマスク / ブレンドモード対応

Undo / Redo 履歴管理

Pixi UI 完全統合（ファイル操作など DOM UI を縮小）

✅ 要点まとめ

背景 Layer 0 (#f0e0d6 固定) + Layer 1 (透明・デフォルトアクティブ)

UIは＋と削除のみの最小構成、ドラッグで順序変更は余裕があれば導入

AI的に扱いやすい最小実装 → 機能拡張しやすい設計



※以下は見本・雛形コード

// ========================
// Futaba Drawing Tool v8 - Pixi UI + Layers 雛形
// ========================

import * as PIXI from 'pixi.js';
import { UIContainer, UIButton, UILabel, UIList, UIDraggable } from '@pixi/ui';
import { Layer, LayerGroup, Stage } from '@pixi/layers';

// ---- 1. PIXI Application ----
const app = new PIXI.Application({
    width: 400,
    height: 400,
    backgroundColor: 0xf0e0d6, // Canvas背景色
});
document.body.appendChild(app.view);

// ---- 2. LayerGroup作成 ----
const drawingLayerGroup = new LayerGroup();
app.stage.addChild(drawingLayerGroup);

// ---- 3. 背景 Layer 0 ----
const layer0 = new PIXI.Container();
const bg = new PIXI.Graphics();
bg.beginFill(0xf0e0d6);
bg.drawRect(0, 0, app.view.width, app.view.height);
bg.endFill();
layer0.addChild(bg);
drawingLayerGroup.addChild(layer0);

// ---- 4. 描画 Layer 1 (透明, デフォルトアクティブ) ----
const layer1 = new PIXI.Container();
drawingLayerGroup.addChild(layer1);
let currentLayer = layer1;

// ---- 5. Pixi UI Layer ----
const uiLayer = new UIContainer();
app.stage.addChild(uiLayer);

// ---- 6. レイヤーパネル作成 ----
const layerPanel = new UIList({
    orientation: 'vertical',
    spacing: 5,
});
uiLayer.addChild(layerPanel);

// ユーティリティ関数: UIリストをLayerGroupと同期
const updateLayerPanel = () => {
    layerPanel.removeChildren();

    const layers = [layer0, layer1]; // 今回は最小2レイヤー
    layers.forEach((layer, index) => {
        const item = new UIContainer();

        // ラベル
        const label = new UILabel({ text: index === 0 ? '背景' : `レイヤー ${index}` });
        item.addChild(label);

        // ➕追加ボタン（末尾追加）
        if(index === layers.length - 1){
            const addBtn = new UIButton({ text: '+' });
            addBtn.on('click', () => {
                const newLayer = new PIXI.Container();
                drawingLayerGroup.addChild(newLayer);
                currentLayer = newLayer;
                updateLayerPanel();
            });
            item.addChild(addBtn);
        }

        // 🗑削除ボタン（背景は削除不可）
        if(index !== 0){
            const delBtn = new UIButton({ text: '🗑' });
            delBtn.on('click', () => {
                drawingLayerGroup.removeChild(layer);
                if(currentLayer === layer) currentLayer = layer1;
                updateLayerPanel();
            });
            item.addChild(delBtn);
        }

        // アクティブハイライト
        if(layer === currentLayer){
            label.style.fill = 0xff0000; // 赤で強調
        }

        // ドラッグで順序変更（余力があれば）
        const draggable = new UIDraggable(item, { axis: 'y' });
        draggable.on('dragend', () => {
            // LayerGroup内インデックス更新処理（未実装:簡易サンプル）
            // 実装時はlayerGroup.children順序をUIリスト順に合わせる
        });

        layerPanel.addChild(item);
    });
};
updateLayerPanel();

// ---- 7. 描画ツールサンプル（ペン） ----
let drawing = false;
app.view.addEventListener('pointerdown', e => {
    drawing = true;
    const rect = app.view.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const graphics = new PIXI.Graphics();
    graphics.lineStyle(2, 0x000000);
    graphics.moveTo(x, y);
    currentLayer.addChild(graphics);

    app.view.addEventListener('pointermove', onPointerMove);
    function onPointerMove(ev){
        if(!drawing) return;
        const nx = ev.clientX - rect.left;
        const ny = ev.clientY - rect.top;
        graphics.lineTo(nx, ny);
    }
});

app.view.addEventListener('pointerup', () => {
    drawing = false;
    app.view.removeEventListener('pointermove', null);
});

⚡ ポイント

Layer 0 = 背景色固定 (#f0e0d6)、削除不可

Layer 1 = 無色透明、デフォルトアクティブ

UI = 最小構成（＋ボタンで追加、🗑ボタンで削除）

ドラッグで並べ替えは UIDraggable を利用、LayerGroup順序更新部分は雛形として記載

描画ツールは currentLayer に直接描画


// ---- 6.1 ドラッグでレイヤー順序変更 ----
const enableLayerDragReorder = () => {
    const items = layerPanel.children;
    items.forEach((item, uiIndex) => {
        const draggable = new UIDraggable(item, { axis: 'y' });

        draggable.on('dragend', () => {
            // 1. UIリスト順を取得
            const newOrder = layerPanel.children;

            // 2. LayerGroup 内の順序を UI順に合わせる
            newOrder.forEach((uiItem, newIndex) => {
                // ラベルのテキストからレイヤーを判定
                const labelText = uiItem.children[0].text; // UILabel
                let targetLayer;
                if(labelText === '背景'){
                    targetLayer = layer0;
                } else {
                    const index = parseInt(labelText.replace('レイヤー ', ''), 10);
                    targetLayer = drawingLayerGroup.children[index];
                }

                // 親のLayerGroupに順序を合わせる
                if(targetLayer && drawingLayerGroup.getChildIndex(targetLayer) !== newIndex){
                    drawingLayerGroup.setChildIndex(targetLayer, newIndex);
                }
            });

            // 3. UIパネル更新してハイライト反映
            updateLayerPanel();
        });
    });
};

// 初回適用
enableLayerDragReorder();

// ---- 6.2 updateLayerPanel にドラッグ再適用を組み込む ----
const updateLayerPanel = () => {
    layerPanel.removeChildren();
    const layers = [layer0, layer1, ...drawingLayerGroup.children.slice(2)];
    layers.forEach((layer, index) => {
        const item = new UIContainer();

        // ラベル
        const label = new UILabel({ text: index === 0 ? '背景' : `レイヤー ${index}` });
        item.addChild(label);

        // ➕追加ボタン（末尾のみ）
        if(index === layers.length - 1){
            const addBtn = new UIButton({ text: '+' });
            addBtn.on('click', () => {
                const newLayer = new PIXI.Container();
                drawingLayerGroup.addChild(newLayer);
                currentLayer = newLayer;
                updateLayerPanel();
            });
            item.addChild(addBtn);
        }

        // 🗑削除ボタン（背景は削除不可）
        if(index !== 0){
            const delBtn = new UIButton({ text: '🗑' });
            delBtn.on('click', () => {
                drawingLayerGroup.removeChild(layer);
                if(currentLayer === layer) currentLayer = layer1;
                updateLayerPanel();
            });
            item.addChild(delBtn);
        }

        // アクティブハイライト
        if(layer === currentLayer){
            label.style.fill = 0xff0000;
        }

        layerPanel.addChild(item);
    });

    // ドラッグ再適用
    enableLayerDragReorder();
};


⚡ ポイント

UIDraggable でUIカードを縦ドラッグ可能に

dragend イベントで LayerGroup 内の順序を UI順に更新

更新後に updateLayerPanel() を呼んでハイライト再描画

背景レイヤーは固定、削除や並べ替え不可


