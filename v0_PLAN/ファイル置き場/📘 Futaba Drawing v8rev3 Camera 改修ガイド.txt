📘 Futaba Drawing v8rev3 Camera 改修ガイド

計画書（ブラッシュアップ版）
Futaba Drawing Tool v8rev3 - Camera 移動改修ガイド

────────────────────────────
序文：現状の課題と改修目的
────────────────────────────
現状の futaba_drawing_v8rev3_camera.html では以下の問題があります。

1. **カメラ枠が移動しない**
   - Space + ドラッグ等の操作を行っても、画面上の描画領域（カメラ枠）が動かず、ワールド全体の移動が確認できない。

2. **座標変換の不整合**
   - worldContainer と UI の座標系が混在しており、描画・UI 操作の一部で不正確な位置が発生する。

3. **イベント処理の不備**
   - PixiJS v8 における `interactive` / `eventMode` の設定不足や、mask による pointer イベント遮断が原因の可能性がある。

本改修計画の目的は、**カメラ移動を正しく実装しつつ描画機能を保持**することにあります。
さらに、AI が効率よく改修できるように、命名統一・辞典化・段階的手順を明示化しています。



1. 用語・辞典（命名統一）
名前	役割	備考
app	Pixi.Application インスタンス	app.stage がルートコンテナ
cameraContainer	ビューポート（マスク付きの窓）	表示範囲を制御。eventMode = "static" を持つ
worldContainer	実際の描画世界（キャンバス相当）	移動・拡縮対象。ペン描画もこの中
uiContainer	サイドバーやポップアップ等	マスク無し。UI 専用
cameraState	カメラ制御の状態保持	{x, y, scale, isPanning, startX, startY}
screenToWorld(x, y)	画面座標 → ワールド座標変換	マウス位置を正しく描画に変換する
worldToScreen(x, y)	ワールド座標 → 画面座標変換	UI / デバッグ用
resetCamera()	カメラ位置・スケール初期化	Home キーで発火
2. 改修計画（段階的）
Step 1. CameraContainer のイベント制御修正

cameraContainer.interactive = true

cameraContainer.eventMode = "static"

mask が pointer event を殺さないように cameraContainer.hitArea = new PIXI.Rectangle(0,0,width,height) を必ず設定。

Step 2. ドラッグ移動（Space + Drag）

keydown → Space 押下で panningMode = true

pointerdown で座標を保持 → pointermove で差分を worldContainer.x/y に加算

pointerup or keyup(Space) で panningMode = false

Step 3. ショートカット制御

Space + ArrowKeys → worldContainer.x/y を ±10px 移動

Home → resetCamera() 呼び出し（位置・スケール初期化）

Step 4. 描画機能復活

条件付き無効化

panningMode = true のときだけ描画を無効化

それ以外はペン・消しゴムツールを通常動作

if (!cameraState.isPanning) { drawLine(...) } のように判定を挟む

Step 5. 座標変換の整理

screenToWorld / worldToScreen を必ず worldContainer.scale, worldContainer.position を考慮して実装

描画系は常に world 座標系で記録

UI 系は screen 座標系を使う

Step 6. ログ出力強化（デバッグ用）

カメラ移動時に console.log(Camera pos: ${worldContainer.x}, ${worldContainer.y}, scale: ${worldContainer.scale.x})

描画座標変換時にもログを出し、誤差をチェックできるようにする

3. 今後の拡張に向けて

レイヤー機能 → worldContainer 内に複数 subContainer を追加

無限キャンバス → worldContainer の背景をタイル描画し、見かけ上無限に広がるようにする

アニメ機能 → cameraState の補間に GSAP を導入し、スムーズ移動・ズーム

✅ この計画に従えば

「ペンが死ぬ」問題は 描画禁止条件の誤設定として解消

「カメラ枠が動かない」問題は interactive / hitArea / eventMode の整理で解消

さらにログで挙動を追えるようになるので、AI でも調整がやりやすい状態になります。




以下は 計画書に沿った「お手本コード」 です。

最小構成で、

・PixiJS コンテナ構造（cameraContainer → worldContainer）

・Space + ドラッグでカメラ移動

・Space + 矢印キーで微調整

・Home キーでリセット

ペン描画は カメラ操作時のみ無効化

を実装しています。

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Futaba Drawing v8rev3 Camera Demo</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.0.5/pixi.min.js"></script>
  <style>
    body { margin: 0; background: #222; overflow: hidden; }
    canvas { display: block; margin: auto; }
  </style>
</head>
<body>
<script>
const app = new PIXI.Application({
  width: 400,
  height: 400,
  backgroundColor: 0x333333,
});
document.body.appendChild(app.view);

// ----------------- Container 構造 -----------------
const cameraContainer = new PIXI.Container();
const worldContainer = new PIXI.Container();
const uiContainer = new PIXI.Container();

cameraContainer.addChild(worldContainer);
app.stage.addChild(cameraContainer);
app.stage.addChild(uiContainer);

// マスク（カメラ枠）
let maskGraphics = new PIXI.Graphics();
maskGraphics.beginFill(0xffffff);
maskGraphics.drawRect(0, 0, app.view.width, app.view.height);
maskGraphics.endFill();
cameraContainer.mask = maskGraphics;
cameraContainer.addChild(maskGraphics);

// hitArea を設定してイベント有効化
cameraContainer.interactive = true;
cameraContainer.eventMode = "static";
cameraContainer.hitArea = new PIXI.Rectangle(0, 0, app.view.width, app.view.height);

// ----------------- カメラ状態 -----------------
const cameraState = {
  x: 0,
  y: 0,
  scale: 1,
  isPanning: false,
  startX: 0,
  startY: 0,
};

// ----------------- 座標変換 -----------------
function screenToWorld(x, y) {
  return {
    x: (x - worldContainer.x) / worldContainer.scale.x,
    y: (y - worldContainer.y) / worldContainer.scale.y,
  };
}

// ----------------- カメラ制御 -----------------
let spacePressed = false;

window.addEventListener("keydown", (e) => {
  if (e.code === "Space") {
    spacePressed = true;
  }
  if (e.code === "ArrowLeft" && spacePressed) worldContainer.x += 10;
  if (e.code === "ArrowRight" && spacePressed) worldContainer.x -= 10;
  if (e.code === "ArrowUp" && spacePressed) worldContainer.y += 10;
  if (e.code === "ArrowDown" && spacePressed) worldContainer.y -= 10;
  if (e.code === "Home") resetCamera();
});

window.addEventListener("keyup", (e) => {
  if (e.code === "Space") {
    spacePressed = false;
    cameraState.isPanning = false;
  }
});

cameraContainer.on("pointerdown", (e) => {
  if (!spacePressed) return; // Space 押下時のみパン
  cameraState.isPanning = true;
  cameraState.startX = e.global.x;
  cameraState.startY = e.global.y;
});

cameraContainer.on("pointermove", (e) => {
  if (!cameraState.isPanning) return;
  const dx = e.global.x - cameraState.startX;
  const dy = e.global.y - cameraState.startY;
  worldContainer.x += dx;
  worldContainer.y += dy;
  cameraState.startX = e.global.x;
  cameraState.startY = e.global.y;
});

cameraContainer.on("pointerup", () => {
  cameraState.isPanning = false;
});
cameraContainer.on("pointerupoutside", () => {
  cameraState.isPanning = false;
});

function resetCamera() {
  worldContainer.x = 0;
  worldContainer.y = 0;
  worldContainer.scale.set(1);
}

// ----------------- ペン描画 -----------------
let drawing = false;
let graphics = new PIXI.Graphics();
worldContainer.addChild(graphics);

cameraContainer.on("pointerdown", (e) => {
  if (spacePressed) return; // カメラ操作中は描画無効
  drawing = true;
  const pos = screenToWorld(e.global.x, e.global.y);
  graphics.moveTo(pos.x, pos.y);
});

cameraContainer.on("pointermove", (e) => {
  if (!drawing || spacePressed) return;
  const pos = screenToWorld(e.global.x, e.global.y);
  graphics.lineStyle(2, 0xffffff, 1);
  graphics.lineTo(pos.x, pos.y);
  graphics.moveTo(pos.x, pos.y);
});

cameraContainer.on("pointerup", () => {
  drawing = false;
});
cameraContainer.on("pointerupoutside", () => {
  drawing = false;
});

console.log("✅ Camera system ready");
</script>
</body>
</html>



以下は ブラッシュアップ版計画書に沿った「お手本コード」 です。

最小構成で、

PixiJS コンテナ構造（cameraContainer → worldContainer）

Space + ドラッグでカメラ移動

Space + 矢印キーで微調整

Home キーでリセット

ペン描画は カメラ操作時のみ無効化

を実装しています。

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Futaba Drawing v8rev3 Camera Demo</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.0.5/pixi.min.js"></script>
  <style>
    body { margin: 0; background: #222; overflow: hidden; }
    canvas { display: block; margin: auto; }
  </style>
</head>
<body>
<script>
const app = new PIXI.Application({
  width: 400,
  height: 400,
  backgroundColor: 0x333333,
});
document.body.appendChild(app.view);

// ----------------- Container 構造 -----------------
const cameraContainer = new PIXI.Container();
const worldContainer = new PIXI.Container();
const uiContainer = new PIXI.Container();

cameraContainer.addChild(worldContainer);
app.stage.addChild(cameraContainer);
app.stage.addChild(uiContainer);

// マスク（カメラ枠）
let maskGraphics = new PIXI.Graphics();
maskGraphics.beginFill(0xffffff);
maskGraphics.drawRect(0, 0, app.view.width, app.view.height);
maskGraphics.endFill();
cameraContainer.mask = maskGraphics;
cameraContainer.addChild(maskGraphics);

// hitArea を設定してイベント有効化
cameraContainer.interactive = true;
cameraContainer.eventMode = "static";
cameraContainer.hitArea = new PIXI.Rectangle(0, 0, app.view.width, app.view.height);

// ----------------- カメラ状態 -----------------
const cameraState = {
  x: 0,
  y: 0,
  scale: 1,
  isPanning: false,
  startX: 0,
  startY: 0,
};

// ----------------- 座標変換 -----------------
function screenToWorld(x, y) {
  return {
    x: (x - worldContainer.x) / worldContainer.scale.x,
    y: (y - worldContainer.y) / worldContainer.scale.y,
  };
}

// ----------------- カメラ制御 -----------------
let spacePressed = false;

window.addEventListener("keydown", (e) => {
  if (e.code === "Space") {
    spacePressed = true;
  }
  if (e.code === "ArrowLeft" && spacePressed) worldContainer.x += 10;
  if (e.code === "ArrowRight" && spacePressed) worldContainer.x -= 10;
  if (e.code === "ArrowUp" && spacePressed) worldContainer.y += 10;
  if (e.code === "ArrowDown" && spacePressed) worldContainer.y -= 10;
  if (e.code === "Home") resetCamera();
});

window.addEventListener("keyup", (e) => {
  if (e.code === "Space") {
    spacePressed = false;
    cameraState.isPanning = false;
  }
});

cameraContainer.on("pointerdown", (e) => {
  if (!spacePressed) return; // Space 押下時のみパン
  cameraState.isPanning = true;
  cameraState.startX = e.global.x;
  cameraState.startY = e.global.y;
});

cameraContainer.on("pointermove", (e) => {
  if (!cameraState.isPanning) return;
  const dx = e.global.x - cameraState.startX;
  const dy = e.global.y - cameraState.startY;
  worldContainer.x += dx;
  worldContainer.y += dy;
  cameraState.startX = e.global.x;
  cameraState.startY = e.global.y;
});

cameraContainer.on("pointerup", () => {
  cameraState.isPanning = false;
});
cameraContainer.on("pointerupoutside", () => {
  cameraState.isPanning = false;
});

function resetCamera() {
  worldContainer.x = 0;
  worldContainer.y = 0;
  worldContainer.scale.set(1);
}

// ----------------- ペン描画 -----------------
let drawing = false;
let graphics = new PIXI.Graphics();
worldContainer.addChild(graphics);

cameraContainer.on("pointerdown", (e) => {
  if (spacePressed) return; // カメラ操作中は描画無効
  drawing = true;
  const pos = screenToWorld(e.global.x, e.global.y);
  graphics.moveTo(pos.x, pos.y);
});

cameraContainer.on("pointermove", (e) => {
  if (!drawing || spacePressed) return;
  const pos = screenToWorld(e.global.x, e.global.y);
  graphics.lineStyle(2, 0xffffff, 1);
  graphics.lineTo(pos.x, pos.y);
  graphics.moveTo(pos.x, pos.y);
});

cameraContainer.on("pointerup", () => {
  drawing = false;
});
cameraContainer.on("pointerupoutside", () => {
  drawing = false;
});

console.log("✅ Camera system ready");
</script>
</body>
</html>

✅ このお手本でできること

Space + ドラッグ → カメラ移動

Space + 矢印キー → 微調整移動

Home → リセット

ペン描画 → Space 押していないときのみ有効