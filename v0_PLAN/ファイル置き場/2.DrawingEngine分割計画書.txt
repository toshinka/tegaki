================================================================================
  DrawingEngine分割計画書 v1.0
  作成日: 2025-10-09
  目的: 機能追加による肥大化防止 + AI可読性向上
================================================================================

【分割方針】
  ■ 単一責任の原則 (SRP) に基づく分割
  ■ 各モジュールは明確なインターフェースを持つ
  ■ core-engine.jsは統合のみ担当
  ■ ファイル構造でフローが把握できる設計

【分割後のファイル構成】

system/
  ├── drawing/
  │   ├── drawing-engine.js          (統合・公開API)
  │   ├── stroke-renderer.js         (Perfect Freehand描画)
  │   ├── stroke-recorder.js         (座標収集・パスデータ管理)
  │   ├── pressure-handler.js        (筆圧検知・疑似筆圧)
  │   ├── brush-settings.js          (ブラシ設定管理)
  │   └── stroke-transformer.js      (レイヤー変形対応)


================================================================================
  1. drawing-engine.js (統合・公開API)
================================================================================

【責務】
  - 各サブモジュールの初期化・統合
  - 外部からの描画操作API提供 (startDrawing, continueDrawing, stopDrawing)
  - EventBus連携
  - History連携の橋渡し

【メソッド】
  ✓ constructor(cameraSystem, layerManager, eventBus, config)
  ✓ startDrawing(screenX, screenY, pressure)
  ✓ continueDrawing(screenX, screenY, pressure)
  ✓ stopDrawing()
  ✓ setTool(tool)
  ✓ setBrushSize(size)
  ✓ setBrushColor(color)
  ✓ setBrushOpacity(opacity)

【依存関係】
  → StrokeRecorder (座標記録)
  → StrokeRenderer (描画実行)
  → PressureHandler (筆圧処理)
  → BrushSettings (設定管理)
  → StrokeTransformer (変形処理)

【サイズ目安】
  200-300行 (統合ロジックのみ)


================================================================================
  2. stroke-renderer.js (Perfect Freehand描画)
================================================================================

【責務】
  - Perfect Freehandによるストローク補正
  - PIXI.Graphicsへの描画実行
  - フォールバック処理 (Perfect Freehand未ロード時)
  - ズーム対応の線幅計算 (Phase 2)

【主要メソッド】
  ✓ constructor(config)
  ✓ renderStroke(points, strokeOptions, graphics)
    - Perfect Freehandでアウトライン生成
    - graphics.poly()で描画
    - エラー時はフォールバック
  
  ✓ renderStrokeWithCircles(points, size, color, opacity, graphics)
    - フォールバック用の円描画
  
  ✓ getScaledSize(baseSize, cameraScale) [Phase 2]
    - ズーム率に応じた線幅計算
  
  ✓ rebuildPathGraphics(pathData) [Undo/Redo用]
    - パスデータからGraphicsを再構築

【依存関係】
  → window.getStroke (Perfect Freehand)
  → PIXI.Graphics

【使用例】
  const renderer = new StrokeRenderer(config);
  renderer.renderStroke(points, strokeOptions, graphics);

【サイズ目安】
  150-200行


================================================================================
  3. stroke-recorder.js (座標収集・パスデータ管理)
================================================================================

【責務】
  - 描画中の座標収集
  - パスデータ構造の生成・管理
  - 距離判定 (間引き処理)
  - パスIDの生成

【主要メソッド】
  ✓ constructor()
  ✓ startNewPath(initialPoint, color, size, opacity, tool, strokeOptions)
    - 新規パス開始
    - パスIDの生成
    - return: pathData
  
  ✓ addPoint(pathData, point)
    - ポイント追加
    - 距離判定で間引き
  
  ✓ finalizePath(pathData)
    - パス完了処理
    - isComplete = true
  
  ✓ generatePathId()
    - ユニークなパスID生成
  
  ✓ clonePathData(pathData)
    - History用のディープコピー

【パスデータ構造】
  {
    id: string,
    points: [{ x, y, pressure }],
    color: number,
    size: number,
    opacity: number,
    tool: 'pen' | 'eraser',
    isComplete: boolean,
    strokeOptions: {...},
    originalSize: number,      [Phase 2]
    scaleAtDrawTime: number    [Phase 2]
  }

【使用例】
  const recorder = new StrokeRecorder();
  const path = recorder.startNewPath(point, color, size, opacity, tool, options);
  recorder.addPoint(path, newPoint);

【サイズ目安】
  100-150行


================================================================================
  4. pressure-handler.js (筆圧検知・疑似筆圧)
================================================================================

【責務】
  - PointerEvent.pressureの取得
  - 筆圧非対応デバイス向けの疑似筆圧算出 (速度ベース)
  - 筆圧正規化 (0.0-1.0範囲に収める)

【主要メソッド】
  ✓ constructor()
  ✓ getPressure(pointerEvent)
    - 実筆圧優先
    - 非対応時は疑似筆圧
    - return: number (0.0-1.0)
  
  ✓ estimatePressureFromVelocity(x, y, timestamp)
    - 移動速度から筆圧推定
    - 速度が速い → 筆圧低い
  
  ✓ normalizePressure(rawPressure)
    - 0.0-1.0に正規化
  
  ✓ reset()
    - 状態リセット (描画終了時)

【内部状態】
  - lastPoint: { x, y }
  - lastTimestamp: number
  - velocityHistory: number[] (移動平均用)

【使用例】
  const pressureHandler = new PressureHandler();
  const pressure = pressureHandler.getPressure(pointerEvent);

【サイズ目安】
  80-120行 (Phase 3で実装)


================================================================================
  5. brush-settings.js (ブラシ設定管理)
================================================================================

【責務】
  - ブラシサイズ・色・不透明度の管理
  - Perfect Freehand strokeOptionsの生成
  - 設定変更時のバリデーション
  - EventBus連携

【主要メソッド】
  ✓ constructor(config, eventBus)
  ✓ getBrushSize()
  ✓ setBrushSize(size)
    - バリデーション (0.1-100)
    - EventBus発火
  
  ✓ getBrushColor()
  ✓ setBrushColor(color)
  
  ✓ getBrushOpacity()
  ✓ setBrushOpacity(opacity)
    - バリデーション (0.0-1.0)
  
  ✓ getStrokeOptions()
    - Perfect Freehand用のオプション生成
    - return: { size, thinning, smoothing, ... }
  
  ✓ updateStrokeOptions(overrides)
    - 部分的な設定上書き

【設定データ】
  {
    size: number,
    color: number,
    opacity: number,
    thinning: number,
    smoothing: number,
    streamline: number,
    simulatePressure: boolean
  }

【使用例】
  const settings = new BrushSettings(config, eventBus);
  const options = settings.getStrokeOptions();

【サイズ目安】
  100-150行


================================================================================
  6. stroke-transformer.js (レイヤー変形対応)
================================================================================

【責務】
  - レイヤー変形時のストローク座標変換
  - PIXI.Matrixを使った座標変換
  - 変形の適用判定

【主要メソッド】
  ✓ constructor(config)
  ✓ applyTransformToPath(path, transform)
    - レイヤー変形をパスに適用
    - 逆行列で座標変換
    - return: 変換後のGraphics
  
  ✓ isTransformNonDefault(transform)
    - 変形が初期値かチェック
  
  ✓ createTransformMatrix(transform, canvasWidth, canvasHeight)
    - 変形用のMatrixを生成

【使用例】
  const transformer = new StrokeTransformer(config);
  const transformedGraphics = transformer.applyTransformToPath(path, transform);

【サイズ目安】
  80-120行


================================================================================
  統合後の core-engine.js
================================================================================

【変更点】
  - DrawingEngineクラスは薄いラッパーに
  - 各サブモジュールのインスタンス保持
  - 外部APIの提供のみ

【擬似コード】
  class DrawingEngine {
    constructor(cameraSystem, layerManager, eventBus, config) {
      this.settings = new BrushSettings(config, eventBus);
      this.recorder = new StrokeRecorder();
      this.renderer = new StrokeRenderer(config);
      this.pressureHandler = new PressureHandler();
      this.transformer = new StrokeTransformer(config);
      // ...
    }
    
    startDrawing(screenX, screenY, pressure) {
      const point = this.cameraSystem.screenToCanvas(screenX, screenY);
      pressure = this.pressureHandler.getPressure(pressure);
      const options = this.settings.getStrokeOptions();
      
      this.currentPath = this.recorder.startNewPath(
        point, 
        this.settings.getBrushColor(),
        this.settings.getBrushSize(),
        this.settings.getBrushOpacity(),
        this.currentTool,
        options
      );
      // ...
    }
    
    continueDrawing(screenX, screenY, pressure) {
      const point = this.cameraSystem.screenToCanvas(screenX, screenY);
      this.recorder.addPoint(this.currentPath, point);
      this.renderer.renderStroke(
        this.currentPath.points,
        this.currentPath.strokeOptions,
        this.currentPath.graphics
      );
    }
    
    stopDrawing() {
      this.recorder.finalizePath(this.currentPath);
      // History登録処理
    }
  }


================================================================================
  分割実施手順
================================================================================

【Phase 0: 分割準備】
  1. system/drawing/ ディレクトリ作成
  2. 各ファイルの雛形作成
  3. グローバル変数の命名規則確認
     - window.TegakiDrawing = { StrokeRenderer, StrokeRecorder, ... }

【Phase 1: StrokeRenderer分離】
  1. stroke-renderer.js作成
  2. renderStroke()実装
  3. rebuildPathGraphics()移動
  4. drawing-engine.jsから呼び出し

【Phase 2: StrokeRecorder分離】
  1. stroke-recorder.js作成
  2. パスデータ生成ロジック移動
  3. drawing-engine.jsから呼び出し

【Phase 3: BrushSettings分離】
  1. brush-settings.js作成
  2. 設定管理ロジック移動
  3. EventBus連携

【Phase 4: その他モジュール】
  1. pressure-handler.js (Phase 3タイミング)
  2. stroke-transformer.js (既存ロジック移動)

【Phase 5: core-engine.js統合】
  1. DrawingEngineをラッパー化
  2. サブモジュール初期化
  3. 動作確認


================================================================================
  分割のメリット
================================================================================

✓ 可読性向上
  - 各ファイル150-300行程度
  - 責務が明確
  - AIが改修しやすい

✓ テスト容易性
  - 各モジュール単体でテスト可能
  - モックを使った単体テスト

✓ 拡張性
  - 新機能追加時に既存コードに影響少ない
  - Phase 5のシェーダー追加が容易

✓ 保守性
  - バグ発生時の影響範囲が限定的
  - 機能の差し替えが容易


================================================================================
  分割のデメリットと対策
================================================================================

▼ ファイル数増加
  → ディレクトリ構造で整理
  → index.html読み込み順を明確化

▼ 初期化順序の複雑化
  → core-engine.jsで一元管理
  → 依存関係を明示

▼ デバッグの難易度
  → 各モジュールにバージョン情報
  → console.log最小限


================================================================================
  index.html 読み込み順序 (分割後)
================================================================================

<script src="system/drawing/stroke-recorder.js"></script>
<script src="system/drawing/stroke-renderer.js"></script>
<script src="system/drawing/brush-settings.js"></script>
<script src="system/drawing/pressure-handler.js"></script>
<script src="system/drawing/stroke-transformer.js"></script>
<script src="system/drawing/drawing-engine.js"></script>
<script src="core-engine.js"></script>


================================================================================
  実施タイミングの推奨
================================================================================

【オプション A: Phase 1完了後すぐに分割】
  メリット: 早期に構造改善、以降の実装が楽
  デメリット: Phase 1の動作確認がやり直し

【オプション B: Phase 3完了後に分割】
  メリット: ある程度機能が揃ってから整理
  デメリット: 分割作業が大規模になる

【推奨: オプション A (Phase 1後すぐ)】
  理由:
  - 早期に構造を確立
  - Phase 2-3の実装が分割後の構造で進む
  - 巨大なcore-engine.jsを避ける


================================================================================
  次のステップ
================================================================================

1. 分割実施の可否決定
2. Phase 1を分割前提で実装するか、従来通り実装後に分割するか選択
3. 分割実施時は stroke-renderer.js から着手


================================================================================
  END OF DOCUMENT
================================================================================