============================================================
Tegaki v8 星型分離改修計画書（ドラフト＋具体化）
============================================================

目的
------------------------------------------------------------
- futaba_layers_rev4.html をベースに、改修時の影響範囲を最小化
  → 主星(MainController)＋1衛星の改修で済む構造を意識
- CANVAS2D 排除、PixiJSによるベクターペン重視描画
- レイヤー移動・Undo/Redo・非破壊描画フローの衛星化
- ショートカット操作（P/E, CTRL+Z/Y）対応

------------------------------------------------------------
1. 基本方針
------------------------------------------------------------
1.1 衛星は「フロー単位」で衛星化する
  - 単純な責務分離ではなく、機能フローとしてまとまったものを衛星化
  - 例：DrawingEngine + LayerService を統合的に扱うが、改修時に LayerService のみ変更可能
1.2 主星は衛星の仲介・確定・エラーハンドリングに専念
  - 衛星同士の直接依存は禁止
1.3 Canvas2Dは排除、描画はPixiJS Graphicsによるベクターペンのみ
  - Transform・Undo/Redo対応のため
1.4 改修時の影響範囲を見える化
  - 各衛星に register(mainApi) を持たせ、主星経由で操作
  - UIやショートカット操作は別衛星化も検討可能だが現状は主星経由で通知

------------------------------------------------------------
2. 衛星・ファイル構成（rev4ベース）
------------------------------------------------------------
| 衛星 (ファイル)               | 主な責務 / API                               | 改修時影響範囲 |
|--------------------------------|---------------------------------------------|----------------|
| MainController (main.html)     | 衛星初期化、イベント仲介、ErrorService 呼び出し | 全体           |
| DrawingEngine (drawing-engine.js)| PixiJS Application生成、EngineBridge 提供 | 描画フロー全般 |
| LayerService (layer-manager.js)| レイヤー生成/削除/移動、Stage管理           | レイヤー関連   |
| PositionService (position-manager.js)| パン・ズーム管理、座標変換                   | キャンバス移動 |
| ToolManager (tool-manager.js)  | ツール登録/選択、Toolインターフェース提供    | ツール操作     |
| BrushTool / EraserTool / TransformTool (tools/*.js)| 描画フローの実装、serialize(), start/move/end| 個別ツール     |
| HistoryService (history-service.js)| record/undo/redo、非破壊記録フロー        | 履歴管理       |
| UIService (ui-manager.js)      | DOM生成、ツール通知、ポップアップ操作        | UI表示         |
| ErrorService (error-service.js)| エラーフロー管理、UI通知                     | 全体           |

------------------------------------------------------------
3. 衛星間フロー例（ペン描画）
------------------------------------------------------------
1. ツール操作（BrushTool.start/move/end） → ToolManager 経由
2. ToolManager → MainController.notify(event)
3. MainController → LayerService/PositionService で描画座標計算
4. MainController → DrawingEngine.drawTemporaryStroke / commitStroke
5. MainController → HistoryService.record(action)（end時）
6. Undo/Redo: MainController → HistoryService.undo()/redo() → LayerService + DrawingEngine更新
7. エラー: 衛星 → MainController.notify({type:'error'}) → ErrorService → UIService

※消しゴムもベクターペン扱い、BlendMode.ERASE相当を使用

------------------------------------------------------------
4. 改修時の操作範囲指針
------------------------------------------------------------
- ペン・消しゴム描画フロー変更 → DrawingEngine + 該当Tool + HistoryService
- レイヤー挿入/削除/移動 → LayerService + HistoryService
- キャンバス移動・ズーム → PositionServiceのみ
- UI表示/ポップアップ変更 → UIServiceのみ
- ショートカット追加 → ToolManager または独立衛星化を検討

------------------------------------------------------------
5. メソッド・フロー辞典の参考構造
------------------------------------------------------------
1. MainController
   - notify(event)
   - dispatch(action)
   - registerSatellite(satelliteApi)
2. DrawingEngine
   - drawTemporaryStroke(layerId, points)
   - commitStroke(layerId, strokeData)
   - clearLayer(layerId)
   - takeSnapshot(layerId)
3. LayerService
   - createLayer(name)
   - removeLayer(layerId)
   - reorderLayer(fromIndex, toIndex)
   - setLayerMeta(layerId, meta)
4. PositionService
   - setPan(x, y)
   - setZoom(scale)
   - canvasToWorld(point)
   - worldToCanvas(point)
5. ToolManager
   - setActiveTool(toolId)
   - registerTool(tool)
6. Brush/Eraser/TransformTool
   - start(point, meta)
   - move(point, meta)
   - end(point, meta)
   - cancel(meta)
   - serialize()
7. HistoryService
   - record(action)
   - undo()
   - redo()
   - getState()
8. UIService
   - createToolbar()
   - createLayerPopup()
   - toggleSidebar()
9. ErrorService
   - reportRecoverable(code, msg, context)
   - reportFatal(code, msg, stack)

------------------------------------------------------------
6. 改修のポイント
------------------------------------------------------------
- 衛星間依存を避け、主星経由でイベント・データやり取り
- Canvas2D排除 → PixiJS Graphicsのみ
- 消しゴムもベクターペンフローで統一
- LayerServiceはDrawingEngineに依存せず、EngineBridgeで描画
- 改修時は衛星単位で済む構造を維持
- Undo/Redo は HistoryServiceで一括管理、非破壊レイヤー対応
- 将来的にショートカットなど新衛星を追加可能な構造

============================================================


📝下記はサンプルコードです。参考にしてください。
============================================================

<!-- futaba_layers_rev5_sample.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tegaki v8 Sample</title>
<style>
  body { margin:0; overflow:hidden; }
  #canvas-container { width:100vw; height:100vh; background:#fff; }
</style>
</head>
<body>
<div id="canvas-container"></div>

<!-- External Libraries -->
<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.0.5/dist/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>

<script>
// =======================
// MainController
// =======================
class MainController {
  constructor() {
    this.satellites = {};
    this.debug = true;
  }

  registerSatellite(name, api) {
    this.satellites[name] = api;
  }

  notify(event) {
    if (this.debug) console.log('[MainController] Event:', event.type, event.payload);
    // Dispatch to satellites if needed
  }
}

// =======================
// DrawingEngine
// =======================
class DrawingEngine {
  constructor(container) {
    this.app = new PIXI.Application({
      width: container.clientWidth,
      height: container.clientHeight,
      backgroundAlpha: 0
    });
    container.appendChild(this.app.view);
    this.layers = {};
  }

  createLayer(id) {
    const layer = new PIXI.Graphics();
    layer.name = id;
    this.app.stage.addChild(layer);
    this.layers[id] = layer;
    return layer;
  }

  drawTemporaryStroke(layerId, points, color=0x000000, width=2) {
    const layer = this.layers[layerId];
    if (!layer) return;
    layer.clear();
    layer.lineStyle(width, color);
    layer.moveTo(points[0].x, points[0].y);
    for (let i=1;i<points.length;i++) layer.lineTo(points[i].x, points[i].y);
  }

  commitStroke(layerId, points, color=0x000000, width=2) {
    const layer = this.layers[layerId];
    if (!layer) return;
    layer.lineStyle(width, color);
    layer.moveTo(points[0].x, points[0].y);
    for (let i=1;i<points.length;i++) layer.lineTo(points[i].x, points[i].y);
  }
}

// =======================
// LayerService
// =======================
class LayerService {
  constructor(engine) {
    this.engine = engine;
    this.layerIds = [];
  }

  createLayer(name) {
    const id = `layer_${this.layerIds.length}`;
    this.layerIds.push(id);
    this.engine.createLayer(id);
    return id;
  }

  reorderLayer(fromIndex, toIndex) {
    if (fromIndex < 0 || toIndex < 0) return;
    const [id] = this.layerIds.splice(fromIndex,1);
    this.layerIds.splice(toIndex,0,id);
    // Stage child reordering
    this.engine.app.stage.setChildIndex(this.engine.layers[id], toIndex);
  }
}

// =======================
// ToolManager
// =======================
class ToolManager {
  constructor(main) {
    this.main = main;
    this.tools = {};
    this.activeTool = null;
  }

  registerTool(tool) {
    this.tools[tool.id] = tool;
  }

  setActiveTool(toolId) {
    this.activeTool = this.tools[toolId];
  }
}

// =======================
// Tools
// =======================
class BrushTool {
  constructor(engine, layerService) {
    this.id = 'brush';
    this.engine = engine;
    this.layerService = layerService;
    this.points = [];
    this.currentLayer = null;
  }

  start(point) {
    if (!this.currentLayer) this.currentLayer = this.layerService.layerIds[0];
    this.points = [point];
  }

  move(point) {
    this.points.push(point);
    this.engine.drawTemporaryStroke(this.currentLayer, this.points, 0x000000, 2);
  }

  end() {
    this.engine.commitStroke(this.currentLayer, this.points, 0x000000, 2);
    this.points = [];
  }

  cancel() {
    this.points = [];
  }

  serialize() {
    return { layer: this.currentLayer, points: this.points };
  }
}

class EraserTool {
  constructor(engine, layerService) {
    this.id = 'eraser';
    this.engine = engine;
    this.layerService = layerService;
    this.points = [];
    this.currentLayer = null;
  }

  start(point) {
    if (!this.currentLayer) this.currentLayer = this.layerService.layerIds[0];
    this.points = [point];
  }

  move(point) {
    this.points.push(point);
    this.engine.drawTemporaryStroke(this.currentLayer, this.points, 0xFFFFFF, 10);
  }

  end() {
    this.engine.commitStroke(this.currentLayer, this.points, 0xFFFFFF, 10);
    this.points = [];
  }

  cancel() {
    this.points = [];
  }

  serialize() {
    return { layer: this.currentLayer, points: this.points };
  }
}

// =======================
// HistoryService
// =======================
class HistoryService {
  constructor() {
    this.stack = [];
    this.pointer = -1;
  }

  record(action) {
    this.stack = this.stack.slice(0,this.pointer+1);
    this.stack.push(action);
    this.pointer++;
  }

  undo() {
    if (this.pointer<0) return;
    const action = this.stack[this.pointer];
    this.pointer--;
    return action;
  }

  redo() {
    if (this.pointer+1>=this.stack.length) return;
    this.pointer++;
    return this.stack[this.pointer];
  }
}

// =======================
// Initialization
// =======================
const container = document.getElementById('canvas-container');
const main = new MainController();
const engine = new DrawingEngine(container);
const layerService = new LayerService(engine);
const toolManager = new ToolManager(main);
const history = new HistoryService();

layerService.createLayer('base');

const brush = new BrushTool(engine, layerService);
const eraser = new EraserTool(engine, layerService);

toolManager.registerTool(brush);
toolManager.registerTool(eraser);
toolManager.setActiveTool('brush');

// =======================
// Mouse / Touch Handling
// =======================
let isDrawing = false;
container.addEventListener('pointerdown', e=>{
  isDrawing = true;
  const pt = { x:e.offsetX, y:e.offsetY };
  toolManager.activeTool.start(pt);
});

container.addEventListener('pointermove', e=>{
  if(!isDrawing) return;
  const pt = { x:e.offsetX, y:e.offsetY };
  toolManager.activeTool.move(pt);
});

container.addEventListener('pointerup', e=>{
  if(!isDrawing) return;
  const pt = { x:e.offsetX, y:e.offsetY };
  toolManager.activeTool.end();
  isDrawing=false;
  history.record(toolManager.activeTool.serialize());
});

// =======================
// Shortcuts
// =======================
document.addEventListener('keydown', e=>{
  if(e.ctrlKey && e.key==='z') {
    const action = history.undo();
    if(action) console.log('Undo:', action);
  }
  if(e.ctrlKey && e.key==='y') {
    const action = history.redo();
    if(action) console.log('Redo:', action);
  }
  if(e.key==='p') toolManager.setActiveTool('brush');
  if(e.key==='e') toolManager.setActiveTool('eraser');
});
</script>
</body>
</html>




このサンプルでは：

Canvas2Dは使用せず、PixiJS Graphicsでベクターペン・消しゴムを描画

Undo/RedoはCtrl+Z / Ctrl+Yで操作

ペン(P)/消しゴム(E)の切替はショートカットのみ

LayerService + DrawingEngine + ToolManager + HistoryServiceの関係を整理

改修時はDrawingEngine内で描画フローを分離して切り出せる構造




◆1. ペン描画→記録フロー

今は「ToolManager → DrawingEngine → LayerManager/PositionManager → MainController → HistoryService」という流れが基本ですが、実務上は以下のように整理すると誤解が少なくなります：

1.ToolManager

 現在アクティブのツールが start/move/end を発火

2.DrawingEngine（EngineBridge）

 描画バッファに一時描画 (drawTemporaryStroke)

 終了時に確定 (commitStroke)

3.LayerManager / PositionManager

 レイヤー構造や座標系の確認

 必要に応じて canvasToWorld / worldToCanvas 変換

4.MainController

 確定イベントを受け取り、HistoryService に通知

5.HistoryService

 action を record

 undo/redo 対応用にスナップショットを保持

ポイント

 消しゴムは commitStroke 内で BLEND_MODE を切り替える

 座標系は 常に World 座標基準で履歴に記録

 Canvas 座標への変換は描画時のみ（スクリーン依存フローを避ける）

◆2. World座標の扱い

 Tool → Engine → Layer の間は World 座標基準

 Canvas 座標は描画・レンダリング時のみ使用

 無限キャンバスやパン/ズーム対応に必要

 フロー辞典に「どこで World → Canvas に変換するか」を明示すると誤用を防げる

◆3. 他に指標として明示すべきフロー

1.非破壊レイヤー移動

 TransformTool → PositionManager → LayerManager → commitStroke / record

 履歴に座標差分だけを残す

2.Undo/Redoフロー

 どの衛星がスナップショットを取得するか

 DrawingEngine が canvas → data に変換する

3.エラー伝播

 Tool で例外発生 → MainController.notify → ErrorService

4.サイレントに隠さず明示的にフローを通す

 アクティブツール切り替え

 ToolManager が activeTool を切り替え

 描画中のイベントは必ず currentTool 経由でのみ発火

