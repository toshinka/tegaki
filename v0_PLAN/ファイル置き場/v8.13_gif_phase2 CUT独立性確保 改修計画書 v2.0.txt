# v8.13_gif_phase2 CUT独立性確保 改修計画書 v2.0

**作成日**: 2025-10-02  
**対象バージョン**: v8.13_gif_phase2  
**目的**: CUT間でのデータ共有問題の完全解決

---

## 📋 目次

1. [問題の詳細分析](#問題の詳細分析)
2. [現在のデータフロー図](#現在のデータフロー図)
3. [根本原因の特定](#根本原因の特定)
4. [改修方針](#改修方針)
5. [段階的改修計画](#段階的改修計画)
6. [各ファイルの改修詳細](#各ファイルの改修詳細)
7. [検証手順](#検証手順)

---

## 問題の詳細分析

### 🐛 観察された症状

#### 症状1: タイムラインにCUT1が表示されない

```
現象: 
- アプリ起動時にタイムラインが空
- +Cボタンを押すと初めてCUT1が出現

原因:
- AnimationSystem.createInitialCutIfNeeded()が正しく動作していない
- EventBus通知タイミングの問題
```

#### 症状2: CUT間でデータが共有される

```
現象:
- CUT1で描画 → CUT2作成 → CUT2にもCUT1の描画が反映される
- CUT1をコピーして隣接ペースト → 両方のCUTが同じ内容

原因:
- deepCopyが機能していない
- Container.childrenの参照共有
```

---

## 現在のデータフロー図

### 初期化フロー

```
┌─────────────────────────────────────────────────────────┐
│ index.html ロード                                        │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ PIXI.Application 初期化                                  │
│  - app = new PIXI.Application()                         │
│  - app.stage 作成                                        │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ CoreEngine.initialize()                                  │
│  ├─ CameraSystem.init(stage)                            │
│  ├─ LayerSystem.init()                                  │
│  │   └─ _createTemporaryCutContainer()  ←★問題箇所1     │
│  │       ├─ currentCutContainer 作成                     │
│  │       ├─ 背景レイヤー作成                              │
│  │       └─ レイヤー1作成                                 │
│  │                                                        │
│  ├─ AnimationSystem.init(layerSystem, app)              │
│  │   ├─ layerSystem.animationSystem = this              │
│  │   ├─ stage.addChild(layerSystem.currentCutContainer) │
│  │   └─ setTimeout(createInitialCutIfNeeded, 150ms)     │
│  │                                                        │
│  └─ TimelineUI.init()                                    │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ createInitialCutIfNeeded() (150ms後)                     │
│  ├─ new Cut('cut1')                                      │
│  ├─ _deepCopyLayer(tempLayer)  ←★問題箇所2              │
│  │   └─ paths参照がコピーされていない可能性                │
│  ├─ stage.removeChild(tempContainer)                     │
│  ├─ stage.addChild(cut.container)                        │
│  └─ emit('animation:initial-cut-created')  ←★問題箇所3   │
│       └─ TimelineUIが受信できていない？                    │
└─────────────────────────────────────────────────────────┘
```

### 描画フロー（現在）

```
┌─────────────────────────────────────────────────────────┐
│ ユーザーがペンで描画                                      │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ DrawingEngine.startDrawing()                             │
│  ├─ currentPath = { points: [], graphics: ... }         │
│  └─ addPathToActiveLayer(currentPath)                   │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ DrawingEngine.stopDrawing()                              │
│  ├─ currentPath.isComplete = true                       │
│  └─ layerManager.requestThumbnailUpdate()               │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ activeLayer (CUT Container内)                            │
│  ├─ layer.layerData.paths.push(path)  ←★ここに保存      │
│  └─ layer.addChild(path.graphics)                       │
└─────────────────────────────────────────────────────────┘
```

### CUT作成フロー（問題発生）

```
┌─────────────────────────────────────────────────────────┐
│ +C ボタン押下                                             │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ AnimationSystem.createNewCutFromCurrentLayers()          │
│  ├─ new Cut('cut_xxx')                                   │
│  └─ currentLayers.forEach(originalLayer => {            │
│       const copiedLayer = _deepCopyLayer(originalLayer) │
│       cut.addLayer(copiedLayer)                          │
│     })                                                   │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ _deepCopyLayer(originalLayer)  ←★問題箇所4               │
│  ├─ new PIXI.Container()                                 │
│  ├─ layerData = { paths: [] }                           │
│  └─ originalLayer.layerData.paths.forEach(path => {     │
│       const copiedPath = _deepCopyPath(path)  ←★ここ     │
│       layerData.paths.push(copiedPath)                   │
│     })                                                   │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ _deepCopyPath(originalPath)  ←★問題箇所5                 │
│  ├─ copiedPoints = originalPath.points.map(p =>         │
│  │     ({ x: p.x, y: p.y })  ←新しい配列作成            │
│  │                                                        │
│  └─ return {                                             │
│       id: 'path_xxx',  ←新しいID                         │
│       points: copiedPoints,  ←新しい配列                 │
│       graphics: new PIXI.Graphics()  ←新しいGraphics     │
│     }                                                    │
└─────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────┐
│ 【理論上は独立しているはず】                               │
│ しかし実際には共有されている...                           │
│                                                          │
│ 可能性1: LayerSystemのcurrentCutContainerが              │
│          切り替わっていない                                │
│                                                          │
│ 可能性2: EventBusのタイミングで古い参照が残る             │
│                                                          │
│ 可能性3: graphics再描画時に元のpointsを参照               │
└─────────────────────────────────────────────────────────┘
```

---

## 根本原因の特定

### ❌ 原因1: CUT切り替え時のContainer更新タイミング

```javascript
// animation-system.js
switchToActiveCut(cutIndex) {
    // 問題: cutSwitchInProgressフラグで再入防止しているが、
    // LayerSystemへの通知が遅延する
    
    targetCut.container.visible = true;
    this.layerSystem.setCurrentCutContainer(targetCut.container);
    
    // ★この時点でLayerSystemのcurrentCutContainerは更新されるが、
    // 描画エンジンはまだ古いContainerを参照している可能性
}
```

### ❌ 原因2: 初期CUT作成の通知タイミング

```javascript
// animation-system.js
createInitialCutIfNeeded() {
    // 問題: setTimeout内で実行されるため、
    // TimelineUIの初期化タイミングとずれる
    
    setTimeout(() => {
        this.generateCutThumbnail(0);
    }, 200);
    
    // ★TimelineUIがまだイベント待ち受けを設定していない可能性
}
```

### ❌ 原因3: deepCopy後のGraphics再構築

```javascript
// animation-system.js
_deepCopyPath(originalPath) {
    const graphics = new PIXI.Graphics();
    
    // ★ここで新しいGraphicsを作成しているが、
    // 元のgraphicsとの関連が残っている可能性
    
    copiedPoints.forEach(point => {
        graphics.circle(point.x, point.y, ...);
        graphics.fill(...);
    });
    
    return {
        points: copiedPoints,
        graphics: graphics  // ★新しいインスタンス
    };
}
```

### 🔍 真の原因（推測）

**LayerSystemの`currentCutContainer`が切り替わっていない**

```javascript
// core-engine.js
DrawingEngine.addPathToActiveLayer(path) {
    const activeLayer = this.layerManager.getActiveLayer();
    // ★この時点でgetActiveLayer()が返すレイヤーは
    // 正しいCUT Containerから取得されているか？
    
    activeLayer.layerData.paths.push(path);
    // ★ここでpushしているpaths配列は
    // 正しいCUT Containerのものか？
}

// layer-system.js
getActiveLayer() {
    const layers = this.getLayers();
    return layers[this.activeLayerIndex];
}

getLayers() {
    return this.currentCutContainer ? 
        this.currentCutContainer.children : [];
}
```

**結論**: `currentCutContainer`の参照が正しく更新されていないか、更新タイミングが遅延している。

---

## 改修方針

### 設計原則

1. **Eager Initialization**
   - 初期CUTをアプリ起動時に即座に作成
   - setTimeoutによる遅延を最小化

2. **Explicit Container Management**
   - CUT切り替え時に明示的にcontainerを更新
   - LayerSystem.currentCutContainerを確実に切り替え

3. **Synchronous Event Emission**
   - CUT作成/切り替えイベントを同期的に発火
   - TimelineUIが確実に受信できるように

4. **Deep Copy Verification**
   - deepCopy後に即座に検証
   - 参照共有がないことを確認

---

## 段階的改修計画

### Phase 0: 検証スクリプト作成（0.5日）

**目的**: 現在の問題を定量的に確認

**作業内容**:
```javascript
// ブラウザコンソールで実行する検証スクリプト
window.TEGAKI_DEBUG = {
    // CUT独立性テスト
    testCutIndependence() {
        const as = window.animationSystem;
        
        // CUT1のレイヤー参照取得
        as.switchToActiveCut(0);
        const cut1Layers = as.getCurrentCutLayers();
        const cut1Layer0 = cut1Layers[0];
        const cut1PathsRef = cut1Layer0.layerData.paths;
        
        console.log('CUT1 paths reference:', cut1PathsRef);
        
        // CUT2作成
        as.createNewBlankCut();
        
        // CUT2のレイヤー参照取得
        const cut2Layers = as.getCurrentCutLayers();
        const cut2Layer0 = cut2Layers[0];
        const cut2PathsRef = cut2Layer0.layerData.paths;
        
        console.log('CUT2 paths reference:', cut2PathsRef);
        
        // 参照が同じか確認
        const isSameReference = (cut1PathsRef === cut2PathsRef);
        console.log('Same reference?', isSameReference);
        
        if (isSameReference) {
            console.error('❌ CUT1 and CUT2 share the same paths array!');
            return false;
        } else {
            console.log('✅ CUT1 and CUT2 have different paths arrays');
            return true;
        }
    },
    
    // Container切り替えテスト
    testContainerSwitch() {
        const as = window.animationSystem;
        const ls = window.layerSystem;
        
        as.switchToActiveCut(0);
        const container1 = ls.currentCutContainer;
        console.log('Container after switch to CUT1:', container1.label);
        
        as.switchToActiveCut(1);
        const container2 = ls.currentCutContainer;
        console.log('Container after switch to CUT2:', container2.label);
        
        const isDifferent = (container1 !== container2);
        
        if (isDifferent) {
            console.log('✅ Containers are different');
            return true;
        } else {
            console.error('❌ Containers are the same!');
            return false;
        }
    },
    
    // 初期CUT存在確認
    testInitialCutExists() {
        const as = window.animationSystem;
        const cutCount = as.getCutCount();
        
        console.log('Current CUT count:', cutCount);
        
        if (cutCount > 0) {
            console.log('✅ Initial CUT exists');
            const cutInfo = as.getCutInfo(0);
            console.log('CUT 0 info:', cutInfo);
            return true;
        } else {
            console.error('❌ No initial CUT found');
            return false;
        }
    },
    
    // 全テスト実行
    runAll() {
        console.log('=== TEGAKI DEBUG TESTS ===');
        
        const results = {
            initialCut: this.testInitialCutExists(),
            containerSwitch: this.testContainerSwitch(),
            cutIndependence: this.testCutIndependence()
        };
        
        console.log('=== TEST RESULTS ===');
        console.log(results);
        
        const allPassed = Object.values(results).every(r => r === true);
        if (allPassed) {
            console.log('✅ ALL TESTS PASSED');
        } else {
            console.error('❌ SOME TESTS FAILED');
        }
        
        return results;
    }
};

// 実行
TEGAKI_DEBUG.runAll();
```

---

### Phase 1: 初期CUT作成タイミング修正（1日）

#### Step 1.1: AnimationSystem初期化改修

**ファイル**: `system/animation-system.js`

**問題箇所**:
```javascript
// ❌ 現在
init(layerSystem, app) {
    // ...
    setTimeout(() => {
        if (!this.initialCutCreated && !this.isInitializing) {
            this.createInitialCutIfNeeded();
        }
    }, 150);  // ★遅延が問題
}
```

**改修後**:
```javascript
// ✅ 改修後
init(layerSystem, app) {
    this.layerSystem = layerSystem;
    this.app = app;
    this.stage = app?.stage;
    
    if (!this.eventBus || !this.layerSystem) {
        console.error('Required dependencies not available');
        return;
    }
    
    this.layerSystem.animationSystem = this;
    
    // ★即座にCUT Container追加
    if (this.stage && this.layerSystem.currentCutContainer) {
        this.stage.addChild(this.layerSystem.currentCutContainer);
    }
    
    this.setupCutClipboardEvents();
    this.setupLayerChangeListener();
    this.hasInitialized = true;
    
    // ★初期CUTを同期的に作成
    this.createInitialCutImmediate();
    
    // ★イベント発火を確実に
    if (this.eventBus) {
        this.eventBus.emit('animation:system-ready');
        this.eventBus.emit('animation:initialized');
    }
}

/**
 * 初期CUTを即座に作成（setTimeout不使用）
 */
createInitialCutImmediate() {
    if (this.initialCutCreated || this.animationData.cuts.length > 0) {
        return;
    }
    
    if (!this.layerSystem?.currentCutContainer) {
        console.error('Temporary container not found');
        return;
    }
    
    const cutId = 'cut_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    const cut = new Cut(cutId, 'CUT1', this.config);
    
    // 一時Containerのレイヤーをコピー
    const tempLayers = this.layerSystem.currentCutContainer.children;
    
    tempLayers.forEach(tempLayer => {
        const copiedLayer = this._deepCopyLayer(tempLayer);
        cut.addLayer(copiedLayer);
    });
    
    this.animationData.cuts.push(cut);
    
    // ★Stageから一時Containerを削除
    if (this.stage && this.layerSystem.currentCutContainer.parent === this.stage) {
        this.stage.removeChild(this.layerSystem.currentCutContainer);
    }
    
    // ★正式なCUT Containerを追加
    this.stage.addChild(cut.container);
    cut.container.visible = true;
    
    // ★LayerSystemに正式なContainerを設定
    this.layerSystem.setCurrentCutContainer(cut.container);
    
    this.animationData.playback.currentCutIndex = 0;
    this.initialCutCreated = true;
    
    // ★イベント発火
    if (this.eventBus) {
        this.eventBus.emit('animation:initial-cut-created', { 
            cutId: cut.id,
            cutIndex: 0
        });
    }
    
    // ★サムネイル生成（少し遅延）
    setTimeout(() => {
        this.generateCutThumbnail(0);
    }, 100);
}
```

**検証ポイント**:
- `TEGAKI_DEBUG.testInitialCutExists()` がtrueを返すこと
- タイムラインにCUT1が即座に表示されること

---

### Phase 2: CUT切り替え確実化（1日）

#### Step 2.1: LayerSystem Container設定改修

**ファイル**: `system/layer-system.js`

**問題箇所**:
```javascript
// ❌ 現在
setCurrentCutContainer(cutContainer) {
    this.currentCutContainer = cutContainer;
    
    // アクティブレイヤーを最上位に設定
    const layers = this.getLayers();
    this.activeLayerIndex = Math.max(0, layers.length - 1);
    
    this.updateLayerPanelUI();
    this.updateStatusDisplay();
}
```

**改修後**:
```javascript
// ✅ 改修後
setCurrentCutContainer(cutContainer) {
    // ★即座にコンテナ更新
    this.currentCutContainer = cutContainer;
    
    // ★レイヤー参照を強制再取得
    const layers = this.getLayers();
    
    // ★アクティブレイヤーインデックス調整
    if (this.activeLayerIndex >= layers.length) {
        this.activeLayerIndex = Math.max(0, layers.length - 1);
    }
    
    // ★UI即時更新
    this.updateLayerPanelUI();
    this.updateStatusDisplay();
    
    // ★Transform値リセット（重要）
    if (this.isLayerMoveMode) {
        this.updateLayerTransformPanelValues();
    }
    
    // ★EventBus通知
    if (this.eventBus) {
        this.eventBus.emit('layer:container-switched', {
            containerLabel: cutContainer.label,
            layerCount: layers.length,
            activeLayerIndex: this.activeLayerIndex
        });
    }
}
```

#### Step 2.2: AnimationSystem切り替え改修

**ファイル**: `system/animation-system.js`

**問題箇所**:
```javascript
// ❌ 現在
switchToActiveCut(cutIndex) {
    if (this.cutSwitchInProgress) {
        setTimeout(() => this.switchToActiveCut(cutIndex), 50);
        return;
    }
    
    this.cutSwitchInProgress = true;
    
    // 全CUT非表示
    this.animationData.cuts.forEach(cut => {
        cut.container.visible = false;
    });
    
    // 選択CUT表示
    targetCut.container.visible = true;
    
    // LayerSystemに設定
    this.layerSystem.setCurrentCutContainer(targetCut.container);
    
    this.cutSwitchInProgress = false;
}
```

**改修後**:
```javascript
// ✅ 改修後
switchToActiveCut(cutIndex) {
    // ★再入防止は維持
    if (this.cutSwitchInProgress) {
        setTimeout(() => this.switchToActiveCut(cutIndex), 50);
        return;
    }
    
    const targetCut = this.animationData.cuts[cutIndex];
    if (!targetCut || !this.layerSystem) {
        console.error('Invalid CUT or LayerSystem not available');
        return;
    }
    
    this.cutSwitchInProgress = true;
    
    try {
        // ★1. 全CUT非表示
        this.animationData.cuts.forEach(cut => {
            cut.container.visible = false;
        });
        
        // ★2. 選択CUT表示
        targetCut.container.visible = true;
        
        // ★3. LayerSystemに確実に設定
        this.layerSystem.setCurrentCutContainer(targetCut.container);
        
        // ★4. インデックス更新
        this.animationData.playback.currentCutIndex = cutIndex;
        
        // ★5. イベント発火（同期）
        if (this.eventBus) {
            this.eventBus.emit('animation:cut-applied', { 
                cutIndex, 
                cutId: targetCut.id,
                layerCount: targetCut.getLayerCount()
            });
        }
        
    } catch (error) {
        console.error('Error during CUT switch:', error);
    } finally {
        this.cutSwitchInProgress = false;
    }
}
```

**検証ポイント**:
- `TEGAKI_DEBUG.testContainerSwitch()` がtrueを返すこと
- CUT切り替え時にレイヤーパネルが即座に更新されること

---

### Phase 3: DeepCopy強化（1日）

#### Step 3.1: _deepCopyPath改修

**ファイル**: `system/animation-system.js`

**現在の実装**:
```javascript
_deepCopyPath(originalPath) {
    if (!originalPath?.points || originalPath.points.length === 0) return null;
    
    const graphics = new PIXI.Graphics();
    
    const copiedPoints = originalPath.points.map(p => ({ x: p.x, y: p.y }));
    
    copiedPoints.forEach(point => {
        graphics.circle(point.x, point.y, (originalPath.size || 16) / 2);
        graphics.fill({
            color: originalPath.color || 0x800000,
            alpha: originalPath.opacity || 1.0
        });
    });
    
    return {
        id: 'path_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        points: copiedPoints,
        size: originalPath.size || 16,
        color: originalPath.color || 0x800000,
        opacity: originalPath.opacity || 1.0,
        tool: originalPath.tool || 'pen',
        graphics: graphics
    };
}
```

**改修内容**: すでに正しく実装されている。**検証を強化する**。

```javascript
// ✅ 検証付きdeepCopy
_deepCopyPath(originalPath) {
    if (!originalPath?.points || originalPath.points.length === 0) return null;
    
    // ★元のパスと新しいパスが異なることを保証
    const graphics = new PIXI.Graphics();
    
    // ★完全に新しい配列を作成
    const copiedPoints = originalPath.points.map(p => ({ 
        x: p.x, 
        y: p.y 
    }));
    
    // ★Graphics再描画
    copiedPoints.forEach(point => {
        graphics.circle(point.x, point.y, (originalPath.size || 16) / 2);
        graphics.fill({
            color: originalPath.color || 0x800000,
            alpha: originalPath.opacity || 1.0
        });
    });
    
    const newPath = {
        id: 'path_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        points: copiedPoints,
        size: originalPath.size || 16,
        color: originalPath.color || 0x800000,
        opacity: originalPath.opacity || 1.0,
        tool: originalPath.tool || 'pen',
        graphics: graphics
    };
    
    // ★デバッグ用検証
    if (window.TEGAKI_DEBUG?.enabled) {
        console.assert(
            originalPath.points !== newPath.points,
            'Path points array must be different'
        );
        console.assert(
            originalPath.graphics !== newPath.graphics,
            'Graphics must be different instances'
        );
    }
    
    return newPath;
}
```

---

### Phase 4: TimelineUI イベント受信確実化（0.5日）

#### Step 4.1: TimelineUI初期化改修

**ファイル**: `ui/timeline-ui.js`

**問題箇所**:
```javascript
// ❌ 現在（推測）
init() {
    // イベントリスナー設定
    this.eventBus.on('animation:initial-cut-created', ...);
    this.eventBus.on('animation:cut-created', ...);
}
```

**改修後**:
```javascript
// ✅ 改修後
init() {
    // ★イベントリスナーを先に設定
    this._setupEventListeners();
    
    // ★初期状態を同期的に取得
    this._syncInitialState();
    
    // ★UI初期描画
    this.render();
}

_setupEventListeners() {
    this.eventBus.on('animation:initial-cut-created', (data) => {
        console.log('TimelineUI: initial CUT created', data);
        this.render();
    });
    
    this.eventBus.on('animation:cut-created', (data) => {
        console.log('TimelineUI: CUT created', data);
        this.render();
    });
    
    this.eventBus.on('animation:cut-applied', (data) => {
        this.updateActiveIndicator(data.cutIndex);
    });
}

_syncInitialState() {
    // ★AnimationSystemの現在状態を取得
    const cutCount = this.animationSystem.getCutCount();
    
    if (cutCount > 0) {
        console.log('TimelineUI: Found', cutCount, 'existing CUTs');
        // 既存CUTがあれば即座に表示
        this.render();
    } else {
        console.log('TimelineUI: No CUTs yet, waiting for initial-cut-created event');
    }
}
```

---

### Phase 5: 統合テスト（1日）

#### テストシナリオ1: 初期起動

```javascript
// テストスクリプト
async function testInitialStartup() {
    console.log('=== Test 1: Initial Startup ===');
    
    // 1. ページをリロード
    location.reload();
    
    // 2. 3秒待機
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // 3. CUT1が存在するか確認
    const result = TEGAKI_DEBUG.testInitialCutExists();
    
    // 4. タイムラインUIに表示されているか確認
    const timelineItems = document.querySelectorAll('.timeline-item');
    const hasTimelineItem = timelineItems.length > 0;
    
    console.log('Timeline items found:', timelineItems.length);
    
    if (result && hasTimelineItem) {
        console.log('✅ Test 1 PASSED');
        return true;
    } else {
        console.error('❌ Test 1 FAILED');
        return false;
    }
}
```

#### テストシナリオ2: CUT独立性

```javascript
async function testCutIndependence() {
    console.log('=== Test 2: CUT Independence ===');
    
    const as = window.animationSystem;
    const ls = window.layerSystem;
    
    // 1. CUT1に切り替え
    as.switchToActiveCut(0);
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // 2. CUT1に描画（手動でペンツールで描く）
    console.log('Please draw on CUT1 manually...');
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // 3. CUT1のpaths参照を取得
    const cut1Layers = as.getCurrentCutLayers();
    const cut1Paths = cut1Layers[1]?.layerData?.paths || [];
    console.log('CUT1 paths count:', cut1Paths.length);
    
    // 4. 新しいCUTを作成
    as.createNewBlankCut();
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // 5. CUT2のpaths参照を取得
    const cut2Layers = as.getCurrentCutLayers();
    const cut2Paths = cut2Layers[1]?.layerData?.paths || [];
    console.log('CUT2 paths count:', cut2Paths.length);
    
    // 6. 参照が異なるか確認
    const isDifferent = (cut1Paths !== cut2Paths);
    
    // 7. CUT2のpathsが空か確認
    const isEmpty = (cut2Paths.length === 0);
    
    if (isDifferent && isEmpty) {
        console.log('✅ Test 2 PASSED');
        return true;
    } else {
        console.error('❌ Test 2 FAILED');
        console.error('Same reference?', !isDifferent);
        console.error('CUT2 not empty?', !isEmpty);
        return false;
    }
}
```

#### テストシナリオ3: CUTコピー

```javascript
async function testCutCopy() {
    console.log('=== Test 3: CUT Copy ===');
    
    const as = window.animationSystem;
    
    // 1. CUT1に切り替え
    as.switchToActiveCut(0);
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // 2. CUT1をコピー
    as.copyCurrent();
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // 3. 隣接ペースト
    as.pasteRightAdjacent();
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // 4. CUT2のpaths参照を取得
    const cut2Layers = as.getCurrentCutLayers();
    const cut2Paths = cut2Layers[1]?.layerData?.paths || [];
    
    // 5. CUT1に戻る
    as.switchToActiveCut(0);
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // 6. CUT1のpaths参照を取得
    const cut1Layers = as.getCurrentCutLayers();
    const cut1Paths = cut1Layers[1]?.layerData?.paths || [];
    
    // 7. 参照が異なるか確認
    const isDifferent = (cut1Paths !== cut2Paths);
    
    // 8. 内容は同じか確認（points数が同じ）
    const cut1TotalPoints = cut1Paths.reduce((sum, p) => sum + p.points.length, 0);
    const cut2TotalPoints = cut2Paths.reduce((sum, p) => sum + p.points.length, 0);
    const sameContent = (cut1TotalPoints === cut2TotalPoints && cut1TotalPoints > 0);
    
    console.log('CUT1 total points:', cut1TotalPoints);
    console.log('CUT2 total points:', cut2TotalPoints);
    console.log('Different references?', isDifferent);
    console.log('Same content?', sameContent);
    
    if (isDifferent && sameContent) {
        console.log('✅ Test 3 PASSED');
        return true;
    } else {
        console.error('❌ Test 3 FAILED');
        return false;
    }
}
```

#### 全テスト実行

```javascript
async function runAllTests() {
    console.log('===================================');
    console.log('TEGAKI CUT INDEPENDENCE TEST SUITE');
    console.log('===================================');
    
    const results = {
        test1: await testInitialStartup(),
        test2: await testCutIndependence(),
        test3: await testCutCopy()
    };
    
    console.log('===================================');
    console.log('TEST RESULTS:');
    console.log('  Test 1 (Initial Startup):', results.test1 ? '✅ PASS' : '❌ FAIL');
    console.log('  Test 2 (CUT Independence):', results.test2 ? '✅ PASS' : '❌ FAIL');
    console.log('  Test 3 (CUT Copy):', results.test3 ? '✅ PASS' : '❌ FAIL');
    
    const allPassed = Object.values(results).every(r => r === true);
    
    if (allPassed) {
        console.log('===================================');
        console.log('🎉 ALL TESTS PASSED 🎉');
        console.log('===================================');
    } else {
        console.log('===================================');
        console.error('❌ SOME TESTS FAILED');
        console.log('===================================');
    }
    
    return results;
}

// 実行
// runAllTests();
```

---

## 各ファイルの改修詳細

### 📄 system/animation-system.js

#### 改修箇所1: init()メソッド

**行番号**: 約120-150行目

**変更内容**:
- `setTimeout`による遅延初期化を廃止
- `createInitialCutImmediate()`を新規追加して即座に実行
- イベント発火タイミングを明確化

#### 改修箇所2: createInitialCutImmediate()メソッド

**行番号**: 新規追加（約200行目）

**変更内容**:
- `createInitialCutIfNeeded()`を置き換え
- setTimeoutを使わず同期的に実行
- EventBus通知を確実に発火

#### 改修箇所3: switchToActiveCut()メソッド

**行番号**: 約600-650行目

**変更内容**:
- try-catch-finallyでエラーハンドリング追加
- Container切り替え手順を明確化
- EventBus通知データを拡充

#### 改修箇所4: _deepCopyPath()メソッド

**行番号**: 約400-450行目

**変更内容**:
- デバッグ検証コード追加
- 参照独立性の確認強化

---

### 📄 system/layer-system.js

#### 改修箇所1: setCurrentCutContainer()メソッド

**行番号**: 約80-100行目

**変更内容**:
- Container更新を即座に反映
- レイヤー参照の強制再取得
- EventBus通知追加

#### 改修箇所2: getLayers()メソッド

**行番号**: 約120-130行目

**変更内容**: 変更なし（既に正しい実装）

**確認事項**:
```javascript
getLayers() {
    return this.currentCutContainer ? 
        this.currentCutContainer.children : [];
}
```
この実装は正しい。`currentCutContainer`が正しく更新されていれば動作する。

---

### 📄 ui/timeline-ui.js

#### 改修箇所1: init()メソッド

**行番号**: 初期化部分

**変更内容**:
- イベントリスナーを先に設定
- `_syncInitialState()`で初期状態を取得
- 初期描画を確実に実行

#### 改修箇所2: _setupEventListeners()メソッド

**行番号**: 新規追加

**変更内容**:
- イベントリスナーを集約
- ログ出力追加で動作確認しやすく

#### 改修箇所3: _syncInitialState()メソッド

**行番号**: 新規追加

**変更内容**:
- AnimationSystemの現在状態を取得
- 既存CUTがあれば即座に描画

---

## 検証方法

### ブラウザコンソールでの検証

#### Step 1: デバッグツール有効化

```javascript
// ブラウザコンソールで実行
window.TEGAKI_DEBUG = { enabled: true };
```

#### Step 2: 初期状態確認

```javascript
TEGAKI_DEBUG.testInitialCutExists();
```

**期待結果**:
```
Current CUT count: 1
✅ Initial CUT exists
CUT 0 info: { id: "cut_xxx", name: "CUT1", ... }
```

#### Step 3: Container切り替え確認

```javascript
// CUT2を作成
animationSystem.createNewBlankCut();

// テスト実行
TEGAKI_DEBUG.testContainerSwitch();
```

**期待結果**:
```
Container after switch to CUT1: cut_xxx
Container after switch to CUT2: cut_yyy
✅ Containers are different
```

#### Step 4: CUT独立性確認

```javascript
// CUT1で描画（手動）
// ... ペンで何か描く ...

// CUT2作成
animationSystem.createNewBlankCut();

// テスト実行
TEGAKI_DEBUG.testCutIndependence();
```

**期待結果**:
```
CUT1 paths reference: [Array(n)]
CUT2 paths reference: []
Same reference? false
✅ CUT1 and CUT2 have different paths arrays
```

---

## ロールバック手順

### 改修前のバックアップ

```bash
# 改修前にファイルをバックアップ
cp system/animation-system.js system/animation-system.js.backup
cp system/layer-system.js system/layer-system.js.backup
cp ui/timeline-ui.js ui/timeline-ui.js.backup
```

### ロールバック実行

```bash
# 問題が発生した場合
mv system/animation-system.js.backup system/animation-system.js
mv system/layer-system.js.backup system/layer-system.js
mv ui/timeline-ui.js.backup ui/timeline-ui.js

# ブラウザでリロード
```

---

## 改修スケジュール

| Phase | 作業内容 | 所要時間 | 担当 |
|-------|---------|---------|------|
| Phase 0 | 検証スクリプト作成 | 0.5日 | Claude |
| Phase 1 | 初期CUT作成修正 | 1日 | Claude |
| Phase 2 | CUT切り替え確実化 | 1日 | Claude |
| Phase 3 | DeepCopy強化 | 1日 | Claude |
| Phase 4 | TimelineUI修正 | 0.5日 | Claude |
| Phase 5 | 統合テスト | 1日 | Claude |
| **合計** | | **5日** | |

---

## 成果物チェックリスト

### Phase 0
- [x] 検証スクリプト作成完了
- [ ] 現状問題の定量的確認

### Phase 1
- [ ] `animation-system.js` init()改修
- [ ] `createInitialCutImmediate()`実装
- [ ] 初期CUT即時作成確認

### Phase 2
- [ ] `layer-system.js` setCurrentCutContainer()改修
- [ ] `animation-system.js` switchToActiveCut()改修
- [ ] Container切り替え確認

### Phase 3
- [ ] `_deepCopyPath()`検証強化
- [ ] DeepCopy独立性確認

### Phase 4
- [ ] `timeline-ui.js` init()改修
- [ ] イベント受信確認

### Phase 5
- [ ] テストシナリオ1実行
- [ ] テストシナリオ2実行
- [ ] テストシナリオ3実行
- [ ] 全テスト合格確認

---

## 次のClaudeへの引き継ぎ方法

この計画書と以下の情報を提供してください:

```
1. 現在のPhase: 例: "Phase 1 Step 1.1まで完了"
2. 完了した作業: 例: "animation-system.js init()改修完了"
3. 検証結果: 例: "TEGAKI_DEBUG.testInitialCutExists() = true"
4. 次の作業: 例: "Phase 1 Step 1.2から開始"
5. 問題点: 例: "TimelineUIにまだ表示されない"
```

---

## 補足: データフロー図（理想形）

### 初期化フロー（改修後）

```
┌─────────────────────────────────────────────────────────┐
│ CoreEngine.initialize()                                  │
│  ├─ LayerSystem.init()                                  │
│  │   └─ _createTemporaryCutContainer()                  │
│  │                                                        │
│  ├─ AnimationSystem.init(layerSystem, app)              │
│  │   ├─ stage.addChild(tempContainer)                   │
│  │   ├─ createInitialCutImmediate()  ←★即座に実行       │
│  │   │   ├─ new Cut('cut1')                             │
│  │   │   ├─ deepCopy(tempContainer)                     │
│  │   │   ├─ stage.removeChild(tempContainer)            │
│  │   │   ├─ stage.addChild(cut1.container)              │
│  │   │   └─ layerSystem.setCurrentCutContainer(cut1)    │
│  │   │                                                   │
│  │   └─ emit('animation:initial-cut-created')  ←★確実   │
│  │                                                        │
│  └─ TimelineUI.init()                                    │
│      ├─ _setupEventListeners()  ←★先に設定              │
│      ├─ _syncInitialState()  ←★初期状態取得            │
│      └─ render()  ←★即座に描画                          │
└─────────────────────────────────────────────────────────┘
```

### CUT切り替えフロー（改修後）

```
┌─────────────────────────────────────────────────────────┐
│ AnimationSystem.switchToActiveCut(1)                     │
│  ├─ cuts[0].container.visible = false                   │
│  ├─ cuts[1].container.visible = true                    │
│  ├─ layerSystem.setCurrentCutContainer(cuts[1])  ←★確実 │
│  │   ├─ currentCutContainer = cuts[1].container         │
│  │   ├─ getLayers() 強制再取得                          │
│  │   ├─ updateLayerPanelUI()                            │
│  │   └─ emit('layer:container-switched')                │
│  │                                                        │
│  └─ emit('animation:cut-applied')  ←★確実               │
└─────────────────────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────────────────────┐
│ DrawingEngine.addPathToActiveLayer(path)                 │
│  ├─ activeLayer = layerSystem.getActiveLayer()          │
│  │   └─ getLayers()[activeLayerIndex]                   │
│  │       └─ currentCutContainer.children[index]  ←★正しい│
│  │                                                        │
│  └─ activeLayer.layerData.paths.push(path)  ←★正しいCUT  │
└─────────────────────────────────────────────────────────┘
```

---

**作成者**: Claude (Anthropic)  
**レビュー**: AI改修専門設計  
**最終更新**: 2025-10-02  
**バージョン**: 2.0