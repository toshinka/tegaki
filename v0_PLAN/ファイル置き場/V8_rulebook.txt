==========================
Tegaki Vector Drawing Tool v8
単一ファイル版ルールブック　（最新版）
==========================

[序文：PixiJS v8 化を最初にする理由]
- 最新API利用の安定性確保
  ・v7 → v8 にいきなり分割化すると、互換性や依存修正が複数ファイルにまたがり面倒
  ・まず単一ファイルで v8 化を完了させることで、動作確認が容易
- ライブラリ統合の効率化
  ・@pixi/ui / pixi-svg などの新規ライブラリ導入も v8 化前提で整理
  ・分割後にライブラリ依存関係を修正する必要がなくなる
- UI/ポップアップ整理は後回しで良い
  ・ツールごとのポップアップは v8 化後でも統合可能
  ・一旦 v8 化で描画・座標管理・基本UIが動く状態を作ることが優先

### 💎 Tegaki Core Philosophy
- **シンプル特化**: 手描き・ペン描画に特化した設計
- **高品質描画**: 60FPS安定・WebGPU活用・レスポンス最優先
- **非破壊編集**: TPF（TegakiPathFormat）による完全可逆操作
- **拡張性確保**: 段階的進化・プラグイン対応・アニメーション基盤
- **ブラウザネイティブ**: HTML直開き・ES2023準拠・車輪の再発明をしないよう相性の良いライブラリの積極活用。

🚫 原則（フォールバック・フェイルセーフ禁止）  
- フォールバックや多重化で誤魔化さず、エラーは検知した上で隠蔽せず、構造上の責務で対処すること。  
- 構造は剛直かつシンプルに保ち、冗長化を避ける。  
- consoleログは必要最低限とし、肥大化を防ぐ。  
- ES2023+最新chromeAPI使用で、後方互換性は気にしない。
- バージョン混在 - v7/v8同時対応・二重管理禁止
- 外部ビルドツール - Vite/TypeScript/ESM/Webpack禁止
- アニメツール化の為の非破壊レイヤー移動する為、ベクターペンが基本。将来的にはWEBGL2やWEBGPU化予定。 




[1. 基本理念]
- ツールは「キャンバス上でベクタ描画」を中心に設計する
- 将来の非破壊変形、レイヤー管理、アニメ化を見据えた構造とする
- PixiJS v8 を中心に据え、既存ライブラリの再発明を避ける

[2. ファイル構造方針]
- 現時点では単一ファイルを前提に改修
- 分割は v8 動作確認後に実施
- UI と描画処理を同一ファイルに収めるが、関数やクラスで局所化・モジュール化する

[3. 依存関係]
- 主要ライブラリ（CDN利用）
  ・PixiJS v8 → 描画・Container管理
  ・@pixi/ui → ボタン・ポップアップなどのUI
  ・pixi-svg → ベクタペン強化、SVGパス描画
  ・Hammer.js → ドラッグ／ズーム／タッチ操作
  ・GSAP → UIアニメーション
  ・lodash-es → 座標計算、ユーティリティ関数

[4. 描画ルール]
1. キャンバス
   - 画面座標とキャンバス座標を変換する関数を統一
   - 初期化時に Pixi.Application で Canvas を生成
2. ベクターペン
   - パスデータとして保持し、非破壊編集可能
   - 色・太さ・アンカーポイントの変更は再描画で反映
3. 非破壊変形
   - 移動・回転・拡大縮小は Transform マトリクスで管理
   - レイヤー単位で Container を使い、将来的に統合・分離可能

[5. UI ルール]
- ポップアップ・ボタン
  ・ツールごとに内包
  ・@pixi/ui Button, Panel を利用
  ・アニメーションは GSAP を使い軽量に
- ツール選択
  ・ボタン選択でアクティブ化
  ・ポップアップで設定値表示・変更可能
- 状態表示
  ・レイヤー数・選択中レイヤーなどは UI に表示
  ・詳細ステータスは別モジュール化時に tegaki-b2-status.html へ移行可能

[6. 座標・レイヤー管理]
- 画面座標 ↔ キャンバス座標 の変換関数を統一
- レイヤー管理は Container 単位で保持
- 将来的な GIF / タイムライン / アニメ化も考慮して非破壊・独立保持

[7. コンソール・デバッグ]
- 不要ログは削除
- エラーは隠さず、構造上で検知
- フェイルセーフやフォールバックは原則禁止

[8. 拡張性]
- 将来の分割化に備え、関数・クラスごとに局所改修可能な命名と構造
- ツール単位、UI単位でモジュール化しておくと分割後も AI による改修が容易
- レイヤーや非破壊変形などの高度機能も同様に局所化を意識

[9. バージョン管理]
- 現在 v8rev1 をベース
- 改修・分割化後はバージョン番号を更新
- ライブラリバージョンも明示しておくこと

[10. 列車型理念（AI向け補足）]
- 「列車型」は車両（モジュール）が順番に連なって走る構造
- 前方の車両にのみ依存するのが原則。横断依存は禁止
- main（統合制御）は station（ヘッダー）を起点に車両を順番に読み込む
- 各車両は局所改修可能で、追加・交換・入れ替えが容易

[11. 概略構成図（ASCII）]
[station] → [main] → [a1-core] → [a2-integration] → [b1-ui] → [b2-status] → [b3-tools]
   │            │
   └────────────┘  （stationが全体責務の参照）

[12. 作業フロー（簡易）]
1. station を読み込み → 全体ルールとライブラリを初期化
2. main を起動 → 描画ループ・イベント管理開始
3. 各車両順に読み込み・初期化
4. 追加車両は後方に連結可能（局所改修）

[13. 列車型採用理由（補足）]
- 依存関係の明確化
  ・前方の車両にのみ依存するので、改修時に横断的な影響を避けられる
  ・ツリー型だと枝分かれが多く、どのモジュールがどの機能に影響するか追いにくい
- 局所改修が容易
  ・一つの車両だけを交換・改修しても、全体の安定性を崩さない
- 改修順序が明確
  ・main が station を起点に車両を順番に読み込むため、初期化順序や依存順序が簡単に把握できる
- 将来の拡張に柔軟
  ・新しいUIやツールを後方に追加しても、前方の既存モジュールに影響しない
[付録：列車型分割原則（フロー重視）]

1. 背景
- 役割別分割（DRY/SOLID）だけでは AI に危険
- ツリー型失敗の原因は、処理フローを無視した分割

2. 分割原則
- 処理フローに沿って車両（モジュール）を並べる
- 依存関係は前方の車両にのみ
- 局所では DRY/SOLID を維持
- 追加・拡張は後方に連結

3. 分割ガイドライン（AI向け）
- 一つの車両は、処理の一段階に対応
  例：描画準備／座標計算／入力処理／描画／UI応答
- 前後関係を乱さない
- 車両内部は局所的に最適化

4. フロー例（単純）
[station]      → アプリ全体責務・初期化
[main]         → 描画ループ・イベント統合
[a1-core]      → 描画基盤・座標管理
[a2-integration]→ 内部補助・描画補助関数
[b1-ui]        → ボタン・ポップアップ・ツール選択
[b2-status]    → 状態表示・レイヤー管理
[b3-tools]     → 拡張ツール・後方追加可能

5. ポイント
- AIはフロー順に従って改修すること
- 局所の最適化（DRY/SOLID）は許可するが、全体の順序は絶対に崩さない
- 将来の分割・追加もこの原則に従う


[付録：列車型分割（初期2～3分割）]

目的：
- 初期段階では大きく 2～3 のブロックに分けることで、AIが依存関係を追いやすくする
- フロー順序を保ちつつ、局所改修・動作確認を容易にする

分割例（2分割）

[station + main + a1-core] → 基盤・描画準備・初期化
[a2-integration + b1-ui + b2-status + b3-tools] → UI・ステータス・ツール拡張

分割例（3分割）

[station + main] → 全体責務・統合制御
[a1-core + a2-integration] → 描画基盤・座標管理・補助関数
[b1-ui + b2-status + b3-tools] → UI・ステータス・ツール拡張

ポイント：
- 前方のブロックにのみ依存
- 各ブロック内は局所的にDRY/SOLIDを意識
- 初期動作確認・バグ検知が容易
- 後で各ブロックをさらに細かい車両単位に分割しても安全
💡 補足：

style.css は分割後の方が安全

初期段階ではCSSも単一ファイルで管理し、v8化・動作確認を先に行う

2～3分割→7車両分割が完了した後、車両ごとに必要なCSSだけをモジュール化できる




