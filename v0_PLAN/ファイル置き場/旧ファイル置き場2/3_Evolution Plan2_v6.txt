# 🎨 Phase2 Evolution Plan - レイヤー機能・変形・範囲選択

> **Phase1.5基盤活用・レイヤー中心設計** - Phase1.5完成後開始

## 🌊 Phase2 データフロー全体像

### 🎨 レイヤー管理フロー
```
1. ユーザー操作 → レイヤーパネルUI
2. LayerPanel.onAddLayer() → LayerManager.createNamedLayer()
3. LayerManager.createLayer() → CanvasManager.createLayer()
4. PIXI.Container作成 → stage.addChild()
5. RecordManager.recordLayerOperation() → 操作記録
6. LayerPanel.updateDisplay() → UI反映
```

### 🔄 レイヤー変形フロー
```
1. TransformTool選択 → LayerManager.setActiveLayer()
2. 変形操作開始 → TransformTool.onPointerDown()
3. リアルタイム変形 → NavigationManager.transformLayer()
4. PIXI.Container.transform更新 → 即座反映
5. 変形確定 → RecordManager.recordTransform()
6. LayerManager.saveLayerState() → 状態保存
```

### 📦 範囲選択フロー
```
1. SelectTool選択 → 選択モード切り替え
2. 範囲指定 → SelectTool.onPointerDrag()
3. 選択領域確定 → LayerManager.getSelectedContent()
4. 選択内容操作 → 移動・変形・削除
5. RecordManager.recordSelection() → 選択操作記録
```

## 🚧 Phase2 前提条件（必須）

### ✅ Phase1.5完成確認項目
- [ ] NavigationManager・RecordManager・CoordinateManager・ShortcutManager完全動作
- [ ] ペン・消しゴムツール完成・Undo/Redo連携
- [ ] キャンバス移動・ズーム・基本ショートカット動作
- [ ] 統合テスト完了・エラー無し動作

### 🚫 Phase2開始禁止条件
- Phase1.5の不完全な状態での開始
- 基盤Managerの未実装・不安定動作
- 既存機能の破壊的変更を伴う設計

## 📦 Phase2-Step1: レイヤー基本機能

### 🎯 Step1実装目標
- 複数レイヤー作成・削除・順序変更
- レイヤー表示/非表示・アクティブレイヤー管理
- レイヤーパネルUI・ドラッグ&ドロップ

### 📁 新規追加ファイル
```
managers/layer-manager.js           # レイヤー管理専任
ui/layer-panel.js                   # レイヤーパネルUI
tools/layer-tool.js                 # レイヤー操作ツール（補助）
```

### 🎨 LayerManager実装詳細

**📁 ファイル**: `managers/layer-manager.js`

```javascript
/**
 * 🎨 LayerManager - レイヤー管理専任（Phase2基盤）
 * 📋 RESPONSIBILITY: レイヤー作成・削除・順序・表示管理・アクティブ管理
 * 🚫 PROHIBITION: 描画処理・ツール処理・UI操作・エラー通知
 * ✅ PERMISSION: レイヤー操作・CanvasManager連携・RecordManager連携
 * 
 * 📏 DESIGN_PRINCIPLE: レイヤー専門・Phase1.5基盤活用・非破壊編集対応
 * 🔄 INTEGRATION: CanvasManager連携 → RecordManager記録 → UI通知
 * 🌊 DATA_FLOW: UI操作 → レイヤー管理 → CanvasManager実行 → 記録・通知
 */
class LayerManager {
    constructor() {
        console.log('🎨 LayerManager作成（Phase2基盤）');
        
        this.canvasManager = null;
        this.recordManager = null;
        
        this.layers = new Map(); // layerId → LayerInfo
        this.layerOrder = []; // レイヤー順序（下から上）
        this.activeLayerId = null;
        this.layerCounter = 0;
        
        this.initialized = false;
    }
    
    /**
     * Phase1.5基盤Manager設定
     */
    setCanvasManager(canvasManager) {
        if (!canvasManager) {
            throw new Error('CanvasManager is required');
        }
        this.canvasManager = canvasManager;
    }
    
    setRecordManager(recordManager) {
        if (!recordManager) {
            throw new Error('RecordManager is required');
        }
        this.recordManager = recordManager;
    }
    
    /**
     * 初期化（Phase1.5基盤確認後）
     */
    initialize() {
        if (!this.canvasManager || !this.recordManager) {
            throw new Error('Required managers not set');
        }
        
        // デフォルトレイヤー確認・追加
        this.setupDefaultLayers();
        
        this.initialized = true;
        console.log('✅ LayerManager初期化完了');
    }
    
    /**
     * デフォルトレイヤー設定
     */
    setupDefaultLayers() {
        // 既存レイヤー確認
        const existingLayers = ['layer0', 'layer1']; // Phase1.5からの継続
        
        existingLayers.forEach((layerId, index) => {
            const pixiContainer = this.canvasManager.getLayer(layerId);
            if (pixiContainer) {
                this.layers.set(layerId, {
                    id: layerId,
                    name: layerId === 'layer0' ? '背景' : 'メインレイヤー',
                    visible: true,
                    locked: layerId === 'layer0', // 背景はロック
                    pixiContainer: pixiContainer,
                    zIndex: index
                });
                this.layerOrder.push(layerId);
            }
        });
        
        // アクティブレイヤー設定
        this.activeLayerId = 'layer1';
        console.log('✅ デフォルトレイヤー設定完了:', Array.from(this.layers.keys()));
    }
    
    /**
     * 名前付きレイヤー作成
     */
    createNamedLayer(name = null, index = null) {
        const layerId = `layer${++this.layerCounter}`;
        const layerName = name || `レイヤー ${this.layerCounter}`;
        
        // CanvasManager経由でPixiJS Container作成
        const pixiContainer = this.canvasManager.createLayer(layerId);
        
        // レイヤー情報作成
        const layerInfo = {
            id: layerId,
            name: layerName,
            visible: true,
            locked: false,
            pixiContainer: pixiContainer,
            zIndex: this.getNextZIndex()
        };
        
        // レイヤー登録
        this.layers.set(layerId, layerInfo);
        
        // 順序管理
        if (index !== null && index >= 0 && index < this.layerOrder.length) {
            this.layerOrder.splice(index, 0, layerId);
            this.updateZIndices();
        } else {
            this.layerOrder.push(layerId);
        }
        
        // アクティブレイヤー設定
        this.setActiveLayer(layerId);
        
        // 記録
        this.recordManager?.recordLayerOperation({
            type: 'layer_create',
            layerId: layerId,
            name: layerName,
            index: this.layerOrder.indexOf(layerId)
        });
        
        console.log('✅ レイヤー作成:', { layerId, layerName });
        return layerId;
    }
    
    /**
     * レイヤー削除
     */
    deleteLayer(layerId) {
        if (!this.layers.has(layerId)) {
            throw new Error(`Layer not found: ${layerId}`);
        }
        
        const layerInfo = this.layers.get(layerId);
        
        // 削除禁止チェック（背景レイヤーなど）
        if (layerInfo.locked) {
            throw new Error(`Cannot delete locked layer: ${layerId}`);
        }
        
        // 唯一のレイヤー削除禁止
        if (this.layers.size <= 1) {
            throw new Error('Cannot delete last layer');
        }
        
        // CanvasManager経由で削除
        this.canvasManager.removeLayer(layerId);
        
        // 管理データ削除
        this.layers.delete(layerId);
        const orderIndex = this.layerOrder.indexOf(layerId);
        this.layerOrder.splice(orderIndex, 1);
        
        // アクティブレイヤー調整
        if (this.activeLayerId === layerId) {
            const newActiveIndex = Math.min(orderIndex, this.layerOrder.length - 1);
            this.activeLayerId = this.layerOrder[newActiveIndex];
        }
        
        // 記録
        this.recordManager?.recordLayerOperation({
            type: 'layer_delete',
            layerId: layerId,
            layerInfo: layerInfo
        });
        
        console.log('✅ レイヤー削除:', layerId);
    }
    
    /**
     * レイヤー順序変更
     */
    moveLayerOrder(layerId, newIndex) {
        if (!this.layers.has(layerId)) {
            throw new Error(`Layer not found: ${layerId}`);
        }
        
        const currentIndex = this.layerOrder.indexOf(layerId);
        if (currentIndex === -1) return;
        
        // 順序配列更新
        this.layerOrder.splice(currentIndex, 1);
        this.layerOrder.splice(newIndex, 0, layerId);
        
        // PixiJS zIndex更新
        this.updateZIndices();
        
        // 記録
        this.recordManager?.recordLayerOperation({
            type: 'layer_reorder',
            layerId: layerId,
            oldIndex: currentIndex,
            newIndex: newIndex
        });
        
        console.log('✅ レイヤー順序変更:', { layerId, newIndex });
    }
    
    /**
     * レイヤー表示/非表示
     */
    setLayerVisibility(layerId, visible) {
        const layerInfo = this.layers.get(layerId);
        if (!layerInfo) {
            throw new Error(`Layer not found: ${layerId}`);
        }
        
        layerInfo.visible = visible;
        layerInfo.pixiContainer.visible = visible;
        
        // 記録
        this.recordManager?.recordLayerOperation({
            type: 'layer_visibility',
            layerId: layerId,
            visible: visible
        });
        
        console.log('✅ レイヤー表示変更:', { layerId, visible });
    }
    
    /**
     * アクティブレイヤー設定
     */
    setActiveLayer(layerId) {
        if (!this.layers.has(layerId)) {
            throw new Error(`Layer not found: ${layerId}`);
        }
        
        this.activeLayerId = layerId;
        
        // CanvasManagerに通知（描画対象レイヤー変更）
        this.canvasManager.setActiveLayer?.(layerId);
        
        console.log('✅ アクティブレイヤー変更:', layerId);
    }
    
    /**
     * アクティブレイヤー取得
     */
    getActiveLayer() {
        return this.activeLayerId ? this.layers.get(this.activeLayerId) : null;
    }
    
    getActiveLayerId() {
        return this.activeLayerId;
    }
    
    /**
     * レイヤー一覧取得（順序付き）
     */
    getLayersInOrder() {
        return this.layerOrder.map(layerId => this.layers.get(layerId));
    }
    
    /**
     * Z-Index更新
     */
    updateZIndices() {
        this.layerOrder.forEach((layerId, index) => {
            const layerInfo = this.layers.get(layerId);
            if (layerInfo) {
                layerInfo.zIndex = index;
                layerInfo.pixiContainer.zIndex = index;
            }
        });
    }
    
    getNextZIndex() {
        return this.layers.size;
    }
    
    /**
     * Phase1.5基盤連携：変形記録
     */
    recordTransformOperation(layerId, transform) {
        this.recordManager?.recordLayerOperation({
            type: 'layer_transform',
            layerId: layerId,
            transform: { ...transform }
        });
    }
    
    /**
     * 準備状態確認
     */
    isReady() {
        return this.initialized && 
               this.canvasManager && 
               this.recordManager && 
               this.layers.size > 0;
    }
    
    /**
     * デバッグ情報
     */
    getDebugInfo() {
        return {
            className: 'LayerManager',
            initialized: this.initialized,
            hasRequiredDeps: !!(this.canvasManager && this.recordManager),
            layerCount: this.layers.size,
            activeLayerId: this.activeLayerId,
            layerOrder: [...this.layerOrder],
            layers: Array.from(this.layers.entries()).map(([id, info]) => ({
                id,
                name: info.name,
                visible: info.visible,
                locked: info.locked,
                zIndex: info.zIndex
            }))
        };
    }
}

// Tegaki名前空間登録
if (!window.Tegaki) window.Tegaki = {};
window.Tegaki.LayerManager = LayerManager;

console.log('🎨 LayerManager Loaded (Phase2基盤)');
```

### 🎨 LayerPanel UI実装詳細

**📁 ファイル**: `ui/layer-panel.js`

```javascript
/**
 * 🎨 LayerPanel - レイヤーパネルUI専任（Phase2 UI）
 * 📋 RESPONSIBILITY: レイヤーUI表示・ユーザー操作・LayerManager連携
 * 🚫 PROHIBITION: レイヤー管理ロジック・PixiJS操作・記録処理
 * ✅ PERMISSION: DOM操作・イベント処理・LayerManager呼び出し
 * 
 * 📏 DESIGN_PRINCIPLE: UI専門・LayerManager委譲・ドラッグ&ドロップ対応
 * 🔄 INTEGRATION: LayerManager連携 → DOM更新 → ユーザー操作受付
 * 🌊 DATA_FLOW: LayerManager状態 → UI表示 → ユーザー操作 → LayerManager呼び出し
 */
class LayerPanel {
    constructor() {
        console.log('🎨 LayerPanel作成（Phase2 UI）');
        
        this.layerManager = null;
        this.panelElement = null;
        this.layerListElement = null;
        
        this.initialized = false;
    }
    
    /**
     * LayerManager設定
     */
    setLayerManager(layerManager) {
        if (!layerManager) {
            throw new Error('LayerManager is required');
        }
        this.layerManager = layerManager;
    }
    
    /**
     * UI初期化
     */
    initialize(containerElement) {
        if (!this.layerManager) {
            throw new Error('LayerManager not set');
        }
        
        this.createPanelUI(containerElement);
        this.setupEventListeners();
        this.updateDisplay();
        
        this.initialized = true;
        console.log('✅ LayerPanel初期化完了');
    }
    
    /**
     * パネルUI作成
     */
    createPanelUI(container) {
        // パネル作成
        this.panelElement = document.createElement('div');
        this.panelElement.className = 'layer-panel';
        this.panelElement.innerHTML = `
            <div class="layer-panel-header">
                <h3>レイヤー</h3>
                <button class="add-layer-btn">+</button>
            </div>
            <div class="layer-list"></div>
        `;
        
        this.layerListElement = this.panelElement.querySelector('.layer-list');
        
        // コンテナに追加
        if (typeof container === 'string') {
            container = document.getElementById(container);
        }
        container.appendChild(this.panelElement);
        
        // CSS適用
        this.applyStyles();
    }
    
    /**
     * イベントリスナー設定
     */
    setupEventListeners() {
        // レイヤー追加ボタン
        const addBtn = this.panelElement.querySelector('.add-layer-btn');
        addBtn.addEventListener('click', () => {
            const layerName = prompt('レイヤー名を入力:', `レイヤー ${Date.now()}`);
            if (layerName) {
                this.layerManager.createNamedLayer(layerName);
                this.updateDisplay();
            }
        });
    }
    
    /**
     * 表示更新
     */
    updateDisplay() {
        if (!this.layerListElement) return;
        
        // 既存内容クリア
        this.layerListElement.innerHTML = '';
        
        // レイヤー一覧取得（順序付き）
        const layers = this.layerManager.getLayersInOrder();
        const activeLayerId = this.layerManager.getActiveLayerId();
        
        // レイヤー要素作成（逆順：上から下）
        layers.reverse().forEach((layerInfo) => {
            const layerElement = this.createLayerElement(layerInfo, activeLayerId);
            this.layerListElement.appendChild(layerElement);
        });
    }
    
    /**
     * レイヤー要素作成
     */
    createLayerElement(layerInfo, activeLayerId) {
        const layerDiv = document.createElement('div');
        layerDiv.className = `layer-item ${layerInfo.id === activeLayerId ? 'active' : ''}`;
        layerDiv.dataset.layerId = layerInfo.id;
        
        layerDiv.innerHTML = `
            <div class="layer-visibility">
                <input type="checkbox" ${layerInfo.visible ? 'checked' : ''} 
                       ${layerInfo.locked ? 'disabled' : ''}>
            </div>
            <div class="layer-name">${layerInfo.name}</div>
            <div class="layer-controls">
                ${!layerInfo.locked ? '<button class="delete-layer">×</button>' : ''}
            </div>
        `;
        
        // イベント設定
        this.setupLayerElementEvents(layerDiv, layerInfo);
        
        return layerDiv;
    }
    
    /**
     * レイヤー要素イベント設定
     */
    setupLayerElementEvents(layerElement, layerInfo) {
        // アクティブレイヤー選択
        layerElement.addEventListener('click', (e) => {
            if (e.target.type !== 'checkbox' && !e.target.classList.contains('delete-layer')) {
                this.layerManager.setActiveLayer(layerInfo.id);
                this.updateDisplay();
            }
        });
        
        // 表示/非表示
        const checkbox = layerElement.querySelector('input[type="checkbox"]');
        checkbox.addEventListener('change', (e) => {
            this.layerManager.setLayerVisibility(layerInfo.id, e.target.checked);
        });
        
        // 削除
        const deleteBtn = layerElement.querySelector('.delete-layer');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm(`レイヤー「${layerInfo.name}」を削除しますか？`)) {
                    try {
                        this.layerManager.deleteLayer(layerInfo.id);
                        this.updateDisplay();
                    } catch (error) {
                        alert(error.message);
                    }
                }
            });
        }
    }
    
    /**
     * スタイル適用
     */
    applyStyles() {
        const style = document.createElement('style');
        style.textContent = `
            .layer-panel {
                position: fixed;
                right: 10px;
                top: 60px;
                width: 200px;
                background: #2a2a2a;
                border: 1px solid #555;
                border-radius: 5px;
                padding: 10px;
                font-family: Arial, sans-serif;
                z-index: 1000;
            }
            
            .layer-panel-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
                color: white;
            }
            
            .layer-panel-header h3 {
                margin: 0;
                font-size: 14px;
            }
            
            .add-layer-btn {
                background: #007acc;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 4px 8px;
                cursor: pointer;
                font-size: 16px;
                line-height: 1;
            }
            
            .add-layer-btn:hover {
                background: #0086cc;
            }
            
            .layer-list {
                max-height: 300px;
                overflow-y: auto;
            }
            
            .layer-item {
                display: flex;
                align-items: center;
                padding: 5px;
                margin-bottom: 2px;
                background: #3a3a3a;
                border-radius: 3px;
                cursor: pointer;
                color: white;
                font-size: 12px;
            }
            
            .layer-item.active {
                background: #007acc;
            }
            
            .layer-item:hover:not(.active) {
                background: #4a4a4a;
            }
            
            .layer-visibility {
                margin-right: 8px;
            }
            
            .layer-name {
                flex: 1;
                overflow: hidden;