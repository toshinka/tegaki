# 📏 Tegaki Rulebook v6 - 剛直基本方針

> **骨太で剛直な開発方針** - エラーを隠すな、構造を透けさせろ、素人が読める構造にしろ

## 🚫 絶対不変原則（改定・削除禁止）

### 💀 重大違反事項（例外なし）
1. **try/catch での握りつぶし禁止** - 必ず `throw` か `console.error` + 詳細ログ
2. **フォールバック・フェイルセーフ禁止** - 正しい構造でのみ動作させる
3. **架空メソッド呼び出し禁止** - 実装されていないメソッドを呼ぶな
4. **二重責務禁止** - 1ファイル＝1責務、似た処理のコピペ禁止
5. **ブラックボックス化禁止** - 全処理に日本語コメント必須

### ✅ 必須遵守事項（全Phase共通）
1. **エラーは ErrorManager 経由のみ** - 他ファイルでの直接通知禁止
2. **名前空間統一** - 全て `window.Tegaki.*` に公開
3. **初期化順序厳守** - HTML読み込み順序通りの依存関係
4. **構文完整性確保** - ES2023準拠、後方互換考慮なし
5. **車輪の再発明禁止** - PixiJS標準機能を最大活用

## 🏗️ アーキテクチャ基本原則

### 📦 責務分離原則（SOLID基盤）
```javascript
// ✅ 正しい：単一責務
class CanvasManager {
    // PixiJS管理のみ
    setPixiApp(pixiApp) { /* PixiJS設定 */ }
    createLayer(id) { /* レイヤー作成 */ }
}

// ❌ 間違い：多重責務
class SuperManager {
    // NG：PixiJS管理 + 描画処理 + UI管理 + エラー処理
    setPixiApp() { /* */ }
    drawLine() { /* */ }
    showDialog() { /* */ }
    handleError() { /* */ }
}
```

### 🔗 依存性管理原則
```javascript
// ✅ 正しい：依存性注入
class ToolManager {
    setCanvasManager(canvasManager) {
        this.canvasManager = canvasManager; // 外部から注入
    }
}

// ❌ 間違い：内部依存
class ToolManager {
    constructor() {
        this.canvasManager = new CanvasManager(); // 内部で直接作成（結合度高）
    }
}
```

### 🔄 DRY原則（Don't Repeat Yourself）
```javascript
// ✅ 正しい：共通化
class ToolBase {
    validateCanvas() {
        if (!this.canvasManager) {
            throw new Error('CanvasManager not set');
        }
    }
}

// ❌ 間違い：重複コード
class PenTool {
    onPointerDown(x, y) {
        if (!this.canvasManager) {
            throw new Error('CanvasManager not set'); // 重複
        }
    }
}
class EraserTool {
    onPointerDown(x, y) {
        if (!this.canvasManager) {
            throw new Error('CanvasManager not set'); // 重複
        }
    }
}
```

## 🚨 エラー処理ポリシー（剛直版）

### ✅ 推奨エラー処理
```javascript
// ✅ 正しい：ErrorManager経由
if (!requiredData) {
    throw new Error('Required data not available');  // 上位でキャッチしてErrorManagerへ
}

// ✅ 正しい：詳細ログ付きthrow
try {
    riskyOperation();
} catch (error) {
    console.error('❌ Operation failed:', error, { context: 'MyClass.method' });
    throw error; // 隠蔽しない
}
```

### 💀 禁止エラー処理（絶対禁止）
```javascript
// ❌ 絶対禁止：握りつぶし
try {
    riskyOperation();  
} catch (e) {
    // 何もしない - 握りつぶし
}

// ❌ 絶対禁止：曖昧なフォールバック
const data = getData() || getDefaultData() || {};

// ❌ 絶対禁止：直接UI通知（ErrorManager以外）
catch (error) {
    alert('エラーが発生しました'); // NG：ErrorManagerを通せ
    console.error(error); // NG：throwして上位に委譲
}
```

### 📂 ファイル別エラー処理方針
- **🚨 error-manager.js** - エラー処理専任・UI通知・ログ・記録
- **🎨 managers/\*.js** - 例外throw専門・直接通知禁止
- **🖊️ tools/\*.js** - 例外throw専門・上位委譲
- **⚙️ js/utils/\*.js** - 例外throw・console.errorやUI呼び出し禁止

## 📝 コメント規則（ブラックボックス撲滅）

### ✅ 必須コメント
```javascript
/**
 * 🎨 ClassName - 役割簡潔説明
 * 📋 RESPONSIBILITY: このクラスの責務
 * 🚫 PROHIBITION: やってはいけないこと
 * ✅ PERMISSION: やっても良いこと
 * 
 * 📏 DESIGN_PRINCIPLE: 設計思想
 * 🔄 INTEGRATION: 他クラスとの連携方法
 * 🌊 DATA_FLOW: データがどのような流れでこのクラスに到達し、処理され、出力されるか
 */
class MyClass {
    /**
     * メソッドの目的説明（何を・なぜ）
     * @param {type} param - パラメータ説明
     * @returns {type} - 戻り値説明
     * @throws {Error} - 例外説明
     */
    myMethod(param) {
        // 処理の意図を日本語で説明
        const result = complexOperation(param);
        
        // なぜこの判定が必要かを説明
        if (!result.isValid) {
            throw new Error('Validation failed: invalid result');
        }
        
        return result;
    }
}
```

### 🚫 不要なコメント（書くな）
```javascript
// ❌ 不要：コードを読めば分かる
let x = 10; // x に 10 を代入

// ❌ 不要：意味のない説明
function getData() {
    return this.data; // データを返す
}
```

### 🌊 データフロー記載必須
各ファイルのヘッダーにデータフローを記載し、改修時の理解を促進する：
```javascript
/**
 * 🌊 DATA_FLOW:
 * 1. HTML読み込み → PixiJS Application作成
 * 2. TegakiApplication.createCanvas() → DOM配置
 * 3. ポインターイベント → handlePointerDown()
 * 4. 座標変換 → CoordinateManager.screenToCanvas()
 * 5. ツール処理 → ToolManager.handlePointerDown()
 * 6. 描画実行 → PenTool.onPointerDown()
 * 7. 操作記録 → RecordManager.recordDraw()
 */
```

## 🏗️ 技術スタック（固定方針）

### ✅ 使用技術（変更禁止）
- **PixiJS v7** - 描画・キャンバス基盤　
- **使用ライブラリは CDN ではなく、プロジェクト内の node_modules フォルダから読み込むこと。フォールバックでのCDNは特別に許可。
- **JavaScript ES2023** - モダン構文積極利用
- **fetch API** - HTTP通信（必要時）
- **HTML直開き** - ローカルファイル直接実行可能

### 🚫 禁止技術（導入禁止）
- **Vite / TypeScript / ESM** - HTML直開きで動くことが必須
- **webpack / Babel** - ビルドプロセス禁止
- **jQuery** - モダン構文で代替
- **後方互換** - 古いブラウザ考慮なし

### 📦 依存関係管理（必須）
```javascript
// 全モジュールは以下に依存（必須）
window.Tegaki.ConfigManagerInstance    // 設定管理
window.Tegaki.ErrorManagerInstance     // エラー処理  
window.Tegaki.EventBusInstance         // イベント配信
```

## 🎮 イベント処理パターン（標準）

### ✅ 推奨パターン（責務分離）
```javascript
// UI層：イベント受信・座標変換
handlePointerDown(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Manager層に委譲
    this.toolManager.handlePointerDown(x, y, e);
}

// Manager層：ツール選択・イベント転送
handlePointerDown(x, y, event) {
    if (this.currentTool?.onPointerDown) {
        this.currentTool.onPointerDown(x, y, event);
    }
}

// Tool層：実際の処理
onPointerDown(x, y, event) {
    this.isDrawing = true;
    this.startNewPath(x, y);
}
```

### 🚫 禁止パターン（責務混在）
```javascript
// ❌ 禁止：全部やる怪物関数
handlePointerDown(e) {
    // 座標変換
    const x = e.clientX - rect.left;
    
    // ツール判定
    if (this.currentTool === 'pen') {
        // 描画処理
        this.graphics = new PIXI.Graphics();
        this.graphics.lineStyle(4, 0x800000);
        this.graphics.moveTo(x, y);
        
        // レイヤー管理
        const layer = this.getLayer('main');
        layer.addChild(this.graphics);
        
        // UI更新
        this.updateStatus('描画中...');
        
        // エラー処理
        try {
            this.saveToHistory();
        } catch (e) {
            alert('エラー：' + e.message);
        }
    }
}
```

## 🧪 デバッグ・品質保証方針

### 📊 デバッグ情報必須
```javascript
class MyManager {
    /**
     * デバッグ情報取得（必須実装）
     */
    getDebugInfo() {
        return {
            initialized: this.initialized,
            hasRequiredDeps: !!this.dependency,
            itemCount: this.items.size,
            currentState: this.state,
            lastError: this.lastError?.message || 'none'
        };
    }
}
```

### 🔍 実行時検証
```javascript
// 開発時は積極的にassert
console.assert(window.PIXI, 'PixiJS not loaded');
console.assert(window.Tegaki.ErrorManagerInstance, 'ErrorManager not available');

// デバッグログは積極的に
console.log('🎨 Manager created:', this.getDebugInfo());
```

## 🎯 PixiJS 活用方針（車輪の再発明禁止）

### ✅ PixiJS標準機能活用
```javascript
// ✅ 正しい：PixiJSの機能そのまま使用
const graphics = new PIXI.Graphics();
graphics.lineStyle({
    width: 4,
    color: 0x800000,
    alpha: 1.0,
    cap: PIXI.LINE_CAP.ROUND,
    join: PIXI.LINE_JOIN.ROUND
});
graphics.moveTo(x, y);
graphics.lineTo(x2, y2);

// ✅ 正しい：Container活用
const layer = new PIXI.Container();
layer.sortableChildren = true;
stage.addChild(layer);
```

### 🚫 車輪の再発明（禁止）
```javascript
// ❌ 禁止：PixiJSにある機能を自作
class MyGraphics {
    constructor() {
        this.points = [];
        this.styles = {};
    }
    
    drawLine(x1, y1, x2, y2) {
        // 独自実装（PixiJS.Graphics使えよ）
    }
}

// ❌ 禁止：座標変換自作
class CoordinateManager {
    screenToCanvas(screenX, screenY) {
        // 独自座標変換（PixiJSのinteractionManagerを使えよ）
    }
}
```

## ⌨️ ショートカットキー基本方針

### 🎯 GPU最適化・遅延0ms目標
- **基本操作**: Ctrl+Z/Y（Undo/Redo）、DEL（消去）、Ctrl+0（ビューリセット）
- **キャンバス操作**: Space+ドラッグ（移動）、Shift+Space+ドラッグ（拡縮・回転）
- **ツール切り替え**: P（ペン）、E（消しゴム）、G（塗りつぶし）など

### 🚫 ショートカット禁止事項
- **システム予約キー侵害禁止** - Ctrl+A, Ctrl+S, F5等の回避
- **複雑な組み合わせ禁止** - 3キー以上の同時押し回避
- **ユーザー混乱回避** - 一般的でないキー配置禁止

## 🔄 Phase移行戦略（大綱）

### 📝 段階的発展方針
- **Phase1**: 基本描画機能・エラー処理・ツール切り替え
- **Phase1.5**: キャンバス移動・非破壊編集基盤・ショートカット
- **Phase2**: レイヤー機能・変形・範囲選択
- **Phase3**: アニメーション・GIF出力・最適化

### 🧹 移行時のリファクタリング方針
```
Phase間移行時：
✅ DO: 新機能追加・既存機能拡張
🚫 DON'T: 既存構造の大幅変更

互換性保証：
✅ DO: 既存APIの維持・機能の累積追加
🚫 DON'T: 破壊的変更・基本操作方法の変更
```

### ⚠️ 各Phase共通禁止事項
1. **エラー握りつぶし** - Phase関係なく絶対禁止
2. **フォールバック構造** - 安直な防御コード禁止
3. **責務混在** - 新機能も1ファイル1責務厳守
4. **ブラックボックス** - 新機能も日本語コメント必須

## 📋 品質基準（全Phase共通）

### 🎯 機能品質基準
- **動作する**: 基本機能が確実に動作
- **理解できる**: コードを読んで動作が理解可能
- **拡張できる**: 次のPhaseで機能追加が容易
- **デバッグできる**: エラー発生時に原因特定可能

### 💀 怪物コード撲滅チェックリスト
- [ ] try/catchで握りつぶしていない
- [ ] フォールバック・フェイルセーフを使っていない
- [ ] 架空メソッドを呼び出していない
- [ ] 1ファイル1責務を守っている
- [ ] 全処理に日本語コメントがある
- [ ] ErrorManager以外でUI通知していない
- [ ] window.Tegaki名前空間を使っている
- [ ] PixiJSの標準機能を活用している

### 🔧 コーディング品質基準
- [ ] SOLID原則遵守（単一責任・開放閉鎖・リスコフ置換・インターフェース分離・依存逆転）
- [ ] DRY原則遵守（重複コード排除・共通化）
- [ ] モダンES2023構文活用
- [ ] 適切な依存性注入
- [ ] デバッグ情報実装（getDebugInfo必須）

## 📄 文書管理方針

### 📚 3冊構造の役割分担
- **📏 Rulebook（本書）**: 基本方針・構造ガイドライン・品質基準（不変大綱）
- **📚 Symbol Dictionary**: 確定した用語・API定義（段階的更新）  
- **🚀 Evolution Plan**: 具体的実装手順・将来計画（頻繁更新・Phase別分冊）

### 🔒 更新ルール
- **Rulebook**: 基本方針は改定禁止・構造追加のみ許可
- **Symbol Dictionary**: 実装完了後に確定事項追加
- **Evolution Plan**: 実装進捗に合わせて随時更新・Phase別管理

### ⚠️ 冗長化防止
- 各文書で重複内容を避ける
- 詳細実装情報はEvolution Planに集約
- 基本原則はRulebookに一元化
- 確定API仕様はSymbol Dictionaryに集約

---

**📝 更新方針**: 基本方針は不変・構造ガイドラインのみ追加可能  
**🎯 品質の鍵**: エラーを隠すな・構造を透けさせろ・素人が読める構造にしろ  
**💀 基本原則**: 怪物コード撲滅を全Phase通して継続