
🔍 現状の問題分析
問題1: CUT1の絵がCUT2に漏れる
症状: CUT1レイヤー1で描いた絵 → CUT2レイヤー1にも表示される
原因推定:
❌ 現在の構造（推定）
AnimationSystem.cuts = [
  { id: 'cut1', layers: [layer1_data] },  // layer1_dataへの参照
  { id: 'cut2', layers: [layer1_data] }   // 同じlayer1_dataへの参照！
]

LayerSystem.layers = [layer1_container]  // Pixi.Container
根本原因:

CUT作成時にLayerDataを参照コピーしている（Deep Copyしていない）
LayerSystemのthis.layers配列がCUT間で共有されている
paths配列が参照で共有されている


💡 解決策の方向性
あなたの直感は正しいです！
2次元マトリクス管理が必須:
CUT軸（横） × Layer軸（縦） = 独立した描画データ

CUT1: [背景Layer, Layer1, Layer2]
CUT2: [背景Layer, Layer1, Layer2]  ← 完全に別物
CUT3: [背景Layer, Layer1]

📐 設計案：3つのアプローチ
案A: AnimationSystem中心設計（推奨★★★）
コンセプト: AnimationSystemが完全な2次元マトリクスを持つ
javascript// AnimationSystem内部
this.animationData = {
  cuts: [
    {
      id: 'cut_001',
      layers: [
        {
          id: 'cut_001_layer_bg',  // CUT毎に一意
          name: '背景',
          paths: [...],             // 独立した配列
          transform: {...}
        },
        {
          id: 'cut_001_layer_01',
          name: 'レイヤー1',
          paths: [...],             // 独立した配列
          transform: {...}
        }
      ]
    },
    {
      id: 'cut_002',
      layers: [
        {
          id: 'cut_002_layer_bg',  // 別のID
          name: '背景',
          paths: [...],             // 完全に別の配列
          transform: {...}
        }
      ]
    }
  ]
}
LayerSystemの役割:

現在のCUTの表示のみを担当
CUT切替時に毎回layersContainerをクリアして再構築
描画時は即座にAnimationSystem.saveCutLayerStates()で保存

メリット:

✅ CUT独立性が確実
✅ データ永続化が容易
✅ AnimationSystemがSingle Source of Truth

デメリット:

CUT切替時の再構築コストがある（許容範囲）


案B: RecordMatrix新ファイル作成
コンセプト: CUTとLayerの交差点データを管理する専用クラス
javascript// system/record-matrix.js
class RecordMatrix {
  constructor() {
    this.matrix = new Map();  // key: 'cutId_layerId', value: LayerRecord
  }
  
  getRecord(cutId, layerId) {
    return this.matrix.get(`${cutId}_${layerId}`);
  }
  
  setRecord(cutId, layerId, layerData) {
    this.matrix.set(`${cutId}_${layerId}`, this.deepClone(layerData));
  }
  
  deepClone(data) {
    // pathsを含む完全なDeep Copy
    return JSON.parse(JSON.stringify(data));
  }
}
メリット:

✅ 責務が明確
✅ 将来的なUndo/Redo対応が容易

デメリット:

新規ファイル追加による複雑化
AnimationSystemとの連携設計が必要


案C: History.js拡張でUndo/Redo対応
コンセプト: 非破壊記録としてHistory管理に統合
javascript// system/history.js拡張
class History {
  constructor() {
    this.timeline = [];  // スナップショット履歴
    this.currentIndex = -1;
  }
  
  recordSnapshot(cutIndex, layerIndex, action, data) {
    const snapshot = {
      timestamp: Date.now(),
      cutIndex,
      layerIndex,
      action,  // 'draw', 'transform', 'delete', etc.
      data: this.deepClone(data)
    };
    
    // 現在位置以降を削除して新規追加
    this.timeline = this.timeline.slice(0, this.currentIndex + 1);
    this.timeline.push(snapshot);
    this.currentIndex++;
  }
  
  undo() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return this.timeline[this.currentIndex];
    }
  }
}
メリット:

✅ Undo/Redoが自然に実装できる
✅ 非破壊記録の理念に合致

デメリット:

メモリ消費が大きい
現時点では過剰設計


🎯 推奨実装：案A（AnimationSystem中心）
実装ステップ
Step 1: AnimationSystem修正
javascript// 新規CUT作成時
createNewEmptyCut() {
  const newCut = {
    id: `cut_${Date.now()}`,
    name: `CUT${this.cuts.length + 1}`,
    layers: [
      {
        id: `cut_${Date.now()}_layer_bg`,  // ★CUT毎に一意なID
        name: '背景',
        isBackground: true,
        paths: [],  // ★新規配列
        transform: { x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1 }
      },
      {
        id: `cut_${Date.now()}_layer_01`,
        name: 'レイヤー1',
        paths: [],  // ★新規配列
        transform: { x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1 }
      }
    ],
    duration: 0.5,
    thumbnailCanvas: null
  };
  
  this.cuts.push(newCut);
  return newCut;
}

// Layer状態保存（Deep Copy必須）
saveCutLayerStates() {
  const currentCut = this.getCurrentCut();
  if (!currentCut || !this.layerSystem) return;
  
  // LayerSystemから取得
  const layers = this.layerSystem.layers;
  
  // ★Deep Copyで保存
  currentCut.layers = layers.map(layer => ({
    id: layer.layerData.id,
    name: layer.layerData.name,
    visible: layer.layerData.visible,
    opacity: layer.layerData.opacity,
    isBackground: layer.layerData.isBackground,
    paths: layer.layerData.paths.map(path => ({
      id: path.id,
      points: [...path.points],  // ★配列コピー
      color: path.color,
      size: path.size,
      opacity: path.opacity,
      tool: path.tool
    })),
    transform: { ...layer.layerData.transform }  // ★オブジェクトコピー
  }));
}
Step 2: LayerSystem修正
javascript// CUT切替時の同期
_syncLayersContainerFromAnimationSystem() {
  // 完全クリア
  while (this.layersContainer.children.length > 0) {
    this.layersContainer.removeChildAt(0);
  }
  
  this.layers = [];  // ★配列もクリア
  
  // AnimationSystemから現在CUTのLayerを取得
  const currentLayers = this.animationSystem.getCurrentCutLayers();
  if (!currentLayers) return;
  
  // ★完全再構築（参照を持たない）
  currentLayers.forEach((layerData) => {
    const layer = new PIXI.Container();
    layer.label = layerData.id;
    
    // ★新しいlayerDataオブジェクトを作成
    layer.layerData = {
      id: layerData.id,
      name: layerData.name,
      visible: layerData.visible,
      opacity: layerData.opacity,
      isBackground: layerData.isBackground,
      paths: []  // ★空から開始
    };
    
    // Pathを再構築
    if (layerData.paths) {
      layerData.paths.forEach(pathData => {
        const path = this._rebuildPathFromData(pathData);
        if (path) {
          layer.layerData.paths.push(path);
          layer.addChild(path.graphics);
        }
      });
    }
    
    this.layers.push(layer);
    this.layersContainer.addChild(layer);
  });
}

📊 Undo/Redoについて
現時点では不要、将来対応を見据えた設計
理由:

まずCUT独立性を確立することが最優先
Undo/Redoは追加機能
AnimationSystemの2次元マトリクスがあればHistory対応は後付け可能

将来の実装案:
javascript// history.js（将来）
class CutHistory {
  recordState(cutIndex) {
    // AnimationSystemの該当CUTをスナップショット
    const snapshot = this.deepClone(
      animationSystem.animationData.cuts[cutIndex]
    );
    
    this.history.push({
      type: 'cut-state',
      cutIndex,
      timestamp: Date.now(),
      data: snapshot
    });
  }
  
  undo() {
    // スナップショットから復元
  }
}

🎬 実装優先順位
Phase 1: CUT独立性の確立（最優先）

✅ AnimationSystem: saveCutLayerStates()でDeep Copy実装
✅ AnimationSystem: createNewEmptyCut()でCUT毎の一意なLayer ID
✅ LayerSystem: _syncLayersContainerFromAnimationSystem()で完全再構築

Phase 2: サムネイル反映

AnimationSystem: generateCutThumbnailOptimized()の確実な実行
TimelineUI: サムネイル表示の更新

Phase 3: 将来拡張（後回し）

RecordMatrix導入（必要に応じて）
History.js拡張でUndo/Redo


🔧 修正が必要なファイル

animation-system.js - CUT独立性の根幹
layer-system.js（phase1e11b版に戻す） - 同期処理のみ修正
timeline-ui.js - サムネイル表示