💡リファクタリング案
javascript// 【現在】 → 【改修後】
StationManager → AppInitializer
MainController → AppController  
CoreEngine → DrawingEngine
CameraManager → DomPositionManager
UIManager → InterfaceManager
ToolManager → DrawingTools
PerformanceMonitor → SystemMonitor

📝シンボル辞典
シンボル　　　　　　　　　　責任範囲　　　　　　　　　　　　　　主要メソッド　　　　　　　　
AppBootstrap　　　　　初期化・ライブラリ管理         init(), checkLibraries()
AppController　　　　 アプリ全体制御init(),          setupInputHandlers()
DrawingEngine         描画・Canvas管理               createPath(), drawLine(), resize()
DomPositionManager    DOM位置制御                    startPanning(), updatePosition()
InterfaceManager      UI状態・ポップアップ           togglePopup(), updateSliders()
DrawingTools          ツール・描画ロジック           startDrawing(), setBrushSize()
SystemMonitor         パフォーマンス監視             trackFPS(), updateStats()

※ AppController は将来的に UIController / AnimationController / PhysicsController などへ分割される可能性がある。
※ 各 Controller は明確な責務単位で命名され、AIが処理対象を容易に把握できるよう配慮される。
※ 将来的に描画やアニメーションの機能が拡張されても、Controller 名から役割を直感的に理解可能にする


💡GROK4のスリム案ではWorld座標系を消すことにしてるけど、近い将来のレイヤー移動で必要になるのでハイブリッドで残したい。

1. screenToWorld / worldToScreen の役割

PixiJSや一般的な仮想カメラ系の描画では、

world座標系：キャンバス上の論理的な座標（描画対象が動く空間）

screen座標系：実際のブラウザ上のピクセル位置

これらを変換する関数が screenToWorld / worldToScreen です。
例えば、マウス座標からキャンバス上の線を引くとき、マウスの 画面座標 を ワールド座標 に変換して描画する、という用途です。

2. DOMパン実装（Rev2）の場合

今回の DOMパンでは、canvas 自体を DOM レベルで移動します。

そのため「マウス座標 = canvas 内の座標」と直接対応させれば描画可能。

Pixi の仮想座標（worldContainer.x/y）での相対計算が不要になるため、 screenToWorld / worldToScreen は使わなくても描画は成立します。

3. 無限キャンバス化との関係

無限キャンバスや「ビューに依存しない描画範囲」を作る場合は、世界座標系が必須です。

例: Canvas 内の任意位置に描画可能

スクロールやパンで viewport を動かしても描画内容は正しい座標に残る

現状の DOMパン実装だと、canvas の絶対位置に依存しているため、canvas の外に描画領域を広げるのは難しいです。

つまり、将来的に無限キャンバスや複数レイヤーで拡張する場合は、再び world座標系への変換やコンテナ移動を意識する必要があります。

4. 結論・方針

現状のDOMパン + Rev2のジッター解消には screenToWorld / worldToScreen は不要

将来的な無限キャンバス対応や複雑なレイヤー変形を見据える場合は、残しておくか、将来復活可能な設計にしておくのが望ましい

☑というわけでハイブリッドで今から仕込無方針で！

今のうちに仕込みを入れておく方が無駄な差し戻しが減ります。理由は以下です。

1. 将来的なメリット

世界座標系の概念を残す

CoreEngine に screenToWorld / worldToScreen をユーティリティとして保持

DOMパンでも呼ばずに済ませつつ、将来無限キャンバスやレイヤー変形で再利用可能

レイヤー移動・変形対応が容易

回転・拡縮・反転・移動などの操作は、座標系を統一しておくと処理がシンプル

コード分離・ハイブリッド切替がスムーズ

DOMパン用と world座標パン用の切替を簡単に追加可能

将来的に Pixi の Container 移動に戻す場合も影響最小

2. 実装方針例

CoreEngine に座標変換関数を残す（未使用でも OK）

screenToWorld(screenX, screenY) { 
    // DOMパンなら画面座標をそのまま返す
    return { x: screenX, y: screenY }; 
}

worldToScreen(worldX, worldY) {
    // DOMパンなら世界座標 = 画面座標
    return { x: worldX, y: worldY };
}

DOMパンでは呼ばず、将来無限キャンバス時に切り替える

イベントハンドラや描画関数は「座標系変換を通す前提」にしておくと混乱防止

3. 注意点

今は DOM 依存の実装でも構わないが、変換関数を残しておくかインターフェースだけ作っておく

後から無限キャンバスに切り替える場合のリファクタリングコストを大幅に削減できる

/* ==============================
   Canvas & Layer Hybrid Design
   ============================== */

/* ------------------------------
   CoreEngine: 座標系ユーティリティ
------------------------------- */
class CoreEngine {
    constructor(canvas) {
        this.canvas = canvas;
        this.isDomPan = true;   // 現在のパンモード: true=DOMパン, false=Worldパン
        this.worldOffset = { x: 0, y: 0 }; // World座標オフセット
    }

    // DOMパン / Worldパン 共通インターフェース
    screenToWorld(screenX, screenY) {
        if (this.isDomPan) {
            // DOMパン時は画面座標 = 世界座標
            return { x: screenX, y: screenY };
        } else {
            // World座標系変換（将来無限キャンバス対応用）
            return { x: screenX - this.worldOffset.x, y: screenY - this.worldOffset.y };
        }
    }

    worldToScreen(worldX, worldY) {
        if (this.isDomPan) {
            return { x: worldX, y: worldY };
        } else {
            return { x: worldX + this.worldOffset.x, y: worldY + this.worldOffset.y };
        }
    }
}

/* ------------------------------
   Canvas / DOM Pan Handling
------------------------------- */
class PanManager {
    constructor(coreEngine, container) {
        this.core = coreEngine;
        this.container = container; // canvas-container DOM
        this.isPanning = false;
        this.start = { x: 0, y: 0 };
    }

    startPan(screenX, screenY) {
        this.isPanning = true;
        this.start.x = screenX;
        this.start.y = screenY;
    }

    updatePan(screenX, screenY) {
        if (!this.isPanning) return;
        const dx = screenX - this.start.x;
        const dy = screenY - this.start.y;

        if (this.core.isDomPan) {
            // DOMパン: canvas-container の left/top を更新
            const currentLeft = parseFloat(this.container.style.left) || 50;
            const currentTop = parseFloat(this.container.style.top) || 50;
            this.container.style.left = `${currentLeft + (dx / window.innerWidth * 100)}%`;
            this.container.style.top  = `${currentTop + (dy / window.innerHeight * 100)}%`;
        } else {
            // Worldパン: CoreEngine 内の worldOffset を更新
            this.core.worldOffset.x += dx;
            this.core.worldOffset.y += dy;
            // Pixi Container に反映
            this.core.worldContainer.x = -this.core.worldOffset.x;
            this.core.worldContainer.y = -this.core.worldOffset.y;
        }

        this.start.x = screenX;
        this.start.y = screenY;
    }

    endPan() {
        this.isPanning = false;
    }

    reset() {
        if (this.core.isDomPan) {
            this.container.style.left = '50%';
            this.container.style.top  = '50%';
        } else {
            this.core.worldOffset = { x: 0, y: 0 };
            this.core.worldContainer.x = 0;
            this.core.worldContainer.y = 0;
        }
    }
}

/* ------------------------------
   Layer / Transformation Handling
------------------------------- */
class LayerManager {
    constructor(coreEngine) {
        this.core = coreEngine;
        this.layers = []; // PIXI.Container配列
    }

    addLayer(layerContainer) {
        this.layers.push(layerContainer);
    }

    // 座標変換を考慮した移動
    moveLayer(layer, dx, dy) {
        if (this.core.isDomPan) {
            // DOM座標系で直接移動
            layer.x += dx;
            layer.y += dy;
        } else {
            // World座標系に合わせて移動
            layer.x += dx;
            layer.y += dy;
        }
    }

    // 拡縮・回転・反転対応 (transform)
    transformLayer(layer, options) {
        if (options.scale !== undefined) layer.scale.set(options.scale);
        if (options.rotation !== undefined) layer.rotation = options.rotation;
        if (options.flipX) layer.scale.x *= -1;
        if (options.flipY) layer.scale.y *= -1;
    }
}

/* ------------------------------
   使用フロー例
------------------------------- */
// 1. DOM or Worldパン設定
coreEngine.isDomPan = true;  // DOMパン優先
// 2. マウス/タッチイベントで PanManager を呼び出す
// 3. 描画時は CoreEngine.screenToWorld を通して座標を統一
// 4. レイヤー変形は LayerManager.transformLayer で統一



DOMパンとWorldパンを切替可能にする

CoreEngine.isDomPan で管理

現状は DOMパンでも将来 Worldパンに戻せる

座標変換関数を残す

screenToWorld / worldToScreen は未使用でも設置

無限キャンバスや複雑レイヤーに再利用可能

レイヤー変形・移動も共通インターフェースで統一

回転・拡縮・反転も扱いやすく

AI観点

メソッド名・クラス名が直感的で、座標系の意図が明確

フローが統一されているので解析しやすい

