// ====================================
// TEGAKI CODE GUIDE v10
// Reference implementations and patterns
// ====================================

// ============================================================================
// SECTION 1: COORDINATE SYSTEM REFERENCE
// ============================================================================

/**
 * coordinate-system.js - Single source of truth for coordinate conversions
 * All coordinates must flow through this system
 */

window.CoordinateSystem = {
  /**
   * Convert screen coordinates to world coordinates
   * @param {PIXI.Application} app - The PIXI application instance
   * @param {number} screenX - X in CSS pixels from canvas top-left
   * @param {number} screenY - Y in CSS pixels from canvas top-left
   * @returns {{x: number, y: number}} World coordinates
   */
  screenToWorld(app, screenX, screenY) {
    // coord: screen -> world
    const interaction = app.renderer.plugins.interaction;
    const point = interaction.mapPositionToPoint(new PIXI.Point(), screenX, screenY);
    return {x: point.x, y: point.y};
  },

  /**
   * Convert world coordinates to screen coordinates
   * @param {PIXI.Application} app
   * @param {number} worldX - X in world units
   * @param {number} worldY - Y in world units
   * @returns {{x: number, y: number}} Screen coordinates
   */
  worldToScreen(app, worldX, worldY) {
    // coord: world -> screen
    const matrix = app.stage.worldTransform;
    const x = worldX * matrix.a + worldY * matrix.c + matrix.tx;
    const y = worldX * matrix.b + worldY * matrix.d + matrix.ty;
    return {x, y};
  },

  /**
   * Convert layer-local coordinates to world coordinates
   * @param {PIXI.Container} layer - Layer container
   * @param {number} layerX - X in layer space
   * @param {number} layerY - Y in layer space
   * @returns {{x: number, y: number}} World coordinates
   */
  layerToWorld(layer, layerX, layerY) {
    // coord: layer -> world
    const worldPoint = layer.toGlobal(new PIXI.Point(layerX, layerY));
    return {x: worldPoint.x, y: worldPoint.y};
  },

  /**
   * Convert world coordinates to layer-local coordinates
   * @param {PIXI.Container} layer
   * @param {number} worldX
   * @param {number} worldY
   * @returns {{x: number, y: number}} Layer coordinates
   */
  worldToLayer(layer, worldX, worldY) {
    // coord: world -> layer
    const layerPoint = layer.toLocal(new PIXI.Point(worldX, worldY));
    return {x: layerPoint.x, y: layerPoint.y};
  },

  /**
   * Transform a point around a pivot with given transform
   * @param {{x: number, y: number}} point - Point to transform
   * @param {{x: number, y: number}} pivot - Pivot point (same coord space as point)
   * @param {Object} transform - {rotation: radians, scaleX: number, scaleY: number, tx: number, ty: number}
   * @returns {{x: number, y: number}} Transformed point
   */
  transformPoint(point, pivot, transform) {
    // All coordinates must be in same space
    const dx = point.x - pivot.x;
    const dy = point.y - pivot.y;
    
    const scaleX = transform.scaleX ?? 1;
    const scaleY = transform.scaleY ?? 1;
    const rotation = transform.rotation ?? 0;
    const tx = transform.tx ?? 0;
    const ty = transform.ty ?? 0;
    
    // Scale
    let nx = dx * scaleX;
    let ny = dy * scaleY;
    
    // Rotate
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    const rx = nx * cos - ny * sin;
    const ry = nx * sin + ny * cos;
    
    // Translate
    return {
      x: pivot.x + rx + tx,
      y: pivot.y + ry + ty
    };
  }
};

// ============================================================================
// SECTION 2: NON-DESTRUCTIVE TRANSFORM PATTERN
// ============================================================================

/**
 * transform-utils.js - Non-destructive path transformations
 */

window.TransformUtils = {
  /**
   * Apply transform to all path points (non-destructive)
   * @param {Layer} layer - Layer containing paths
   * @param {Transform} transform - Transform to apply
   * @param {string} pivotMode - "camera" | "selection" | "layer"
   */
  applyTransformToPaths(layer, transform, pivotMode = "camera") {
    const pivot = this.getPivot(layer, pivotMode);
    
    // Transform each path point
    layer.paths.forEach(path => {
      path.points = path.points.map(point => {
        // coord: layer
        const worldPt = CoordinateSystem.layerToWorld(layer.container, point.x, point.y);
        const transformed = CoordinateSystem.transformPoint(worldPt, pivot, transform);
        const layerPt = CoordinateSystem.worldToLayer(layer.container, transformed.x, transformed.y);
        return {x: layerPt.x, y: layerPt.y};
      });
    });
    
    // Reset visual transform
    layer.container.position.set(0, 0);
    layer.container.scale.set(1, 1);
    layer.container.rotation = 0;
    
    // Mark for redraw
    layer.isDirty = true;
  },

  /**
   * Get pivot point based on mode
   * @param {Layer} layer
   * @param {string} mode
   * @returns {{x: number, y: number}} Pivot in world coordinates
   */
  getPivot(layer, mode) {
    const app = window.TegakiApp;
    
    switch(mode) {
      case "camera": {
        // coord: screen -> world
        const screenCenter = {
          x: app.renderer.screen.width / 2,
          y: app.renderer.screen.height / 2
        };
        return CoordinateSystem.screenToWorld(app, screenCenter.x, screenCenter.y);
      }
      
      case "selection": {
        // coord: layer -> world
        const bounds = this.getSelectionBounds(layer);
        return CoordinateSystem.layerToWorld(
          layer.container,
          bounds.x + bounds.width / 2,
          bounds.y + bounds.height / 2
        );
      }
      
      case "layer": {
        // coord: layer -> world  
        return CoordinateSystem.layerToWorld(
          layer.container,
          layer.width / 2,
          layer.height / 2
        );
      }
      
      default:
        throw new Error(`TransformUtils.getPivot: Unknown mode ${mode}`);
    }
  }
};

// ============================================================================
// SECTION 3: LAYER SYSTEM DATA MODEL
// ============================================================================

/**
 * layer-system.js - Path-first layer architecture
 */

window.LayerSystem = {
  /**
   * Layer data structure - This is the source of truth
   * @typedef {Object} Layer
   * @property {string} id - Unique identifier
   * @property {Path[]} paths - Array of path data
   * @property {Transform} transform - Current transform (temporary)
   * @property {boolean} visible
   * @property {number} opacity - 0.0 to 1.0
   * @property {string} blendMode - PIXI blend mode
   * @property {PIXI.Container} container - Display container
   * @property {PIXI.RenderTexture|null} cache - Render cache
   * @property {boolean} isDirty - Needs redraw
   */

  /**
   * Path data structure
   * @typedef {Object} Path
   * @property {string} id - Unique identifier
   * @property {Point[]} points - Array of {x, y} in layer space
   * @property {StyleData} style - Stroke/fill style
   * @property {boolean} closed - Is path closed
   * @property {string} tool - Tool that created this path
   */

  /**
   * Create a new layer
   * @param {Object} options
   * @returns {Layer}
   */
  createLayer(options = {}) {
    const layer = {
      id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      paths: [],
      transform: {scale: 1, rotation: 0, tx: 0, ty: 0},
      visible: true,
      opacity: 1,
      blendMode: 'NORMAL',
      container: new PIXI.Container(),
      cache: null,
      isDirty: true
    };
    
    layer.container.layerData = layer; // Back-reference
    return layer;
  },

  /**
   * Deep clone layer with new IDs
   * @param {Layer} source
   * @returns {Layer}
   */
  cloneLayer(source) {
    const clone = this.createLayer();
    
    // Deep clone paths
    clone.paths = source.paths.map(path => ({
      id: `path_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      points: path.points.map(p => ({x: p.x, y: p.y})),
      style: {...path.style},
      closed: path.closed,
      tool: path.tool
    }));
    
    clone.visible = source.visible;
    clone.opacity = source.opacity;
    clone.blendMode = source.blendMode;
    clone.isDirty = true;
    
    return clone;
  },

  /**
   * Rebuild graphics from path data
   * @param {Layer} layer
   */
  rebuildGraphics(layer) {
    // Clear existing graphics
    layer.container.removeChildren();
    
    layer.paths.forEach(path => {
      const graphics = new PIXI.Graphics();
      
      // Apply style
      if (path.style.stroke) {
        graphics.lineStyle(
          path.style.strokeWidth,
          path.style.strokeColor,
          path.style.strokeAlpha
        );
      }
      
      if (path.style.fill) {
        graphics.beginFill(path.style.fillColor, path.style.fillAlpha);
      }
      
      // Draw path
      if (path.points.length > 0) {
        graphics.moveTo(path.points[0].x, path.points[0].y);
        for (let i = 1; i < path.points.length; i++) {
          graphics.lineTo(path.points[i].x, path.points[i].y);
        }
        if (path.closed) {
          graphics.closePath();
        }
      }
      
      if (path.style.fill) {
        graphics.endFill();
      }
      
      layer.container.addChild(graphics);
    });
    
    // Update cache if needed
    if (layer.cache) {
      this.updateCache(layer);
    }
    
    layer.isDirty = false;
  }
};

// ============================================================================
// SECTION 4: CLIPBOARD SYSTEM
// ============================================================================

/**
 * clipboard-system.js - Deep clone clipboard operations
 */

window.ClipboardSystem = {
  clipboard: null,
  
  /**
   * Copy layer to clipboard (deep clone)
   * @param {Layer} layer
   */
  copy(layer) {
    if (!layer) throw new Error("ClipboardSystem.copy: No layer provided");
    
    this.clipboard = {
      type: 'layer',
      data: LayerSystem.cloneLayer(layer),
      timestamp: Date.now()
    };
    
    console.log(`Copied layer ${layer.id}`);
  },
  
  /**
   * Paste from clipboard
   * @returns {Layer|null}
   */
  paste() {
    if (!this.clipboard) return null;
    if (this.clipboard.type !== 'layer') return null;
    
    // Clone again to allow multiple pastes
    const layer = LayerSystem.cloneLayer(this.clipboard.data);
    
    // Offset slightly to show it's a new layer
    layer.transform.tx += 10;
    layer.transform.ty += 10;
    
    return layer;
  },
  
  /**
   * Cut layer (copy then mark for deletion)
   * @param {Layer} layer
   * @returns {string} Layer ID to be deleted
   */
  cut(layer) {
    this.copy(layer);
    return layer.id; // Caller should delete this layer
  }
};

// ============================================================================
// SECTION 5: CORE RUNTIME FACADE
// ============================================================================

/**
 * core-runtime.js - Engine star main facade
 */

window.CoreRuntime = {
  // Subsystem references
  coord: null,
  camera: null,
  layer: null,
  transform: null,
  draw: null,
  clipboard: null,
  
  /**
   * Initialize all subsystems
   * @param {PIXI.Application} app
   */
  init(app) {
    this.coord = window.CoordinateSystem;
    this.camera = window.CameraSystem;
    this.layer = window.LayerSystem;
    this.transform = window.TransformUtils;
    this.draw = window.DrawingEngine;
    this.clipboard = window.ClipboardSystem;
    
    // Store app reference
    window.TegakiApp = app;
    
    // Initialize subsystems
    this.camera.init(app);
    this.layer.init(app);
    this.draw.init(app);
    
    console.log("CoreRuntime initialized");
  },
  
  /**
   * Public API for UI layer
   */
  api: {
    // Camera operations
    panCamera: (dx, dy) => CoreRuntime.camera.pan(dx, dy),
    zoomCamera: (factor, centerX, centerY) => CoreRuntime.camera.zoom(factor, centerX, centerY),
    resetCamera: () => CoreRuntime.camera.reset(),
    
    // Layer operations
    createLayer: () => CoreRuntime.layer.createLayer(),
    deleteLayer: (id) => CoreRuntime.layer.deleteLayer(id),
    setActiveLayer: (id) => CoreRuntime.layer.setActive(id),
    
    // Transform operations
    transformActive: (transform, pivotMode) => {
      const layer = CoreRuntime.layer.getActive();
      CoreRuntime.transform.applyTransformToPaths(layer, transform, pivotMode);
    },
    
    // Drawing operations
    startPath: (x, y, style) => CoreRuntime.draw.startPath(x, y, style),
    addPoint: (x, y) => CoreRuntime.draw.addPoint(x, y),
    endPath: () => CoreRuntime.draw.endPath(),
    
    // Clipboard operations
    copy: () => CoreRuntime.clipboard.copy(CoreRuntime.layer.getActive()),
    paste: () => {
      const layer = CoreRuntime.clipboard.paste();
      if (layer) CoreRuntime.layer.addLayer(layer);
    },
    cut: () => {
      const active = CoreRuntime.layer.getActive();
      const idToDelete = CoreRuntime.clipboard.cut(active);
      CoreRuntime.layer.deleteLayer(idToDelete);
    }
  }
};

// ============================================================================
// SECTION 6: EVENT SYSTEM
// ============================================================================

/**
 * Event system for inter-system communication
 */

window.TegakiEvents = {
  listeners: {},
  
  /**
   * Subscribe to event
   * @param {string} event - Event name
   * @param {Function} handler - Event handler
   * @returns {Function} Unsubscribe function
   */
  on(event, handler) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(handler);
    
    // Return unsubscribe function
    return () => {
      const index = this.listeners[event].indexOf(handler);
      if (index > -1) {
        this.listeners[event].splice(index, 1);
      }
    };
  },
  
  /**
   * Emit event
   * @param {string} event - Event name
   * @param {*} data - Event data
   */
  emit(event, data) {
    if (!this.listeners[event]) return;
    
    this.listeners[event].forEach(handler => {
      handler(data);
    });
  }
};

// Event definitions
const EVENTS = {
  // Layer events
  'layer:created': 'Layer created',
  'layer:deleted': 'Layer deleted',
  'layer:activated': 'Layer activated',
  'layer:transformed': 'Layer transformed',
  'layer:dirty': 'Layer needs redraw',
  
  // Camera events
  'camera:moved': 'Camera panned or zoomed',
  'camera:reset': 'Camera reset to default',
  
  // Drawing events  
  'path:started': 'New path started',
  'path:updated': 'Path points added',
  'path:completed': 'Path finalized',
  
  // Tool events
  'tool:changed': 'Active tool changed',
  'tool:settings': 'Tool settings updated'
};

// ============================================================================
// SECTION 7: MIGRATION PATTERNS
// ============================================================================

/**
 * Patterns for migrating from core-engine.js
 */

// BEFORE (core-engine.js):
/*
class TegakiCore {
  transformLayer(layer, transform) {
    const container = layer.container;
    container.position.x += transform.x;
    container.scale.x *= transform.scale;
    // ... mixed responsibilities
  }
}
*/

// AFTER (separated):
/*
// In transform-utils.js
TransformUtils.applyTransformToPaths(layer, transform, 'camera');

// In layer-system.js  
LayerSystem.markDirty(layer);

// In drawing-engine.js
DrawingEngine.scheduleRedraw(layer);
*/

// ============================================================================
// SECTION 8: COMMON PITFALLS AND SOLUTIONS
// ============================================================================

/**
 * PITFALL 1: Mixed coordinate spaces
 */

// WRONG:
function wrongTransform(container, mouseX, mouseY) {
  // Mixing screen and world coordinates!
  container.x = mouseX; // mouseX is screen, container.x is world
}

// CORRECT:
function correctTransform(container, mouseX, mouseY) {
  // coord: screen -> world
  const worldPos = CoordinateSystem.screenToWorld(app, mouseX, mouseY);
  container.x = worldPos.x;
  container.y = worldPos.y;
}

/**
 * PITFALL 2: Destructive transforms
 */

// WRONG:
function wrongApply(layer, scale) {
  // Destroys original path data!
  layer.paths.forEach(path => {
    path.points.forEach(pt => {
      pt.x *= scale;
      pt.y *= scale;
    });
  });
}

// CORRECT:
function correctApply(layer, scale) {
  // Non-destructive: creates new points
  layer.paths.forEach(path => {
    path.points = path.points.map(pt => ({
      x: pt.x * scale,
      y: pt.y * scale
    }));
  });
}

/**
 * PITFALL 3: Memory leaks with RenderTextures
 */

// WRONG:
function wrongCache(layer) {
  // Leaks old texture!
  layer.cache = PIXI.RenderTexture.create({width: 100, height: 100});
}

// CORRECT:
function correctCache(layer) {
  // Destroy old texture first
  if (layer.cache) {
    layer.cache.destroy(true);
  }
  layer.cache = PIXI.RenderTexture.create({width: 100, height: 100});
}

// ============================================================================
// END OF CODE GUIDE
// ============================================================================