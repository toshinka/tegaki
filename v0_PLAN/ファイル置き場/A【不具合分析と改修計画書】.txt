================================================================================
【不具合分析と改修計画書】ベクターペン対応 History/State統合改修
================================================================================

■ 現状分析結果
================================================================================

【改修状況の診断】
Phase 1: History.js コマンドパターン化 → ✅ 実装済み（ただし統合不完全）
Phase 2: StateManager 階層構造導入 → ⚠️ 部分的実装（Cut/Frame混在）
Phase 3: LayerSystem 階層State対応 → ❌ 未実装
Phase 4: CoreEngine 描画コマンド化 → ❌ 未実装
Phase 5: Timeline機能追加 → ⚠️ 独自実装あり（設計と異なる）

【データ構造の不整合】
計画書定義: timeline.frames[].layers[].strokes[]
実際の実装: 
- StateManager: cuts[].layers[]（frameではなくcutを使用）
- TimelineUI: 独自のcutsデータを保持
- History: コマンドパターン実装済みだが、実際には使われていない

【重大な問題点】
1. StateManagerとTimelineUIが別々のデータを管理（二重管理）
2. History.push()が呼ばれていない（描画操作が履歴に記録されない）
3. Cut/Frame用語の混在による混乱


================================================================================
■ 不具合の原因分析
================================================================================

【問題1: 方向キー上下がレイヤー入れ替えになる】
原因箇所: core-engine.js L1141-1185

```
case 'ArrowUp':
    if (e.ctrlKey) {
        LayerSystem.moveLayerUp(activeIndex);  // レイヤー移動
    } else {
        TimelineUI.selectPreviousCut();  // Cut選択
    }
```

問題点:
- Ctrl+↑↓ がレイヤー移動に割り当てられている
- しかし moveLayerUp/Down の実装が swapLayers を呼んでいる
- swapLayersは入れ替え処理のため、階層移動ではなく入れ替えになる

【問題2: CUT矢印の左右が逆】
原因箇所: timeline-ui.js L457-474

```
case 'ArrowLeft':
    this.selectNextCut();  // 左キーで次へ（誤り）
case 'ArrowRight':
    this.selectPreviousCut();  // 右キーで前へ（誤り）
```

selectNextCut/selectPreviousの呼び出しが逆になっている

【問題3: CUTクリック時に別のCUTに飛ぶ】
原因箇所: timeline-ui.js L235-261

```
selectCut(cutId) {
    const cut = this.cuts.get(cutId);
    const cutIndex = this.cutsOrder.indexOf(cutId);
    
    // StateManagerのindexとTimelineUIのindexが一致しない
    StateManager.setCurrentCutIndex(cutIndex);
}
```

問題点:
- TimelineUIの`cuts`とStateManagerの`cuts`が同期していない
- IDとIndexの変換時に不整合が発生

【問題4: Ctrl+Z/Yで戻らない、Historyが増えない】
原因箇所: 複数ファイルにまたがる問題

1. core-engine.js: 描画完了時にHistory.push()を呼んでいない
2. layer-system.js: レイヤー操作時にHistory.push()を呼んでいない
3. state-manager.js: addStroke等のメソッドが存在しない

現状の実装:
```javascript
// core-engine.js L784
stopDrawing() {
    // History.push()の呼び出しがない！
    this.saveCurrentPath();  // パスを保存するだけ
}
```


================================================================================
■ 緊急修正事項（Quick Fix）
================================================================================

【修正1: 方向キーの挙動】
core-engine.js L1141-1185 を以下に変更:

```javascript
case 'ArrowUp':
    if (e.ctrlKey) {
        // レイヤーを上に移動（入れ替えではなく移動）
        const layers = StateManager.getCurrentCut().layers;
        if (activeIndex > 0) {
            const layer = layers.splice(activeIndex, 1)[0];
            layers.splice(activeIndex - 1, 0, layer);
            LayerSystem.updateLayersList();
        }
    } else {
        TimelineUI.selectPreviousCut();
    }
    break;

case 'ArrowDown':
    if (e.ctrlKey) {
        // レイヤーを下に移動（入れ替えではなく移動）
        const layers = StateManager.getCurrentCut().layers;
        if (activeIndex < layers.length - 1) {
            const layer = layers.splice(activeIndex, 1)[0];
            layers.splice(activeIndex + 1, 0, layer);
            LayerSystem.updateLayersList();
        }
    } else {
        TimelineUI.selectNextCut();
    }
    break;
```

【修正2: CUT矢印の左右】
timeline-ui.js L457-474 を以下に変更:

```javascript
case 'ArrowLeft':
    e.preventDefault();
    this.selectPreviousCut();  // 左で前へ
    break;
case 'ArrowRight':
    e.preventDefault();
    this.selectNextCut();  // 右で次へ
    break;
```

【修正3: History記録の追加】
core-engine.js stopDrawing() に追加:

```javascript
stopDrawing() {
    if (!this.isDrawing || !this.currentPath || this.currentPath.length < 2) {
        this.isDrawing = false;
        this.currentPath = null;
        return;
    }

    // パスを保存
    const pathData = this.saveCurrentPath();
    
    // History に記録を追加
    if (window.History && pathData) {
        const command = {
            name: 'draw-stroke',
            do: () => {
                // 既に描画済みなので何もしない
            },
            undo: () => {
                const layer = LayerSystem.getActiveLayer();
                if (layer && layer.paths) {
                    const index = layer.paths.indexOf(pathData);
                    if (index !== -1) {
                        layer.paths.splice(index, 1);
                        LayerSystem.renderActiveLayer();
                    }
                }
            },
            meta: { type: 'stroke', pathData }
        };
        History.push(command);
    }

    this.isDrawing = false;
    this.currentPath = null;
}
```


================================================================================
■ 根本的改修計画（Phase別実装順序）
================================================================================

【Phase 0: 用語統一とデータ構造整理】
目的: Cut/Frame の混在を解消し、データ構造を統一

1. 用語の統一決定:
   - 「Cut」で統一（AviUtl/動画編集ソフトとの親和性）
   - timeline.cuts[].layers[].strokes[] 構造に統一

2. 二重管理の解消:
   - TimelineUI.cuts を削除
   - StateManager.state.timeline.cuts を唯一のデータソースに

【Phase 1: History完全統合】
目的: すべての操作を History に記録

実装内容:
1. DrawingEngine.stopDrawing() に History.push() 追加
2. LayerSystem の全操作に History.push() 追加
3. TimelineUI の Cut操作に History.push() 追加

【Phase 2: StateManager API整備】
目的: 計画書のAPIを完全実装

追加メソッド:
- addStroke(strokeData) - ストローク追加
- removeStroke(strokeId) - ストローク削除
- addLayer(name) - レイヤー追加
- removeLayer(layerId) - レイヤー削除
- addCut(name) - Cut追加
- removeCut(cutId) - Cut削除

【Phase 3: イベント駆動統合】
目的: EventBus経由でUI更新を統一

実装内容:
1. stroke:added, stroke:removed イベント追加
2. layer:added, layer:removed イベント追加
3. cut:added, cut:removed イベント追加
4. 各UIコンポーネントがイベントをリスン


================================================================================
■ 改修実装ガイド（各ファイル別）
================================================================================

【system/history.js】
現状: ✅ コマンドパターン実装済み
課題: 実際に使われていない
対応: 他のファイルから呼び出す必要あり

【system/state-manager.js】
現状: ⚠️ 基本構造のみ実装
必要な追加実装:
```javascript
// ストローク操作
addStroke(strokeData) {
    const cut = this.getCurrentCut();
    const layer = cut.layers[cut.activeLayerIndex];
    const strokeId = this.generateId('stroke');
    const stroke = { id: strokeId, ...strokeData };
    
    const command = {
        name: 'add-stroke',
        do: () => {
            layer.strokes.push(stroke);
            EventBus.emit('stroke:added', { cutId: cut.id, layerId: layer.id, stroke });
        },
        undo: () => {
            const index = layer.strokes.findIndex(s => s.id === strokeId);
            if (index !== -1) {
                layer.strokes.splice(index, 1);
                EventBus.emit('stroke:removed', { cutId: cut.id, layerId: layer.id, strokeId });
            }
        }
    };
    
    History.push(command);
    return stroke;
}
```

【core-engine.js】
必要な改修:
1. stopDrawing() で StateManager.addStroke() を呼ぶ
2. キーボードイベントの修正（上記Quick Fix参照）

【system/layer-system.js】
必要な改修:
1. createLayer() で History.push() を呼ぶ
2. deleteLayer() で History.push() を呼ぶ
3. moveLayerUp/Down を階層移動に変更（入れ替えではなく）

【ui/timeline-ui.js】
必要な改修:
1. this.cuts を削除し、StateManager.state.timeline.cuts を参照
2. 左右矢印キーの修正（上記Quick Fix参照）


================================================================================
■ テスト項目
================================================================================

【Phase 0 完了後】
□ StateManager.state.timeline.cuts が唯一のデータソース
□ TimelineUI.cuts が存在しない
□ Cut/Frame の用語が統一されている

【Phase 1 完了後】
□ 描画 → History.canUndo() が true
□ 描画 → Ctrl+Z → ストロークが消える
□ レイヤー作成 → Ctrl+Z → レイヤーが消える
□ Cut追加 → Ctrl+Z → Cutが消える

【Phase 2 完了後】
□ StateManager.addStroke() が動作
□ StateManager.addLayer() が動作
□ StateManager.addCut() が動作
□ 各操作で自動的にHistory記録

【Phase 3 完了後】
□ EventBus経由でUI自動更新
□ 手動のrenderActiveLayer()呼び出し不要
□ 手動のupdateLayersList()呼び出し不要


================================================================================
■ 実装優先順位
================================================================================

優先度1（即座に修正）:
1. 左右矢印キーの修正（timeline-ui.js L457-474）
2. 上下矢印キーの修正（core-engine.js L1141-1185）

優先度2（基本機能復旧）:
1. History記録の追加（core-engine.js stopDrawing()）
2. StateManager.addStroke()の実装

優先度3（データ構造統一）:
1. TimelineUI.cutsの削除
2. StateManager経由のデータアクセスに統一

優先度4（完全統合）:
1. 全操作のHistory対応
2. EventBus経由のUI更新統一


================================================================================
■ 注意事項
================================================================================

【ベクターペン固有の考慮事項】
1. パスデータ（points配列）は参照ではなくコピーを保存
2. Graphics オブジェクトは State に含めない（再構築可能）
3. ストロークIDによる識別を徹底

【PixiJS v8.13 対応】
1. Graphics.clear() → Graphics.clear()（変更なし）
2. Container.addChild() → Container.addChild()（変更なし）
3. 新しいGraphics作成時は new PIXI.Graphics() を使用

【メモリ管理】
1. 削除したGraphicsは必ず destroy() を呼ぶ
2. 大量のパスデータは structuredClone() を避ける
3. Undo/Redo時は必要最小限の再描画

================================================================================