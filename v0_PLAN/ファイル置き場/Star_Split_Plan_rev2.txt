z# 改修計画書：星型（主星＝main）アーキテクチャ採用プロジェクト
## 序文：なぜツリー型ではなく星型にするのか
- ツリー型は呼び出しの深さと依存方向が増え、モジュール横断時に「どこが責務か」を見失いやすい。
- 星型（主星＝司令塔 / 衛星＝責務モジュール）を採ることで依存グラフを平坦化し、AIや人間が**「何が起点で何が確定処理か」**を一目で把握できる。
- 主星が「発火・仲介・確定」を担い、衛星は処理とデータ保持に集中する。これにより「切り離し」「差し替え」「AIによるリファクタ」が安定化する。

## アーキテクチャ概要（高レベル）
- main.html（主星）
  - 初期化、モジュール（衛星）初期化・接続、イベントルーティング、最終確定処理、レンダリング確定トランザクション。
- 衛星モジュール（各 .js）
  - レイヤー（layers.js）
  - 描画（pen.js / vectorPen.js）
  - 履歴（history.js）
  - UI（toolsUI.js）
  - エンジンラッパー（engineBridge.js）
- 通信ルール：必ず main を経由する（衛星→衛星の直接参照禁止）
- イベントパターン：命名はドット表記 "domain.eventName"（例：tools.brushDown, layers.moveRequest）

## 命名規則（厳格）
- ファイル名：kebab-case（例：main.html, layer-manager.js → layer-manager.js is allowed but prefer layers.js）
- クラス名：PascalCase（例：LayerController, HistoryService）
- 関数/メソッド：camelCase（例：createLayer(), confirmStroke()）
- 定数：SCREAMING_SNAKE_CASE（例：DEFAULT_BRUSH_SIZE）
- インターフェース / オブジェクト契約：Suffixで役割を明確化
  - *Bridge*：Engine など外部システムとの橋渡し（例：LayerBridge, EngineBridge）
  - *Controller*：主星が保持する「仲介ロジック」（例：MainController）
  - *Service*：ステート操作の純粋ロジック（例：HistoryService）
  - *UI*：DOM/ポップアップ生成（例：LayerUI）
- **禁止事項**：曖昧な `Manager` / `Handler` の多用は不可（例外的使用は明確な責務注記を必須とする）

## イベント & インターフェース設計（抜粋）
- 全イベントは `{ type: "domain.event", payload: {...}, meta: { requestId, origin } }` 形
- 主なイベント
  - tools.brushStart -> payload: { toolId, x,y,settings }
  - tools.brushMove -> payload: { points[] }
  - tools.brushEnd -> payload: { strokeData }
  - layers.moveRequest -> payload: { layerId, toIndex }  // 衛星が要求
  - layers.moveConfirm -> payload: { layerId, fromIndex, toIndex } // 主星が確定
  - history.record -> payload: { actionType, data }
- **RPC-like 関数契約**（main → 衛星、衛星 → main双方向）
  - 衛星は必ず `register(mainApi)` メソッドをエクスポートして main から受け取る（例：`mainApi.notify(event)`、`mainApi.requestConfirm(requestId)`）
  - main は衛星に対して `sandboxed` なハンドラを渡す（最小API）

## レイヤー周り（非破壊移動・変形・記録）の設計方針
- レイヤーは**immutable-ish** な変更履歴を保持する（状態は HistoryService に記録）
- レイヤーコンテンツはベクター（パス）ベースで管理。各ストロークはオブジェクト（id, points[], style, transform）
- 非破壊レイヤー移動：
  1. 衛星(LayersUI) が `layers.moveRequest` を main に送信（非確定）
  2. main が検証（重複、依存、ロック）を行い `layers.moveConfirm` を発行
  3. main が HistoryService に `record({type: "layerMove", before, after})`
- 変形（transform）はレイヤー毎に「transform record」を作成し、元状態を保持（undo 用）
- ペン描画確定：
  - 描画はまず PenModule が一時バッファ（未確定）に蓄積
  - `tools.brushEnd` にて main に `strokeData` を送信 → main が `validate` → 履歴に `record` → EngineBridge に描画確定命令

## 責務とどの程度 main に残すか（ガイドライン）
- main に残す（肥大化容認）：
  - イベントルーティング／検証／トランザクション境界（原子的に確定する処理）
  - 履歴（HistoryService）呼び出しの「唯一の窓口（ただし実装は衛星が持てる）」
  - レイヤー並び替え等、複数衛星にまたがる整合性確保処理
- 衛星に委譲する：
  - 実際の計算処理（パス生成、スナップ、変形アルゴリズム）
  - UI 描画（ポップアップ、スライダー）
  - 一時状態管理（未確定の描画バッファなど）

## エラー／フォールバック方針
- **原則**：フォールバックで誤魔化さず、エラーは検知しログに残し、構造上の責務で対処する。
  - 衛星は input validation に失敗したら `mainApi.notifyError({code,msg,context})` を送る
  - main は受け取りログ化し、UI に可視化されたエラー通知（致命的でないものはユーザ通知）
- **例外管理**：
  - 衛星側で補完可能な軽微エラーは衛星で自己解決（かつ main に info 報告）
  - 整合性を壊すエラー（履歴不整合、LayerBridge 未定義等）は main で停止してエラー表示
- エラーコード体系（命名例）：ERR_DOMAIN_SHORT（例：ERR_LAYERS_MOVE_CONFLICT）

## ログ／コンソール方針
- console.log は最小限（info は main の debug モードのみ出力）
- 重要ログは structured logger（`log(level, tag, payload)`）を用意
- 本番デフォルト：error と user-facing warnings のみ
- デバッグモードでのみ詳細ログ（stack traces, payload）を出力

## 技術スタック & 制約
- Pixi v8 (WebGL2 を利用)、ES2023 準拠、Chrome 最新 API を想定（古いブラウザ互換性は切る）
- WebGPU を視野に入れた抽象化（EngineBridge 層で将来差し替え可能に）
- 依存ライブラリは最小限：検討候補
  - イベント管理：mitt もしくは自作軽量 dispatcher
  - Immutable helpers：immer（必要なら）
  - Vector utilities：paths-js など（必要なら）
- テスト：ユニットテスト（Jest）、統合テストは headless browser（Playwright）

## 非機能要求（パフォーマンス・拡張）
- レイテンシ：描画中は主に衛星（PenModule）で直書き反映、確定処理は main が同期的に履歴記録・確定（非同期IOは別thread）
- メモリ：ストロークは差分保存（フルコピーを避ける）
- GPU：重要な描画はシェーダーやバッファを利用（EngineBridge に移譲）

## テスト / 移行手順（高レベル）
1. 既存 monolith を read-only で保存（rev tag）
2. main を作成（入口・event routerのみ）
3. Layers を衛星化（layers.js）→ main から register → 単体テスト
4. PenModule を衛星化 → main に統合テスト
5. HistoryService を main 側窓口で実装、衛星は履歴登録 API を利用
6. 全統合テスト・性能検証（描画スループット・Undo/Redo整合性）

## 付録：ガバナンスとルール
- 衛星間直接参照は禁止（PR レビューでチェック）
- 命名・役割違反は CI の lint / rule で検出（ESLint カスタムルール）
- main は「API カタログ（JSON）」を持つ：各衛星はこのカタログに登録することで整合性保証

-- END OF PLAN --


※下記はガイド用の参考コードです。あくまで「お手本・骨組み」で、機能詳細は入れていません。主星（main.html）と衛星モジュール（Layers, Pen, History, ToolsUI）の関係がわかる構造です。

<!-- -------------------- main.html (主星) -------------------- -->
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Star-Architecture Drawing Tool (HTML直開き版)</title>
<!-- PixiJS CDN -->
<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.4.0/dist/pixi.min.js"></script>

<!-- 衛星モジュール -->
<script src="layers.js"></script>
<script src="pen.js"></script>
<script src="history.js"></script>
<script src="toolsUI.js"></script>

<script>
(function(){
  class MainController {
      constructor() {
          this.layers = new MyApp.LayerModule(this);
          this.pen = new MyApp.PenModule(this);
          this.history = new MyApp.HistoryService();
          this.toolsUI = new MyApp.ToolUI(this);
          this.init();
      }

      init() {
          console.log("MainController initialized");
          this.layers.register(this);
          this.pen.register(this);
          this.toolsUI.register(this);
      }

      notify(event) {
          switch(event.type) {
              case 'layers.moveRequest':
                  this.layers.moveConfirm(event.payload);
                  this.history.record({ type: 'layerMove', data: event.payload });
                  break;
              case 'tools.brushEnd':
                  this.pen.confirmStroke(event.payload);
                  this.history.record({ type: 'stroke', data: event.payload });
                  break;
              default:
                  console.warn('Unknown event:', event.type);
          }
      }
  }

  window.app = new MainController();
})();
</script>
</head>
<body>
<div id="canvas-container"></div>
<div id="tools-container"></div>
</body>
</html>

// -------------------- layers.js (衛星: レイヤー管理) --------------------
window.MyApp = window.MyApp || {};

(function(global){
  class LayerModule {
      constructor(mainController) {
          this.main = mainController;
          this.layers = [];
      }

      register(mainController) {
          this.main = mainController;
      }

      createLayer(name) {
          const layer = { id: this.layers.length, name, transform: null };
          this.layers.push(layer);
          return layer;
      }

      moveLayer(fromIndex, toIndex) {
          const payload = { fromIndex, toIndex };
          this.main.notify({ type: 'layers.moveRequest', payload });
      }

      moveConfirm(payload) {
          const layer = this.layers.splice(payload.fromIndex, 1)[0];
          this.layers.splice(payload.toIndex, 0, layer);
          console.log('Layer moved:', payload);
      }
  }

  global.MyApp.LayerModule = LayerModule;
})(window);

// -------------------- pen.js (衛星: ペン描画) --------------------
window.MyApp = window.MyApp || {};

(function(global){
  class PenModule {
      constructor(mainController) {
          this.main = mainController;
          this.strokeBuffer = [];
      }

      register(mainController) {
          this.main = mainController;
      }

      startStroke(point) {
          this.strokeBuffer.push([point]);
      }

      addPoint(point) {
          this.strokeBuffer[this.strokeBuffer.length-1].push(point);
      }

      endStroke() {
          const payload = this.strokeBuffer.pop();
          this.main.notify({ type: 'tools.brushEnd', payload });
      }

      confirmStroke(payload) {
          console.log('Stroke confirmed:', payload);
          // 実際の描画処理はここに
      }
  }

  global.MyApp.PenModule = PenModule;
})(window);

// -------------------- history.js (衛星: 操作履歴) --------------------
window.MyApp = window.MyApp || {};

(function(global){
  class HistoryService {
      constructor() {
          this.stack = [];
          this.index = -1;
      }

      record(action) {
          this.stack = this.stack.slice(0, this.index+1);
          this.stack.push(action);
          this.index++;
          console.log('History recorded:', action);
      }

      undo() {
          if(this.index < 0) return;
          const action = this.stack[this.index--];
          console.log('Undo:', action);
      }

      redo() {
          if(this.index >= this.stack.length-1) return;
          const action = this.stack[++this.index];
          console.log('Redo:', action);
      }
  }

  global.MyApp.HistoryService = HistoryService;
})(window);

// -------------------- toolsUI.js (衛星: ツール UI) --------------------
window.MyApp = window.MyApp || {};

(function(global){
  class ToolUI {
      constructor(mainController) {
          this.main = mainController;
      }

      register(mainController) {
          this.main = mainController;
          this.initUI();
      }

      initUI() {
          console.log("Tool UI initialized");

          const brushBtn = document.createElement('button');
          brushBtn.textContent = 'Brush';
          brushBtn.onclick = () => this.main.notify({ type:'tools.brushStart', payload:{ toolId:'brush' } });
          document.getElementById('tools-container').appendChild(brushBtn);
      }
  }

  global.MyApp.ToolUI = ToolUI;
})(window);

✅ この置き換え版のポイント

HTML直開きで動作可能

import/exportなし

<script> で順番に読み込むだけで OK

名前空間管理

衛星モジュールは MyApp に集約

衛星間のグローバル汚染や名前衝突を防止

star-architectureそのまま

主星がイベント仲介・確定

衛星は処理専念・一時状態保持

将来的に非破壊レイヤー移動や変形も追加しやすい

LayerModule 側に transform ロジック追加可能

PenModule でストローク確定・バッファ管理可能





