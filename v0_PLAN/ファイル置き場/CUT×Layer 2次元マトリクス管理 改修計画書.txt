# CUT×Layer 2次元マトリクス管理 改修計画書

## 📋 現状の問題分析

### 発生している不具合
1. **タイムラインのサムネイルが反映されない**
2. **CUT1 Layer1で描いた絵がCUT2 Layer1に反映される**

### 根本原因
現状は **部分的なDeep Copy** に留まっており、以下の問題があります：

```javascript
// ❌ 問題1: LayerSystemのlayers配列が参照を保持
this.layers = []; // AnimationSystemのCUTデータへの参照が混在

// ❌ 問題2: saveCutLayerStates()のタイミング問題
// 描画中にLayerSystemのlayersが更新されても、AnimationSystemへの保存が遅延

// ❌ 問題3: CUT切替時のsync処理が不完全
// _syncLayersContainerFromAnimationSystem()でDeep Copyせずに参照を渡している
```

---

## 🎯 採用するアーキテクチャ

### **選択: A案 - 2次元マトリクス管理**

#### 理由
- **B案（フォルダ管理）** は将来のレイヤーフォルダ機能と競合する可能性
- **A案** はCUT軸とLayer軸を明確に分離し、既存構造を活かせる
- AnimationSystemが「唯一の真実の情報源（Single Source of Truth）」として機能

#### データ構造
```javascript
AnimationSystem.animationData.cuts = [
  {
    id: 'cut_001',
    name: 'CUT1',
    duration: 0.5,
    layers: [
      { id: 'cut_001_layer_bg', name: '背景', paths: [...], transform: {...} },
      { id: 'cut_001_layer_01', name: 'レイヤー1', paths: [...], transform: {...} },
      { id: 'cut_001_layer_02', name: 'レイヤー2', paths: [...], transform: {...} }
    ],
    thumbnailCanvas: <Canvas>
  },
  {
    id: 'cut_002',
    name: 'CUT2',
    duration: 0.5,
    layers: [
      { id: 'cut_002_layer_bg', name: '背景', paths: [...], transform: {...} },
      { id: 'cut_002_layer_01', name: 'レイヤー1', paths: [...], transform: {...} }  // ← 完全独立
    ],
    thumbnailCanvas: <Canvas>
  }
];

// LayerSystemは「現在のCUTのView」でしかない
LayerSystem.layers = []; // PIXI.Containerの配列（描画用）
```

---

## 🔧 改修方針

### 原則
1. **AnimationSystem = データの唯一の所有者**
2. **LayerSystem = 描画とUI操作のView**
3. **すべてのデータ変更はAnimationSystemを経由**
4. **参照の共有を完全排除**

### キーポイント
- `LayerSystem.layers`は**読み取り専用のView**
- 描画完了時は**即座にAnimationSystemへDeep Copy保存**
- CUT切替時は**完全なLayer再構築**

---

## 📝 詳細改修内容

### 1. AnimationSystem の改修

#### 1-1. `copyCurrentLayersToIndependentState()` - 完全性保証
**目的**: LayerSystemの現在状態から完全独立のCUTデータを生成

**改修内容**:
```javascript
copyCurrentLayersToIndependentState(cutId) {
  // ✅ paths配列の完全Deep Copy
  // ✅ points配列も新規作成
  // ✅ transform情報も複製
  // ❌ 参照の共有を絶対にしない
}
```

**使用箇所**:
- `createNewCutFromCurrentLayers()` - CUT作成時
- `saveCutLayerStates()` - 描画後の状態保存
- `saveCutLayerStatesBeforeSwitch()` - CUT切替前の保存

---

#### 1-2. `deepCloneCutLayers()` - 二重防御
**目的**: CUTのLayer配列を完全に複製（バックアップ用）

**改修内容**:
```javascript
deepCloneCutLayers(cutLayers) {
  // ✅ すべての階層で新規オブジェクト生成
  // ✅ paths, points配列も新規作成
  // ❌ Object.assign()は使用しない（浅いコピーになるため）
}
```

**使用箇所**:
- `createNewCutFromCurrentLayers()` - 作成時
- `createNewBlankCut()` - 空CUT作成時
- `saveCutLayerStates()` - 保存時（Map用）
- `deepCopyCutData()` - クリップボード用

---

#### 1-3. `saveCutLayerStates()` - 即時保存の徹底
**目的**: 描画変更を即座にAnimationSystemに反映

**改修前の問題**:
```javascript
// ❌ LayerSystemのlayers配列を参照していた
currentCut.layers = this.layerSystem.layers; // 参照の共有！
```

**改修後**:
```javascript
saveCutLayerStates() {
  const currentCut = this.getCurrentCut();
  if (!currentCut || !this.layerSystem) return;
  
  // ✅ Deep Copyで完全独立保存
  const currentState = this.copyCurrentLayersToIndependentState(currentCut.id);
  
  // ✅ CUTデータに保存（参照ではなくコピー）
  currentCut.layers = this.deepCloneCutLayers(currentState);
  
  // ✅ Mapにも保存（二重保存）
  this.cutLayerStates.set(currentCut.id, this.deepCloneCutLayers(currentState));
  
  // ✅ イベント発火
  this.eventBus.emit('animation:cut-updated', { 
    cutIndex: this.animationData.playback.currentCutIndex,
    cutId: currentCut.id
  });
}
```

**呼び出し元**:
- `LayerSystem.addPathToLayer()` - 描画完了時
- `LayerSystem.updateActiveLayerTransform()` - Transform変更時
- `LayerSystem.flipActiveLayer()` - 反転時
- EventBus: `layer:updated`, `layer:visibility-changed`, `layer:path-added`

---

#### 1-4. `setActiveCut()` - 完全再構築
**目的**: CUT切替時にLayerSystemを完全に再構築

**改修内容**:
```javascript
setActiveCut(cutIndex, resetTransform = false) {
  const cut = this.animationData.cuts[cutIndex];
  if (!cut || !this.layerSystem) return;
  
  // ✅ Step 1: LayerSystemを完全クリア
  this.clearLayerSystemLayers();
  
  // ✅ Step 2: 最新状態を取得（Map優先）
  const cutLayers = this.cutLayerStates.get(cut.id) || cut.layers || [];
  
  // ✅ Step 3: 完全再構築（新しいPIXI.Container生成）
  this.rebuildLayersFromCutData(cutLayers, resetTransform);
  
  // ✅ UI更新
  if (this.layerSystem.updateLayerPanelUI) {
    this.layerSystem.updateLayerPanelUI();
  }
}
```

---

#### 1-5. `rebuildLayersFromCutData()` - PIXI.Container新規生成
**目的**: CUTデータから完全に新しいPIXI構造を生成

**重要ポイント**:
```javascript
rebuildLayersFromCutData(cutLayers, resetTransform) {
  cutLayers.forEach((cutLayerData, index) => {
    // ✅ 新しいPIXI.Container作成
    const layer = new PIXI.Container();
    layer.label = cutLayerData.id;
    
    // ✅ 新しいlayerDataオブジェクト作成（参照を持たない）
    layer.layerData = {
      id: cutLayerData.id,
      name: cutLayerData.name,
      visible: cutLayerData.visible !== false,
      opacity: cutLayerData.opacity || 1.0,
      isBackground: cutLayerData.isBackground || false,
      paths: []  // ← 空から開始
    };
    
    // ✅ paths再構築（新しいPIXI.Graphics生成）
    if (cutLayerData.paths && Array.isArray(cutLayerData.paths)) {
      cutLayerData.paths.forEach(pathData => {
        const reconstructedPath = this.rebuildPathFromData(pathData);
        if (reconstructedPath) {
          layer.layerData.paths.push(reconstructedPath);
          layer.addChild(reconstructedPath.graphics);
        }
      });
    }
    
    this.layerSystem.layers.push(layer);
    this.layerSystem.layersContainer.addChild(layer);
  });
}
```

---

### 2. LayerSystem の改修

#### 2-1. `_syncLayersContainerFromAnimationSystem()` - 削除
**理由**: 
- AnimationSystemの`setActiveCut()`が完全再構築を行うため不要
- 二重管理を避ける

**代替**:
```javascript
// ✅ AnimationSystemのイベントに応答するだけ
this.eventBus.on('animation:cut-applied', (data) => {
  setTimeout(() => {
    // AnimationSystemが既にlayersを再構築済み
    this.updateLayerPanelUI();
    this.updateStatusDisplay();
  }, 100);
});
```

---

#### 2-2. `addPathToLayer()` - 即時保存の徹底
**目的**: 描画完了時に即座にAnimationSystemへ保存

**改修後**:
```javascript
addPathToLayer(layerIndex, path) {
  if (layerIndex >= 0 && layerIndex < this.layers.length) {
    const layer = this.layers[layerIndex];
    
    // ✅ LayerSystemのlayersに追加
    layer.layerData.paths.push(path);
    layer.addChild(path.graphics);
    
    this.requestThumbnailUpdate(layerIndex);
    
    // ✅ AnimationSystemへ即座に保存
    if (this.animationSystem?.saveCutLayerStates) {
      requestAnimationFrame(() => {
        this.animationSystem.saveCutLayerStates();
        
        // ✅ サムネイル生成も連動
        const currentCutIndex = this.animationSystem.getCurrentCutIndex();
        setTimeout(() => {
          this.animationSystem.generateCutThumbnailOptimized(currentCutIndex);
        }, 50);
      });
    }
    
    // ✅ イベント発火
    if (this.eventBus) {
      this.eventBus.emit('layer:path-added', { 
        layerIndex, 
        pathId: path.id,
        layerId: layer.layerData.id
      });
    }
  }
}
```

---

#### 2-3. Transform操作系メソッド - 保存連動
**対象メソッド**:
- `updateActiveLayerTransform()`
- `flipActiveLayer()`
- `confirmLayerTransform()`

**改修内容**:
```javascript
updateActiveLayerTransform(property, value) {
  // ... Transform適用処理 ...
  
  // ✅ AnimationSystemへ即座に通知
  if (this.animationSystem?.updateCurrentCutLayer) {
    this.animationSystem.updateCurrentCutLayer(this.activeLayerIndex, {
      transform: { ...transform }
    });
  }
  
  // ✅ AnimationSystemへ保存
  if (this.animationSystem?.saveCutLayerStates) {
    this.animationSystem.saveCutLayerStates();
  }
}
```

---

### 3. EventBus連動の強化

#### 3-1. 追加するイベント

| イベント名 | 発火タイミング | 用途 |
|-----------|---------------|------|
| `layer:path-added` | 描画完了時 | AnimationSystemへの保存トリガー |
| `layer:updated` | Layer変更時 | AnimationSystemへの保存トリガー |
| `animation:cut-updated` | CUT保存完了時 | タイムラインUI更新 |
| `animation:thumbnail-generated` | サムネイル生成完了時 | タイムラインUI反映 |

#### 3-2. イベントフロー図
```
[描画完了]
    ↓
LayerSystem.addPathToLayer()
    ↓
eventBus.emit('layer:path-added')
    ↓
AnimationSystem: saveCutLayerStates()
    ↓
eventBus.emit('animation:cut-updated')
    ↓
[タイムラインUI更新]
```

---

## 🔄 動作フロー

### A. 描画時のフロー
```
1. ユーザーが描画
   ↓
2. DrawingEngine: path作成
   ↓
3. LayerSystem.addPathToActiveLayer(path)
   ↓
4. layer.layerData.paths.push(path) ← LayerSystemに追加
   ↓
5. requestAnimationFrame(() => {
     AnimationSystem.saveCutLayerStates()  ← Deep Copy保存
   })
   ↓
6. currentCut.layers = deepCloneCutLayers(...)  ← AnimationSystemに保存
   ↓
7. cutLayerStates.set(cutId, deepCloneCutLayers(...))  ← Map保存
   ↓
8. generateCutThumbnailOptimized(cutIndex)  ← サムネイル更新
   ↓
9. eventBus.emit('animation:cut-updated')
   ↓
10. TimelineUI: サムネイル反映
```

### B. CUT切替時のフロー
```
1. AnimationSystem.switchToActiveCutSafely(cutIndex)
   ↓
2. saveCutLayerStatesBeforeSwitch()  ← 現在CUTを保存
   ↓
3. clearLayerSystemLayers()  ← LayerSystemを完全クリア
   ↓
4. cutLayers = cutLayerStates.get(newCutId)  ← 新CUTデータ取得
   ↓
5. rebuildLayersFromCutData(cutLayers)  ← 完全再構築
   │
   ├─ new PIXI.Container()  ← 新しいLayer作成
   ├─ new layerData { paths: [] }  ← 新しいlayerData作成
   ├─ rebuildPathFromData()  ← 各Pathを再構築
   │   └─ new PIXI.Graphics()  ← 新しいGraphics作成
   ↓
6. LayerSystem.layers = [...新しいLayer配列]  ← View更新
   ↓
7. updateLayerPanelUI()  ← UIパネル更新
   ↓
8. eventBus.emit('animation:cut-applied')
```

### C. CUT作成時のフロー
```
1. AnimationSystem.createNewCutFromCurrentLayers()
   ↓
2. copyCurrentLayersToIndependentState(cutId)
   │
   ├─ LayerSystemのlayersを読み取り
   ├─ 各Layerをループ
   │   ├─ generateUniqueCutLayerId(cutId)  ← 新しいID生成
   │   ├─ paths配列をDeep Copy
   │   │   └─ points配列もDeep Copy
   │   └─ transform情報もコピー
   ↓
3. cut.layers = independentLayers  ← 独立データ保存
   ↓
4. cutLayerStates.set(cutId, deepCloneCutLayers(independentLayers))  ← Map保存
   ↓
5. switchToActiveCutSafely(newCutIndex)  ← 新CUTへ切替
   ↓
6. generateCutThumbnailOptimized(newCutIndex)  ← サムネイル生成
   ↓
7. eventBus.emit('animation:cut-created')
```

---

## 📚 主要メソッド辞典

### AnimationSystem

| メソッド名 | 責務 | 入力 | 出力 | 備考 |
|-----------|------|-----|------|------|
| `copyCurrentLayersToIndependentState(cutId)` | LayerSystemの現在状態からCUT独立データ生成 | cutId: string | Array<LayerData> | Deep Copy実行 |
| `deepCloneCutLayers(cutLayers)` | CUT Layer配列の完全複製 | Array<LayerData> | Array<LayerData> | バックアップ用 |
| `saveCutLayerStates()` | 現在CUTの状態をAnimationSystemに保存 | なし | void | 描画完了時に呼ぶ |
| `saveCutLayerStatesBeforeSwitch()` | CUT切替前の状態保存 | なし | void | 切替前に必ず呼ぶ |
| `setActiveCut(cutIndex, resetTransform)` | CUT切替・LayerSystem再構築 | cutIndex: number, resetTransform: boolean | void | 完全再構築 |
| `rebuildLayersFromCutData(cutLayers, resetTransform)` | CUTデータからPIXI構造を生成 | Array<LayerData>, boolean | void | 新規Container生成 |
| `rebuildPathFromData(pathData)` | PathデータからPIXI.Graphics生成 | PathData | Path | 新規Graphics生成 |
| `generateCutThumbnailOptimized(cutIndex)` | CUTサムネイル生成 | cutIndex: number | Promise<void> | Canvas2D使用 |
| `createNewCutFromCurrentLayers()` | 現在Layerから新CUT作成 | なし | Cut | Deep Copy保存 |
| `createNewBlankCut()` | 空CUT作成 | なし | Cut | 初期Layer構造生成 |
| `switchToActiveCutSafely(cutIndex, resetTransform)` | 安全なCUT切替 | cutIndex: number, resetTransform: boolean | void | ロック機構あり |

### LayerSystem

| メソッド名 | 責務 | 入力 | 出力 | 備考 |
|-----------|------|-----|------|------|
| `addPathToLayer(layerIndex, path)` | LayerにPath追加・AnimationSystem保存 | layerIndex: number, Path | void | 即時保存 |
| `addPathToActiveLayer(path)` | アクティブLayerにPath追加 | Path | void | addPathToLayerを呼ぶ |
| `updateActiveLayerTransform(property, value)` | Transform更新・AnimationSystem保存 | property: string, value: number | void | 即時保存 |
| `flipActiveLayer(direction)` | Layer反転・AnimationSystem保存 | direction: 'horizontal'\|'vertical' | void | 即時保存 |
| `confirmLayerTransform()` | Transform確定・PathへBake | なし | void | V Key離脱時 |
| `updateLayerPanelUI()` | LayerパネルUI更新 | なし | void | HTML生成 |
| `updateThumbnail(layerIndex)` | Layer個別サムネイル更新 | layerIndex: number | void | Canvas2D使用 |
| `setActiveLayer(index)` | アクティブLayer変更 | index: number | void | UI更新連動 |
| `toggleLayerVisibility(layerIndex)` | Layer可視性トグル | layerIndex: number | void | AnimationSystem保存 |
| `createLayer(name, isBackground)` | 新Layer作成 | name: string, isBackground: boolean | {layer, index} | AnimationSystem通知 |
| `deleteLayer(layerIndex)` | Layer削除 | layerIndex: number | boolean | AnimationSystem保存 |

---

## 🚨 重要な注意事項

### 1. 参照の共有を絶対に避ける
```javascript
// ❌ NG例
currentCut.layers = this.layerSystem.layers;  // 参照の共有！

// ✅ OK例
currentCut.layers = this.deepCloneCutLayers(
  this.copyCurrentLayersToIndependentState(currentCut.id)
);
```

### 2. Deep Copyの徹底
```javascript
// ❌ NG例
const newLayer = { ...originalLayer };  // 浅いコピー（paths配列は参照）

// ✅ OK例
const newLayer = {
  ...originalLayer,
  paths: originalLayer.paths.map(path => ({
    ...path,
    points: path.points.map(p => ({ x: p.x, y: p.y }))
  }))
};
```

### 3. 保存タイミング
```javascript
// ✅ 描画完了後は必ず保存
addPathToActiveLayer(path) {
  // ... path追加 ...
  
  requestAnimationFrame(() => {
    this.animationSystem.saveCutLayerStates();  // ← 必須
  });
}
```

### 4. CUT切替時の完全クリア
```javascript
// ✅ 必ず完全クリアしてから再構築
switchToActiveCutSafely(cutIndex) {
  this.saveCutLayerStatesBeforeSwitch();  // ← 現在CUT保存
  this.clearLayerSystemLayers();  // ← 完全クリア
  this.rebuildLayersFromCutData(...);  // ← 再構築
}
```

---

## 📊 改修前後の比較

### 問題1: タイムラインのサムネイル反映

| | 改修前 | 改修後 |
|---|-------|-------|
| 原因 | `saveCutLayerStates()`が参照を保存 | `deepCloneCutLayers()`で完全独立 |
| 症状 | サムネイル生成時にデータが空 | 常に最新状態を反映 |
| 解決 | ❌ | ✅ |

### 問題2: CUT間のLayer混在

| | 改修前 | 改修後 |
|---|-------|-------|
| 原因 | `LayerSystem.layers`が参照を保持 | 完全再構築で新規Container生成 |
| 症状 | CUT1の描画がCUT2に反映 | CUT毎に完全独立 |
| 解決 | ❌ | ✅ |

---

## ✅ 改修完了チェックリスト

### AnimationSystem
- [ ] `copyCurrentLayersToIndependentState()`: paths/points Deep Copy確認
- [ ] `deepCloneCutLayers()`: 全階層Deep Copy確認
- [ ] `saveCutLayerStates()`: 二重Deep Copy保存確認
- [ ] `setActiveCut()`: 完全再構築確認
- [ ] `rebuildLayersFromCutData()`: 新規Container生成確認

### LayerSystem
- [ ] `addPathToLayer()`: 即時保存確認
- [ ] `updateActiveLayerTransform()`: 即時保存確認
- [ ] `flipActiveLayer()`: 即時保存確認
- [ ] `_syncLayersContainerFromAnimationSystem()`: 削除確認

### 統合テスト
- [ ] CUT1で描画 → CUT2で空白 → CUT1に戻ると描画が残る
- [ ] CUT作成時にサムネイル即座に反映
- [ ] CUT切替時にサムネイル正しく表示
- [ ] Transform操作後にサムネイル更新
- [ ] クリップボードコピー/ペーストで独立性維持

---

## 📈 今後の拡張性

### レイヤーフォルダ実装時
```javascript
// 現在の構造を拡張
cut.layers = [
  { 
    id: 'folder_001', 
    name: 'フォルダA',
    type: 'folder',  // ← 追加
    children: [  // ← 追加
      { id: 'layer_001', ... },
      { id: 'layer_002', ... }
    ]
  }
];

// フォルダサムネイル = 子Layer合成
generateFolderThumbnail(folder) {
  const composite = folder.children.reduce(...);
  return composite;
}
```

### LIVE2D/SPINEアニメ実装時
```javascript
// Transform情報を拡張
layer.transform = {
  x, y, rotation, scaleX, scaleY,
  // ↓ 追加
  keyframes: [
    { time: 0, x: 0, y: 0 },
    { time: 0.5, x: 10, y: 20 }
  ]
};
```

---

## 🎯 まとめ

### 改修のコアコンセプト
1. **AnimationSystem = 唯一の真実の情報源**
2. **LayerSystem = 描画View（読み取り専用）**
3. **参照の共有を完全排除**
4. **Deep Copyの徹底**
5. **即時保存の原則**

### 期待される効果
✅ CUT毎のLayer完全独立性  
✅ タイムラインサムネイル即時反映  
✅ CUT切替時のデータ混在解消  
✅ コードの可読性・保守性向上  
✅ 将来の機能拡張への柔軟性確保

---

**改修担当AI**: Claude Sonnet 4.5  
**改修日**: 2025-09-30  
**バージョン**: v8.13_gif_phase2_matrix