# SatellitePlan_RuleBook_v8.txt
# Tegaki PixiJS v8.13 分割開発・非破壊化ルールブック（Claude実装最適化版）

## 🎯 基本方針（v8更新）
- **index.html + main.js 二分割をコア**とし、AIが main.js のみ修正で済むファイル構成
- **main.js を AI 改修の中枢**として一本化維持、外部サテライトファイルは参照のみ
- **非破壊性担保**：レイヤー変形時も元描画データ（パス/ストローク）を保持
- **Claude可読性最優先**：改修時に触る必要のあるコードは main.js に集約

---

## 📁 ファイル構成案（段階的分割）

### Phase1: index.html + main.js 二分割（現状 → 即実施）
```
index.html        # UIの土台、DOM要素、Canvas配置、スクリプト読込
main.js          # PixiJS描画・レイヤー管理・ツールロジックの中枢
```

**分割ルール**:
- **index.html**: HTMLタグ、CSS、静的UI定義、外部ライブラリ読込
- **main.js**: 全JavaScript機能（PixiJS初期化・描画・レイヤー・UI制御・イベント）
- AIが改修する際は **main.js のみ修正** で完結させる

### Phase2: サテライトファイル分離（main.js 肥大化後）
```
index.html
main.js          # 依然として中枢、サテライトから値を参照するのみ
config.js        # 定数・キャンバスサイズ・DPI・ツールデフォルト値（参照専用）
assets.js        # アイコン定義・テーマカラー・外部リソース（参照専用）
i18n.js          # 国際化文字列・UI文言辞書（参照専用）
```

**分割ルール**:
- **main.js** は引き続き機能の中枢を担う
- **サテライトファイル** は main.js からの参照専用、AIは値確認のみ
- サテライトファイルの値変更時も、main.js でロジック調整完結

### Phase3: 機能別分離（完全分離）
```
index.html
main.js          # エントリーポイント + 各モジュール統合制御
config.js        # 設定値（参照専用）
assets.js        # リソース（参照専用）  
i18n.js          # 国際化（参照専用）
network.js       # 2窓連携・サーバ連携専用（独立）
```

**分割ルール**:
- AIが改修する機能は main.js に残す
- 独立性が高い機能（network等）のみ分離
- main.js でサテライトを統合管理

---

## 🏗 非破壊化アーキテクチャ設計

### データ構造変更（必須改修）
```javascript
// レイヤーデータ構造（v8改定）
layer.layerData = {
  id: 'layer_1',
  name: 'レイヤー1',  
  visible: true,
  opacity: 1.0,
  pivot: {x: CONFIG.canvas.width/2, y: CONFIG.canvas.height/2}, // 変形中心
  transform: { x: 0, y: 0, scale: 1, rotation: 0 },              // 論理transform
  paths: [                                                        // 非破壊パスデータ
    {
      id: 'p123',
      type: 'stroke'|'fill'|'shape',
      commands: [ {cmd:'moveTo', x, y}, {cmd:'bezierCurveTo', ...}, ... ],
      style: { width, cap, join, color, opacity },
      createdAt, updatedAt
    }
  ],
  cache: { texture: null, scaleAtCreation: 1, rotationAtCreation: 0, dpr: 1 }
};
```

### コアレンダリング関数（新規実装必須）
```javascript
// パス → PIXI.Graphics 再構築（pure function）
function buildGraphicsFromPath(pathObj) {
  const g = new PIXI.Graphics();
  g.lineStyle(pathObj.style.width, pathObj.style.color, pathObj.style.opacity);
  pathObj.commands.forEach(cmd => {
    switch(cmd.cmd) {
      case 'moveTo': g.moveTo(cmd.x, cmd.y); break;
      case 'lineTo': g.lineTo(cmd.x, cmd.y); break;
      case 'bezierCurveTo': g.bezierCurveTo(cmd.cp1x, cmd.cp1y, cmd.cp2x, cmd.cp2y, cmd.x, cmd.y); break;
    }
  });
  return g;
}

// レイヤー再描画（キャッシュor再生成）
function renderLayerViewFromLayerData(layer) {
  const view = layer.view; // PIXI.Container
  view.removeChildren();
  
  // 1) キャッシュが有効で条件に合うなら sprite使用
  if (layer.layerData.cache.texture && cacheMatches(layer)) {
    const s = new PIXI.Sprite(layer.layerData.cache.texture);
    s.alpha = layer.layerData.opacity;
    view.addChild(s);
    return;
  }
  
  // 2) paths を再描画
  layer.layerData.paths.forEach(path => {
    const g = buildGraphicsFromPath(path);
    view.addChild(g);
  });
}

// 高解像度キャッシュ作成
function createLayerCache(layer, {dpr = window.devicePixelRatio, extraScale = 1.2} = {}) {
  const width = Math.ceil(CONFIG.canvas.width * dpr * extraScale);
  const height = Math.ceil(CONFIG.canvas.height * dpr * extraScale);
  const rt = PIXI.RenderTexture.create({ width, height, resolution: dpr });
  
  // 一時containerでlayerのviewを構築してレンダリング
  const tmp = new PIXI.Container();
  // rebuild view at scale=dpr*extraScale if needed
  rebuildLayerForCache(layer, tmp, dpr * extraScale);
  app.renderer.render(tmp, { renderTexture: rt });
  
  layer.layerData.cache = { 
    texture: rt, 
    scaleAtCreation: layer.transform.scale, 
    rotationAtCreation: layer.transform.rotation, 
    dpr 
  };
}
```

### 確定操作の選択制（改修必須）
```javascript
// 論理確定（推奨デフォルト・非破壊）
function confirmLayerTransformLogical(layer) {
  // 1) layer.layerData.transform に現在のtransformを合成
  layer.layerData.transform = composeTransforms(
    layer.layerData.transform, 
    currentTransformFromContainer(layer)
  );
  // 2) viewのtransformをリセットして再描画
  resetViewTransform(layer);
  renderLayerViewFromLayerData(layer);
}

// 焼き込み確定（オプション・高解像度用）
function confirmLayerTransformBake(layer) {
  // 1) バックアップとしてpathデータ保持
  layer.layerData._backupPaths = deepClone(layer.layerData.paths);
  // 2) 高解像度で焼き込み
  createLayerCache(layer, {dpr: window.devicePixelRatio * 2, extraScale: 1.5});
  // 3) viewをcache spriteのみに差し替え（pathsは保持）
  replaceViewWithCache(layer);
}
```

---

## 🔧 PixiJS v8.13 統一API設計

### 座標変換ルール（厳格化）
```javascript
// [1] DOM座標（ペン入力） → スクリーン座標
const screenPoint = { x: e.clientX, y: e.clientY };

// [2] スクリーン座標 → キャンバス座標（描画用・レイヤー変形考慮しない）
const canvasPoint = cameraSystem.screenToCanvasForDrawing(screenX, screenY);

// [3] スクリーン座標 → レイヤーローカル座標（レイヤー操作用）
const layerPoint = activeLayer.toLocal(screenPoint);

// 禁止: 直接座標計算、手動Matrix操作
```

### Container階層（確定版）
```javascript
app.stage
└── worldContainer (カメラ変形用)
    └── canvasContainer (キャンバス領域)
        ├── canvasMask (描画領域制限)
        ├── layersContainer
        │   ├── layer0 (背景層)
        │   │   └── layer0.view (表示用Container)
        │   ├── layer1
        │   │   └── layer1.view
        │   └── ...
        └── cameraFrame (キャンバス枠表示)
```

### レンダリングパイプライン（統一）
```javascript
// 描画フロー統一
app.ticker.add(() => {
  // 1. サムネイル更新キュー処理
  layerManager.processThumbnailUpdates();
  // 2. キャッシュ無効化フラグがあれば再生成
  layerManager.processRenderUpdates();  
  // 3. アニメーション更新（将来）
  // animationManager.updateTimeline();
});

// ペン描画フロー
function addPathToLayer(layerIndex, path) {
  const layer = layers[layerIndex];
  layer.layerData.paths.push(path);          // 1. 非破壊データに記録
  const graphics = buildGraphicsFromPath(path); // 2. Graphics生成
  layer.view.addChild(graphics);             // 3. 表示に追加
  requestThumbnailUpdate(layerIndex);        // 4. サムネイル更新要求
}
```

---

## 🚀 段階的改修タスク（実装順）

### フェーズ0: 安全対策（即実施・小変更）
- [ ] `confirmLayerTransform()` を非破壊版に差し替え
- [ ] デフォルト確定を「論理確定」に変更
- [ ] 破壊的焼き込みはオプション化

### フェーズ1: データ構造移行（必須）
- [ ] `layer.layerData.paths` 配列を正式化
- [ ] pathオブジェクトに `{id, type, commands, style}` 実装
- [ ] `addPathToLayer()` をpathオブジェクト受け渡しに統一
- [ ] `buildGraphicsFromPath()` 関数実装

### フェーズ2: レンダリングパイプライン分離（描画最適化）
- [ ] `renderLayerViewFromLayerData()` 関数実装
- [ ] キャッシュシステム `createLayerCache()` 実装  
- [ ] レイヤー論理層（layerData）と表示層（view）の分離
- [ ] サムネイル更新最適化（Ticker制御）

### フェーズ3: UI改修（確定操作）
- [ ] 確定ボタンを2種類に分割（論理確定・焼き込み確定）
- [ ] Undo/Redo履歴をlayerDataシリアライズで実装
- [ ] エラー表示の簡素化

### フェーズ4: アニメ準備（将来拡張）
- [ ] レイヤーパーツ化（paths群 + pivot + initialTransform）
- [ ] JSONエクスポート機能
- [ ] GIF書き出し（高解像度キャッシュ利用）

---

## 🔄 AI改修フロー（Claude作業最適化）

### 改修時の基本ルール
1. **main.js のみ修正**でタスク完結させる
2. サテライトファイル（config.js等）は**値参照のみ**、ロジック変更しない
3. 新機能実装時は**既存構造を壊さず追加**する方式
4. **エラーは隠蔽せず、明確なメッセージで表面化**

### 修正対象コード特定方法
```javascript
// 修正対象: main.js内の関数
function confirmLayerTransform() {
  // 【改修箇所】破壊的処理をここで非破壊化
}

function addPathToLayer(layerIndex, graphics) {
  // 【改修箇所】pathオブジェクト対応
}

class LayerManager {
  // 【改修箇所】レンダリングパイプライン分離
  processThumbnailUpdates() {
    // サムネイル最適化
  }
}
```

### テスト・検証方法
```javascript
// デバッグ用（開発時のみ有効化）
const CONFIG = {
  debug: true, // リリース時は false
  // ...
};

const log = (...args) => {
  if (CONFIG.debug) console.log(...args);
};

// テスト項目チェックリスト
// 1. レイヤー移動 → 確定（論理）後にUndoで戻せるか
// 2. 拡縮・回転を複数回行ってもジャギー発生しないか  
// 3. キャッシュ無効化時に描画が正しく再生成されるか
// 4. 大きなDPR（2〜3）でぼやけないか
```

---

## ⚠️ 禁止事項（Claude実装時・厳格）

### 🚫 ファイル構成
- **HTML一本化への回帰禁止** - 必ず index.html + main.js 分割維持
- **main.js以外でのロジック実装禁止** - サテライトファイルは参照用のみ
- **相談なしの構造変更・短縮・冗長化禁止**

### 🚫 技術制約
- PixiJS v7/v8混在対応禁止
- Canvas2D/TypeScript/ESM/bundler導入禁止
- localStorage/sessionStorage使用禁止（Claudeアーティファクト制約）

### 🚫 実装制約
- **フォールバック・フェイルセーフ処理絶対禁止** - 曖昧動作・暗黙修復禁止
- 過度なユーザー向けエラー演出禁止 - 開発中なので不要
- 二重実装・冗長化禁止
- 座標計算の直接実装禁止（toLocal/toGlobal必須）

---

## 📋 実装チェックリスト（Claude用）

### データ構造確認
- [ ] `layer.layerData.paths` 配列が実装済み
- [ ] pathオブジェクトに必要プロパティ全て含有
- [ ] transform情報が適切に分離（論理transform / 表示transform）

### 関数実装確認  
- [ ] `buildGraphicsFromPath()` が pathオブジェクトから Graphics を正しく生成
- [ ] `renderLayerViewFromLayerData()` がキャッシュ・再生成を適切に分岐
- [ ] `confirmLayerTransformLogical()` が非破壊確定を実行
- [ ] `createLayerCache()` が高解像度テクスチャを生成

### パフォーマンス確認
- [ ] サムネイル更新がTicker制御で最適化済み
- [ ] キャッシュが適切に無効化・再生成される
- [ ] 60fps維持でUI応答性確保
- [ ] メモリリーク未発生

### 将来拡張準備確認
- [ ] レイヤーデータがJSON化可能
- [ ] パーツ単位でのtransform適用が可能
- [ ] GIF出力用の高解像度レンダリング対応済み

---

## 🎯 将来進化ステージ（ロードマップ）

### ステージ1: 描画ツール強化（v8対応完了）
- [x] 非破壊ベクター保持とGIF出力実装  
- [x] config.js でエクスポート解像度・FPS調整可能

### ステージ2: GIFアニメツール化（次期）
- [ ] main.js に Timeline/Frame 管理追加
- [ ] i18n.js にアニメーションUI文言追加

### ステージ3: 2窓化連携（描画 + アニメ）
- [ ] network.js 追加し、JSON データやり取り
- [ ] index.html を2種類に分岐（draw.html, animate.html）

### ステージ4: Live2D/Spine的アニメ化（最終）
- [ ] main.js に Mesh/Bone 管理追加
- [ ] assets.js でモデルデータ・テクスチャアトラス参照
- [ ] network.js でモデルデータを複数アプリ間共有

---

## 📚 付録: 重要APIリファレンス

### PixiJS v8.13 確定API
```javascript
// Container transform (PixiJS v8標準)
container.position.set(x, y);
container.rotation = radians;
container.scale.set(scaleX, scaleY);

// RenderTexture (高解像度対応)
PIXI.RenderTexture.create({width, height, resolution});
app.renderer.render(object, {renderTexture});

// 座標変換 (必須API)
container.toLocal(globalPoint);
container.toGlobal(localPoint);

// Graphics (v8.13推奨方式)
graphics.moveTo(x, y);
graphics.lineTo(x, y);
graphics.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
graphics.stroke({width, color, alpha});
graphics.fill({color, alpha});
```

### 禁止API（非推奨・削除予定）
```javascript
// 禁止: 旧Graphics API
graphics.lineStyle(); // v8では stroke()使用
graphics.beginFill(); // v8では fill()使用

// 禁止: 直接座標計算
const localX = globalX - container.x; // toLocal()使用必須

// 禁止: 古いRenderTexture API  
container.generateTexture(); // RenderTexture.create()使用必須
```

---

## 🔚 まとめ
- **index.html + main.js 二分割**を基盤とし、AI改修は main.js のみで完結
- **非破壊性担保**でpathデータ常時保持、キャッシュは再生成可能な派生物
- **PixiJS v8.13 標準API**活用で将来のアニメ化・メッシュ化に備えた拡張性確保
- **Claude実装最適化**で改修時の見通し・作業効率を最大化