# お絵かきツール CUTフォルダ方式 改修計画書

## 📋 現状の問題点

### 問題1: CUT間でレイヤーが共有される
- **現象**: CUT1 Layer1で描いた絵がCUT2 Layer1にも反映される
- **原因**: 
  - AnimationSystemのDeep Copyが不完全
  - paths配列やpoints配列が参照コピーになっている
  - LayerSystemのlayersContainerに配置されているPIXI.Container実体が共有されている可能性

### 問題2: タイムラインのサムネイルが反映されない
- **現象**: CUTの「代表画像」が正しく生成・更新されない
- **原因**:
  - サムネイル更新処理のタイミングが不適切
  - AnimationSystemとLayerSystemの同期が曖昧

## 🎯 改修方針: CUTフォルダ方式

### 基本コンセプト
```
現行: CUTとレイヤーを独立に管理し、インデックス参照で紐づけ
   ↓
改修後: CUT = PIXI.Container (フォルダ)
       CUT.children = [Layer1, Layer2, ...]
```

### 設計原則
1. **各CUTは独立したPIXI.Container**
2. **CUT内部にレイヤー群を保持**
3. **CUT切り替え = Containerの切り替え**
4. **サムネイル = renderer.render(cutContainer)**

## 📐 新しいデータ構造

```javascript
// CUT構造
class Cut {
    constructor(id, name) {
        this.id = id;
        this.name = name;
        this.duration = 0.5;
        this.container = new PIXI.Container();  // ★CUTフォルダ
        this.container.label = `cut_${id}`;
        this.thumbnailCanvas = null;
    }
    
    // レイヤーアクセス
    getLayers() {
        return this.container.children;
    }
    
    addLayer(layer) {
        this.container.addChild(layer);
    }
    
    removeLayer(layer) {
        this.container.removeChild(layer);
    }
}

// AnimationSystem構造
animationData = {
    cuts: [Cut],  // Cut[]
    playback: {
        currentCutIndex: 0,
        isPlaying: false
    }
}
```

## 🔧 改修内容

### Phase 1: CUT Container化

#### 1-1. CUTクラスの作成
**ファイル**: `system/animation-system.js`

```javascript
class Cut {
    constructor(id, name, config) {
        this.id = id;
        this.name = name || `CUT${Date.now()}`;
        this.duration = config?.animation?.defaultCutDuration || 0.5;
        
        // ★CUTフォルダとしてのContainer
        this.container = new PIXI.Container();
        this.container.label = `cut_${id}`;
        this.container.sortableChildren = true;  // zIndex有効化
        
        this.thumbnailCanvas = null;
        this.createdAt = Date.now();
    }
    
    // レイヤー操作API
    getLayers() {
        return this.container.children;
    }
    
    addLayer(layer) {
        this.container.addChild(layer);
        return layer;
    }
    
    removeLayer(layer) {
        if (layer.parent === this.container) {
            this.container.removeChild(layer);
        }
    }
    
    getLayer(index) {
        return this.container.children[index] || null;
    }
    
    getLayerCount() {
        return this.container.children.length;
    }
    
    // シリアライズ（保存用）
    serialize() {
        return {
            id: this.id,
            name: this.name,
            duration: this.duration,
            layers: this.container.children.map(layer => ({
                id: layer.layerData.id,
                name: layer.layerData.name,
                visible: layer.visible,
                opacity: layer.alpha,
                isBackground: layer.layerData.isBackground,
                transform: {
                    x: layer.position.x,
                    y: layer.position.y,
                    rotation: layer.rotation,
                    scaleX: layer.scale.x,
                    scaleY: layer.scale.y
                },
                paths: layer.layerData.paths.map(path => ({
                    id: path.id,
                    points: path.points.map(p => ({ x: p.x, y: p.y })),
                    size: path.size,
                    color: path.color,
                    opacity: path.opacity,
                    tool: path.tool
                }))
            }))
        };
    }
}
```

#### 1-2. AnimationSystem改修
**変更点**:
- `animationData.cuts`を`Cut[]`に変更
- レイヤー配列廃止、Container直接管理に変更

```javascript
createNewBlankCut() {
    const cutId = 'cut_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    const cut = new Cut(cutId, `CUT${this.animationData.cuts.length + 1}`, this.config);
    
    // ★初期レイヤーをCUT Container内に作成
    const bgLayer = this._createBackgroundLayer(cutId);
    const layer1 = this._createBlankLayer(cutId, 'レイヤー1');
    
    cut.addLayer(bgLayer);
    cut.addLayer(layer1);
    
    this.animationData.cuts.push(cut);
    return cut;
}

_createBackgroundLayer(cutId) {
    const layer = new PIXI.Container();
    layer.label = `${cutId}_layer_bg`;
    layer.layerData = {
        id: `${cutId}_layer_bg_${Date.now()}`,
        name: '背景',
        visible: true,
        opacity: 1.0,
        isBackground: true,
        paths: []
    };
    
    const bg = new PIXI.Graphics();
    bg.rect(0, 0, this.config.canvas.width, this.config.canvas.height);
    bg.fill(this.config.background.color);
    layer.addChild(bg);
    layer.layerData.backgroundGraphics = bg;
    
    return layer;
}

_createBlankLayer(cutId, name) {
    const layer = new PIXI.Container();
    layer.label = `${cutId}_layer_${Date.now()}`;
    layer.layerData = {
        id: layer.label,
        name: name,
        visible: true,
        opacity: 1.0,
        isBackground: false,
        paths: []
    };
    
    return layer;
}
```

#### 1-3. CUT切り替え処理
```javascript
switchToActiveCut(cutIndex) {
    const cut = this.animationData.cuts[cutIndex];
    if (!cut) return;
    
    // ★現在のCUT Containerを非表示
    this.animationData.cuts.forEach(c => {
        c.container.visible = false;
    });
    
    // ★選択CUT Containerを表示
    cut.container.visible = true;
    
    // ★LayerSystemにCUTのレイヤー参照を渡す
    this.layerSystem.setCurrentCutContainer(cut.container);
    
    this.animationData.playback.currentCutIndex = cutIndex;
    
    if (this.eventBus) {
        this.eventBus.emit('animation:cut-applied', { cutIndex, cutId: cut.id });
    }
}
```

### Phase 2: LayerSystem改修

#### 2-1. LayerSystem構造変更
**ファイル**: `system/layer-system.js`

```javascript
class LayerSystem {
    constructor() {
        this.currentCutContainer = null;  // ★現在アクティブなCUT Container
        this.activeLayerIndex = -1;
        this.layerTransformPanel = null;
        // ... 他のプロパティ
    }
    
    // ★新API: CUT Containerを設定
    setCurrentCutContainer(cutContainer) {
        this.currentCutContainer = cutContainer;
        this.activeLayerIndex = Math.max(0, cutContainer.children.length - 1);
        this.updateLayerPanelUI();
        this.updateStatusDisplay();
    }
    
    // レイヤー取得（CUT Container経由）
    getLayers() {
        return this.currentCutContainer ? this.currentCutContainer.children : [];
    }
    
    getActiveLayer() {
        const layers = this.getLayers();
        return this.activeLayerIndex >= 0 ? layers[this.activeLayerIndex] : null;
    }
    
    // レイヤー作成（CUT Container内に追加）
    createLayer(name, isBackground = false) {
        if (!this.currentCutContainer) {
            console.error('No active CUT container');
            return null;
        }
        
        const layer = new PIXI.Container();
        layer.label = `layer_${Date.now()}`;
        layer.layerData = {
            id: layer.label,
            name: name || `レイヤー${this.currentCutContainer.children.length + 1}`,
            visible: true,
            opacity: 1.0,
            isBackground: isBackground,
            paths: []
        };
        
        if (isBackground) {
            const bg = new PIXI.Graphics();
            bg.rect(0, 0, this.config.canvas.width, this.config.canvas.height);
            bg.fill(this.config.background.color);
            layer.addChild(bg);
            layer.layerData.backgroundGraphics = bg;
        }
        
        this.currentCutContainer.addChild(layer);
        this.activeLayerIndex = this.currentCutContainer.children.length - 1;
        
        this.updateLayerPanelUI();
        
        if (this.eventBus) {
            this.eventBus.emit('layer:created', { layerId: layer.label, name });
        }
        
        return layer;
    }
}
```

### Phase 3: サムネイル生成改修

#### 3-1. CUT Container直接レンダリング
**ファイル**: `system/animation-system.js`

```javascript
async generateCutThumbnail(cutIndex) {
    const cut = this.animationData.cuts[cutIndex];
    if (!cut || !this.app?.renderer) return;
    
    const canvasWidth = this.config.canvas.width;
    const canvasHeight = this.config.canvas.height;
    
    // ★CUT Containerを直接レンダリング
    const renderTexture = PIXI.RenderTexture.create({
        width: canvasWidth,
        height: canvasHeight,
        resolution: 1
    });
    
    this.app.renderer.render({
        container: cut.container,
        target: renderTexture
    });
    
    const canvas = this.app.renderer.extract.canvas(renderTexture);
    
    // サムネイルサイズにリサイズ
    const thumbWidth = 72;
    const thumbHeight = Math.round(72 / (canvasWidth / canvasHeight));
    
    const thumbCanvas = document.createElement('canvas');
    thumbCanvas.width = thumbWidth;
    thumbCanvas.height = thumbHeight;
    
    const ctx = thumbCanvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(canvas, 0, 0, thumbWidth, thumbHeight);
    
    cut.thumbnailCanvas = thumbCanvas;
    
    renderTexture.destroy();
    
    if (this.eventBus) {
        this.eventBus.emit('animation:thumbnail-generated', { cutIndex });
    }
}
```

### Phase 4: TimelineUI改修

#### 4-1. サムネイル更新処理
**ファイル**: `ui/timeline-ui.js`

```javascript
updateTimelineUI() {
    if (!this.animationSystem) return;
    
    const cuts = this.animationSystem.getAllCuts();
    const currentCutIndex = this.animationSystem.getCurrentCutIndex();
    
    this.timelineContent.innerHTML = '';
    
    cuts.forEach((cut, index) => {
        const cutItem = document.createElement('div');
        cutItem.className = `timeline-cut-item ${index === currentCutIndex ? 'active' : ''}`;
        cutItem.dataset.cutIndex = index;
        
        // ★サムネイル表示
        const thumbnail = document.createElement('div');
        thumbnail.className = 'timeline-cut-thumbnail';
        
        if (cut.thumbnailCanvas) {
            const img = document.createElement('img');
            img.src = cut.thumbnailCanvas.toDataURL();
            thumbnail.appendChild(img);
        } else {
            thumbnail.innerHTML = '<div class="thumbnail-placeholder">Empty</div>';
        }
        
        cutItem.appendChild(thumbnail);
        
        // CUT名・時間表示
        const info = document.createElement('div');
        info.className = 'timeline-cut-info';
        info.innerHTML = `
            <div class="cut-name">${cut.name}</div>
            <div class="cut-duration">${cut.duration}s</div>
        `;
        cutItem.appendChild(info);
        
        this.timelineContent.appendChild(cutItem);
    });
}
```

## 🚀 改修ステップ

### Step 1: CUT Containerクラス実装 (優先度: 最高)
- [ ] Cutクラス作成
- [ ] AnimationSystemにCut統合
- [ ] テスト: CUT作成・切り替え

### Step 2: LayerSystem接続 (優先度: 高)
- [ ] `setCurrentCutContainer()` API実装
- [ ] レイヤー操作をCUT Container経由に変更
- [ ] テスト: レイヤー追加・削除

### Step 3: サムネイル生成 (優先度: 高)
- [ ] CUT Container直接レンダリング実装
- [ ] TimelineUI更新処理改修
- [ ] テスト: サムネイル表示

### Step 4: 既存機能維持確認 (優先度: 中)
- [ ] 描画機能確認
- [ ] Undo/Redo確認
- [ ] GIF出力確認

### Step 5: クリップボード対応 (優先度: 中)
- [ ] CUT Container丸ごとコピー実装
- [ ] ペースト時の新Container生成

## 📊 期待される効果

### メリット
1. **CUT独立性の確実な保証**: Container分離により参照混在が原理的に不可能
2. **実装難易度の低下**: PixiJSの仕組みに沿った自然な実装
3. **サムネイル生成の簡略化**: `renderer.render(cutContainer)` で完結
4. **拡張性の向上**: レイヤーフォルダ機能への流用が容易
5. **デバッグの容易化**: Container階層が可視化可能

### 注意点
1. **メモリ管理**: 全CUT Containerをメモリ保持（大量CUT時の負荷）
2. **既存データ移行**: 現行のanimationData構造からの変換処理が必要
3. **Transform保存**: LayerのTransformをserialize/deserializeで保存

## 🔍 検証項目

### 必須検証
- [ ] CUT1で描画 → CUT2に影響しない
- [ ] CUT切り替え時にレイヤー構造が正しく復元される
- [ ] サムネイルが各CUT毎に正しく表示される
- [ ] レイヤー追加・削除が正常動作
- [ ] Transform(移動・回転・拡縮)が保存される
- [ ] Undo/Redo動作

### 追加検証
- [ ] 複数CUT作成・切り替えストレステスト
- [ ] 大量レイヤー時の動作確認
- [ ] GIF出力の動作確認
- [ ] メモリリーク確認

## 📝 実装上の注意事項

### 1. Container可視性制御
```javascript
// ★全CUT Containerをstageに追加しておき、visible制御で切り替え
stage.addChild(cut1.container);
stage.addChild(cut2.container);

cut1.container.visible = true;   // アクティブ
cut2.container.visible = false;  // 非アクティブ
```

### 2. レイヤーTransform保存
```javascript
// serialize時にTransformを保存
transform: {
    x: layer.position.x,
    y: layer.position.y,
    rotation: layer.rotation,
    scaleX: layer.scale.x,
    scaleY: layer.scale.y,
    pivotX: layer.pivot.x,
    pivotY: layer.pivot.y
}
```

### 3. Path graphics再構築
```javascript
// paths配列からPIXI.Graphicsを再生成
layer.layerData.paths.forEach(pathData => {
    const graphics = new PIXI.Graphics();
    pathData.points.forEach(point => {
        graphics.circle(point.x, point.y, pathData.size / 2);
        graphics.fill({ color: pathData.color, alpha: pathData.opacity });
    });
    layer.addChild(graphics);
});
```

## ✅ 成功基準

1. **CUT独立性**: CUT間でレイヤー・描画内容が完全に独立
2. **サムネイル表示**: 全CUTのサムネイルが正確に表示・更新される
3. **既存機能維持**: 描画・Transform・Undo/Redo・GIF出力が正常動作
4. **パフォーマンス**: CUT切り替えが200ms以内
5. **コード可読性**: AIから見て理解しやすい構造

---

**改修方針**: 段階的実装により既存機能を維持しながら、確実にCUT独立性を確立する。