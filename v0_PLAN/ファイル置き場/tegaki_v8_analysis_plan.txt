# 📋 Tegaki v8 改修計画書 - 座標系統一・履歴管理実装

## 🔍 **現状分析結果**

### **検出された問題点**

#### 1. **座標系の混線問題**
```javascript
// 問題箇所: OffCanvasManager.screenToWorld()
screenToWorld(clientX, clientY) {
    const canvasRect = this.coreEngine.app.canvas.getBoundingClientRect();
    const canvasX = clientX - canvasRect.left;
    const canvasY = clientY - canvasRect.top;
    
    // ❌ 二重変換: container座標とworld座標が混在
    const container = this.coreEngine.drawingContainer;
    const worldX = (canvasX - container.x) / container.scale.x;
    const worldY = (canvasY - container.y) / container.scale.y;
    
    return { x: worldX, y: worldY };
}
```

**問題**: Screen→Canvas→World の3段階変換で誤差蓄積・座標ズレ発生

#### 2. **履歴管理の未実装**
```javascript
// ❌ HistoryManager クラス自体が存在しない
// ❌ undo/redo のキーイベントリスナーなし
// ❌ ストローク確定時の履歴記録なし
```

#### 3. **オフキャンバス描画の中途半端な実装**
```javascript
// 問題箇所: OffCanvasManager.continueOffCanvasStroke()
continueOffCanvasStroke(pointerId, x, y) {
    // ❌ 距離フィルター (1.5px) が厳しすぎて描画が途切れる
    if (distance >= 1.5) {
        strokeData.points.push({ x, y, timestamp: Date.now() });
        // ❌ steps計算で描画が飛び飛びになる
    }
}
```

#### 4. **UI設定の未連動**
```javascript
// ❌ スライダー変更がリアルタイム反映されていない
// ❌ オフキャンバスチェックボックスの状態管理が不完全
```

---

## 🛠️ **改修計画**

### **Phase 1: 座標系統一アーキテクチャ**

#### **新座標フロー設計**
```
[PointerEvent] → [Screen座標] → [World座標] → [Layer座標] → [Render座標]
     │              │              │             │            │
   clientX/Y    Canvas内相対    無限キャンバス    描画データ    PIXI表示
```

#### **統一座標変換マネージャー**
```javascript
class CoordinateManager {
    constructor(coreEngine) {
        this.coreEngine = coreEngine;
        this.viewport = { x: 0, y: 0, scale: 1 }; // カメラ状態
    }
    
    // Screen → World (統一変換)
    screenToWorld(clientX, clientY) {
        const canvasRect = this.coreEngine.app.canvas.getBoundingClientRect();
        const canvasX = clientX - canvasRect.left;
        const canvasY = clientY - canvasRect.top;
        
        // Viewport変換を適用
        return {
            x: (canvasX - this.viewport.x) / this.viewport.scale,
            y: (canvasY - this.viewport.y) / this.viewport.scale
        };
    }
    
    // World → Layer (描画データ用)
    worldToLayer(worldX, worldY) {
        return { x: worldX, y: worldY }; // 基本は同一
    }
    
    // キャンバス境界判定
    isWorldPointInCanvas(worldX, worldY) {
        return (worldX >= 0 && worldX <= this.coreEngine.config.canvasWidth &&
                worldY >= 0 && worldY <= this.coreEngine.config.canvasHeight);
    }
}
```

---

### **Phase 2: 履歴管理システム実装**

#### **HistoryManager クラス**
```javascript
class HistoryManager {
    constructor() {
        this.undoStack = [];
        this.redoStack = [];
        this.maxHistorySize = 50;
    }
    
    // 履歴イベント追加
    pushEvent(eventType, payload, inversePayload) {
        const event = {
            id: `history_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            type: eventType,
            payload: payload,
            inversePayload: inversePayload,
            timestamp: Date.now()
        };
        
        this.undoStack.push(event);
        this.redoStack = []; // redo履歴をクリア
        
        // 履歴サイズ制限
        if (this.undoStack.length > this.maxHistorySize) {
            this.undoStack.shift();
        }
    }
    
    // アンドゥ実行
    undo(coreEngine) {
        if (this.undoStack.length === 0) return false;
        
        const event = this.undoStack.pop();
        this.redoStack.push(event);
        
        // 逆操作を適用
        this.applyInverseEvent(event, coreEngine);
        return true;
    }
    
    // リドゥ実行
    redo(coreEngine) {
        if (this.redoStack.length === 0) return false;
        
        const event = this.redoStack.pop();
        this.undoStack.push(event);
        
        // 正操作を適用
        this.applyEvent(event, coreEngine);
        return true;
    }
}
```

#### **キーボードショートカット**
```javascript
// UIController.init() に追加
setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
            switch(e.key.toLowerCase()) {
                case 'z':
                    if (e.shiftKey) {
                        // Ctrl+Shift+Z = Redo
                        this.historyManager.redo(this.coreEngine);
                    } else {
                        // Ctrl+Z = Undo
                        this.historyManager.undo(this.coreEngine);
                    }
                    e.preventDefault();
                    break;
                case 'y':
                    // Ctrl+Y = Redo
                    this.historyManager.redo(this.coreEngine);
                    e.preventDefault();
                    break;
            }
        }
    });
}
```

---

### **Phase 3: オフキャンバス描画の再設計**

#### **統一描画フロー**
```javascript
class UnifiedStrokeManager {
    constructor(coreEngine, coordinateManager, historyManager) {
        this.coreEngine = coreEngine;
        this.coordinateManager = coordinateManager;
        this.historyManager = historyManager;
        this.activeStrokes = new Map(); // pointerId → strokeData
        this.offCanvasEnabled = true;
    }
    
    startStroke(pointerId, clientX, clientY, brushSettings) {
        // 1. 座標変換（統一フロー）
        const worldPos = this.coordinateManager.screenToWorld(clientX, clientY);
        const layerPos = this.coordinateManager.worldToLayer(worldPos.x, worldPos.y);
        
        // 2. ストローク開始（キャンバス内外問わず）
        const strokeData = {
            id: `stroke_${pointerId}_${Date.now()}`,
            pointerId: pointerId,
            points: [{ x: layerPos.x, y: layerPos.y, timestamp: Date.now() }],
            brushSettings: { ...brushSettings }, // 現在設定のスナップショット
            isInsideCanvas: this.coordinateManager.isWorldPointInCanvas(worldPos.x, worldPos.y),
            tempGraphics: null,
            commitedPath: null
        };
        
        this.activeStrokes.set(pointerId, strokeData);
        
        // 3. 初期描画（プレビューまたは確定）
        this.updateStrokeVisual(strokeData);
    }
    
    continueStroke(pointerId, clientX, clientY) {
        const strokeData = this.activeStrokes.get(pointerId);
        if (!strokeData) return;
        
        const worldPos = this.coordinateManager.screenToWorld(clientX, clientY);
        const layerPos = this.coordinateManager.worldToLayer(worldPos.x, worldPos.y);
        
        // 距離フィルターを緩和 (0.8px → より滑らか)
        const lastPoint = strokeData.points[strokeData.points.length - 1];
        const distance = Math.sqrt((layerPos.x - lastPoint.x) ** 2 + (layerPos.y - lastPoint.y) ** 2);
        
        if (distance >= 0.8) {
            strokeData.points.push({ x: layerPos.x, y: layerPos.y, timestamp: Date.now() });
            
            // キャンバス境界チェック
            const nowInside = this.coordinateManager.isWorldPointInCanvas(worldPos.x, worldPos.y);
            if (!strokeData.isInsideCanvas && nowInside) {
                // オフキャンバス → キャンバス内 移行
                this.commitStroke(strokeData);
            }
            
            this.updateStrokeVisual(strokeData);
        }
    }
    
    endStroke(pointerId) {
        const strokeData = this.activeStrokes.get(pointerId);
        if (!strokeData) return;
        
        if (!strokeData.commitedPath) {
            // 未確定ストロークの処理
            if (strokeData.isInsideCanvas || !this.offCanvasEnabled) {
                this.commitStroke(strokeData);
            } else {
                // オフキャンバスのまま終了 → orphanとして保持
                this.cleanupTempVisual(strokeData);
            }
        }
        
        this.activeStrokes.delete(pointerId);
    }
}
```

---

### **Phase 4: リアルタイムUI連動**

#### **設定即時反映システム**
```javascript
class SettingsManager {
    constructor() {
        this.currentSettings = {
            brushSize: 16.0,
            opacity: 0.85,
            color: 0x800000,
            offCanvasEnabled: true
        };
        this.listeners = new Set();
    }
    
    // 設定変更通知
    updateSetting(key, value) {
        if (this.currentSettings[key] !== value) {
            this.currentSettings[key] = value;
            this.notifyListeners(key, value);
        }
    }
    
    // リスナー登録
    addListener(callback) {
        this.listeners.add(callback);
    }
    
    // 通知実行
    notifyListeners(key, value) {
        this.listeners.forEach(callback => callback(key, value));
    }
}
```

---

## 🚀 **実装ロードマップ**

### **M1: 緊急修正 (1-2時間)**
- [ ] 座標変換の統一 (`CoordinateManager` 実装)
- [ ] オフキャンバス描画の距離フィルター緩和
- [ ] 基本的な Undo/Redo 実装

### **M2: 安定化 (2-3時間)**
- [ ] `UnifiedStrokeManager` による描画フロー統一
- [ ] `HistoryManager` の完全実装
- [ ] キーボードショートカット (Ctrl+Z/Y)

### **M3: 品質向上 (1-2時間)**
- [ ] `SettingsManager` による UI 即時反映
- [ ] オフキャンバス チェックボックス完全連動
- [ ] パフォーマンス最適化

---

## 🧪 **テスト計画**

### **動作確認項目**
1. **オフキャンバス描画**
   - [ ] キャンバス外で開始 → 滑らかに描画継続
   - [ ] キャンバス内進入 → 自動確定
   - [ ] チェックボックス ON/OFF → 即座に反映

2. **座標精度**
   - [ ] ズーム/パン状態でも正確な座標
   - [ ] 画面サイズ変更に対応
   - [ ] マルチタッチ対応

3. **履歴管理**
   - [ ] Ctrl+Z でアンドゥ
   - [ ] Ctrl+Y / Ctrl+Shift+Z でリドゥ
   - [ ] 履歴スタック制限 (50件)

4. **UI連動**
   - [ ] スライダー変更 → 即座に次のストロークに反映
   - [ ] ポップアップ開閉 → 設定保持

---

## 💡 **技術的考慮事項**

### **メモリ管理**
- オルファンストロークの自動クリーンアップ (時間ベース)
- 履歴サイズ制限による メモリリーク防止
- PIXI.Graphics の適切な destroy() 呼び出し

### **パフォーマンス**
- 座標変換の計算コスト最小化
- requestAnimationFrame による描画更新制御
- キャッシュ戦略 (静的ストロークの bitmap 化)

### **拡張性**
- レイヤー管理への対応準備
- アニメーション機能への座標系統一
- プラグインシステムへの拡張可能性

---

この改修により、**「最初の数ピクセルで止まる」「設定が効かない」「履歴管理なし」** の主要問題が根本解決され、設計文書通りの **クリスタ風キャンバス外描画** が実現されます。