=== 概要 ===
- v8rev3_camera を基盤に、Pixi Container方式を導入
- カメラ移動はショートカットキーのみ
- 描画・UIイベントを camera 操作から分離
- レイヤーや画面外描画を後で追加可能な拡張性を保持

=== 段階 1：Pixi Container方式導入 ===
1. Container階層の整理
   - stage
     ├─ cameraContainer（マスク付き、表示窓）
     │    └─ worldContainer（描画対象レイヤーをまとめる）
     └─ uiContainer（UI表示用、マスク無し）
2. worldContainer の position, scale, rotation でカメラ制御
3. カメラ枠サイズ変更対応
   - デフォルト 400x400
   - mask 再生成 & app.renderer.resize 呼び出し
4. カメラ操作は **ショートカットのみ**
   - Space + ドラッグ → カメラパン
   - Space + 矢印キー → 微調整移動
   - Home → カメラ位置リセット

=== 段階 2：描画イベント分離 ===
1. カメラ操作 pointer イベント
   - cameraContainer にのみバインド
   - Space 押下時に有効化
2. ペン描画 pointer イベント
   - worldContainer または uiContainer にバインド
   - Space 非押下時のみ有効
3. 座標変換
   - screen → worldContainer 座標変換を描画時に必ず適用
   - cameraContainer.position を考慮

=== 段階 3：レイヤー実装前の安定化 ===
1. カメラ移動 + 描画が両立して動作することを確認
2. UI / ツールポップアップが cameraContainer の影響を受けないことを確認
3. コンソールエラーが発生しないことを確認

=== 段階 4：レイヤー・拡張機能追加（将来段階） ===
1. worldContainer 内にレイヤー Container を追加
2. 画面外描画や拡縮・回転・反転を追加
3. UI との干渉を最小化したまま拡張可能

=== 注意事項 ===
- UIボタンは不要、ショートカット運用のみ
- pointerイベントの競合を必ず避ける
- 将来的に Pixi Container 方式に置き換える前提でコード設計

※下記はお手本コード

/**
 * PixiJS v8 - Camera movement + drawing event separation
 * 基盤は v8rev3_camera
 */

// -------------------------
// アプリ初期化
// -------------------------
const app = new PIXI.Application({ width: 400, height: 400, backgroundColor: 0xffffff });
document.body.appendChild(app.view);

// -------------------------
// Container構造
// -------------------------
const cameraContainer = new PIXI.Container();
const worldContainer = new PIXI.Container();
cameraContainer.addChild(worldContainer);
app.stage.addChild(cameraContainer);

// UI用Container（カメラ移動の影響を受けない）
const uiContainer = new PIXI.Container();
app.stage.addChild(uiContainer);

// -------------------------
// Cameraオブジェクト
// -------------------------
const camera = { x: 0, y: 0, scale: 1, rotation: 0 };

// -------------------------
// Camera操作（Space + ドラッグ / 矢印 / Home）
// -------------------------
let isPanning = false;
let lastX = 0, lastY = 0;

cameraContainer.interactive = true;

cameraContainer.on('pointerdown', (e) => {
  if (e.data.originalEvent.getModifierState("Space")) {
    isPanning = true;
    const pos = e.data.global;
    lastX = pos.x;
    lastY = pos.y;
  }
});

cameraContainer.on('pointermove', (e) => {
  if (!isPanning) return;
  const pos = e.data.global;
  const dx = pos.x - lastX;
  const dy = pos.y - lastY;
  worldContainer.x += dx;
  worldContainer.y += dy;
  lastX = pos.x;
  lastY = pos.y;
  app.render();
});

cameraContainer.on('pointerup', () => { isPanning = false; });
cameraContainer.on('pointerupoutside', () => { isPanning = false; });

document.addEventListener("keydown", (e) => {
  const step = 20;

  if (e.getModifierState("Space")) {
    switch (e.code) {
      case "ArrowLeft": worldContainer.x += step; break;
      case "ArrowRight": worldContainer.x -= step; break;
      case "ArrowUp": worldContainer.y += step; break;
      case "ArrowDown": worldContainer.y -= step; break;
    }
    app.render();
  }

  if (e.code === "Home") {
    worldContainer.x = 0;
    worldContainer.y = 0;
    app.render();
  }
});

// -------------------------
// screen → world 座標変換（ペン描画用）
// -------------------------
function screenToWorld(screenX, screenY) {
  return {
    x: screenX - worldContainer.x,
    y: screenY - worldContainer.y
  };
}

// -------------------------
// 描画イベント（worldContainer / uiContainer にバインド）
// -------------------------
let isDrawing = false;
let lastPoint = null;

worldContainer.interactive = true;

worldContainer.on('pointerdown', (e) => {
  if (!e.data.originalEvent.getModifierState("Space")) {
    isDrawing = true;
    const pos = screenToWorld(e.data.global.x, e.data.global.y);
    lastPoint = pos;
  }
});

worldContainer.on('pointermove', (e) => {
  if (!isDrawing) return;
  const pos = screenToWorld(e.data.global.x, e.data.global.y);
  if (lastPoint) {
    const line = new PIXI.Graphics();
    line.lineStyle(2, 0x000000, 1);
    line.moveTo(lastPoint.x, lastPoint.y);
    line.lineTo(pos.x, pos.y);
    worldContainer.addChild(line);
  }
  lastPoint = pos;
});

worldContainer.on('pointerup', () => { isDrawing = false; lastPoint = null; });
worldContainer.on('pointerupoutside', () => { isDrawing = false; lastPoint = null; });

✅ 特徴

Pixi Container方式

cameraContainer → worldContainer → 描画

uiContainer → UI専用（カメラ操作の影響なし）

カメラ操作（ショートカット）

Space + ドラッグ：パン移動

Space + 矢印キー：微調整

Homeキー：リセット

描画イベント分離

Space非押下時のみ描画可能

worldContainer に pointerイベントをバインド

screen → world 座標変換を適用

将来的な拡張

拡縮・回転・反転やレイヤー追加も容易

UIやツールポップアップを cameraContainer に影響されず配置可能

