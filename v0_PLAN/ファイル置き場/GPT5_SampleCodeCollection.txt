※下記は叩き台となるお手本コードです。

<!-- main.html -->
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Star-Architecture Drawing Tool - Sample</title>
<!-- PixiJS v8 CDN -->
<script src="https://cdn.jsdelivr.net/npm/pixi.js@8.4.0/dist/pixi.min.js"></script>

<!-- Services / Tools (衛星) -->
<script src="error-service.js"></script>
<script src="history-service.js"></script>
<script src="drawing-engine.js"></script>
<script src="layer-service.js"></script>
<script src="position-service.js"></script>
<script src="tool-manager.js"></script>
<script src="tools/brush-tool.js"></script>
<script src="tools/eraser-tool.js"></script>
<script src="tools/transform-tool.js"></script>
<script src="ui-service.js"></script>

<script>
/*
  main.html - MainController (主星)
  - window.MyApp.debug を切り替えでログ量を制御
  - mainApi を各衛星に渡すことで通信を統一
*/
window.MyApp = window.MyApp || {};
(function(global){
  const DEBUG = false;
  global.MyApp.debug = DEBUG;

  function log(level, tag, payload) {
    if (!global.MyApp.debug && level === 'debug') return;
    const out = `[${tag}] ${payload instanceof Object ? JSON.stringify(payload) : payload}`;
    if(level === 'error') console.error(out);
    else if(level === 'warn') console.warn(out);
    else console.log(out);
  }

  class MainController {
    constructor() {
      this.name = 'MainController';
      this._initGlobals();
      this._initServices();
      this._initOrder();
    }

    _initGlobals(){
      // mainApi: 衛星が使う最低API
      this.mainApi = {
        notify: (event) => this.notify(event),
        requestConfirm: (req) => this._handleRequestConfirm(req),
        getEngineBridge: () => this.engineBridge,
        getLayerList: () => this.layerService.getLayerList(),
        debugMode: global.MyApp.debug
      };
      global.MyApp.mainApi = this.mainApi;
    }

    _initServices(){
      // 必ず読み込み順に依存するため script の順序に依る
      // 各衛星は window.MyApp.Xxx クラスとして提供される前提
      this.errorService = new (global.MyApp.ErrorService || function(){})();
      this.historyService = new (global.MyApp.HistoryService || function(){})();
      this.engine = new (global.MyApp.DrawingEngine || function(){})();
      this.layerService = new (global.MyApp.LayerService || function(){})();
      this.positionService = new (global.MyApp.PositionService || function(){})();
      this.toolManager = new (global.MyApp.ToolManager || function(){})();
      this.uiService = new (global.MyApp.UIService || function(){})();
    }

    _initOrder(){
      try{
        // register順序: Engine -> Layers -> Position -> Tools -> UI -> History/Error
        if(this.engine && this.engine.register) this.engine.register(this.mainApi);
        this.engineBridge = this.engine && this.engine.getEngineBridge ? this.engine.getEngineBridge() : null;

        if(this.layerService && this.layerService.register) this.layerService.register(this.mainApi);
        if(this.positionService && this.positionService.register) this.positionService.register(this.mainApi);
        if(this.toolManager && this.toolManager.register) this.toolManager.register(this.mainApi);
        // register tools if toolManager has registerTool API
        if(global.MyApp.BrushTool && this.toolManager.registerTool) {
          this.toolManager.registerTool(new global.MyApp.BrushTool());
        }
        if(global.MyApp.EraserTool && this.toolManager.registerTool) {
          this.toolManager.registerTool(new global.MyApp.EraserTool());
        }
        if(global.MyApp.TransformTool && this.toolManager.registerTool) {
          this.toolManager.registerTool(new global.MyApp.TransformTool());
        }

        if(this.uiService && this.uiService.register) this.uiService.register(this.mainApi);
        if(this.historyService && this.historyService.register) this.historyService.register(this.mainApi);
        if(this.errorService && this.errorService.register) this.errorService.register(this.mainApi);

        log('debug', 'Main', 'Initialization completed');
      } catch (err) {
        log('error', 'Main', 'Initialization failed: ' + (err && err.stack ? err.stack : err));
        // 致命エラーは UI に通知
        if(this.errorService && this.errorService.notifyFatal) {
          this.errorService.notifyFatal({ code: 'INIT_FAIL', msg: String(err) });
        }
      }
    }

    // 衛星からの全イベントのエントリポイント
    notify(event){
      // basic validation
      if(!event || !event.type) {
        this._reportRecoverableError('INVALID_EVENT', 'Event missing type', event);
        return;
      }
      // routing - minimal switch; expand as needed
      switch(event.type) {
        case 'layers.reorderRequest':
          // validate payload
          this._handleLayerReorderRequest(event.payload, event.meta);
          break;
        case 'tools.strokeCommit':
          // payload: { layerId, strokeData, meta }
          this._handleStrokeCommit(event.payload);
          break;
        case 'tools.toolStart':
          // delegate to toolManager
          this.toolManager.handleToolStart && this.toolManager.handleToolStart(event.payload);
          break;
        case 'error.recoverable':
        case 'error.fatal':
          if(this.errorService && this.errorService.receiveError) {
            this.errorService.receiveError(event);
          }
          break;
        default:
          // Forwards to toolManager if possible
          if(this.toolManager && this.toolManager.handleEvent) {
            this.toolManager.handleEvent(event);
          } else {
            log('warn', 'Main', 'Unhandled event: ' + event.type);
          }
      }
    }

    _handleLayerReorderRequest(payload){
      // validation examples
      if(!payload || typeof payload.fromIndex !== 'number' || typeof payload.toIndex !== 'number') {
        this._reportRecoverableError('INVALID_REORDER', 'Invalid reorder payload', payload);
        return;
      }
      // Confirm via layerService and then record history
      const ok = this.layerService.prepareReorder ? this.layerService.prepareReorder(payload) : true;
      if(!ok) {
        this._reportRecoverableError('REORDER_BLOCKED', 'Reorder blocked by validation', payload);
        return;
      }
      // apply
      this.layerService.reorderLayer(payload.fromIndex, payload.toIndex);
      // take snapshot and record
      const snap = this.engineBridge && this.engineBridge.takeSnapshot ? this.engineBridge.takeSnapshot() : null;
      this.historyService.record({ type: 'layerReorder', payload, snapshot: snap, timestamp: Date.now() });
    }

    _handleStrokeCommit(payload){
      if(!payload || typeof payload.layerId === 'undefined') {
        this._reportRecoverableError('INVALID_STROKE', 'Missing layerId', payload);
        return;
      }
      // ask engine to commit
      if(this.engineBridge && this.engineBridge.commitStroke) {
        this.engineBridge.commitStroke(payload.layerId, payload.strokeData);
        const snap = this.engineBridge.takeSnapshot && this.engineBridge.takeSnapshot(payload.layerId);
        this.historyService.record({ type: 'stroke', payload, snapshot: snap, timestamp: Date.now() });
      } else {
        this._reportRecoverableError('ENGINE_MISSING', 'EngineBridge missing', {});
      }
    }

    _handleRequestConfirm(req){
      // Placeholder: future RPC confirmations
      log('debug', 'Main', ['requestConfirm', req]);
    }

    _reportRecoverableError(code, msg, context){
      log('warn', 'Main', {code, msg, context});
      if(this.errorService && this.errorService.receiveError) {
        this.errorService.receiveError({ type: 'error.recoverable', payload:{code,msg,context} });
      }
    }
  }

  // start on DOM ready
  window.addEventListener('DOMContentLoaded', ()=> {
    global.MyApp.main = new MainController();
  });

})(window.MyApp = window.MyApp || {});
</script>
</head>
<body>
<div id="app-root" style="display:flex; gap:12px; padding:8px;">
  <div id="canvas-container" style="flex:1; border:1px solid #ddd; min-width:480px; min-height:360px;"></div>
  <div id="sidebar" style="width:260px;">
    <div id="tools-container" style="margin-bottom:12px;"></div>
    <div id="layers-container"></div>
    <div id="status" style="margin-top:12px; font-size:12px; color:#666;"></div>
  </div>
</div>
</body>
</html>

// error-service.js
// 小さく単純な ErrorService。mainApi に register されて use される想定。
window.MyApp = window.MyApp || {};
(function(global){
  class ErrorService {
    register(mainApi) { this.mainApi = mainApi; }
    receiveError(event) {
      // event: { type: 'error.recoverable'|'error.fatal', payload:{code,msg,context}}
      const payload = event.payload || {};
      const msg = `${payload.code||'ERR'}: ${payload.msg||'unknown'}`;
      // UI表示（UIService があれば使う）
      if(global.MyApp.UIServiceInstance && global.MyApp.UIServiceInstance.showError) {
        global.MyApp.UIServiceInstance.showError(msg);
      } else {
        console.error('[ErrorService]', msg, payload.context || '');
      }
      // For fatal, could stop some services (not auto-recover)
    }
    notifyFatal(info) {
      this.receiveError({ type:'error.fatal', payload: info });
    }
  }
  global.MyApp.ErrorService = ErrorService;
})(window);

// history-service.js
// シンプルな HistoryService。main に register される。
window.MyApp = window.MyApp || {};
(function(global){
  class HistoryService {
    register(mainApi) { this.mainApi = mainApi; this.stack = []; this.index = -1; }
    record(action) {
      // action: {type, payload, snapshot?, timestamp}
      this.stack = this.stack.slice(0, this.index + 1);
      this.stack.push(action);
      this.index++;
      if(global.MyApp.debug) console.log('[History] record', action.type);
    }
    undo() {
      if(this.index < 0) return;
      const action = this.stack[this.index--];
      // TODO: apply rollback using snapshots or invert actions
      if(global.MyApp.debug) console.log('[History] undo', action.type);
    }
    redo() {
      if(this.index >= this.stack.length - 1) return;
      const action = this.stack[++this.index];
      if(global.MyApp.debug) console.log('[History] redo', action.type);
    }
  }
  global.MyApp.HistoryService = HistoryService;
})(window);

// drawing-engine.js
// EngineBridge を提供。Pixi.Application を生成し、描画用最小APIを expose する。
window.MyApp = window.MyApp || {};
(function(global){
  class DrawingEngine {
    constructor(){
      this._initialized = false;
      this._layers = {}; // layerId -> PIXI.Container
    }

    register(mainApi){
      this.mainApi = mainApi;
      this._createPixiApp();
    }

    _createPixiApp(){
      const container = document.getElementById('canvas-container');
      if(!container) {
        console.error('[DrawingEngine] canvas-container not found');
        return;
      }
      const app = new PIXI.Application({ backgroundColor: 0xFFFFFF, resizeTo: container });
      container.appendChild(app.view);
      this.app = app;
      this.renderer = app.renderer;
      this.stage = app.stage;
      this._initialized = true;

      // expose engineBridge
      this.engineBridge = {
        app: app,
        drawTemporaryStroke: (layerId, strokePoints, style) => this._drawTempStroke(layerId, strokePoints, style),
        commitStroke: (layerId, strokeData) => this._commitStroke(layerId, strokeData),
        clearLayer: (layerId) => this._clearLayer(layerId),
        takeSnapshot: (layerId) => this._takeSnapshot(layerId)
      };
      // register globally
      global.MyApp.DrawingEngineInstance = this;
    }

    getEngineBridge(){ return this.engineBridge; }

    ensureLayerContainer(layerId){
      if(!this._layers[layerId]) {
        const c = new PIXI.Container();
        c.name = `layer-${layerId}`;
        this.stage.addChild(c);
        this._layers[layerId] = { container: c, graphicsList: [] };
      }
      return this._layers[layerId].container;
    }

    _drawTempStroke(layerId, strokePoints, style = {}) {
      const container = this.ensureLayerContainer(layerId);
      // temporary Graphics for preview
      const g = new PIXI.Graphics();
      const size = style.size || 4;
      // set blend according to tool (brush = NORMAL, eraser = ERASE)
      if(style.tool === 'eraser' && PIXI.BLEND_MODES.ERASE) {
        g.blendMode = PIXI.BLEND_MODES.ERASE;
      } else {
        g.blendMode = PIXI.BLEND_MODES.NORMAL;
      }
      g.lineStyle(size, style.color ?? 0x000000, style.alpha ?? 1);
      if(strokePoints && strokePoints.length>0) {
        g.moveTo(strokePoints[0].x, strokePoints[0].y);
        for(let i=1;i<strokePoints.length;i++){
          g.lineTo(strokePoints[i].x, strokePoints[i].y);
        }
      }
      container.addChild(g);
      // store reference so commit can convert to permanent
      this._layers[layerId].graphicsList.push(g);
      return g;
    }

    _commitStroke(layerId, strokeData) {
      // strokeData: { points: [{x,y}], style: {...} }
      const container = this.ensureLayerContainer(layerId);
      const g = new PIXI.Graphics();
      const style = strokeData.style || {};
      if(style.tool === 'eraser' && PIXI.BLEND_MODES.ERASE) {
        g.blendMode = PIXI.BLEND_MODES.ERASE;
      } else {
        g.blendMode = PIXI.BLEND_MODES.NORMAL;
      }
      g.lineStyle(style.size || 4, style.color ?? 0x000000, style.alpha ?? 1);
      const pts = strokeData.points || [];
      if(pts.length>0){
        g.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
      }
      container.addChild(g);
      // for undo, store minimal meta
      if(this._layers[layerId]) this._layers[layerId].graphicsList.push(g);
    }

    _clearLayer(layerId){
      const container = this._layers[layerId] && this._layers[layerId].container;
      if(container) {
        container.removeChildren();
        this._layers[layerId].graphicsList = [];
      }
    }

    _takeSnapshot(layerId){
      // Minimal snapshot: return number of children and optionally serialized data
      const container = this._layers[layerId] && this._layers[layerId].container;
      return { layerId, childCount: container ? container.children.length : 0, timestamp: Date.now() };
    }
  }

  global.MyApp.DrawingEngine = DrawingEngine;
})(window);

// layer-service.js
// LayerService は Layer のメタと順序だけ管理。実描画は EngineBridge に委譲。
// API: register(mainApi), createLayer(name), reorderLayer(fromIndex,toIndex), getLayerList()
window.MyApp = window.MyApp || {};
(function(global){
  class LayerService {
    constructor(){
      this.layers = []; // [{id, name, visible, locked}]
      this._nextId = 0;
    }
    register(mainApi){ this.mainApi = mainApi; }
    createLayer(name='Layer'){ const id = this._nextId++; const layer = { id, name, visible:true, locked:false }; this.layers.push(layer); return layer; }
    getLayerList(){ return this.layers.map(l=>Object.assign({}, l)); } // immutable copy
    reorderLayer(fromIndex, toIndex){
      if(fromIndex<0||toIndex<0||fromIndex>=this.layers.length||toIndex>this.layers.length-1) {
        return false;
      }
      const item = this.layers.splice(fromIndex,1)[0];
      this.layers.splice(toIndex,0,item);
      if(global.MyApp.debug) console.log('[LayerService] reorder', fromIndex, '->', toIndex);
      return true;
    }
    prepareReorder(payload){
      // validate reorder (example): cannot move locked layers
      const layer = this.layers[payload.fromIndex];
      if(!layer) return false;
      if(layer.locked) return false;
      return true;
    }
  }
  global.MyApp.LayerService = LayerService;
})(window);

// position-service.js
// 位置系（camera, coordinate conversion）を管理する軽量サービス
window.MyApp = window.MyApp || {};
(function(global){
  class PositionService {
    constructor(){ this.camera = { x:0, y:0, zoom:1 }; }
    register(mainApi){ this.mainApi = mainApi; }
    worldToScreen(x,y){ return { x: (x - this.camera.x) * this.camera.zoom, y: (y - this.camera.y) * this.camera.zoom }; }
    screenToWorld(x,y){ return { x: x / this.camera.zoom + this.camera.x, y: y / this.camera.zoom + this.camera.y }; }
    setCamera(x,y,zoom=1){ this.camera.x = x; this.camera.y = y; this.camera.zoom = zoom; }
  }
  global.MyApp.PositionService = PositionService;
})(window);

// tool-manager.js
// ToolManager は登録済みツールの切替とイベント中継を担う。
// register(mainApi), registerTool(toolInstance), setActiveTool(id), handleEvent(...)
window.MyApp = window.MyApp || {};
(function(global){
  class ToolManager {
    constructor(){ this.tools = {}; this.active = null; }
    register(mainApi){ this.mainApi = mainApi; }
    registerTool(toolInstance){
      if(!toolInstance || !toolInstance.id) return;
      this.tools[toolInstance.id] = toolInstance;
      if(toolInstance.register) toolInstance.register(this.mainApi);
      if(!this.active) this.active = toolInstance.id;
      if(global.MyApp.debug) console.log('[ToolManager] registered', toolInstance.id);
    }
    setActiveTool(id){ if(this.tools[id]) this.active = id; }
    getActiveTool(){ return this.tools[this.active]; }
    handleEvent(event){
      // route events to active tool if relevant (tools.handleEvent implementation optional)
      const tool = this.getActiveTool();
      if(tool && tool.handleEvent) tool.handleEvent(event);
    }
    handleToolStart(payload){
      // example: payload { toolId, x,y, settings }
      if(payload && payload.toolId) this.setActiveTool(payload.toolId);
      const tool = this.getActiveTool();
      if(tool && tool.start) tool.start(payload);
    }
  }
  global.MyApp.ToolManager = ToolManager;
})(window);

// tools/brush-tool.js
// BrushTool: collects points, requests temporary draw and commit via main.notify
window.MyApp = window.MyApp || {};
(function(global){
  class BrushTool {
    constructor(){ this.id = 'brush'; this.points = []; this.style = { tool:'brush', size:4, color:0x000000, alpha:1 }; }
    register(mainApi){ this.mainApi = mainApi; this.engine = mainApi.getEngineBridge(); }
    start(payload){
      this.points = [];
      if(payload && payload.x !== undefined) this.points.push({x:payload.x, y:payload.y});
      // notify main to draw temporary (for preview)
      this._drawTemp();
    }
    move(point){
      this.points.push(point);
      this._drawTemp();
    }
    end(){
      // commit stroke via main.notify
      this.mainApi.notify({ type:'tools.strokeCommit', payload:{ layerId: 0, strokeData: { points: this.points.slice(), style: this.style } } });
      this.points = [];
    }
    _drawTemp(){
      if(!this.engine) this.engine = this.mainApi.getEngineBridge();
      if(this.engine && this.engine.drawTemporaryStroke) {
        this.engine.drawTemporaryStroke(0, this.points, this.style);
      }
    }
  }
  global.MyApp.BrushTool = BrushTool;
})(window);

// tools/eraser-tool.js
// EraserTool uses PIXI.BLEND_MODES.ERASE when available to truly remove (transparent) pixels
window.MyApp = window.MyApp || {};
(function(global){
  class EraserTool {
    constructor(){ this.id = 'eraser'; this.points = []; this.style = { tool:'eraser', size:16 }; }
    register(mainApi){ this.mainApi = mainApi; this.engine = mainApi.getEngineBridge(); }
    start(payload){
      this.points = [];
      if(payload && payload.x !== undefined) this.points.push({x:payload.x, y:payload.y});
      this._drawTemp();
    }
    move(point){
      this.points.push(point);
      this._drawTemp();
    }
    end(){
      this.mainApi.notify({ type:'tools.strokeCommit', payload:{ layerId: 0, strokeData: { points: this.points.slice(), style: this.style } } });
      this.points = [];
    }
    _drawTemp(){
      if(!this.engine) this.engine = this.mainApi.getEngineBridge();
      if(this.engine && this.engine.drawTemporaryStroke) {
        this.engine.drawTemporaryStroke(0, this.points, this.style);
      }
    }
  }
  global.MyApp.EraserTool = EraserTool;
})(window);

// tools/transform-tool.js
// TransformTool: placeholder - computes transforms and asks main to apply via layerService
window.MyApp = window.MyApp || {};
(function(global){
  class TransformTool {
    constructor(){ this.id = 'transform'; }
    register(mainApi){ this.mainApi = mainApi; }
    start(payload){ /* start transform */ }
    move(payload){ /* compute transform */ }
    end(payload){
      // example: ask main to reorder or apply transform
      // this.mainApi.notify({ type:'layers.reorderRequest', payload:{fromIndex:0,toIndex:1} });
    }
  }
  global.MyApp.TransformTool = TransformTool;
})(window);

// ui-service.js
// UIService: minimal toolbar + layer list + simple error display
window.MyApp = window.MyApp || {};
(function(global){
  class UIService {
    constructor(){}
    register(mainApi){
      this.mainApi = mainApi;
      global.MyApp.UIServiceInstance = this;
      this._containerTools = document.getElementById('tools-container');
      this._containerLayers = document.getElementById('layers-container');
      this._status = document.getElementById('status');
      this._renderToolbar();
      this._renderLayers();
    }
    _renderToolbar(){
      if(!this._containerTools) return;
      // Brush
      const brushBtn = document.createElement('button');
      brushBtn.textContent = 'Brush';
      brushBtn.onclick = () => this.mainApi.notify({ type:'tools.toolStart', payload:{ toolId:'brush', x:20, y:20 }});
      this._containerTools.appendChild(brushBtn);
      // Eraser
      const eraserBtn = document.createElement('button');
      eraserBtn.textContent = 'Eraser';
      eraserBtn.onclick = () => this.mainApi.notify({ type:'tools.toolStart', payload:{ toolId:'eraser', x:20, y:20 }});
      this._containerTools.appendChild(eraserBtn);
    }
    _renderLayers(){
      if(!this._containerLayers) return;
      // simple layer listing
      const list = document.createElement('div');
      list.textContent = 'Layers:';
      const ll = document.createElement('ul');
      const layers = this.mainApi.getLayerList ? this.mainApi.getLayerList() : [];
      layers.forEach(l => {
        const li = document.createElement('li');
        li.textContent = `${l.id}: ${l.name}`;
        ll.appendChild(li);
      });
      list.appendChild(ll);
      this._containerLayers.appendChild(list);
    }
    showError(msg){
      if(this._status) this._status.textContent = `Error: ${msg}`;
    }
  }
  global.MyApp.UIService = UIService;
})(window);

説明（短く）

主星（MainController）は mainApi を作り、各衛星の register(mainApi) を想定しています。

DrawingEngine は engineBridge を作り、drawTemporaryStroke と commitStroke を提供します。

BrushTool と EraserTool は一時描画を drawTemporaryStroke で行い、確定は mainApi.notify({type:'tools.strokeCommit', payload}) によって行います（Main が履歴記録と commit を仲介）。

Eraser は style.tool === 'eraser' を判定して PIXI.BLEND_MODES.ERASE をセットするので、透明消しが可能（環境により WebGL2 のサポートが必要）。

ログは window.MyApp.debug フラグで制御。デフォルトは false（出力を抑制）。