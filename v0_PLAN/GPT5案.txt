=== 改修計画書（Plain text）===
目的：
  - Undo/Redo（以下、History）の不安定動作を根本的に修正し、
    「操作ごとに1つの履歴が確実に残る」「Undo/Redoの応答が即時で一貫する」状態を実現する。

現象（まとめ）：
  1. 描画・レイヤー操作・CUT作成・アクティブレイヤー移動後にHistoryのカウントが増えない操作がある。
  2. Undo を押した最初の一回目で「history pointer の値だけ変わるが画面復元が起きない」ことがある（2回目で復元される）。
  3. 複数サブシステム（レイヤー、カメラ、タイムライン）の同時変更時に履歴が分割される、あるいは逆に合成されずに状態不整合を起こす。

推定原因（優先度つき）：
  A. 履歴実装のポインタ管理ミス（off-by-one）：push / undo / redo で pointer の意味が曖昧。
     - currentIndex を「最後に適用済みのインデックス」とするのか「次にapplyすべきインデックス(=size)」にするか混在。
  B. 操作のコミットタイミングが不統一（描画は strokeend でコミットすべきところ、mousemove毎に分割／未コミットのまま次処理）。
  C. 複合操作のトランザクション化不足：複数の低レベル変更が個別履歴として入るため、Undo時に中間状態が存在する。
  D. 一部のサブシステムが直接データを変更しており、History API を経由していない（＝履歴に記録されない変更）。
  E. 非同期処理・遅延描画（requestAnimationFrameや画像読み込み等）と履歴同期が取れていない。
  F. EventBus の発火順やハンドラで副作用があり、undo時の再適用順序が狂う。

設計方針（基本ルール）：
  1. History の単一真理（single source of truth）を確立する。すべての状態変更は「State Manager」経由またはHistory APIを通して行う。
  2. History はコマンドパターン（do/undo を持つオブジェクト）で実装。状態スナップショット方式は巨大化を避けるため最小差分／コマンド推奨。
  3. currentIndex の定義を厳格にする：
     - history.entries : array of Entry
     - history.index : number, 「最後に適用済みのエントリのインデックス」。初期値 -1（何も適用されていない）。
     - push(entry) は history.index をインクリメントし、その index に entry を設置・entry.do() を呼ぶ。
     - undo() は entry.undo() を呼び、history.index--。
     - redo() は history.index+1 の entry.do() を呼び、history.index++。
     - push() の前に index < entries.length-1 の場合は future を切り捨てる（truncate）。
  4. 操作は「原子的（atomic）」に記録する。複数のサブ操作を含む場合は CompositeEntry を使って一つの履歴として登録する。
  5. UIイベント（mousemoveなど）やレンダリングループは履歴を直接触らない。履歴はユーザー操作の完了時（stroke end, drop end, layer move end, cut create end）にのみコミットする。
  6. 非同期処理は明示的に同期化（例えば、画像の読み込みは load完了後にstateを更新してから履歴にpushする）。
  7. state-manager.js を「履歴を通す唯一の書き換えポイント」にする。直接 mutable なグローバルオブジェクトを避ける。
  8. Event-bus の発火順は「pre-change -> change -> post-change」に統一し、undo/redo 実行時は post-change をブロック（再帰発火防止）する。

必須API（History）— 提案インターフェース：
  - History.init(options)
  - History.push(entry: HistoryEntry)  // entry.do() を呼ぶ。pushは必ず現在の状態上に「適用済み」として格納する
  - History.undo() -> boolean (成功/失敗)
  - History.redo() -> boolean
  - History.clear()
  - History.canUndo(), History.canRedo()
  - History.getIndex(), History.getLength()
  - History.createComposite(name, entries[]) -> CompositeEntry
  - HistoryEntry interface:
      - { name: string, do: ()=>void, undo: ()=>void, meta?:object }
  - CompositeEntry implements HistoryEntry: do() は各 child.do() を順次実行、undo() は逆順で実行

ファイル別改修指示（優先順）：

1) system/history.js  —— 最重要
  - 目的：History の単一実装。現在のコードを全面見直し。
  - 実装方針：
    - 上記 API を実装。history.index を -1 から開始する。
    - push(entry) の内部で try/catch。失敗時はロールバック（entry.do() が例外を投げたら、entry.undo() を呼ぶか、state を前の状態に戻す）。
    - push は entry.do() を実行してから entries.splice(index+1) を切り詰め、entries[++index] = entry。
    - undo() は entries[index].undo(); index--。undo() 実行中は再入禁止フラグを設定（isApplying）。
    - redo() は entries[index+1].do(); index++。同様に再入禁止。
    - isApplying フラグを使用して、undo/redo 実行中の event-bus 発火を必要最小限に抑える（詳細は下記）。
  - ログ/検査用のデバッグフラグ（最小限）：
    - debugHistoryTrace()（開発時のみ有効にする）
  - テストケース（実装後必須）：
    - 単一push → undo → redo の循環
    - Composite push（複数操作まとめ）→ undo が中間を経ないこと
    - push 中に例外発生時の不変条件

2) system/state-manager.js
  - 目的：アプリの状態更新はここを通す。History と結合し state の一貫性を保つ。
  - 実装方針：
    - 直接オブジェクトを変更する関数は廃止（または内部限定）。外部からは「commit(action)」経由のみで変更する。
    - commit(action) は action を受け取り、History.push(actionHistoryEntry) を行う。action は以下を含む：
        { name, do: ()=>{ mutate state }, undo: ()=>{ revert state }, meta }
    - GUI からの変更はまず stateManager.prepareChange() → 低レベル mutate を実行（ただし実行は commit 内で行う）。
    - レンダリングは stateManager の state変更通知（イベント）に基づいて行う。stateManager は event-bus を通じて "state:changed" を発火する。ただし undo/redo 実行中は "state:changed" を発火させるが、UI側は isApplying フラグに応じた扱いをする（時間差の2重描画問題回避）。
  - 重要：mutation は不可逆的にするのではなく、undo 用の逆操作（関数）を用意する。例：layer insert -> undo は layer remove、layer move -> undo は move back。

3) system/event-bus.js
  - 目的：イベント発火の順序と再入制御を明示化。
  - 改修：
    - 発火テンプレート： emitPre(event, payload) -> doChange() -> emitPost(event, payload)
    - undo/redo 実行時は emitPost を止めるのではなく payload に {internal:true} を入れる。UI/サブシステムは internal フラグを見て副作用を抑える。
    - イベントハンドラは idempotent（何度呼ばれても状態が破壊されない）に設計する。
  - 追加：イベントハンドラ登録時に priority を付け、依存関係の順序管理が可能にする（例：state更新 -> layer更新 -> renderer 更新）。

4) system/drawing-clipboard.js（および描画系）
  - 目的：筆圧/ストローク系は「開始（pointerdown）→描画→終了（pointerup）」で一つの履歴エントリとして記録。
  - 改修：
    - strokeStart(): create transient stroke object（まだ push しない）
    - strokeUpdate(): transient に点を追加（ここでは履歴に影響させない）
    - strokeEnd(): commit stroke を finalize して History.push( strokeEntry )
      - strokeEntry.do() -> add stroke to layer data and renderer
      - strokeEntry.undo() -> remove stroke from layer data and renderer
  - 注意：mousemoveごとにpushしない。undoの分割や大量履歴を防ぐ。

5) system/layer-system.js
  - 目的：レイヤーの追加・削除・順序移動・アクティブ変更等を全て History を通す。
  - 改修：
    - API 例：
        addLayer(params) -> stateManager.commit({name:'add-layer', do:..., undo:...})
        removeLayer(id) -> commit(...)
        moveLayer(id, toIndex) -> commit(...)
        setActiveLayer(id) -> commit(...)  // ただし setActiveLayer は短い操作でも一つの履歴として扱う
    - moveLayer はトランザクション化：dragstart で beginComposite(); dragend で endComposite() して１エントリにまとめる。
    - レイヤー変更により renderer のz-order を直接変更するのではなく、state の変化により renderer が再構築される流れにする（単純で可検査）。

6) system/camera-system.js
  - 目的：カメラ移動やズームも履歴化（必要であれば）。
  - 改修：
    - カメラドラッグなどで多数のイベントが起きる場合は、インタラクションの完了（pointerup）で履歴にコミットする。
    - または、短時間の操作は throttle して合成エントリにする。

7) system/history.js と UI/timeline関連（ui/timeline-ui.js, ui/timeline-thumbnail-utils.js）
  - 目的：タイムライン上のCUT追加・フレーム挿入・サムネ縮小等を History 経由で一貫処理する。
  - 改修：
    - CUTの作成／削除は一つのCompositeEntryにする（関連する layer データ、timeline データ、thumbnail の更新を含む）。
    - サムネイル作成は非同期処理だが、thumbnail 画像生成自体は履歴化対象外。thumbnail の参照切替を履歴に含める。

8) core-engine.js / core-runtime.js
  - 目的：レンダリングループとイベントハンドリングの整合性を取る。
  - 改修：
    - core-engine は stateManager の state 変化を読みレンダリングするだけに限定する。状態変更は決して core-engine が直接行わない。
    - Undo/redo の実行は core-engine がトリガーしない（button/shortcut ハンドラが History を呼ぶ）。core-engine は isApplying を考慮して差分レンダリングする。

具体的な修正サンプル（擬似コード、history の核）：
  - （history.js の重要ロジック）
  const History = {
    entries: [],
    index: -1,
    isApplying: false,

    push(entry) {
      if (this.isApplying) throw new Error('Cannot push during apply');
      // truncate future
      if (this.index < this.entries.length - 1) {
        this.entries.length = this.index + 1;
      }
      // apply
      try {
        this.isApplying = true;
        entry.do();
        this.entries.push(entry);
        this.index++;
      } catch (e) {
        // attempt rollback if possible
        try { entry.undo?.(); } catch (e2) {}
        throw e;
      } finally {
        this.isApplying = false;
      }
    },

    undo() {
      if (this.isApplying) return false;
      if (this.index < 0) return false;
      const entry = this.entries[this.index];
      try {
        this.isApplying = true;
        entry.undo();
        this.index--;
        return true;
      } finally {
        this.isApplying = false;
      }
    },

    redo() {
      if (this.isApplying) return false;
      if (this.index >= this.entries.length - 1) return false;
      const entry = this.entries[this.index + 1];
      try {
        this.isApplying = true;
        entry.do();
        this.index++;
        return true;
      } finally {
        this.isApplying = false;
      }
    },
    ...
  };

エッジケースと設計上の注意点：
  - index と entries の不整合：push を行う前に truncate と apply の順序を誤ると pointer がずれる。上記の順序（apply → push array → index++）で明確化。
  - 一時オブジェクトの参照（transient stroke）は undo 時に確実に削除できるように ID を付与しておく。
  - 非同期処理（画像読み込みなど）は、load が完了して state に反映 → push の順で履歴化する。load開始時点で push してしまわない。
  - undo/redo 実行時は UI が再度イベントを発火して二重履歴を作らないように isApplying チェックをUI側にも入れる。
  - ショートカット（Ctrl+Z 等）は History.undo() をラップするのみ。UI側は状態変更を引き起こさない。

移行プラン（ステップ実行・リスク最小化）：
  1. history.js を上記 API で全面書き換え（テスト済みの小さなエントリで動作確認）。
  2. state-manager の commit 周りを実装し、既存の変更箇所を段階的に commit 経由に切り替える。
  3. 描画（drawing-clipboard）を strokeEnd で commit するよう改修。旧APIを残す場合は deprecation 警告を出す。
  4. layer-system の add/remove/move を commit 経由に変更。drag系は beginComposite()/endComposite() で一つのエントリにまとめる。
  5. camera/timeline/animation 系を順次 commit 経由にする。各ステップでユニットテスト（手動操作でのundo/redo）を実施。
  6. 全体統合テスト：複合操作（例：レイヤー入れ替え→描画→CUT作成）を行い履歴が期待通りに復元されるか確認する。
  7. 不具合が出た箇所は最小単位でロールバックできるように git ブランチ戦略を使う。

テストチェックリスト（必須）：
  - [ ] 描画1 stroke -> undo -> redo が即時に動作する
  - [ ] レイヤー移動（ドラッグ） -> undo が一発で元に戻る（中間状態が残らない）
  - [ ] CUT作成（複数レイヤーを含む一連操作） -> undo が一発で消える
  - [ ] アクティブレイヤー変更 -> undo により以前のアクティブに戻る
  - [ ] Undo を最初に押した時点で pointer と画面状態が乖離しない（つまり1回で戻る）
  - [ ] 非同期画像読み込み後の state push が確実に履歴に乗る
  - [ ] Ctrl+Z/Ctrl+Y のショートカットで History の状態とUIの整合性が保たれる

追加提案（品質向上）：
  - minimal debug mode を提供して history.entries を簡易的に可視化する、（開発時のみ）。
  - 各 HistoryEntry に human-readable な name を付けて undo/redo の履歴表示を可能にする（UIは簡素でよい）。
  - 履歴の最大長 maxHistory を設定してメモリ枯渇対策（古い履歴を切る）。
  - 変更点ごとにユニットテスト（node を使う必要なし。簡易テストフレームワークを作ってブラウザで走らせる）。

最後に（まとめ）：
  - 根本的原因は「履歴ポインタ定義の曖昧さ」「コミットタイミングのばらつき」「サブシステムがHistoryを経由していない」の混合と推定。まず system/history.js を単一の正しい実装に置き換え、state-manager を経由した変更フローに統一することで一気に改善が見込めます。
  - 進め方は段階的にファイルを置き換え（history -> state-manager -> drawing -> layer -> others）し、各段階で手動テストを必須にすること。Composite（合成）履歴を導入すればドラッグやCUT作成での中間不整合は解消します。

添付：軽微なサンプルユニット（擬似）
  - push undo redo の単体テストを system/history.js に組み込み、ブラウザのコンソールで実行して検証するスクリプトを用意すること（本番では無効化）。

=== end of document ===
