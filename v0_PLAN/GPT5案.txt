=== 修正版改修計画書（ベーシック） - tegaki (PixiJS v8.13) ===
提出形式: プレーンテキスト（.txt）
作成日: 2025-10-05
目的:
  - getGlobalBounds による "Maximum call stack size exceeded" を原因究明・修正
  - レイヤーパネル（layer panel）非表示問題の解決
  - キー割当（CTRL+Z / CTRL+Y / ←→キー）誤動作の修正
  - アンドゥで「ペン描画」「新規レイヤー」「新規CUT」の状態が完全にロールバックされる履歴設計

前提ルール（開発ルールの遵守）
  - Chrome 最新、file:// 実行
  - PixiJS v8.13（CDN読み込み）
  - ES2023（モジュール無し）
  - Canvas2D 使用禁止（ただしサムネは例外）
  - フォールバック・曖昧な自動修復は行わない
  - ログは最小限。デバッグは一時的に例外時に限定。

----------------------------------------------------------------------
1) 現象の整理（ユーザー報告より）
  - カメラフレーム枠、タイムライン、サイドアイコンは出る。
  - 描画用キャンバス（描画レイヤ）やレイヤーパネルは表示されない。
  - CTRL+Z が「CUT移動（左）」、CTRL+Y が「CUT移動（右）」に誤マップ。
  - ← と → キーが効かず、↑↓ は「レイヤ移動モード」挙動（だがパネルが無いので目視不可）。
  - エラー: getGlobalBounds.ts:135 Uncaught RangeError: Maximum call stack size exceeded

----------------------------------------------------------------------
2) 高優先度（必須）修正方針 - 原因推定と対処（要即適用）
  A. スタックオーバーフロー（getGlobalBounds）
    - 概要原因（推定）:
      1) PixiJS の getGlobalBounds / getBounds 系の呼び出しで、親→子→親 .. の循環参照が発生している。
         - 具体的には、Container/DisplayObject の parent が自分自身を含む（自己参照）か、
           いずれかの container の ancestor がその container に再び参照を作る操作がある。
      2) もしくは getGlobalBounds を上書きしているカスタム実装が再帰を止められていない。
    - すぐやること（デバッグ手順）:
      1) Chrome DevTools の Sources で "Pause on exceptions" を有効にして例外発生時に停止する。
         - 発生時の call stack を展開し、最初にループしている関数（/getGlobalBounds/ を呼んでいる箇所）を特定。
      2) call stack に出る DisplayObject の id/label/名前をコンソールに出して、親子関係を追跡する。
         - 例: `let cur = obj; while(cur){ console.log(cur.name || cur.label || cur); cur = cur.parent; if (seen[cur]) break; }`
      3) 検出できない場合は getGlobalBounds 呼び出し直前に一時防御コードを入れて guard を行う（下にサンプル）。
    - 短期パッチ（コード差分案: CHECK を入れる）
      - 目的: Container へ child を add する前に循環参照を検出・阻止する。
      - サンプルユーティリティ（追加ファイルまたは既存 addChild 呼び出し前に利用）:
        ```js
        // utils/scene-guards.js (簡潔実装)
        function isAncestor(potentialAncestor, child) {
          let cur = potentialAncestor;
          while (cur) {
            if (cur === child) return true;
            cur = cur.parent;
          }
          return false;
        }
        // addChild 前に呼ぶ
        function safeAddChild(parent, child) {
          if (parent === child) {
            console.error('safeAddChild: attempt to add container to itself', parent);
            return false;
          }
          if (isAncestor(child, parent)) {
            console.error('safeAddChild: would create cyclical parent-child', parent, child);
            return false;
          }
          parent.addChild(child);
          return true;
        }
        ```
      - 適用箇所候補:
        - CoreRuntime.switchCut, any code that `addChild(...)` to cut.container or to worldContainer
        - layer-system のレイヤ生成 / コンテナ結合箇所
      - 期待効果: 循環参照が根本原因なら即消える。スタックオーバーフロー回避。

  B. レイヤーパネル未表示 / internal.layerManager が未初期化の疑い
    - 概要原因（推定）:
      - CoreRuntime.init に与える `options` に layerManager や drawingEngine, cameraSystem の参照が渡されていない、または initの呼び出し順で UI パネル作成より初期化が遅れている。
    - すぐやること:
      1) CoreRuntime.init 呼び出し箇所（index.html もしくは core-engine）を検索し、渡している `options` を確認する。
         - 必要なキー: `app`, `worldContainer`, `canvasContainer`, `cameraSystem`, `layerManager`, `drawingEngine`
      2) CoreRuntime.init 成功時に `CoreRuntime.internal.initialized === true` を確認するログ（短期）を配置し、未初期化なら UI 作成を待つロジックにする。
    - 短期パッチ（起動順序の保護）:
      - index.html / 起動スクリプトにて、すべてのサブシステム生成後に `CoreRuntime.init({ app, worldContainer, canvasContainer, cameraSystem, layerManager, drawingEngine })` を呼ぶこと。
      - もしレイヤーパネル生成がイベントベースなら、`TegakiEventBus.emit('system:ready')` を発行し、UI側はそれを受けて初期描画する（遅延初期化）。
    - 期待効果: layerManager が無ければ UI を描画しない振る舞いを統一し、未表示を解消。

  C. キー割当の誤動作（CTRL+Z / CTRL+Y）
    - 概要原因（推定）:
      - キーイベント処理が `event.keyCode` / `event.key` / `event.code` を混在して使用している、かつ条件分岐順序が誤っている（例: `if (event.ctrlKey && event.key === 'ArrowLeft')` 等の間違い）。
      - また `preventDefault()` の扱いが漏れているか、keydown ハンドラが複数登録されている（重複）。
    - すぐやること:
      1) キーイベントハンドラを一本化（centralKeyHandler）し、使用は `event.code` と `event.ctrlKey` の組み合わせで判断する。`keyCode` は避ける。
      2) Undo/Redo は必ず `Ctrl+Z` / `Ctrl+Y` で履歴 API（history.undo()/redo()）を呼ぶように実装。方向キーの単体処理は `event.code === 'ArrowLeft'` などで分岐。
    - 具体パッチ（単純な例）:
      ```js
      // input/key-handler.js
      window.addEventListener('keydown', (ev) => {
        const code = ev.code;
        if (ev.ctrlKey && code === 'KeyZ') { ev.preventDefault(); History.undo(); return; }
        if (ev.ctrlKey && code === 'KeyY') { ev.preventDefault(); History.redo(); return; }
        if (!ev.ctrlKey && code === 'ArrowLeft') { /* timeline: left */ return; }
        if (!ev.ctrlKey && code === 'ArrowRight') { /* timeline: right */ return; }
        if (!ev.ctrlKey && code === 'ArrowUp') { /* layer move up */ return; }
        if (!ev.ctrlKey && code === 'ArrowDown') { /* layer move down */ return; }
      });
      ```
    - 期待効果: CTRL+Z が切替動作にマップされる誤りを解消。

----------------------------------------------------------------------
3) 中期修正（推奨） - 履歴（History）とコマンド体系の強化
  - 目的: 1) ペン描画だけでなく「新規レイヤー」「新規CUT」操作も Undo/Redo で元に戻ること。
  - 方針: Command パターンを厳格に適用（既に command-base.js / layer-commands.js がある様子なので拡張）。
    - すべきこと:
      1) 各操作（ペン描画 stroke、レイヤ作成、CUT作成、レイヤ削除、レイヤ移動）を Command オブジェクト化する（execute/undo/redo）。
      2) History はコマンドスタックを持ち、undo はスタック順にコマンド.undo() を呼ぶ。
      3) レイヤ追加時は Command の undo で `container.removeChild(layer)` と内部データ（layer list）更新を行う。CUT 追加時は stage から remove してProject.cuts から削除する。
      4) Command 実行時に UI 更新イベント（TegakiEventBus.emit('layer:changed') 等）を必ず発火させる。
  - 注意点:
    - レイヤ削除 undo 時にレイヤの DisplayObject を保管しておく（参照保持）こと。DOM の再作成は最小限に。
    - 履歴容量は既定 (e.g. 50) を設け、安全に破棄する。
  - テスト:
    - 作成 → undo（ペン/レイヤ/CUT）→ redo を手動確認。

----------------------------------------------------------------------
4) 低優先（推奨） - コード品質改善 / 安全網
  - a) addChild/removeChild 等の操作で例外を吐かないようガード関数を導入（上記 safeAddChild）。
  - b) getGlobalBounds 等を呼ぶ箇所に「深さ制限ガード」を入れる。例: bounds 計算を自前でラップして 50 回以上の再帰があったら abort する（デバッグ用にのみ）。
  - c) UI の生成は必ず system:ready イベントで行い、依存が整っていないなら描画しない。
  - d) 重要な内部参照（layerManager, cameraSystem 等）は必ず `CoreRuntime.internal` にコピーしておく。null 判定があること。

----------------------------------------------------------------------
5) 具体的差分例（パッチ候補） — 直接貼れるミニパッチ（検討用）
  1) safeAddChild の追加（utils フォルダ or layer-system の先頭へ）
     (上記 short-patch を参照)
  2) キーハンドラの一本化（input/key-handler.js）
     (上記 key handler を参照)
  3) CoreRuntime.init 呼び出し確認（index.html 側）
     - index.html の起動スクリプト末尾で:
       ```js
       // すべての subsystems を作った後で呼ぶ
       CoreRuntime.init({
         app: pixiApp,
         worldContainer: worldContainer,
         canvasContainer: canvasContainer,
         cameraSystem: cameraSystem,
         layerManager: layerManager,
         drawingEngine: drawingEngine
       });
       window.TegakiEventBus?.emit('system:ready');
       ```
  4) History / Command: レイヤ作成コマンド（雛形）
     ```js
     class CreateLayerCommand {
       constructor(layerManager, layerData) {
         this.layerManager = layerManager;
         this.layerData = layerData;
         this.layerRef = null;
       }
       execute() {
         this.layerRef = this.layerManager._createLayerInternal(this.layerData); // internal API
         this.layerManager.updateLayerPanelUI();
       }
       undo() {
         if (!this.layerRef) return;
         this.layerManager._removeLayerInternal(this.layerRef);
         this.layerManager.updateLayerPanelUI();
       }
     }
     ```
     - 注: `_createLayerInternal` / `_removeLayerInternal` は副作用を最小にする内部メソッドとして実装する（外部からは触らない）。

----------------------------------------------------------------------
6) テスト & 検証手順（エンジニア向け）
  - ステップ1: DevTools を開き "Pause on exceptions" を有効にしてアプリを起動。例外発生時に callstack を確認する。
  - ステップ2: 例外 stack 上のオブジェクトをコンソールで inspect。parent chain を辿って循環があるか確認。
  - ステップ3: safeAddChild を導入し、例外が出ていた操作（CUT 切替 / レイヤ生成 等）を再実行。例外が消えることを確認。
  - ステップ4: キー処理を一本化して Ctrl+Z / Ctrl+Y / Arrow keys の動作を確認。
  - ステップ5: History のコマンド化を追加し、作成・削除・描画操作の undo/redo を検証（ペン描画、新規レイヤー、新規CUT）。

----------------------------------------------------------------------
7) 影響範囲・リスク
  - safeAddChild を導入すると、既存で「循環を作っていた（意図しない）箇所」が明示的に止まる → 必要に応じて呼び出し元を修正する必要あり。
  - 履歴の Command 化は API 変更を伴う（既存コードのリファクタリングが必要）。
  - 一時的な防御ガード（深さ制限）はデバッグ用に留め、本番では root cause を潰すこと。

----------------------------------------------------------------------
8) 追加推奨（運用 / 長期）
  - 例外発生時の最小ロギング（例: どの DisplayObject が例外を誘発したか）を記録。だがログは冗長にしない。
  - unit tests: layer create/delete, cut create/switch, undo/redo の統合テストを用意（headless でも動く簡易テストを検討）。
  - ドキュメント: CoreRuntime.init の contract（必須 options リスト）を README に明記。

----------------------------------------------------------------------
9) 優先度別作業順（短期-中期）
  - すぐ：DevTools でのスタックトレース取得と safeAddChild の導入（最小パッチ）
  - 次：キーイベントの一本化（Ctrl+Z/Ctrl+Y 修正）
  - 次：CoreRuntime.init 引数・呼び出し順の確認と system:ready イベント整備
  - 次：History の Command 化（レイヤ・CUT を含む）
  - 最後：テスト自動化 / ドキュメント整備

----------------------------------------------------------------------
10) 参考（調査メモ）
  - getGlobalBounds による stack overflow は通常「親子の循環参照」か「カスタム getGlobalBounds の再帰」で起きる。
  - 対処は「循環参照を作らないチェック」を最初に導入するのが最も確実で軽量。

----------------------------------------------------------------------
付録: デバッグ用ワンライナー（例外発生時の親チェーントレース）
  (console で実行)
  ```js
  function printParentChain(obj){
    const seen = new Set();
    let cur = obj;
    while(cur && !seen.has(cur)){
      console.log(cur.name || cur.label || cur);
      seen.add(cur);
      cur = cur.parent;
    }
    if (cur) console.warn('cycle detected at', cur);
  }
