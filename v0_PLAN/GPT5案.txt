重要：調査で参照した現行実装（history の改訂版）が既に「重複保存の排除」「redo の実装」「イベント発火周りの調整」を含むことを確認しました（該当箇所をそのまま使う/更に安定化する方向で進めます）。参照：system/history.js。
GitHub

1) 調査サマリ（現状把握）

症状 A：Ctrl+Y（リドゥ）が動作しない／未実装。

症状 B：レイヤー／CUT を追加した後に Undo しても「増やした分が減らない」、History が大幅に増える、挙動不審になる。

確認したこと：リポジトリの system/history.js 中に「二重 saveStateFull 発生を抑止する修正」や redo() の実装、イベントリスナー整理が含まれる版が存在するのを確認。History は window.History として公開されており history:undo-request / history:redo-request イベントを購読している。
GitHub

2) 根本原因の仮説（まとめ）

二重保存（double-save）

CUT 作成・レイヤー作成のフローの中で 同じ操作をトリガーするイベントが複数箇所で発火 しており、それぞれが History に snapshot を保存している → 履歴が想定より増える／重複する。

history 側で animation:cut-created 等のリスナーが saveStateFull() を呼んでいたり、生成側（layer/animation system）でも saveStateFull() を触っていたため二重記録になっているケースがある（history.js 内の注釈にも該当箇所の修正痕跡あり）。
GitHub

コマンドパターンの未整備 or スナップショット戦略の不一致

追加系（create layer / create cut / paste）を単に「状態スナップショット」で記録している部分と、明確な Command(do,undo) オブジェクトで扱う場所が混在している。結果、Undo 時に「復元ロジック(or restore)」が意図通り働かないパスがある。

Undo/Redo 実行中の副作用抑止が不十分

Undo/Redo 実行中にイベントが発火して history に再度 push されるとエラーや無限ループ同様の挙動になる。history.js では isExecutingUndoRedo フラグを使い抑止する実装があるが、イベントを発火する側（layer/animation/cut 作成コード）で適切に考慮されていない箇所が残っている。

キーボードハンドラの紐付け不足

Ctrl+Z の Undo 呼び出しは実装済みでも、Ctrl+Y が UI 側で登録されていない（あるいは eventBus を経由して history:redo-request を emit していない）ため Redo が動かない。

3) 改修方針（設計方針）

基本方針：既存ファイルの「追加修正（patch）」で済むように最小侵襲で対応。history.js の良い実装（Command パターン・二重記録対策・フラグ抑止）を活かし、イベント発行側（layer-system / animation-system / ui）を整合させる。

命名規約：イベント名は verb:object[-detail] を維持（例：layer:created / animation:cut-created）。ただし同一操作で複数イベント発火させない。

操作単位：可能な限り「操作単位で Command を作成」する（例：CreateLayerCommand、DeleteLayerCommand、CreateCutCommand）。ただし重コストの操作は snapshot（saveStateFull）で扱う。

Undo/Redo中はイベント抑止：window.History._manager.isExecutingUndoRedo を読んで発火を抑止するか eventBus 経由で抑止フラグを設ける。history.js 側ですでにフラグはあるので、発火元のコードを少修正してチェックする。
GitHub

4) 具体的改修項目（ファイル別・差分案／コードスニペット付き）

重要：以下は「既存のコードを壊さない最小パッチ」の提案です。system/history.js の現在の実装（Command / isExecutingUndoRedo / saveStateFull の整理）が前提になっています。
GitHub

4.1 system/history.js —（確認・微調整）

目的：既にかなりの修正が入っている版を基に、外部から確実に使える API（History.saveState() / History.saveStateFull() / History.redo()）が正しく機能することを保証する。

やること：

History.setLayerSystem(layerSystem) 呼び出しが layer-system 初期化直後に行われているか確認。もし初期化順の問題があれば layer:system-initialized イベントの発火を確実にする（下記で対応）。
GitHub

saveState() / saveStateFull() は 非同期に複数回呼ばれても重複登録しない ロジック（現在の実装は splice/position 管理によりある程度対処済み）を検証。もし race が起きる場面が残るなら内部に short debounce（例：同一 tick 内の同一 type の save は無視）を追加する。

※既にある改善点（history.js 内）：

animation:cut-created の二重 save 排除コメントがあり、layer:created のリスナーは setTimeout(()=>saveState(),50) で少し遅延させている実装を確認。
GitHub

直接ファイル差分は小さく、まずは「発火元側」を直すことで多くの問題が解決します。

4.2 system/layer-system.js —（修正案）

目的：レイヤー作成／削除の際に 不要なイベント重複発火 を止め、History 側に正しいタイミングで一回だけ snapshot/command を登録させる。

修正ポイント（擬似パッチ）：

// レイヤー作成処理の例（抜粋）
function createLayer(options = {}) {
  // 1) internal create (no history)
  const layer = _internalCreateLayer(options); // 既存関数

  // 2) emit only one event, and let History decide snapshot
  //    but DO NOT call History.saveStateFull() directly from here.
  if (!window.History?._manager?.isExecutingUndoRedo) {
    window.TegakiEventBus.emit('layer:created', { layerId: layer.layerData.id });
  }

  return layer;
}


注意：

ここで window.History.saveState() を直接呼ばない（history 側で購読して1回だけ保存する戦略に揃える）。

createLayer() の中で他の内部処理が layer:created を再発火していないか（例えば UI 更新関数が再度 emit していないか）をレビューし、重複箇所は一つにまとめる。

4.3 system/animation-system.js（CUT 関連） —（修正案）

目的：CUT 作成・貼り付け時の二重 save を排除。createNewBlankCut() 等は イベント発火はするが、history に直接 save を要求しない。history が受け取って1回だけ snapshot を登録するようにする。

修正ポイント（擬似パッチ）：

function createNewBlankCut() {
  // existing creation logic...
  const cut = _internalCreateCut();

  // emit single 'animation:cut-created' AFTER creation complete
  if (!window.History?._manager?.isExecutingUndoRedo) {
    window.TegakiEventBus.emit('animation:cut-created', { cutId: cut.id });
  }

  return cut;
}


補足：history.js では animation:cut-deleted に対し saveStateFull() を呼ぶリスナーが残っているので、create 側で saveStateFull() を呼ばないようにする（或いは cut-created → history.saveStateFull(), cut-deleted → history.saveStateFull() のように一元化する）。

4.4 ui/core-runtime.js または ui/timeline-ui.js —（Ctrl+Y: redo のキーマッピング）

目的：ユーザー操作で Ctrl+Y（または Ctrl+Shift+Z）を押したときに History.redo() を呼ぶ実装を追加。

コードスニペット（推奨）：

// core-runtime または UI 初期化時に一度だけ登録
window.addEventListener('keydown', (ev) => {
  const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
  const metaKey = isMac ? ev.metaKey : ev.ctrlKey;

  if (metaKey && ev.key.toLowerCase() === 'z' && ev.shiftKey) {
    // Ctrl+Shift+Z -> redo (some users expect this)
    ev.preventDefault();
    if (window.History && typeof window.History.redo === 'function') {
      window.History.redo();
    }
  } else if (metaKey && !ev.shiftKey && ev.key.toLowerCase() === 'y') {
    // Ctrl+Y -> redo
    ev.preventDefault();
    if (window.History && typeof window.History.redo === 'function') {
      window.History.redo();
    }
  } else if (metaKey && !ev.shiftKey && ev.key.toLowerCase() === 'z') {
    // Ctrl+Z -> undo (既にある場合は重複確認)
    ev.preventDefault();
    if (window.History && typeof window.History.undo === 'function') {
      window.History.undo();
    }
  }
});


注：既に同様の keydown が他で登録されている場合は重複を避けるためフラグで一回だけ登録する（例： window._tegaki_keybind_installed = true）。

4.5 Command 化推奨（中〜長期、ただし優先度は中）

目的：create/delete/paste のような操作単位で Command インスタンスを作成し History.execute(command) に投げる。これにより Undo/Redo の粒度とロジックが明確になり、スナップショットに頼りすぎない安定した挙動が得られる。

備考：history.js は Command クラスを提供しているため、既存の Command を利用して下のようにするだけで良い（例）：

// CreateLayerCommand の例（簡略）
const cmd = new History.Command(
  () => { /* do: 実際に layer を create して UI 更新 */ },
  () => { /* undo: その layer を削除して UI 更新 */ },
  { type: 'create-layer', layerId: '...' }
);
window.History.execute(cmd);

5) テスト項目（動作確認リスト）

各テストは「クリーンなページを file:// で直接開き（または local server）」「DevTools のコンソールで window.History.getHistoryInfo() を観察」して実施

基本 Undo/Redo

操作：何か線を描く（path 追加）→ Ctrl+Z（Undo）→ Ctrl+Y（Redo）

期待：Undo で直前の描画が消える、Redo で再表示される。History.getHistoryInfo() の canUndo/canRedo の状態遷移が正しい。

レイヤー作成→Undo

操作：レイヤーを追加 → window.History.getHistoryInfo() を確認 → Ctrl+Z

期待：追加したレイヤーが消える、履歴スタックは 1 件増えて 1 件減る。

CUT 作成 / 削除

操作：新しい CUT を作成 → Undo → Redo

期待：CUT の数が正しく戻る・進む。history の重複登録がない（stackSize が想定より膨らまない）。

連続複数操作（レイヤー＋CUT）

操作：CUT 作成 → レイヤー作成 ×2 → Undo ×3 → Redo ×3

期待：逐次元通りに遡り、履歴が整合する（履歴件数の急増が無い）。

コピー＆ペースト（右隣 or new）

操作：レイヤー or CUT をコピーして隣にペースト（cut:pasted-right-adjacent / cut:pasted-new のイベント）

期待：history に 1 回だけ snapshot が追加される（history.js はこれらのイベントで saveStateFull() を呼ぶ実装があるので、イベントが一つだけ発生することを確認）。
GitHub

Undo/Redo 実行中のイベント抑止

操作：複雑な undo (CUT restore 等) を行いながら eventBus のログを見る

期待：undo 実行中に layer/animation 系のイベントで history に再登録されない（isExecutingUndoRedo が機能すること）。

6) 実施手順（短く、順序通り）

system/history.js の最新版をプロジェクトに取り込み（既にあるならそのまま適用）し、window.History の公開 API を確認。
GitHub

layer-system.js の create/delete 部分をパッチし、「発火は1回」「History に直接 saveState を呼ばない」の方針に変更（上記スニペット参照）。

animation-system.js（CUT 関連）を同様に整理。createNewBlankCut()等が saveStateFull() を直接呼んでいないことを確認。

UI 側（core-runtime または timeline-ui）に Ctrl+Y / Ctrl+Shift+Z のキーバインドを追加（上記スニペット）。既存 keydown 処理と重複しないようガードを入れる。

上のテスト項目を順に実施。問題が出た個所は history の Command 化を優先して対処する（Create/Delete 操作用に Command を作る）。

テスト OK なら軽いコードレビュー＆コメント追加（誰が見ても分かるように）→ master へマージ。

7) 追加の注意点・落とし穴

イベント設計の一貫性：発火元を複数箇所に分散させると二重登録リスクが高い。発火は「状態を変えた直後の 1 箇所」に限定すること。

非同期タイミング：setTimeout(...,50) のような遅延を入れている箇所がいくつかあることを確認。これは race を避けるための暫定対処なので、最終的には同期的に History 登録を行うべき（ただし UI/描画の都合により非同期が必要な場合もある）。

大きなリファクタ：Command パターンへ全面移行が最も堅牢だが工数大。まずはイベントの重複排除→キーバインド追加→Command 化（段階的）を推奨。

8) 回帰時のチェックリスト（リリース直前）

 Undo/Redo の基本ケース全部パス（描画 / レイヤー / CUT / paste）。

 History.stack の肥大化が解消（大量に同じ snapshot が追加されない）。

 Undo 実行中に新たな history push が発生していない。

 Ctrl+Y / Ctrl+Shift+Z が全ブラウザで期待通り動作。

 コンソールに冗長なログが残っていない（デバッグログは削除または guarded by DEBUG flag）。

9) 提案：最小パッチ（今すぐ入れるべき変更）

layer-system.js／animation-system.js の 「直接 History API 呼び出し」 を削除して eventBus.emit('layer:created') / emit('animation:cut-created') のみにまとめる。

core-runtime.js（もしくは timeline-ui.js）へ Ctrl+Y / Ctrl+Shift+Z ハンドラを追加。

system/history.js の saveState() と saveStateFull() に 簡単な debounce（100ms） を追加して、短時間に同種の保存が複数回呼ばれても一つに纏める（副次的に二重 push を防ぐ）。

（history.js の現行版には既に二重防止のロジックやイベント整理コメントが入っているため、1/2 の変更で多くは直るはずです）。
GitHub

10) 参考（調査で確認した主要箇所）

system/history.js（現行改修版。Command 実装・redo 実装・二重 save 排除/イベントリスナー整理あり）。
GitHub

最後に（要点まとめ）

まずは**「発火元（layer/animation）での二重イベント発火を潰す」 + 「UI 側で Ctrl+Y を登録」**を最優先で実施してください。

それで症状が消えなければ（または不整合が残るなら）次に 操作単位の Command 化 を段階的に導入します。

既に system/history.js の良い実装があるため、出来るだけそれをそのまま使い、発火元を整えるだけで問題の多くは解消されます。