改修計画書：タイムラインサムネイル即時更新
改修目的

現在は「新規レイヤー複製時」にのみタイムラインサムネイルが反映される。

ユーザーがレイヤーに描画を確定（筆跡を終了、またはレイヤー操作を適用）した際に、即座に該当フレームのサムネイルを更新する。

UIのリアクティブ性を高め、アニメーション編集時のフィードバックを改善する。

改修対象ファイル

system/layer-system.js
レイヤー描画確定のイベント発火ポイントを定義する。

ui/timeline-ui.js
サムネイル描画を外部から呼び出せる API を追加し、LayerSystemから呼び出せるようにする。

system/event-bus.js
イベント定義を一元化し、DRAW_COMMITイベントを追加する。

実装方針

1. EventBus の拡張

event-bus.js

// 新規イベント定義
const Events = {
  LAYER_ADDED: "layer:added",
  LAYER_REMOVED: "layer:removed",
  LAYER_UPDATED: "layer:updated", // ← 既存用途
  DRAW_COMMIT: "draw:commit",     // ← 新規：描画確定時
  TIMELINE_REFRESH: "timeline:refresh"
};


2. LayerSystem 側で描画確定時にイベント発火

layer-system.js

function commitDrawing(layerId) {
  const layer = layers[layerId];
  if (!layer) return;

  // レイヤーの状態を確定（バッファ適用や表示更新）
  layer.texture.update(); 

  // 新イベントを発火
  EventBus.emit("draw:commit", { layerId });
}


3. TimelineUI 側で即時サムネイル更新

timeline-ui.js

// サムネイル更新用の公開APIを追加
function refreshThumbnail(layerId) {
  const frameElem = document.querySelector(`[data-layer-id="${layerId}"] canvas`);
  if (!frameElem) return;

  const layer = LayerSystem.getLayer(layerId);
  if (!layer) return;

  const ctx = frameElem.getContext("2d");
  ctx.clearRect(0, 0, frameElem.width, frameElem.height);
  ctx.drawImage(layer.sprite.texture.baseTexture.resource.source, 0, 0,
                frameElem.width, frameElem.height);
}

// EventBus購読
EventBus.on("draw:commit", ({ layerId }) => {
  refreshThumbnail(layerId);
});


4. DrawingEngine または CoreEngine 側から呼び出す

ペンツールの描画終了時（mouseup / touchend）

移動や変形ツールで「確定」した直後

// 例: DrawingEngine.js 内で描画終了時に
LayerSystem.commitDrawing(activeLayerId);


アーキテクチャ上の整理

EventBus基盤を使って疎結合化することで、LayerSystemとTimelineUIを直結させない。

Timeline更新ロジックはUIレイヤーに集約、LayerSystemはあくまでイベント通知に徹する。

既存の layer:updated イベントとは用途を分ける（更新は位置・回転・透明度なども含むため、描画確定専用イベントを分離）。


メリット

即時性：ユーザーが描いた内容がサムネイルにすぐ反映。

可読性：イベント名 draw:commit で目的が明確。

改修容易性：TimelineUIにrefreshThumbnailを集約 → 将来「差分更新」「GPUベースの縮小」などへ拡張しやすい。

次ステップ

event-bus.js に DRAW_COMMIT を追加

layer-system.js に commitDrawing API 実装

timeline-ui.js に refreshThumbnail API 実装 + EventBus購読

DrawingEngine または CoreEngine 内の描画終了フックで commitDrawing 呼び出し

---

改修計画書（拡張版）：確定操作すべてでタイムラインサムネイル即時更新
改修目的

描画だけでなく、**レイヤーに対するすべての「確定操作」**でサムネイルが最新状態になるようにする。

アニメーション制作を見据えて「確定操作 = 1フレームの見た目が固まったタイミング」でUI反映する仕組みを統一。

改修対象

event-bus.js
→ 「確定操作」を表すイベントを 一元管理。

layer-system.js
→ すべての操作確定時にイベント発火。

timeline-ui.js
→ イベント購読してサムネイル更新。

イベント設計

event-bus.js

const Events = {
  LAYER_ADDED: "layer:added",
  LAYER_REMOVED: "layer:removed",
  LAYER_UPDATED: "layer:updated",   // 値の変化があった瞬間（中間も含む）
  OPERATION_COMMIT: "operation:commit", // ← 新規：確定操作全般
  DRAW_COMMIT: "draw:commit",       // ← 既存の描画確定（内部的にOPERATION_COMMITを呼ぶ）
  TIMELINE_REFRESH: "timeline:refresh"
};


ポイント：

DRAW_COMMIT はペンツール専用のイベントだが、内部で OPERATION_COMMIT を呼び出すようにする。

変形や移動、フィルタ適用も OPERATION_COMMIT に統一することで、Timeline側は1種類のイベントを購読するだけで済む。

LayerSystem 側の改修

layer-system.js

function commitDrawing(layerId) {
  const layer = layers[layerId];
  if (!layer) return;
  layer.texture.update();

  // 専用イベントと統合イベントの両方を発火
  EventBus.emit("draw:commit", { layerId });
  EventBus.emit("operation:commit", { layerId, type: "draw" });
}

function commitTransform(layerId) {
  const layer = layers[layerId];
  if (!layer) return;

  // transform の適用（座標・回転・スケールなど）
  layer.sprite.updateTransform();

  EventBus.emit("operation:commit", { layerId, type: "transform" });
}

function commitFilter(layerId) {
  const layer = layers[layerId];
  if (!layer) return;

  // フィルタ確定（PixiJSのフィルタ適用後に再描画）
  layer.sprite.filters = [...layer.pendingFilters];

  EventBus.emit("operation:commit", { layerId, type: "filter" });
}

TimelineUI 側

timeline-ui.js

function refreshThumbnail(layerId) {
  const frameElem = document.querySelector(`[data-layer-id="${layerId}"] canvas`);
  if (!frameElem) return;

  const layer = LayerSystem.getLayer(layerId);
  if (!layer) return;

  const ctx = frameElem.getContext("2d");
  ctx.clearRect(0, 0, frameElem.width, frameElem.height);

  // spriteから元のHTMLImageElement/Canvasを描画
  const base = layer.sprite.texture.baseTexture.resource.source;
  ctx.drawImage(base, 0, 0, frameElem.width, frameElem.height);
}

// すべての確定操作を監視
EventBus.on("operation:commit", ({ layerId }) => {
  refreshThumbnail(layerId);
});

呼び出し側（DrawingEngine, CameraSystem など）

ペンツール → LayerSystem.commitDrawing(id)

移動/回転/反転/スケール → LayerSystem.commitTransform(id)

フィルタ適用完了 → LayerSystem.commitFilter(id)

メリット

一元化された仕組み：Timelineは operation:commit だけ購読すればよい。

拡張しやすい：将来的に「物理シミュレーション結果を確定」といったケースも operation:commit で対応可能。

AI可読性：操作の確定ポイントが commit○○ に統一され、関数名から意図が明確に分かる。
