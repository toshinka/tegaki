===== 改修計画書: GIFクリップボード＆ポップアップ完結化（file:// 対応） =====
作成: ChatGPT（指示に基づく改修案）
目的:
  - 別タブを開かず、ポップアップ内で画像（PNG/GIFなど）のプレビュー・コピー・ダウンロードを完結させる。
  - file:// 環境向けに Data URL を採用し、必ずプレビューおよびダウンロードの手段が残ること。
  - Clipboard API が使用可能なら直接コピーを試行し、不可の場合はプレビューを表示してユーザが右クリックでコピー/保存できるようにする。
  - UIはシンプルで、既存の export-popup に統合。アイコンや余計な装飾は加えない。

前提ルール（既存ルールに従う）:
  - PixiJS v8.13、ES2023、モジュールは使用しない。
  - file:// での直開き対応。
  - コンソールログは最小限。
  - ベクターデータの取り扱いは慎重に。ラスタ化はエクスポータの責務と明示する。

概要フロー（高レベル）:
  1. ユーザが「エクスポート」→「GIF」を選択 → エクスポータが GIF バイナリ (Uint8Array / ArrayBuffer) を生成する。
  2. Export Manager はバイナリを受け取り Data URL を作成（`data:image/gif;base64,...`）および `Blob` を生成。
  3. ポップアップ（ui/export-popup.js 拡張）を開く。ポップアップ内に:
     - サムネイル（<img src="data:...">）を表示
     - 「直接コピー（Clipboard）」ボタン（表示は Clipboard API 利用可判定による）
     - 「ダウンロード」ボタン（`<a download>` link）
     - ステータス領域（成功/失敗メッセージ）
  4. ボタン操作:
     - 直接コピーボタン: `navigator.clipboard.write([ new ClipboardItem({ 'image/gif': blob }) ])` を試行。
         - 成功: ステータス更新（"クリップボードにコピーしました"）→ UI は閉じる/そのまま
         - 失敗/例外: ステータスにエラーを表示し、自動でプレビュー表示（既に表示されている）を促す
     - ダウンロードボタン: data URL を `href` に持つ `<a download="image.gif">` を渡す（file:// でも動作）
  5. 自動フォールバック:
     - Clipboard API が存在かつ権限がある場合は「直接コピー」UIを表示
     - それ以外は「コピー不可（プレビューで右クリックしてください）」というメッセージとダウンロードリンクを表示

変更対象ファイル（候補）と作業内容:
  - system/export-manager.js
    - 追加/変更:
      - `exportToGif()` の返り値を `ArrayBuffer | Uint8Array` とする既存仕様を確認し、`prepareExportResultForPopup({mime, arrayBuffer, filename})` を追加。Data URL / Blob を作成して popup に渡す統一 API を提供。
      - 新 helper: `arrayBufferToDataUrl(arrayBuffer, mime)` 、 `arrayBufferToBlob(arrayBuffer, mime)` を実装。

  - system/exporters/gif-exporter.js
    - 追加/変更:
      - 現在の GIF 生成ロジックはそのまま利用。ただし、出力は **ArrayBuffer** を返すよう統一（既にそうであればそのまま）。
      - メソッド名例: `exportGifAsArrayBuffer({frames, options}) => Promise<ArrayBuffer>`

  - ui/export-popup.js
    - 追加/変更:
      - Popup の DOM を JS で生成（既存 popup 構造を拡張）。popup 内に以下領域を持つ:
         * プレビューイメージ領域: `<img id="exportPreview" alt="preview">`
         * ボタン群: 「Copy to Clipboard（id=btnCopy）」, 「Download（id=btnDownload）」, 「Close」
         * ステータスメッセージ領域: `<div id="exportStatus">`
      - 関数 `showExportPopup({mime, dataUrl, blob, filename})` を実装。
      - 関数 `tryCopyImageBlobToClipboard(blob)` を実装（ClipboardItem を使用）。`async/await` で例外を捕捉し、失敗したら UI にエラーメッセージ表示。
      - file:// 対応のため、ダウンロードリンクには `href = dataUrl` を設定。

  - system/history.js / system/drawing-clipboard.js
    - 変更不要（ただしエクスポータが取り出すフレーム/ベクターデータ API が変わる場合は調整）。

UI/UXルール（簡潔に）:
  - ポップアップはモーダル風（既存の export-popup を流用）で過度な装飾無し。
  - Clipboard API の可否は起動時に判定して、ボタンの有無/enable 状態を切り替える。
  - エラーは短い日本語で表示（例: "クリップボードへの書き込みに失敗しました。ブラウザの権限を確認するか、下のダウンロードを使用してください。"）
  - 画像は `max-width: 100%` のレスポンシブ表示（ポップアップ内で右クリックしやすい）にする。

セキュリティ／権限注意:
  - Clipboard API の失敗は普通に発生する（file:// やブラウザ設定）。必ずダウンロード/プレビューが使えること。
  - `navigator.clipboard.write` に渡す MIME タイプは正確に（`image/gif` など）する。

追加ユーティリティ（小さな関数群）:
  - `arrayBufferToBase64(arrayBuffer) => string`（base64 変換）
  - `arrayBufferToDataUrl(arrayBuffer, mime) => 'data:...;base64,....'`
  - `arrayBufferToBlob(arrayBuffer, mime) => Blob`

テスト手順（簡潔）:
  1. 開発環境（file://）で GIF エクスポート → ポップアップ表示 → プレビューが表示されること
  2. 「ダウンロード」クリック → ブラウザがダウンロード（または保存ダイアログ）を出すこと
  3. HTTPS 環境（ローカルサーバ or 本番）で GIF エクスポート → ポップアップが Clipboard ボタンを表示 → 「コピー」を押すとペースト先に GIF が貼れること（例: Slack/Google Docs/画像エディタ等）
  4. Clipboard API が拒否された場合はステータスメッセージが出ること

実装スニペット（必須の核心部分、ui/export-popup.js に入れる想定）:
  - 下記の "実装例コード" セクションをそのまま追加して差し替え可能。

保守性・AI対応:
  - 関数名は動詞＋名詞で明確に（例: `showExportPopup`, `tryCopyImageBlobToClipboard`）。
  - エクスポータは **ArrayBuffer を返すことを契約** とする（他の形式は manager 側で統一的に変換）。
  - popup は DOM を JS で完全生成し、CSS も小さなスコープスタイルを付与（外部依存を避ける）。
  - すべての変更点をコメントで明示（Claude が読みやすいように）。

----- END OF PLAN -----
下に、実装例コード（抜粋） を置きます。後続 Claude はこれを 見て ui/export-popup.js と system/export-manager.js、system/exporters/gif-exporter.js に適用してください。必要に応じて関数名を既存コードに合わせてください。

（重要）このコードは モジュール化していない ES2023 非モジュール形式 を想定しています。exportManager 等の既存オブジェクトに統合してください。

javascript
コードをコピーする
/* ---------- system/export-manager.js 追加ユーティリティ ---------- */

/**
 * ArrayBuffer -> base64
 */
function arrayBufferToBase64(buffer) {
  // digit-by-digit safe conversion
  const bytes = new Uint8Array(buffer);
  let binary = "";
  // chunk to avoid stack blow
  const chunkSize = 0x8000;
  for (let i = 0; i < bytes.length; i += chunkSize) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
  }
  return btoa(binary);
}

/**
 * ArrayBuffer -> data URL
 */
function arrayBufferToDataUrl(buffer, mime) {
  const base64 = arrayBufferToBase64(buffer);
  return `data:${mime};base64,${base64}`;
}

/**
 * ArrayBuffer -> Blob
 */
function arrayBufferToBlob(buffer, mime) {
  return new Blob([buffer], { type: mime });
}

/* Example integration point:
   exportManager.exportGif(...) returns Promise<ArrayBuffer>
   after receiving array buffer:
*/
async function handleExportResultArrayBuffer(arrayBuffer, { filename = 'image.gif', mime = 'image/gif' } = {}) {
  const dataUrl = arrayBufferToDataUrl(arrayBuffer, mime);
  const blob = arrayBufferToBlob(arrayBuffer, mime);
  // call UI
  showExportPopup({ mime, dataUrl, blob, filename });
}

/* ---------- ui/export-popup.js 追加/差し替え ---------- */

/**
 * showExportPopup: ポップアップを DOM で生成して制御します。
 * 引数: { mime, dataUrl, blob, filename }
 */
function showExportPopup({ mime, dataUrl, blob, filename }) {
  // 既存ポップアップがあれば再利用 or 削除
  const existing = document.getElementById('exportPopupContainer');
  if (existing) existing.remove();

  // create container
  const container = document.createElement('div');
  container.id = 'exportPopupContainer';
  container.style.position = 'fixed';
  container.style.left = '50%';
  container.style.top = '50%';
  container.style.transform = 'translate(-50%, -50%)';
  container.style.zIndex = 9999;
  container.style.background = '#fff';
  container.style.padding = '12px';
  container.style.border = '1px solid #ccc';
  container.style.borderRadius = '8px';
  container.style.boxShadow = '0 2px 12px rgba(0,0,0,0.2)';
  container.style.maxWidth = '90vw';
  container.style.maxHeight = '80vh';
  container.style.overflow = 'auto';
  container.style.fontFamily = 'sans-serif';

  // image preview
  const img = document.createElement('img');
  img.id = 'exportPreview';
  img.src = dataUrl;
  img.alt = filename || 'export';
  img.style.maxWidth = '320px';
  img.style.maxHeight = '320px';
  img.style.display = 'block';
  img.style.marginBottom = '8px';
  img.style.cursor = 'context-menu'; // right-click hint

  // buttons container
  const btnWrap = document.createElement('div');
  btnWrap.style.display = 'flex';
  btnWrap.style.gap = '8px';
  btnWrap.style.alignItems = 'center';
  btnWrap.style.marginBottom = '8px';

  // Copy button (may be hidden if clipboard unsupported)
  const btnCopy = document.createElement('button');
  btnCopy.id = 'btnCopyImage';
  btnCopy.textContent = 'クリップボードにコピー';
  btnCopy.style.padding = '6px 10px';
  btnCopy.style.borderRadius = '6px';
  btnCopy.style.border = '1px solid #888';
  btnCopy.style.background = '#f7f7f7';
  btnCopy.style.cursor = 'pointer';

  // Download link button
  const linkDownload = document.createElement('a');
  linkDownload.id = 'btnDownloadImage';
  linkDownload.download = filename || 'image.gif';
  linkDownload.href = dataUrl;
  linkDownload.textContent = 'ダウンロード';
  linkDownload.style.display = 'inline-block';
  linkDownload.style.padding = '6px 10px';
  linkDownload.style.borderRadius = '6px';
  linkDownload.style.border = '1px solid #888';
  linkDownload.style.background = '#f7f7f7';
  linkDownload.style.textDecoration = 'none';
  linkDownload.style.color = 'inherit';

  // Close button
  const btnClose = document.createElement('button');
  btnClose.textContent = '閉じる';
  btnClose.style.padding = '6px 10px';
  btnClose.style.borderRadius = '6px';
  btnClose.style.border = '1px solid #888';
  btnClose.style.background = '#f7f7f7';
  btnClose.style.cursor = 'pointer';

  // Status
  const status = document.createElement('div');
  status.id = 'exportStatus';
  status.style.fontSize = '13px';
  status.style.color = '#333';
  status.style.marginTop = '6px';
  status.textContent = '右クリックで画像をコピーまたは保存できます。';

  // Assemble
  btnWrap.appendChild(btnCopy);
  btnWrap.appendChild(linkDownload);
  btnWrap.appendChild(btnClose);

  container.appendChild(img);
  container.appendChild(btnWrap);
  container.appendChild(status);
  document.body.appendChild(container);

  // Clipboard availability check
  const clipboardAvailable = !!(navigator.clipboard && window.ClipboardItem);
  if (!clipboardAvailable) {
    // Hide copy button if not supported and make status clear
    btnCopy.style.display = 'none';
    status.textContent = 'クリップボードへの直接コピーはこの環境でサポートされていません。右クリックでコピー／保存してください。';
  }

  // tryCopyImageBlobToClipboard: attempt to copy blob to clipboard
  async function tryCopyImageBlobToClipboard(blobToCopy) {
    try {
      // create ClipboardItem
      const item = new ClipboardItem({ [mime]: blobToCopy });
      await navigator.clipboard.write([item]);
      status.textContent = 'クリップボードに画像をコピーしました。ペーストして確認してください。';
      // Optionally close popup after success
      // container.remove();
    } catch (err) {
      // handle errors gracefully
      console.warn('Clipboard write failed:', err);
      status.textContent = 'クリップボードへの書き込みに失敗しました。右クリックでコピー/保存してください。';
    }
  }

  // event listeners
  btnCopy.addEventListener('click', function () {
    // disable button to prevent double-click
    btnCopy.disabled = true;
    btnCopy.textContent = 'コピー中...';
    // try copy
    tryCopyImageBlobToClipboard(blob).finally(() => {
      btnCopy.disabled = false;
      btnCopy.textContent = 'クリップボードにコピー';
    });
  });

  btnClose.addEventListener('click', function () {
    container.remove();
  });

  // Accessibility: allow ESC to close
  function onKey(e) {
    if (e.key === 'Escape') container.remove();
  }
  window.addEventListener('keydown', onKey, { once: true });
}

/* ---------- system/exporters/gif-exporter.js (期待される返り値) ----------
 * 既存の GIF としてエンコードする処理はそのまま残すが、
 * 必ず Promise<ArrayBuffer> を返すように統一してください。
 *
 * 例:
 * function exportGifAsArrayBuffer(frames, options) { return Promise<ArrayBuffer>; }
 *
 * この ArrayBuffer を export-manager 側の handleExportResultArrayBuffer() に渡します。
 */

/* ---------- 使い方（例） ----------
exportButton.onclick = async function() {
  // 1) GIF を生成（ArrayBuffer を取得）
  const arrayBuffer = await gifExporter.exportGifAsArrayBuffer(frames, options);

  // 2) 結果を handleExportResultArrayBuffer に渡す
  handleExportResultArrayBuffer(arrayBuffer, { filename: 'my_drawing.gif', mime: 'image/gif' });
};
*/
補足メモ（小さな実務アドバイス）
navigator.clipboard.write はユーザーアクション（ボタンの click）中の呼び出しで成功しやすいです。自動で行わず「コピー」ボタンを押させるのが安全です。

file:// 環境ではクリップボードが使えない想定で、ポップアップを表示したら即プレビューとダウンロードリンクを見せるUIにしておくと UX が良いです。

GIF のバイナリサイズが大きい場合、Data URL を直接 DOM に埋めるとメモリを消費します。大きな GIF の場合は Blob URL（URL.createObjectURL(blob)) を使う方法もあります。※ただし Blob URL は file:// 環境でも動作します。もし Data URL にこだわるなら Base64 生成処理を慎重に（上の arrayBufferToBase64 を使用）。