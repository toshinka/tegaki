要点サマリ（1行）

根本原因は「座標系の混在」と「変形確定（transform の焼き込み）の不整合」。まず座標変換APIを厳格化し、LayerSystem に変形を集約して「パスは常にキャンバス（canonical）座標で保存」する設計に統一します。

GPT5案

改修方針（設計原則）

座標系を厳密に定義する（screen / world / canvas / local）— 各APIで入力/出力座標系を必ず注記。

GPT5案

パス（path.points）は常に canvas（canonical）座標で保持。描画は Camera/Layer の transform を合成してスクリーンへ投影。

GPT5案

レイヤー変形は LayerSystem が一元管理。Container の transform は表示のために使うだけ。変形確定（confirm）時は points に焼き込み、Container transform をリセット。

GPT5案

Clipboard は canonical 座標で copy/paste（変形状態は保存しない／初期化する）。

GPT5案

イベント同期は EventBus（文字列定義されたイベント）で行う。直接参照の多用は避ける（ただしレガシー参照は残しても可）。

GPT5案

範囲（絶対条件）

改修対象は phase2c の下記 4 ファイル内の実装のみ（core-engine.js, systems/camera-system.js, systems/layer-system.js, systems/drawing-clipboard.js）。他ファイル（ui-panels.js, core-runtime.js, config.js など）は触らない。

ただし必要な public API/イベントの追加は core-engine.js（中枢）に追加して外部と整合させる。

成果物（フェーズ別：フェーズ名のみ、時間は提示しない）

フェーズA（必須・最優先）

座標変換 API の明確化・実装（screen↔world↔canvas⇄local の 4 API）

DrawingEngine の入力ルートを screen→canvas に統一（ペン描画が左にズレる問題解消）

LayerSystem.confirmLayerTransform() の非破壊正実装（パスへの焼き込み）

ClipBoard の copy/paste を canonical 化

フェーズB（中期）

rebuildPathGraphics() と path.graphics の position/transform ルールを固定化

EventBus イベント契約の定義と各システムへの配備

レイヤーパネルの階層移動 API（レイヤー順序・アクティブ移動）安定化（移動時のアンカー補正）

フェーズC（拡張・安定化）

キャンバスサイズ変更対応（キャンバス依存レイヤーの扱い、サムネイル更新）

Undo/Redo を変形確定前後で扱えるような履歴インターフェース（必要なら）

テストスイート（単体手順チェックリストの自動化 or manual checklist）

（上位方針は GPT5案.txt に準拠）。

GPT5案

詳細設計（API 定義と重要アルゴリズム）
座標系の定義（プロジェクト共通）

screen: ブラウザのクライアントピクセル（mouse event の clientX/Y）。

world: worldContainer 上の座標（Camera の pan/zoom/rotation を含む）。

canvas (canonical): 「キャンバス内容の論理座標」。path.points は常にこの座標で保存。

local: Layer コンテナのローカル座標（通常 canvas と同義。ただし layer に anchor がある場合は異なる）。

すべての関数/メソッドは JSDoc で @input/@output を明示すること（例: @input screen @returns canvas）。

GPT5案

CameraSystem（責務）

変換 API を公開：

screenToWorld({x,y}) -> {x,y}

worldToCanvas({x,y}) -> {x,y}

screenToCanvas({x,y}) -> {x,y}（上二つの合成）

canvasToWorld(...), canvasToScreen(...)（逆変換も用意）

getWorldContainer(), getCanvasContainer() は必要時に使えるが、transformの読み書きは避ける（LayerSystem 経由で行う）。

マスク/ビューサイズ更新は camera:resize イベントで通知。

実装注意: DOM の getBoundingClientRect()・CSS scale を考慮してスクリーン→キャンバス変換を行う。

GPT5案

LayerSystem（責務：核）

データモデル（例）

layerData = {
  id: 'layer_001',
  name: 'ink',
  visible: true,
  opacity: 1.0,
  isBackground: false,
  // paths は常に canvas 座標系（canonical）
  paths: [{ id: 'p1', points: [{x,y},...], color, size, opacity, isComplete }, ...],
  metadata: {...}
};
layerTransform = { x:0, y:0, rotation:0, scaleX:1, scaleY:1, hFlip:false, vFlip:false };


公開メソッド（必須）

applyTransformToPoints(layerId, transform)
→ transform の matrix を作り、すべての path.points に matrix を適用して layerTransform を identity に戻す（＝変形確定）。

GPT5案

getLayerCanonicalPaths(layerId) -> Array<Path>（常に canvas 座標）

rebuildPathGraphics(path)（path.points を canvas 座標として受け取り、Graphics を作る）

setLayerOrder(layerId, newIndex)（レイヤー階層移動）

createLayer(initialProps) / removeLayer(layerId) / duplicateLayer(layerId)（UI や Clipboard のために）

confirmLayerTransform 実装擬似コード（必須）

// LayerSystem.confirmLayerTransform(layerId)
const transform = this.layerTransforms.get(layerId);
if (isIdentity(transform)) return;
const layer = this.getLayerById(layerId);
const matrix = buildTransformMatrix(transform, anchor /* e.g. canvas center or layer.anchor */);
layer.layerData.paths.forEach(path=>{
  path.points = path.points.map(pt => applyMatrix(matrix, pt)); // canvas coords に焼き込む
});
// リセット
this.layerTransforms.set(layerId, identityTransform());
layer.container.setTransform(0,0,1,1,0);
layer.container.removeChildren(); // or update graphics via rebuildPathGraphics
layer.layerData.paths.forEach(p=> this.rebuildPathGraphics(p));
EventBus.emit('layer:transform:confirmed', {layerId});


buildTransformMatrix() はアンカー（中心）を厳密に決めること。アンカーを canvas center に統一するか、レイヤー毎に anchor プロパティを持たせる。

GPT5案

注意点

Container の transform を残したままだと、rebuild 時に二重適用 / 消失が起きる（これが現象の主因）。必ず焼き込み or 永続的に Container を表示専用にする。

GPT5案

Drawing-Clipboard（責務）

Copy は LayerSystem.getLayerCanonicalPaths(layerId) を呼び、canonical points の深いコピーを作る（transform を適用済みにする、見かけ上の transform を保存してはいけない）。

Paste は新規レイヤーを作り、canonical points をそのまま rebuild する（レイヤー transform は identity）。

Clipboard 内に「見かけ上の transform」を混ぜない。これで paste 後に消える問題を解消。

GPT5案

rebuildPathGraphics のルール

rebuildPathGraphics(path) は path.points を canvas 座標系として受け取る。

path.graphics.position を {0,0} にして内部で moveTo/lineTo を実行する（path.graphics に transform を持たせない）。

path.graphics は layer.container に addChild されるが layer.container は常に identity（変形確定後）か、一時的に transform を使うに留める（変形中は transform を使う）。

GPT5案

EventBus（契約例）

イベント名とペイロードを厳密に定義してソースにコメントを残す。

'layer:transform:confirmed' → {layerId}

'layer:paths:changed' → {layerId}

'camera:resize' → {width,height}

'clipboard:copied' → {layerId}

'layer:order:changed' → {layerId, newIndex}

実装注意: EventBus は小さな Pub/Sub オブジェクトで十分。直接的な this.layerManager = ... のような遅延設定は避け、EventBus 経由で初期同期を行う。

GPT5案

具体的な改修手順（コピペで直せるレベルの優先順）
1) CameraSystem: screen→canvas の確実化（最優先）

実装（擬似コード）

// CameraSystem.screenToWorld
screenToWorld(screenPt){
  const rect = app.view.getBoundingClientRect();
  const x = screenPt.x - rect.left;
  const y = screenPt.y - rect.top;
  // CSS ピクセルや devicePixelRatio を考慮する場合はここで補正
  return this.worldContainer.toLocal({x,y}, app.stage);
}
screenToCanvas(screenPt){
  const world = this.screenToWorld(screenPt);
  return this.canvasContainer.toLocal(world, this.worldContainer);
}


Drawing input は必ず camera.screenToCanvas() を経由するよう DrawingEngine を書き換える（onPointerMove / onPointerDown で直接 clientX を使わない）。

GPT5案

2) LayerSystem.confirmLayerTransform（次）

実装擬似コードは上記参照（必ず matrix を作る）。全 path.points に適用後、container transform を reset、rebuild。

GPT5案

3) Clipboard: copy/paste を canonical 化

コピーは getLayerCanonicalPaths() を呼ぶ。paste は新しい layer を作り、paths をそのまま rebuildPathGraphics() で描く（transform は identity）。

GPT5案

4) rebuildPathGraphics の整備

path.graphics の position を 0,0 にして draw。Container 側で transform を与えない（または確実に reset する）。

GPT5案

5) EventBus を導入して同期不整合を防ぐ

各重要操作（confirm、paste、createLayer、resize）でイベント発行。UI はイベント購読して更新。

GPT5案

テストチェックリスト（必ず実行）

ペンで描画 → 見た目通り canvas に保存される（screen→canvas 入力正）

レイヤー選択 → 移動（ドラッグ）→ 確定（confirmLayerTransform）→ 絵が消えないか

移動→確定後に拡縮・回転 → 消えない（前処理で path.points が正しく焼かれている）

コピー（Ctrl+C）→ ペースト（Ctrl+V）→ 見た目同一で復元される（複数回）

レイヤーの階層移動（UI）→ 実際の表示順が変わり、アクティブレイヤー移動が正しく反映される

キャンバスリサイズ → 背景レイヤー/キャンバス依存レイヤーの表示が崩れないか（フェーズC）

サムネイル更新が都度正しい（layer:paths:changed を購読するテスト）

（上の順に従って単体でテスト。自動化は後で追加可能）

GPT5案

AI（Claude 等）向け実装ガイド（チェックリスト形式） — 必ず守らせること

すべての座標変換関数は @input / @output を JSDoc に明記。

Matrix.apply を使う場所は review 必須（座標破壊リスク）。

絶対に path.points を screen/world のまま保存しない（常に canvas）。

confirmLayerTransform は「焼き込み（bake）」方式で行い、Container.transform を残さないこと。残すと将来の rebuild で二重適用される。

GPT5案

Clipboard は表示上の transform（見かけ上の座標）を保存しない。復元側で transform を持たせたい場合は別のメタ領域に記録し、Paste時には初期化する。

レイヤー階層移動（order）を change する際は EventBus で UI と同期。setLayerOrder() 呼び出し後に layer:order:changed を emit させる。

Console.log は CONFIG.debug ガード下のみにする（不要なログは削る）。

PixiJS v8.13 の API に従う（Container.toLocal / toGlobal 等）こと。プロジェクトの既存 index.html が参照するスクリプトパスと編集する branch が一致しているか確認。

GPT5案

よくあるミスと対処（QA）

ミス: confirm せずに container.transform を残す → 結果: 後続の rebuild で消える/二重変換
対処: confirmLayerTransform で path.points に焼き込むこと。

GPT5案

ミス: Clipboard が「見かけ座標」で copy → paste で座標系不一致
対処: copy は getLayerCanonicalPaths() の結果のみを deepCopy して保存する。

GPT5案

ミス: DrawingEngine が直接 clientX/Y を path に push する → 左にズレる等
対処: DrawingEngine は camera.screenToCanvas(event) を使うこと。

GPT5案

レビュー時の重点確認ポイント（PR チェックリスト）

 各関数に @input/@output の注記あり

 CameraSystem の screenToCanvas が正しく動く（手動で pointer test）

 confirmLayerTransform の実行で layer.container.transform が identity になっている

 Clipboard の paste で新規 layer が identity transform で生成される

 rebuildPathGraphics は path.points を canvas 前提で描いている

 EventBus イベントが適切に発火・購読されている（UI も更新される）

 console.log が CONFIG.debug 下のみである

追加の作業上の注意（運用ルール）

既存 branch のファイルパス（index.html が読み込むファイル）と実際改修するファイルが同じであることを必ず確認する（間違ったファイルを修正しても動作しない）。これは過去に発生している問題で、確認を怠らないでください。

GPT5案

重大な座標修正（confirmLayerTransform 等）は small step で commit & 実行確認 → rollback しやすい commit message をつける。

テストケースを PR に添付し、描画→確定→コピー→ペーストなどの順で manual test を要求する。

最後に（短く）

優先度は座標変換APIの統一 → confirmLayerTransform の非破壊実装 → Clipboard の canonical 化 の順。上に示した API 定義と疑似コードに従えば、現状報告の「左ズレ・消失・階層移動不可・新規レイヤー作成不可・キャンバスリサイズ不可」などの多くは解消されるはずです。