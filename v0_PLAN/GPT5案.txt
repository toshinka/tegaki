要点（短く）

1.原因想定: 現状は「レイヤ配列がプロジェクト全体で1つだけ」になっていて、CUT（シーン・コマ）を切り替えても同じレイヤ配列に描き込まれている。よって CUT1 のレイヤ1 の絵が CUT2 のレイヤ1 にも表示される。

2.設計方針: LayerSystem が cutIndex × layerIndex の 2次元データを持つ（あるいは frames[cut][layer] = コンテナ/RenderTexture）にする。

3.タイムラインのサムネイル: 各（cut, layer）を renderer.render(container, renderTexture) でレンダーして、canvas/base64 を timeline のサムネイル img に設定する。

4.短期対応: 既存の API を壊さないために LayerSystem に ensureFrame(cut, layer) と setActiveCut(cut) を追加する。既存呼び出しはほぼ変えずに内部だけ2Dに変換できる。

テスト: CUTを切替えて描画→timelineサムネイル生成→CUT切替再表示でオリジナルが残ることを確認。

具体的な変更（概念設計 → すぐコピペできるコード例）

以下は system/layer-system.js を置き換える（または主要ロジック差し替え）例です。注意：あなたの既存コードの命名（LayerSystem の呼び出し方）に合わせて細かな調整が必要ですが、方針はこれで動きます。

// system/layer-system.js
// PixiJS v8 前提、モジュール無しで読み込めるように UMD-ish にしておく

(function(global){
  // LayerSystem コンストラクタ
  function LayerSystem(app, options = {}) {
    this.app = app; // PIXI.Application
    this.renderer = app.renderer;
    this.defaultCanvasSize = options.canvasSize || {width: 400, height: 400};

    // frames[cutIndex] = [ layer0Container, layer1Container, ... ]
    // 各 layerContainer は PIXI.Container（表示用）
    this.frames = []; 

    // 管理用の "activeCut" と "activeLayerIndex"
    this.activeCut = 0;
    this.activeLayer = 0;

    // 履歴や undo 用に binary snapshot を残すなら別途
  }

  LayerSystem.prototype.ensureCut = function(cutIndex) {
    if (!this.frames[cutIndex]) {
      this.frames[cutIndex] = [];
    }
  };

  LayerSystem.prototype.ensureLayer = function(cutIndex, layerIndex) {
    this.ensureCut(cutIndex);
    const cut = this.frames[cutIndex];
    if (!cut[layerIndex]) {
      // 新しいレイヤはコンテナと、描画保持用の RenderTexture を持たせる
      const container = new PIXI.Container();
      container.name = `cut${cutIndex}_layer${layerIndex}_container`;
      // 位置や変換は container に設定する（LayerSystem が管理）
      cut[layerIndex] = {
        container: container,
        // optional: renderTexture を持っておけばサムネ作成が速い
        renderTexture: PIXI.RenderTexture.create({
          width: this.defaultCanvasSize.width,
          height: this.defaultCanvasSize.height
        })
      };
    }
  };

  // アクティブ CUT を切り替える
  LayerSystem.prototype.setActiveCut = function(cutIndex) {
    this.activeCut = cutIndex;
    this.ensureCut(cutIndex);
    // ここでステージ（app.stage）への差し替えを行う
    // まず既存のレイヤ表示を全部外す
    this._clearStageLayers();
    // 次に activeCut の全レイヤ container を app.stage に追加（順序保持）
    const cut = this.frames[cutIndex];
    for (let i = 0; i < (cut ? cut.length : 0); i++) {
      if (cut[i] && cut[i].container) {
        this.app.stage.addChild(cut[i].container);
      }
    }
  };

  LayerSystem.prototype._clearStageLayers = function() {
    // ここは app.stage の中でレイヤ関連だけを除去するルールにする
    // 例えば全 child を走査し name に 'cut' が含まれているものを外す
    const stage = this.app.stage;
    for (let i = stage.children.length - 1; i >= 0; i--) {
      const c = stage.children[i];
      if (c.name && c.name.startsWith('cut')) {
        stage.removeChildAt(i);
      }
    }
  };

  // 新規レイヤを作る（現在の activeCut に）
  LayerSystem.prototype.createLayer = function(layerIndex) {
    const cut = this.activeCut;
    this.ensureLayer(cut, layerIndex);
    const layerObj = this.frames[cut][layerIndex];
    // 既にstageに入っていなければ追加
    if (!this.app.stage.children.includes(layerObj.container)) {
      this.app.stage.addChild(layerObj.container);
    }
    return layerObj;
  };

  // 描画系は layerObj.container に Graphics / Sprite を追加していく
  // ここでは簡易 API を示す
  LayerSystem.prototype.drawStroke = function(cutIndex, layerIndex, pixiDisplayObject) {
    this.ensureLayer(cutIndex, layerIndex);
    const layerObj = this.frames[cutIndex][layerIndex];
    layerObj.container.addChild(pixiDisplayObject);
  };

  // サムネイル作成：layer の現在表示を renderTexture にレンダーして dataURL を返す
  LayerSystem.prototype.generateThumbnailDataURL = function(cutIndex, layerIndex) {
    this.ensureLayer(cutIndex, layerIndex);
    const layerObj = this.frames[cutIndex][layerIndex];
    // render to layerObj.renderTexture
    this.renderer.render(layerObj.container, { renderTexture: layerObj.renderTexture, clear: true });
    // コピーして canvas にする
    const canvas = this.renderer.extract.canvas(layerObj.renderTexture);
    return canvas.toDataURL('image/png');
  };

  // 既存 API を上書きせずに互換性を保つために global に展開
  global.LayerSystem = LayerSystem;
})(window);

timeline-ui 側（変更点）

タイムライン側は「サムネ取得時に LayerSystem.generateThumbnailDataURL(cut, layer) を呼ぶ」ように変更します。既存の timeline の列が cut、行が layer なら、サムネ画像要素の src を上記の dataURL に差し替えます。

// ui/timeline-ui.js の該当箇所（サムネ生成部の例）
function updateThumbnail(cutIndex, layerIndex) {
  const thumbnailImgEl = document.querySelector(`#thumb-cut${cutIndex}-layer${layerIndex}`);
  if (!thumbnailImgEl) return;
  const dataURL = window.layerSystem.generateThumbnailDataURL(cutIndex, layerIndex);
  thumbnailImgEl.src = dataURL;
}

// 例：CUT を作る・切り替え時に全レイヤ分サムネを更新する
function refreshTimelineForCut(cutIndex) {
  const layerCount = getLayerCountSomehow(); // 既存 API から取得
  for (let li = 0; li < layerCount; li++) {
    updateThumbnail(cutIndex, li);
  }
}


ポイント: getLayerCountSomehow() は既存の UI が持つレイヤ数取得 API を使ってください。なければ LayerSystem に getLayerCount(cutIndex) を追加してください。

バグの典型 — どこを探すか

LayerSystem が single array (this.layers = []) を使っていて、CUT切替時に this.layers を差し替えていない（または差し替え不能）。→ frames 未導入。

描画時に activeCut を参照せず this.layers[layerIndex] を直接追加している（つまり常に同じ container に描画）。

Timeline のサムネ作成が「現在 stage の順序の snapshot を取っている」実装になっていて、CUTの切替になおさら同期していない。→ サムネは frames[cut][layer].renderTexture を直接描画する方針で独立させる。

レイヤ移動 / 変換（回転・スケール）を app.stage の transform にしていると、stage差し替え時に想定外の影響を受ける（各レイヤ container に transform を持たせるべき）。

マイグレーション手順（実際の作業順・短）

LayerSystem に frames を追加し、ensureCut / ensureLayer / setActiveCut を実装。上のコードをベースに。

core-engine や描画処理がレイヤを参照する箇所を検索して、getCurrentLayerContainer() を経由するように置換（直接 layers[...] 参照がないかチェック）。

Timeline UI を generateThumbnailDataURL(cut,layer) 呼び出しに切替。

GIF エクスポートは gif-exporter 側で for each cut: for each layer: render layerObj.container → collect frame の順でレンダーするように修正。

テスト：CUT1 に線を描く → サムネ反映 → CUT2 切替 → サムネが異なること確認 → GIF エクスポートで各カットが個別に出てるか確認。

追加の注意点（実践的）

座標基準の統一：coordinate-system.js（既にあるはず）に world <-> layer container local の変換関数を集中させる。描画イベントは必ず「マウス座標→world→layer-local」に変換して描くこと。これで CUT 切替／レイヤ移動でのずれを防げます。

メモリ：RenderTexture をカット数×レイヤ数分作るとメモリを食います。必要なら「非表示のカットは renderTexture を free する / 小さいサムネ用に縮小レンダーする」戦略をとる。

互換性：一度に大量のカットがあるなら frames を sparse object にして必要な cut だけ allocate する。frames = Object.create(null) でもOK。

API 命名：LayerSystem.createLayer(cut, layerIndex) や LayerSystem.getLayerContainer(cut, layerIndex)、LayerSystem.setActiveCut(cut) の命名を推奨します。AI での改修を前提に、API を小さく限定するのが楽です。