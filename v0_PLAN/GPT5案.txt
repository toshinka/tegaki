要約（結論）

コンソールの TypeError: CoordinateSystem.init is not a function は CoordinateSystem が期待する「静的メソッド init」を持っていないか、CoordinateSystem がグローバル（window）に正しく公開されていない、あるいは coordinate-system.js が index.html より後に読み込まれている のが最も高確率の原因です。
即効での対処は以下のどちらか（プロジェクト方針に合わせて選択）：

index.html 側を修正して、CoordinateSystem の新しい API（クラスコンストラクタ）呼びに合わせる。

coordinate-system.js に互換ラッパ（静的 init）を追加して、既存の呼び出しを生かす。

以下に原因候補、確認手順、具体的な修正例（パッチ）、および長期的な改修計画書を提示します。どれでも即座に反映できる内容です。

1) 優先度付き原因候補（上から確認する）

スクリプト読み込み順が不適切

index.html が coordinate-system.js より先に core-runtime 等を読み、CoordinateSystem を使おうとしている。file:// 直開きでも順序は重要。

coordinate-system.js のエクスポート方法の不整合

以前は window.CoordinateSystem = { init: ... } だったが、新版で class CoordinateSystem { constructor(...) { ... } } に変わり、グローバル変数が上書き/未公開になっている。

名前競合または二重定義

別ファイルで const CoordinateSystem = { ... } が宣言され再代入不可になっているか、他ファイルで let CoordinateSystem を上書きしている。

ビルドやES機能の不一致（ESM/モジュール呼び出しミス）

index.html はノンモジュールで使う前提なのに、coordinate-system.js が export などモジュール専用記法になっている。

Type mismatch（関数でなくオブジェクト/クラス）

index.html 側が CoordinateSystem.init(...) を想定しているが、coordinate-system.js が new CoordinateSystem(...) を期待している。

名前空間（PI参照、座標基準）やAPI名のリネーム

init が initialize 等に変更されたが呼び先が更新されていない。

2) まず開発者が「今すぐ」確認すべきこと（チェックリスト）

 index.html の <script> タグの順序を確認（coordinate-system.js が呼ばれる前にロードされるか）。<script src="coordinate-system.js"></script> は呼び出し側より上にあるか？

 coordinate-system.js の冒頭で window.CoordinateSystem を定義しているか確認（あるいは class CoordinateSystem の後で window.CoordinateSystem = CoordinateSystem しているか）。

 coordinate-system.js が ES module 構文（export / import）を使っていないか（index.html は module で読み込んでいない前提）。

 index.html の該当行（エラーログにある DrawingApp.initialize 呼び出し付近）で CoordinateSystem を console.log して型を確認：

console.log('CoordinateSystem is', CoordinateSystem, typeof CoordinateSystem);


 repository のブランチ差分を見て、coordinate-system.js のAPI変更（init が削除された/改名された）をチェック。

 他ファイル（新しく追加した layer-system.js / camera-system.js / core-engine.js）で CoordinateSystem を再定義していないか grep する。

（上の console.log はデバッグ一時実装 → 削除忘れ注意）

3) 即効修正パターン（そのままコピペ可）
パターンA — 互換ラッパを coordinate-system.js に追加（既存コードを壊さない最短修正）

もし新しい実装が class CoordinateSystem { ... } で、既存呼び出しが CoordinateSystem.init(...) を期待しているなら、下記を coordinate-system.js の末尾に追加してください。

// 末尾に追加（既に class CoordinateSystem {...} がある前提）
if (typeof window !== 'undefined') {
  // 既にグローバルに存在する場合は上書きしないが、
  // init が無ければ互換 wrapper を提供する
  if (!window.CoordinateSystem) {
    // エクスポートされていない場合、クラス名がスコープ内にあるか確認してから公開
    try {
      // 'CoordinateSystem' クラスがこのスコープにある場合
      if (typeof CoordinateSystem === 'function') {
        window.CoordinateSystem = CoordinateSystem;
      }
    } catch (e) {
      // 無ければフォールバックで空オブジェクト（エラー検出の助け）
      window.CoordinateSystem = {};
    }
  }
  // もし init が無ければ静的 init 互換を追加
  if (!window.CoordinateSystem.init) {
    window.CoordinateSystem.init = function (...args) {
      // 既存の呼び出しを new に変換してラップ
      // 例: args = [canvas, config]
      const instance = new window.CoordinateSystem(...args);
      // もし初期化メソッドが instance.init や instance.initialize なら呼ぶ
      if (typeof instance.init === 'function') instance.init();
      else if (typeof instance.initialize === 'function') instance.initialize();
      return instance;
    };
  }
}


このパッチは APIを壊さず、既存 CoordinateSystem.init(...) 呼びを正常化します。まずはこれを入れて動くか確認してください。

パターンB — index.html 側を新APIに合わせる（よりクリーン）

もし coordinate-system.js が class CoordinateSystem { constructor(canvas, config) { ... } } を提供しているなら、index.html（または core-runtime.js 内）での呼び出しを下記のように変えます。

変更前（エラーが出ている想定）:

CoordinateSystem.init(appCanvas, config);


変更後:

// 直接インスタンス化して必要ならグローバルに保持
const coordinateSystem = new CoordinateSystem(appCanvas, config);
// 既存コードが参照する必要があるなら window に置く
window.coordinateSystemInstance = coordinateSystem;
// instance に initialize メソッドがあれば呼ぶ
if (typeof coordinateSystem.initialize === 'function') coordinateSystem.initialize();


この方法は型が明確になり、複数インスタンスが必要な設計にも向きます。ただし既存コードの CoordinateSystem.* 呼び出しをすべて coordinateSystemInstance.* に切り替える必要があります（またはグローバルに window.CoordinateSystem = coordinateSystem とする手もある）。

パターンC — モジュール誤使用の修正（もし export が紛れ込んでいたら）

coordinate-system.js の先頭や末尾に export / import が使われていたら、index.html の <script type="module"> にするか、逆にモジュールをやめて UMD 互換にする必要があります。あなたの要件では ESM を使わない方針なので、export があれば取り除き、グローバル公開（window.CoordinateSystem = ...）するのが簡単です。

4) 追加で確認すべき“常犯”ポイント（座標系とPI参照等）

座標系の統一：プロジェクト内で world / camera / screen の各座標系の命名と変換関数を一箇所（CoordinateSystem）に集中させる。混在がバグ源。

例 API: worldToScreen(vec), screenToWorld(vec), worldToCamera()

PI 定数参照の不整合：Math.PI を直に使うか、const PI = Math.PI を global constants に集約するか方針を決める。複数定義は危険。

EventBus 整合：複数の system（Layer/Cam/Core/UI）が個別の EventBus を作っていると競合する。EventBus は singleton に統一し、window.EventBus で公開するか CoreEngine.getEventBus() で取得する。

PixiJS 依存：Pixi v8.13 の API を再確認（例えば PIXI.Application の引数や Renderer の生成）。CDN 読込のバージョンと互換性を必ず一致させる。

グローバル vs インスタンス：古いコードで CoordinateSystem をグローバル関数群として使っていたのをクラス化した場合、呼び調整を全体で行う。

5) 改修計画書（AIが直接改修できるレベルでのタスク分解）

以下タスクは優先度つきで列挙。各タスクは「目的」「確認項目」「実装例/方針」「検証方法」を含みます。

タスク A：ブロック1 — 致命エラーの即時修復（最短ルート）

目的：CoordinateSystem.init エラーを消し、アプリを起動させる。

対処案：上のパターンAを適用（互換ラッパ追加）。もし望めばパターンBで index.html 側を変更。

検証：DrawingApp.initialize がエラーなく通ること、コンソールに CoordinateSystem is function/object が期待通りであること。

タスク B：読み込み順と script タグの整備

目的：依存関係順にスクリプトを並べる（coordinate-system → layer-system → camera → core-runtime → core-engine → ui-panels → index.html の init）

実装：index.html の <script> 順序を明示し、重要度の高い依存はコメントで記載。defer 属性を検討する（file:// では注意）。

検証：reload で未定義エラーが出ないこと。

タスク C：API仕様書と型（短いドキュメント）

目的：各 System の公開 API を明文化（CoordinateSystem, LayerSystem, CameraSystem, EventBus）

要点（例）:

CoordinateSystem:

static init(canvas, config) もしくは new CoordinateSystem(canvas, config)

worldToScreen(point), screenToWorld(point), toLocal, toGlobal

LayerSystem:

createLayer(name, options), moveLayer(layerId, targetIndex), rotateLayer(layerId, deg), flipLayer(layerId, axis)

EventBus:

on(event, handler), emit(event, payload), off(event, handler)

検証：ユニットテスト（簡易 JS テスト）で API 呼び出しを実行。

タスク D：座標基準と定数の集約

目的：PI, DPI, DEFAULT_ZOOM, SCREEN_ORIGIN 等、共通定数を config.js に移し、すべての system が参照するようにする。

検証：数値上の微妙なズレ（例：レイヤー描画位置のずれ）が解消されるか。

タスク E：EventBus の統合（singleton化）

目的：イベント連携の混乱を排除。

実装：window.EventBus = new EventBus() または CoreEngine.getEventBus()。既存コードの new EventBus() を撤去・差し替え。

検証：UI 操作 → LayerSystem の反応が期待通りであること。

タスク F：重複実装と未使用ライブラリの整理

目的：再発明を防ぐ。PixiJS の既存 API を利用する（例えばフィルタ、スプライト、コンテナ変換）ことでコードを簡潔化。

実装：コードレビューし、重複する transform / draw / bbox 計算を CoordinateSystem に統一。

タスク G：品質改善（リファクタ）

目的：AI が読みやすく、修正しやすいコードベースにする。

具体策：関数は小さく（max 40行）、一つの責務、JSDoc コメント、明確な命名規則（camelCase、PascalCase の統一）、単一責任の徹底。

検証：レビュー後、AI により自動修正スクリプトが走るときに diff が小さくなるはず。

6) 具体的な差分パッチ例（coordinate-system.js に貼る互換ブロック）

再掲だが、すぐ貼って試す用：

// --- COORDINATE SYSTEM UMD/互換ラッパ ---
// 既存の class/関数がある前提で、グローバルに公開し、init 互換を付与する。
(function () {
  if (typeof window === 'undefined') return;
  try {
    // もし CoordinateSystem がグローバル関数・クラスならそれを利用
    if (typeof window.CoordinateSystem === 'undefined') {
      if (typeof CoordinateSystem === 'function') {
        window.CoordinateSystem = CoordinateSystem;
      } else {
        // もしモジュールスコープのままなら、適宜ここに代入する（必要なら編集）
        // window.CoordinateSystem = MyExportedCoordinateSystem;
      }
    }
  } catch (e) {
    // 何もしない。最小限のフォールバック
    window.CoordinateSystem = window.CoordinateSystem || {};
  }

  // init が無ければ互換 wrapper を追加
  if (!window.CoordinateSystem.init) {
    window.CoordinateSystem.init = function (...args) {
      // args に canvas, config が入る前提
      if (typeof window.CoordinateSystem === 'function') {
        const instance = new window.CoordinateSystem(...args);
        if (typeof instance.init === 'function') instance.init();
        else if (typeof instance.initialize === 'function') instance.initialize();
        // 既存コードが静的 API を参照している場合への互換としても置く
        window.coordinateSystemInstance = instance;
        return instance;
      } else if (typeof window.coordinateSystemInstance === 'object') {
        // 既に singleton があるならそれを返す
        return window.coordinateSystemInstance;
      }
      // 最後のフォールバックで空オブジェクトを返す
      return {};
    };
  }
})();

7) デバッグ用スニペット（index.html の initialize 周りに一時追加して原因特定）

DrawingApp.initialize の冒頭に入れて動作確認：

console.group('DEBUG CoordinateSystem');
console.log('CoordinateSystem raw:', typeof CoordinateSystem, CoordinateSystem);
console.log('window.CoordinateSystem:', typeof window.CoordinateSystem, window.CoordinateSystem);
try {
  console.log('CoordinateSystem.init exists?', typeof CoordinateSystem.init);
} catch (e) {
  console.warn('CoordinateSystem not defined in this scope');
}
console.groupEnd();


これでコンソール出力から「関数ではない」「undefined」「object」「class」などが判断できます。

8) テスト & 検証フロー（簡潔）

まず 互換ラッパ（パッチA） を coordinate-system.js に追加 → index.html でエラーが消えるか確認。

console.log で型と中身を確認。必要なら index.html の呼び方を パターンB に変更。

Layer / Camera が正しく座標を受け取っているか（例：マウス座標で線が引けるか）確認。

EventBus の挙動を手動操作（レイヤ作成・移動）で検証。

不整合が残る API をドキュメント化して順次リファクタ。

9) 推奨方針（設計上の提言）

API 互換性を優先して段階的にリファクタする（互換ラッパ → 内部クリーン → 外部公開 API 更新）。

各 System（Coordinate/Layer/Camera/Core/UI）ごとに明確な責務と公開メソッドを宣言し、README に短く書く。

EventBus を single source にしてログやデバッグトレースを付与。

PixiJS の機能（Container の transform、Sprite の pivot、フィルタ）を活用し自前計算を減らす。

ユニットテスト（node-less でも動く小さなテストファイル）を導入し、座標変換やレイヤ移動などの基本ロジックを自動化で検証。

10) 追加で付けておく「よくある小ミス」チェックリスト

script タグに type="module" が誤って付与されていないか。

defer / async の使い方で読み込み順が狂っていないか。

ファイルパスの大文字小文字ミス（ローカル file:// では OS に依存）。

const CoordinateSystem = {} として後から書き換えようとして失敗していないか（再代入不可エラー）。

同一プロジェクト内に古い coordinate-system.js が残っていないか（キャッシュや別ディレクトリ）。

11) 最後に：今すぐできる最短アクション（優先度順）

coordinate-system.js に【互換ラッパ】を貼って保存 → ブラウザでリロード（file://）。ログで CoordinateSystem の型を確認。

スクリプト順を確認し、coordinate-system.js を core より前に配置。

index.html の DrawingApp.initialize の開始行にデバッグログを入れて型を再確認。

エラー消えたら Layer/Cam の簡単な操作で挙動確認。