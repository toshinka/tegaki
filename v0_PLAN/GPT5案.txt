問題（まとめ）

レイヤー描画確定時にタイムラインのサムネイルが、ペン描画中／直後に反映されない

レイヤー削除時に出る「レイヤー 'レイヤー1' を削除しますか？」の確認ダイアログを廃止したい（現状は確認あり）

レイヤーパネルの階層（順序）移動が反映されない／一度動かすと二度と動かせない（UI とモデルの整合性不良）

前提（コードベース観察に基づく想定）

提供されたファイル群（layer-system.js, layer-utils.js, event-bus.js, timeline-ui.js, ui-panels.js, core-engine.js, core-runtime.js 等）から推測すると、アーキテクチャは以下のパターン：

中央に layer-system（モデル配列）

UI は DOM/パネルを直接更新している（DOM の index = 配列 index に依存）

描画操作（ペン）は PIXI レイヤー（Graphics / RenderTexture）へ直接描く

タイムラインのサムネイル更新処理は「レイヤーが確定されたとき」や「レイヤーが切り替わったとき」にのみ呼ばれている（＝描画途中／直後を監視していない）

確認ダイアログはUI側（ui-panels.js）が confirm() を使っているか、あるいは history の処理と混ざっている

根本原因（各問題ごと）
1) サムネイルが描画直後に更新されない

推定原因

サムネイル生成/書き込み処理が「レイヤーアクティベート」「コピー」「新規作成」などのイベントハンドラでしか呼ばれておらず、描画イベント（stroke end / frame buffer 更新）に紐づいていない。

ペンは PIXI.RenderTexture や Graphics に連続的に描いているが、タイムライン側へ「レイヤーが変更された」ことを通知していない。

パフォーマンス対策で「高頻度更新を避ける」意図があるか、あるいは無名関数で直結しておらずデータフローが切れている。

2) 削除時の確認ポップアップが出る

推定原因

ui-panels.js（またはレイヤー UI）の削除処理に if (!confirm(...)) return; のような直接 confirm() がある。

仕様では UX を軽くするために削除即実行で良いが、履歴（undo）対応が存在するため、開発者が保険で確認を入れてしまった可能性が高い。

3) レイヤー階層の反映不良 / 一度動かすと動かなくなる

推定原因

UI が配列 index に依存して DOM 要素の data-index を参照しているが、レイヤー移動で配列を再構築しても DOM の dataset 更新が正しく行われていない（あるいは逆）。

レイヤーに一意 ID が付与されておらず、移動操作や再描画時の差分検知が index ベースで壊れる。

イベントリスナ（ドラッグハンドラ等）が DOM 要素に直接バインドされていて、再レンダリング／再生成で古いリスナが解除されず、二度目以降の操作が無効化される（ガーベジ・リスナ破綻）。

さらに「移動操作中に同一配列を mutate してイベントループの外で参照している」などの同期問題がある可能性。

改修方針（設計哲学）

モデル（layer-system）を単一ソースにする：UI はモデルに対するビュー。UI は常に event-bus を通じて最新モデルを再描画する。

レイヤーには必ず一意 ID を持たせる（例：layer.id = 'L-xxxx'）。インデックスは表示のためのもので、識別に使わない。

イベントベース：描画の終端（stroke end / pointerup）で event-bus.emit('layer:dirty', {id, frame, thumbnailNeeded:true}) を出し、timeline-ui はそれを受けてサムネイル更新（デバウンス付き）を行う。

不要な confirm() を削除し、履歴（history）を使った undo を代替安全策とする。もしユーザーが誤操作したら Ctrl+Z/履歴で戻せる。

**UI は常に layers:changed を受けて DOM を完全再描画（差分で良いがまずは確実な全描画）**し、DOM 要素にリスナを再バインドする。これにより「一度しか動かない」問題を回避。

具体的改修計画（優先度付き）
優先度高（即座に体感改善するもの）
A. サムネイル即時反映（ペン描画時）

変更対象（主要）

system/layer-system.js

system/event-bus.js

ui/timeline-ui.js

system/drawing-clipboard.js（または描画処理を行うファイル）

実装ステップ

layer オブジェクトに markDirty(frame) メソッドを追加（もしくは layer.dirtyFrames 管理）。

ペン描画処理（pointerup / pointercancel / stroke-end）で eventBus.emit('layer:stroke:end', { layerId, frame }) を発行。サンプル:

// event-bus.js (既存に統一API)
const EventBus = {
  on: (k, h) => document.addEventListener(k, h),
  emit: (k, detail) => document.dispatchEvent(new CustomEvent(k, {detail})),
};
// 使用例: 描画終了時
EventBus.emit('layer:stroke:end', { layerId: activeLayer.id, frame: currentFrame });


timeline-ui.js はこのイベントを受け、**デバウンス（例えば 200–300ms）**してサムネイル更新処理を呼ぶ。

サムネイル更新は PIXI.RenderTexture の renderer.extract.canvas(rootDisplayObject)（Pixi の extract）等で取得 → 小さい <canvas> に drawImage → 既存のサムネイル格納ロジックへ渡す。

高頻度で重くなる場合は「初回 stroke-end で即更新」「以降は 500ms 間隔で更新（throttle）」というハイブリッドにする。

簡易コード断片（timeline-ui 側 listener）

let thumbnailUpdateTimer = null;
document.addEventListener('layer:stroke:end', (e) => {
  const {layerId, frame} = e.detail;
  // すぐ更新する（低レイテンシ体感）
  updateThumbnail(layerId, frame);

  // さらに高頻度を抑える throttle 例（保険）
  if (thumbnailUpdateTimer) clearTimeout(thumbnailUpdateTimer);
  thumbnailUpdateTimer = setTimeout(() => {
    updateThumbnail(layerId, frame);
    thumbnailUpdateTimer = null;
  }, 300);
});


注意点

renderer.extract は Pixi の renderer インスタンスが必要。core-runtime.js や core-engine.js から extract 関数を公開しておく（CoreRenderer.extractCanvas(root) のように）。

ファイル I/O（サムネイルの永続化）は既存ルールに合わせる。

優先度中（UX の修正）
B. 削除確認の削除（confirm() 廃止）

変更対象

ui/ui-panels.js（想定）または system/layer-system.js の delete handler

実装ステップ

confirm() を呼んでいるコードを見つけて削除。直接削除関数を呼ぶように置換：

// 旧
if (!confirm(`レイヤー "${name}" を削除しますか？`)) return;
// 新（そのまま削除）
layerSystem.removeLayer(layerId);
// 履歴追加
history.push({ type: 'layer_remove', layerSnapshot });


削除は history へ snapshot を push して undo を可能にしておく（履歴処理が既にあるならそれを利用）。

UI には小さなトーストは不要（ルールで演出控えめ）。

注意点

削除即実行によって直感的な UX 向上。ただし重大なデータ損失を懸念する場合は「長押しで削除」や「Ctrl+Backspace」などショートカットに割り当てる選択肢を残す（設計段階で検討）。

優先度高（整合性の根本修正）
C. レイヤー階層移動の不具合修正（モデルとビューの分離）

変更対象

system/layer-system.js

system/layer-utils.js

ui/ui-panels.js（レイヤーパネル描画・ドラッグ処理）

system/event-bus.js

実装ステップ

レイヤーに id を付与（ユニーク文字列）。既存の配列 index に依存する箇所をすべて id ベースに置換。
例: layer.id = 'L-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,6);

layer-system に API を整備：

getLayers() → 配列（順序保つ）

moveLayer(id, toIndex) → 内部で splice を行い emit('layers:changed')

removeLayer(id) → splice + emit

addLayer(layer, toIndex) → emit

UI (ui-panels) はドラッグ終了で layerSystem.moveLayer(draggedId, newIndex) を呼ぶだけ。UI 自身は moveLayer を呼んだ後に layers:changed イベントを受け取り フル再描画する。

DOM の差分更新（最初はフル再描画で確実に）。再描画時は古い DOM を完全削除して新しく作ることで古いイベントリスナ残留を防止する。

再描画後、各 DOM 要素に対して必要なイベントリスナ（クリック・ドラッグハンドラ）を再バインドする。

ドラッグハンドラは DOM に直接長く貼るのではなく、UI のレンダリングルーチン中でハンドラを再付与することで「二度と動かせなくなる」問題を解消。

重要な設計ルール

常に layerSystem が single source of truth。UI は参照のみ。UI の DOM dataset に index を書き込むときは、必ず layerSystem.getLayers() の順序でセットする。

小さなコード例（moveLayer）

// layer-system.js
function moveLayer(layerId, toIndex) {
  const idx = layers.findIndex(l => l.id === layerId);
  if (idx === -1) return;
  const [layer] = layers.splice(idx, 1);
  layers.splice(Math.max(0, Math.min(toIndex, layers.length)), 0, layer);
  EventBus.emit('layers:changed', { layers: getLayers() });
}

テスト項目（受け入れ条件）

各修正後、以下を必ず手動で検証する（自動テストは今は不要）：

サムネイル更新

ペンで1ストローク描いて pointerup → タイムラインサムネイルが数百ms以内に更新される。

細かい連続描画でも UI が重くならない（30FPS以下のドロップが酷ければ throttle 値を上げる）。

レイヤー削除

レイヤー削除操作で確認ダイアログが表示されない。

削除後、undo（履歴の戻し）が正しくレイヤーを復元する（レイヤー内容も含め復元できること）。

レイヤー移動

レイヤーを上下に移動 → パネル順序・描画順序ともに即反映。

何度でも（10回以上）移動しても壊れない。

DOM 再描画後にイベント（選択／ドラッグ）が再び動作すること。

その他（回帰）

既存の「レイヤー作成」「コピー」「アクティブ切替」機能が壊れていないか確認。

画面を local file (file://) で直接開いた環境でも問題なく動くか確認（fetch の制約等）。

実装マイルストーン（作業ブロック）

EventBus 安定化（共通 API を統一） — system/event-bus.js をコアに。

layer-system の API 整備 & id 付与 — system/layer-system.js の修正。

描画終了イベントを起点とした thumbnail 更新パス実装 — system/drawing-clipboard.js（あるいは core の描画処理） + ui/timeline-ui.js。

削除 confirm 削除 & history 統合 — ui/ui-panels.js の削除処理修正。

UI 側の完全再描画実装（layers:changed リスナ） — ui/ui-panels.js。

総合テスト（上のテスト項目を実施）+ バグ修正。

パフォーマンス調整（thumbnail throttle 値の調整、requestAnimationFrame でのキュー）

リスクと回避策

パフォーマンス：描画中にサムネイル更新を頻繁に行うと重くなる → デバウンス/スロットリングで回避。まずは即時更新（stroke end）＋ 300ms throttle を推奨。

互換性：既存コードが index ベースで深く結びついている場合は、id 移行で手作業の置換が必要。最初は影響箇所を grep で洗い出して patch を適用する。

history の整合性：即削除にしても undo snapshot を忘れるとデータ喪失に見える → 削除前に完全 snapshot を history に push すること（layer とその renderTexture を含む）。

最終ノート（すぐやれる最短パッチ）

もし「とにかく今すぐ体感を改善したい」なら、まず下記最低限の１パッチを当ててください（レイヤー削除 confirm 削除 + ストローク終了イベントから thumbnail を一度更新）：

ui/ui-panels.js の削除処理から confirm() を削る（上に示したコード）。

system/event-bus.js を整備して layer:stroke:end を emit できるようにする（pointerup ハンドラに一行追加）。

ui/timeline-ui.js に document.addEventListener('layer:stroke:end', handler) を追加し、updateThumbnail(layerId, frame) を一回呼ぶだけにする。

これだけでユーザーが一番気にしている「描いてもサムネイル変わらない」「毎回確認出てウザい」は劇的に改善します。残り（階層移動の根本）は同時に進めるべきですが、優先度は下げても UX 的には許容できるはずです。