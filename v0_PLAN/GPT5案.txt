【概要】
このドキュメントは、v8.13_Based ブランチ（v8.13_History10g）で「PNG/GIF エクスポートが失敗する」問題の原因調査結果と、Claude（後続AI）が素早く改修できるようにした改修計画書です。

要点（先に結論）

* GIFエクスポートの致命エラー：`this.manager.animationSystem.captureAllLayerStates is not a function`
  → animation-system に GIF exporter が期待する公開 API（captureAllLayerStates / restoreFromSnapshots / applyCutToLayers / getAnimationData / getCurrentCutIndex / generateCutThumbnail 等）が実装されていないか、アサインされているオブジェクトが想定の AnimationSystem インスタンスではない。

* PNGエクスポートの致命エラー：`Cannot read properties of undefined (reading 'updateLocalTransform')`
  → Pixi のレンダラーが渡された `container` オブジェクトに対して `updateLocalTransform` を呼び出そうとしたが、`container` が undefined か、Pixi の DisplayObject（Container等）ではない。具体的には `ExportManager.renderToCanvas()` が参照する `layerSystem.layersContainer` が未定義、または初期化順序が不正で ExportManager 作成時に正しい参照が渡されていない。

設計方針（ユーザーの制約準拠）

* PixiJS v8.13 固有 API に合わせる。
* ES2023、モジュール無し、ローカル file:// で動く形で修正。
* ベクターペン主体なのでデータ所有権（layerData 等）は触りすぎない。API と命名を厳格に定義する。
* フェイルセーフでの暗黙修復は禁止。明確なバリデーションとエラーを出す。
* コンソールログは最小限（重要なエラー / 開発用 WARN のみ）。

改修サマリ（ファイル毎）

1. system/animation-system.js — 必須公開 API を実装

* 目的: GIFエクスポーターが期待する API を提供する。

* 追加（必須）メソッド（名前／シグニチャ）：

  * captureAllLayerStates() → Array<Snapshot>
  * restoreFromSnapshots(snapshots) → void
  * applyCutToLayers(cutIndex) → void
  * getAnimationData() → { cuts: [...] }
  * getCurrentCutIndex() → number
  * generateCutThumbnail(cutIndex) → void  (UI 呼び出し用は既に利用箇所あり)

* 実装方針（簡潔）:

  * Snapshot は「非破壊」で十分な情報のみを保持する。例: { layerId, visible, alpha, x, y, scaleX, scaleY, rotation }
  * captureAllLayerStates は layerSystem.getLayers()（または layerSystem 内の公開 API）を使って各レイヤーの状態を取得して返す。
  * restoreFromSnapshots は snapshot を受け取り layerSystem のレイヤーに一括で適用する（破壊的にレイヤーを削る/作るのではなく、表示状態と transform を復元する）。
  * applyCutToLayers は animation data（cut の定義: 各 cut が保持する layer state）を layerSystem に適用する。animationSystem 内で cut -> layer のマッピングが必要。
  * getAnimationData は animator の内部データ構造をそのまま返す（ただし参照渡しは避け、必要なら shallow copy を返す）。

* サンプル実装（抜粋: 追加コード）:

```javascript
// animation-system.js — 追加メソッドの例（簡易、安全第一）
AnimationSystem.prototype.captureAllLayerStates = function() {
  if (!this.layerSystem) throw new Error('AnimationSystem: layerSystem is not assigned');
  const layers = this.layerSystem.getLayers();
  return layers.map(layer => ({
    layerId: layer.layerData?.id ?? null,
    visible: !!layer.layerData?.visible,
    alpha: typeof layer.alpha === 'number' ? layer.alpha : (layer.layerData?.opacity ?? 1.0),
    x: layer.x ?? 0,
    y: layer.y ?? 0,
    scaleX: layer.scale?.x ?? 1,
    scaleY: layer.scale?.y ?? 1,
    rotation: layer.rotation ?? 0
  }));
};

AnimationSystem.prototype.restoreFromSnapshots = function(snapshots) {
  if (!this.layerSystem) throw new Error('AnimationSystem: layerSystem is not assigned');
  const layers = this.layerSystem.getLayers();
  // レイヤー順が同一である前提。ただし layerId があれば照合して当てる
  snapshots.forEach(snap => {
    const layer = layers.find(l => (l.layerData?.id ?? null) === snap.layerId) || layers.shift();
    if (!layer) return; // 無ければ無視
    if (typeof snap.visible === 'boolean') layer.visible = snap.visible;
    if (typeof snap.alpha === 'number') layer.alpha = snap.alpha;
    if (typeof snap.x === 'number') layer.x = snap.x;
    if (typeof snap.y === 'number') layer.y = snap.y;
    if (typeof snap.scaleX === 'number') layer.scale.x = snap.scaleX;
    if (typeof snap.scaleY === 'number') layer.scale.y = snap.scaleY;
    if (typeof snap.rotation === 'number') layer.rotation = snap.rotation;
  });
};

AnimationSystem.prototype.getAnimationData = function() {
  // 内部データ構造（this.animData など）を返す。参照渡しは避ける。
  return this.animData ? JSON.parse(JSON.stringify(this.animData)) : { cuts: [] };
};

AnimationSystem.prototype.getCurrentCutIndex = function() {
  return typeof this.currentCutIndex === 'number' ? this.currentCutIndex : 0;
};

AnimationSystem.prototype.applyCutToLayers = function(cutIndex) {
  const animData = this.getAnimationData();
  const cut = animData.cuts[cutIndex];
  if (!cut) throw new Error(`AnimationSystem: cut ${cutIndex} not found`);
  // cut.layers : [{layerId, visible, alpha, x,y, ...}] 等を想定
  if (!cut.layers || !Array.isArray(cut.layers)) return;
  const layers = this.layerSystem.getLayers();
  cut.layers.forEach(layerState => {
    const layer = layers.find(l => (l.layerData?.id ?? null) === layerState.layerId);
    if (!layer) return;
    if (typeof layerState.visible === 'boolean') layer.visible = layerState.visible;
    if (typeof layerState.alpha === 'number') layer.alpha = layerState.alpha;
    if (typeof layerState.x === 'number') layer.x = layerState.x;
    if (typeof layerState.y === 'number') layer.y = layerState.y;
    // scale/rotation 等も同様
  });
};
```

※ この実装は「既存の layerSystem.getLayers() が正しく Pixi Container を返す」ことを前提にしています。

2. system/export-manager.js / system/exporters/png-exporter.js / system/gif-exporter.js — 明確な入力バリデーションを追加

* 目的: 早期に原因を検出し、わかりやすいエラーに置き換える（暗黙の回復はしない）。

* 追加方針:

  * renderToCanvas の最初で `if (!container || typeof container.updateLocalTransform !== 'function') throw new Error('ExportManager.renderToCanvas: invalid container');`
  * PNGExporter.export と GIFExporter.exportGIF の冒頭で `if (!this.manager || !this.manager.layerSystem) throw new Error('...')`
  * GIF の backupSnapshots 呼び出しは `if (typeof this.animationSystem.captureAllLayerStates !== 'function') throw new Error('AnimationSystem.captureAllLayerStates missing')`

* サンプル修正（ExportManager.renderToCanvas）:

```javascript
renderToCanvas(options = {}) {
  const container = options.container || this.layerSystem?.layersContainer;
  if (!container) throw new Error('ExportManager: layers container is not available. Ensure ExportManager was constructed after LayerSystem initialization and that layerSystem.layersContainer is a PIXI.Container.');
  if (typeof container.updateLocalTransform !== 'function') throw new Error('ExportManager: provided container is not a PIXI DisplayObject');
  // ... 以降は既存処理
}
```

* GIFExporter 側でも同様に早期検査:

```javascript
if (!this.animationSystem) throw new Error('GIFExporter: animationSystem not assigned');
if (typeof this.animationSystem.captureAllLayerStates !== 'function') throw new Error('GIFExporter: required method captureAllLayerStates missing in AnimationSystem');
```

3. core-runtime.js / core-engine.js — 初期化順序の明確化と責務分離ドキュメントを追記

* 目的: ExportManager や UI が未初期化のオブジェクトを参照してしまう初期化順序不備を排除。

* 方針:

  * コア初期化フローを一箇所（core-runtime.js）に集約し、順序を明記する（例: 1. EventBus, 2. StateManager, 3. LayerSystem, 4. AnimationSystem, 5. CameraSystem, 6. ExportManager, 7. UI）。
  * ExportManager は layerSystem, animationSystem をコンストラクタで受け取るが、受け取り時点で未初期化の可能性があるなら setLayerSystem/setAnimationSystem を持たせ、`validate()` を呼ぶ設計を採る（ただし暗黙の遅延初期化は最小限）。

* 追加ドキュメント例（core-runtime.js の最上部コメント形式）:

```
Initialization order (must be preserved):
1. EventBus
2. StateManager
3. LayerSystem (provides getLayers(), layersContainer)
4. AnimationSystem (depends on LayerSystem)
5. CameraSystem
6. ExportManager (depends on LayerSystem & AnimationSystem)
7. UI
```

4. system/layer-system.js — layersContainer の公開性を確認

* 目的: レンダリング用 root container を必ず `layersContainer` として公開する契約を明確化。
* チェック: `this.layersContainer` が `PIXI.Container`（もしくは DisplayObject）であるか、`getLayers()` が期待する配列を返すか。
* 変更点: ファイル先頭に small API doc-comment を追記。

追加検査＆テスト手順（実務）

1. 開発ブランチで unit-like quick check を行う:

   * console で `window.TegakiLayerSystem` / `window.TegakiAnimationSystem` / `window.ExportManager` が定義済みか確認。
   * `typeof window.TegakiAnimationSystem.captureAllLayerStates` が 'function' であることを確認。
   * `window.TegakiLayerSystem.layersContainer instanceof PIXI.Container` を確認。
2. エクスポート試験（手順）:

   * PNG: UI から PNG を選択 -> 失敗時はエラーメッセージをそのまま表示（詳細は DevTools）。
   * GIF: UI から GIF を選択 -> 同上。
3. もし上の関数が未だ無ければ、animation-system.js に上記サンプルを追加し再試行。

改修の優先順位（短期→中期）

* 優先 (1-2日): ExportManager の入力バリデーション追加、GIFExporter の存在チェック、PNG エラー原因の早期検出メッセージ化。
* 優先 (2-4日): animation-system に capture/restore/applyCut 系の最小実装を追加（UI やアセットの壊滅を避けるために浅いコピーで実装）。
* 中期 (4-7日): core-runtime の初期化フローを明文化し、コンストラクタで渡すオブジェクトの「契約」をJS Doc 化。
* 改善 (任意): animationSystem の単体テスト（簡易 smoke test）追加。

付録: 具体的パッチ案（差分スタイル）

* animation-system.js に以下を追加する（ファイル末尾に diff で貼る想定）:

```diff
+ // === GIF/Png Exporter 用の互換 API ===
+ AnimationSystem.prototype.captureAllLayerStates = function() { ... }
+ AnimationSystem.prototype.restoreFromSnapshots = function(snapshots) { ... }
+ AnimationSystem.prototype.applyCutToLayers = function(cutIndex) { ... }
+ AnimationSystem.prototype.getAnimationData = function() { ... }
+ AnimationSystem.prototype.getCurrentCutIndex = function() { ... }
+
```

* export-manager.js の renderToCanvas 先頭に以下挿入:

```diff
+ const container = options.container || this.layerSystem?.layersContainer;
+ if (!container) throw new Error('ExportManager.renderToCanvas: layers container missing. Ensure LayerSystem initialized before ExportManager.');
+ if (typeof container.updateLocalTransform !== 'function') throw new Error('ExportManager.renderToCanvas: container is not a PIXI display object');
```

最後に（実装時のヒント）

* 既存コードは UI/History 側で `window.History._manager.isApplying` 等の後方互換アクセサを使っているため、既存の public surface を壊さない範囲で実装すること。
* Snapshot の保存は軽量に。GIF 作成時に大量のデータコピーを行うとメモリが爆発するため、必要最小限のプロパティに絞る。
* `restoreFromSnapshots` は、存在しないレイヤー参照を無視して安全に復元する。

---

このドキュメントは .txt での納品を前提としています。実際のパッチ（差分）を作る場合は、上記のサンプルをベースに小さなコミット単位で作業してください。変更時は必ず `core-runtime.js` の初期化順を確認の上、Export 関連を再検証してください。

以上です。必要ならこのまま具体的な `animation-system.js` への差分パッチ（完全なコード）を作成します。
