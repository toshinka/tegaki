まとめ（先に結論）

①（History/Undo の異常増加）
原因（高確度推定）：History スタックの設計がコマンド（操作）単位で分離されておらず、undo 実行中に副作用として「新しい CUT（またはUT）」を生成する処理が混入している／同じ操作が複数回 push されている（イベントの重複登録・コールバックの二重呼び出し）。
改修方針：Command パターン（do()/undo()）で操作を明確に分離し、History は純粋に命令の push/pop のみ担当。副作用（UI再描画・サムネ生成等）はコマンドの外で行うか、コマンド内でも「undo時は push しないフラグ」を厳格に扱う。イベントリスナ重複は一箇所で防ぐ。

②（全カット時間変更アイコンの重なり）
原因（高確度推定）：timeline のコントロール要素を同じ親 container 内で絶対配置／重ね書きしている。DOM/CSS のレイアウトが固定幅に依存しているため、数値入力枠の内側にアイコン群が重なっている。
改修方針：DOM を構造的に分離（左：数値入力 / 中央：数値 / 右：アイコン列）し、CSS は柔軟な display:flex を採用。PixiDOM（HTML UI）なら DOM 側で再レイアウト。アイコンは独立要素として左右並列にする。

詳細原因（想定されるコードパターンと問題箇所）

① History 増加が止まらない — よくあるパターン

history.push(state) を呼ぶ箇所が多く、undo 中のロジックにも無条件で push している。→ undo をやっても新しい push がされるためスタックが増える。

イベントバインドが複数回されている（例：timeline のリセットやレンダラ更新時に同じ onClick を addEventListener している）。結果、1回の操作で複数回 push。

Undo実行時に UI 再構築のため CUT を再生成する処理が走り、その再生成でまた history.push が呼ばれる（循環副作用）。

② UI 重なり — よくあるパターン

アイコン群が position:absolute / 親 container の相対位置内に配置され、親の幅が狭まると重なる。

数値入力を入れる枠（inner box）が overflow:hidden でアイコンを隠したり、逆に上書きしたりしている。

DOM 構造が「数値レイヤ」と「アイコンレイヤ」を同じ要素で表現している（分離不足）。

改修計画（優先度順・実施手順・担当ファイル付き）
A. 緊急（必須） — History の修正（blocker）

目的：undo 時に history カウントが増え続ける不具合を解消する。
ファイル：system/history.js, system/animation-system.js（該当する操作呼び出し部）, ui/timeline-ui.js（イベント登録チェック）
手順（実作業）：

History を Command パターンに置換（段階的）

既存 history.push(state) 型をすべて検索（find）して、直接 push する呼び出しを一旦ラップする History.execute(command) を作る。

command は以下の形（擬似）に統一する：

// system/history.js 追加（シンプル実装）
const History = (function(){
  const stack = [];
  let pos = -1;
  return {
    execute(command){
      // command: { do: fn, undo: fn, meta: {...} }
      // 実行中に history に push されないよう、ここでのみ push を行う
      command.do();
      pos++;
      stack.splice(pos, stack.length - pos, command);
    },
    undo(){
      if(pos < 0) return;
      const cmd = stack[pos];
      if(cmd && typeof cmd.undo === 'function') {
        // undo 実行中に別の箇所が History.execute を呼ばないこと
        cmd.undo();
        pos--;
      }
    },
    redo(){
      if(pos + 1 >= stack.length) return;
      pos++;
      const cmd = stack[pos];
      cmd.do();
    },
    // debug / getState
  };
})();


目的：do() と undo() の中で 直接 History.execute を呼ばない ルールを守れば、undo 中に別の push が発生しない。

既存の「state シリアライズ push」を Command に変換

例：CUT を追加する処理は、AddCutCommand = { do: addCut, undo: removeCut } にして History.execute(new AddCutCommand(...)) を呼ぶ。

既存コードは段階的にラップしていき、すべての UI 操作（CUT追加、UT追加、時間変更、レイヤ追加など）をコマンド化する。

イベントリスナの重複防止

ui/timeline-ui.js の初期化関数は idempotent（何度呼んでも副作用が無い） にする。

element.removeEventListener(...); element.addEventListener(...); で必ず remove を行うか、once オプション、もしくは初期化を一回だけ行うフラグ initialized = true を持つ。

例：

function initTimelineUI(){
  if(window._timelineInitDone) return;
  window._timelineInitDone = true;
  // ... bind listeners
}


undo 実行時の副作用切り分け

undo/redo 中は「サムネ再生成」「外部 API 呼び出し（gif-exporter 等）」を suppress するフラグ History.isUndoing を導入し、外部処理側はそのフラグを尊重して push をしない／重い処理を行わないようにする。

ただしこれは暫定手段。根本は「History.execute の外で副作用を発生させないこと」。

メモリ参照のコピー

History にオブジェクト参照を push している場合、将来の状態変更で History 内の過去 state が変化する問題がある（参照渡し）。必ず deep clone で保存する（ただしサイズ注意）。Command パターンでは undo() に必要最小限の情報だけ保持するため clone を小さく出来る。

実施サンプルパッチ（抜粋）
system/history.js を上書きする形で下記を入れる（簡易実装）：

// system/history.js (simple command stack)
const History = (function(){
  const stack = [];
  let pos = -1;
  return {
    execute(command){
      // command: { do:fn, undo:fn, meta:object }
      if(typeof command.do !== 'function') throw new Error('command must have do()');
      command.do();
      pos++;
      stack.splice(pos, stack.length - pos, command);
    },
    canUndo(){ return pos >= 0; },
    canRedo(){ return pos + 1 < stack.length; },
    undo(){
      if(pos < 0) return;
      const cmd = stack[pos];
      if(cmd && typeof cmd.undo === 'function'){
        cmd.undo();
        pos--;
      }
    },
    redo(){
      if(pos + 1 >= stack.length) return;
      pos++;
      const cmd = stack[pos];
      if(cmd && typeof cmd.do === 'function') cmd.do();
    },
    clear(){ stack.length = 0; pos = -1; },
    getStack(){ return stack.slice(); }
  };
})();


AddCut の呼び出しは以下のように置き換え：

// 旧: addCut(cutData); historyPush(...)
const addCutCmd = {
  do: () => addCut(cutData),
  undo: () => removeCutById(cutData.id)
};
History.execute(addCutCmd);


補足：addCut と removeCutById は 副作用を持たない純粋なデータ操作 にする。UI 更新は呼び出し元で行う。

B. UI 修正（中優先）

目的：全カット時間変更アイコン群を重ならないように独立配置して左右並べにする。
ファイル：ui/timeline-ui.js, ui/timeline-thumbnail-utils.js（関係するDOM生成箇所）
手順：

DOM 構造を下記のように変更（HTML 想定）：

<div class="time-control">
  <div class="time-input-wrap"> <!-- 左寄せ -->
    <label>全カット時間</label>
    <input type="number" class="time-input" />
  </div>
  <div class="time-value-wrap"> <!-- 中央（必要なら）-->
    <input type="number" class="time-value" />
  </div>
  <div class="time-action-wrap"> <!-- 右寄せ：アイコン等 -->
    <button class="icon-btn set-all">Set</button>
    <button class="icon-btn reset-all">Reset</button>
  </div>
</div>


CSS（シンプル、flex）：

.time-control {
  display: flex;
  gap: 8px;
  align-items: center;
  padding: 4px;
}
.time-input-wrap { flex: 0 0 auto; display:flex; gap:6px; align-items:center; }
.time-value-wrap { flex: 1 1 auto; display:flex; }
.time-action-wrap { flex: 0 0 auto; display:flex; gap:6px; }
.icon-btn { min-width:28px; height:28px; border-radius:4px; }


ポイント：flex にすることで、親幅が狭くなっても横並びを維持。必要ならレスポンシブで列に落とす。

JavaScript 側では DOM を直接編集しているなら、構造変更に対応する。timeline-ui.js の生成コードを置き換え、既存の絶対配置スタイルを削除。

簡易パッチ（timeline-ui.js）抜粋

function createGlobalTimeControl(){
  const wrapper = document.createElement('div');
  wrapper.className = 'time-control';

  const left = document.createElement('div');
  left.className = 'time-input-wrap';
  left.innerHTML = '<label>全カット時間</label>';
  const input = document.createElement('input');
  input.type = 'number';
  input.className = 'time-input';
  left.appendChild(input);

  const center = document.createElement('div');
  center.className = 'time-value-wrap';
  // add center elements if needed

  const right = document.createElement('div');
  right.className = 'time-action-wrap';
  const setBtn = document.createElement('button'); setBtn.className='icon-btn set-all'; setBtn.textContent='Set';
  const resetBtn = document.createElement('button'); resetBtn.className='icon-btn reset-all'; resetBtn.textContent='Reset';
  right.appendChild(setBtn); right.appendChild(resetBtn);

  wrapper.appendChild(left);
  wrapper.appendChild(center);
  wrapper.appendChild(right);

  return wrapper;
}

C. 追加の設計改善（長期、推奨）

命令合成（バッチ）：複数の低レベル変更（例：複数 CUT に対する時間変更）を一つの BatchCommand にまとめ、do と undo を一度で行えるようにする。UI で「全カットに適用」等を押すと履歴が一つになる（これで undo 回数が増えすぎる問題を抑止）。

イベントハブの見直し：system/event-bus.js で event 名を厳密化し、リスナが重複登録されないよう、on / off の API を整備する。

History のサイズとメモリ：deep clone を避けるため Command に必要最小限の差分データだけ持たせる（例：oldValue/newValue）。

テスト用ユニットシナリオ：自動化は難しくても、手順化した再現テストケースを tests/history-tests.md のように作る。

検証手順（再現性のあるテストケース）

検証1（History）

ツール起動 → 新規 CUT を追加（UTも追加） → History スタックが 1 つ増えることを確認（History.getStack().length）。

追加した CUT に対して undo を 1 回実行 → CUT が削除される。History.getStack().length が減っていることを確認。

同じ操作を何回か繰り返す（追加→undo→redo→add別のCUT）して、stack が不自然に増えないこと。

複数 UT を増やした後、undo を数回実行し History カウントが戻る（増え続けない）。

UI で操作する際、コンソールに history.push を呼ぶ箇所が無いか確認（不要な push は無くなっている）。

検証2（UI レイアウト）

画面幅を狭める／広げる → 全カット時間のアイコンが重ならず左→中央→右に並ぶ。

アイコンを押したときのクリック領域とツールチップが正しく動く。

開発注意点（あなたの改修ルールに合わせた運用）

PixiJS のレンダリングと UI（DOM）は明確に分離する。タッチイベントやドラッグは Pixi のイベントを使い、フォームやアイコン等の細かい UI は HTML DOM に置く（今回の timeline コントロールは DOM 側で良い）。

「曖昧な動作・自動修復」は禁止とのことなので、undo の副作用 suppression は明確に History の中で制御し、他の箇所が勝手に history.execute を呼べないアーキテクチャにする。

console.log は最小限に。検証情報は dev-only フラグで出す設計にする。

細かい差分（すぐ入れられる最小修正：hotfix）

もし今すぐ最小限の修正を入れたい（リスク低、まず試すべき）なら下記 2 点を行ってください。

system/history.js に「undo 実行中フラグ」を導入（短時間でできる、既存コードの侵襲少）：

// 既存 history オブジェクトに追加
History._isUndoing = false;
History.undo = function(){
  if(this._isUndoing) return;
  this._isUndoing = true;
  try {
    // 既存 undo 処理
  } finally {
    this._isUndoing = false;
  }
};


そして他所の push 実行箇所を if(History._isUndoing) return; でガードする。

ui/timeline-ui.js のアイコン要素を absolute => flex に変える（短い CSS 差し替え）。前述 CSS をぶち込むだけでレイアウトは改善する。

これらは 暫定的 で、最終的にはコマンドパターンへの移行を強く推奨します。

リスクと注意点

History の設計変更はツール全体に影響するため段階的に移行する。まずは「既知の操作（CUT/UT の追加・削除・時間変更）」から Command 化してテストを回す。

Deep clone を乱用するとメモリ消費が大きくなる（大きな画像など）。Command は「差分」を保持するスタイルが理想。

DOM/CSS 変更は他 UI に影響する可能性があるため、既存の UI コンポーネントで CSS クラス名が被らないよう名前空間を付ける（例：.tgk-time-control のように接頭辞）。