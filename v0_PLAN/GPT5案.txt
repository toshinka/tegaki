改修計画書：Undo / Redo（統一履歴管理）調査・設計・実装プラン
===============================================================================
対象リポジトリ（参照ファイル）
- index.html
- config.js
- coordinate-system.js
- system/event-bus.js
- system/camera-system.js
- system/layer-system.js
- system/drawing-clipboard.js
- system/history.js         ← 現状履歴関連（調査する起点）
- system/animation-system.js
- system/gif-exporter.js
- ui/timeline-ui.js
- ui/ui-panels.js
- ui/timeline-thumbnail-utils.js
- core-runtime.js
- core-engine.js

目的
- 「絵（ストローク・ピクセル）」「CUT（タイムラインのカット構造）」「レイヤー」など複数ドメインにまたがる操作のUndo/Redoを1箇所で一貫して扱えるようにする。
- 二重実装や責務分散による不整合を解消し、可読性と保守性を高める。
- パフォーマンス上の現実的配慮（大きなビットマップのコピーをむやみにやらない）を取り入れる。

設計方針（高レベル）
- 単一の履歴管理（HistoryManager）を採用する。UIや各サブシステムは全てこのManagerに対してコマンドを送る/コマンドを実行させる。
- コマンドパターン（Command）を用いる：各操作は "execute()" と "undo()" を持つ自己完結型オブジェクトとして表現する。コマンドは直列に積まれ、undo/redoはそのスタック/ポインタで制御する。
- データ所有権の明確化：どのモジュールがどのデータの“ソース・オブ・トゥルース”（truth）を保つかを定義する（例：LayerSystem がレイヤーオブジェクトを所有、AnimationSystem がCUT構造を所有、Drawing 系はストロークデータを所有）。
- 「差分（Delta）保存」優先：可能な限り軽量な差分（例：ストロークオブジェクト、レイヤーメタの変更）を保存する。ビットマップそのものの差分保存が不可避な場合は、参照式（Texture ID）＋最小バイナリ保存戦略を採る。
- シンプルで可検証なAPI：HistoryManager は (1) applyCommand(command) (2) undo() (3) redo() (4) clear() だけを公開する。
- event-bus と統合：既存の event-bus を通じて各種サブシステムが "command" を HistoryManager に渡す。UI は直接状態を書き換えない（※例外：読み取り系/表示系）。

用語定義
- Command：execute()/undo() を持つオブジェクト（serialize可能推奨）。例：DrawStrokeCommand, CreateLayerCommand, DeleteLayerCommand, MoveCutCommand
- HistoryEntry：コマンド + メタ（タイムスタンプ, 作者, undoable:true/false）
- State Owner：データの単一所有者（例：layerSystem.layers[] は LayerSystem が sole owner）
- Snapshot：大きな操作（例：全レイヤー削除）の安全対策として使う（全体状態の薄いスナップショット or 圧縮差分）

実装案（APIとサンプルコード：ES2023、モジュール無し、PixiJS 環境前提）
（注）実運用では既存 system/history.js をリファクタして HistoryManager を統合することを勧める。

1) Command interface（抽象）
```js
// Command インターフェイスの雛形（要実装）
function Command(name) {
  this.name = name || 'unnamed';
}
Command.prototype.execute = function() { throw new Error('execute not implemented'); };
Command.prototype.undo = function() { throw new Error('undo not implemented'); };
// optional: serialize/deserialize for persistence
Command.prototype.serialize = function() { return { name: this.name }; };


2.HistoryManager（単一インスタンスで管理）

// HistoryManager（単純実装）
function HistoryManager(maxEntries = 200) {
  this.past = [];   // 実行済みコマンド（undo 用）
  this.future = []; // 取り消したコマンド（redo 用）
  this.maxEntries = maxEntries;
  this.onChange = null; // UI 更新コールバック (optional)
}
HistoryManager.prototype.applyCommand = function(command) {
  // command: must implement execute() and undo()
  command.execute();
  this.past.push(command);
  if (this.past.length > this.maxEntries) this.past.shift();
  this.future = []; // 新コマンド実行で redo 履歴クリア
  if (this.onChange) this.onChange();
};
HistoryManager.prototype.undo = function() {
  if (!this.past.length) return false;
  var cmd = this.past.pop();
  cmd.undo();
  this.future.push(cmd);
  if (this.onChange) this.onChange();
  return true;
};
HistoryManager.prototype.redo = function() {
  if (!this.future.length) return false;
  var cmd = this.future.pop();
  cmd.execute();
  this.past.push(cmd);
  if (this.onChange) this.onChange();
  return true;
};
HistoryManager.prototype.clear = function() {
  this.past = [];
  this.future = [];
  if (this.onChange) this.onChange();
};


3.具体的コマンド例（ストローク）

// ストロークを保持する方針（ベクタデータ推奨）
// drawSystem.addStroke(stroke) / removeStroke(strokeId)
function DrawStrokeCommand(drawSystem, stroke) {
  this.name = 'DrawStroke';
  this.drawSystem = drawSystem;
  this.stroke = stroke; // 可能な限りオブジェクト参照（serialize可能にする）
}
DrawStrokeCommand.prototype.execute = function() {
  this.drawSystem.addStroke(this.stroke);
};
DrawStrokeCommand.prototype.undo = function() {
  this.drawSystem.removeStroke(this.stroke.id);
};
DrawStrokeCommand.prototype.serialize = function() {
  return { name:this.name, stroke: this.stroke };
};


4.レイヤー操作コマンド例

function CreateLayerCommand(layerSystem, layerData) {
  this.name = 'CreateLayer';
  this.layerSystem = layerSystem;
  this.layerId = null;
  this.layerData = layerData;
}
CreateLayerCommand.prototype.execute = function() {
  var layer = this.layerSystem.createLayer(this.layerData);
  this.layerId = layer.id;
};
CreateLayerCommand.prototype.undo = function() {
  this.layerSystem.deleteLayer(this.layerId);
};


5.CUT（タイムライン）操作コマンド例

// cutData は最小限のメタ情報（index, length 等）
function CreateCutCommand(animationSystem, cutData) {
  this.name = 'CreateCut';
  this.animationSystem = animationSystem;
  this.cutData = cutData;
  this.cutId = null;
}
CreateCutCommand.prototype.execute = function() {
  this.cutId = this.animationSystem.createCut(this.cutData);
};
CreateCutCommand.prototype.undo = function() {
  this.animationSystem.deleteCut(this.cutId);
};

データ戦略（設計上の判断）

描画（ストローク主体）：

ベクタ（ストロークオブジェクト）を履歴に保存 → 再レンダリングでラスタ描画（Pixi RenderTexture を使う）

既にラスタ（ピクセル）編集が多用される場合は、レイヤーごとの局所的スナップショットを採用（例：そのフレームのTextureのコピーをHistoryEntryに格納）。ただしメモリ増大に注意。

レイヤー / CUT / メタ：

小さいJSON差分（追加・削除・プロパティ変更）をコマンドで持つ。image dataが必要ならTexture IDやBlob参照を持つ。

大きな破壊的操作（例：全レイヤー削除、全フレーム置換）：

Optional: "SnapshotCommand" を用意し、実行時に最小圧縮スナップを取る（例：各レイヤーのメタ＋重要テクスチャのBlob URL）。但し滅多に使わない操作だけに限定。

既存コードとの統合ポイント

system/history.js：現在の履歴ロジックを読み取り、責務が分散している箇所（複数のundo実装）を特定する。ここを改名/置換して HistoryManager をエクスポートする。

system/drawing-clipboard.js：クリップボード関連の copy/paste 操作は、ClipboardCommand を通す。Clipboard 実行は履歴に残す/残さないを明示 (例：paste は undoable)。

system/layer-system.js：レイヤーのcreate/delete/move/merge API を最小で提供し、コマンドはそのAPIを叩く。レイヤーAPIは副作用を持たない（状態は LayerSystem が内包）。

system/animation-system.js（CUT）：CUT の追加・削除・並べ替えはすべて Command 経由にする。

ui/timeline-ui.js, ui-panels.js：UI のイベントハンドラは直接 Model を変更せず、Command を生成して HistoryManager.applyCommand(cmd) を呼ぶ。UI は onChange で履歴状態を反映（Undo ボタン活性等）。

移行手順（ステップ・バイ・ステップ）

調査フェーズ（1日）

system/history.js の全コードと、他ファイル内で "undo"/"redo" を呼んでいる箇所をgrepで抽出。

二重実装（複数箇所で状態を revert している）パターンを列挙。

各操作（ストローク追加、レイヤー作成、CUT変更、パラメタ変更、消しゴム適用など）がどのモジュールでどのように実装されているかを一覧化。

設計・合意（0.5日）

上記設計方針をチーム内で確認。特に「ベクタ保存へ移行するか」「ラスタをそのまま保存するか」を決定。

最小リファクタ（1-2日）

HistoryManager の骨格を system/history.js に実装（applyCommand/undo/redo/clear）。

既存の undo 呼び出しをすべて HistoryManager 経由に差し替える（UI 側から直接 state 変更している箇所を Command 化）。

event-bus を介してコマンド登録ができるようにする（例：eventBus.emit('command.apply', cmd)）。

コマンド実装（2-4日）

代表的なコマンドを実装・テスト（DrawStrokeCommand, EraseStrokeCommand, CreateLayerCommand, DeleteLayerCommand, MoveLayerCommand, CreateCutCommand, DeleteCutCommand）。

各コマンドは小さな単位で実装→テスト→マージ。

互換レイヤ（1日）

既存履歴データや過去エントリがある場合の互換ロジックを実装（旧 API 呼び出しをラップして新 Command を呼ぶ）。

ベンチ＆メモリ改善（1-2日）

大きい操作のメモリ使用を測定。必要に応じて差分圧縮や参照の導入（Blob URL / offscreen storage）を検討。

総合テスト（1-2日）

Undo/Redo のシーケンステスト（複合操作：ストローク→レイヤー移動→CUT挿入→Undo×3→Redo×2 など）

保存→読み込みでHistoryの互換性テスト（必要なら履歴は保存しないと決める）

ドキュメント化（0.5日）

履歴の設計図、API一覧、Command 作り方のテンプレートを README 等に記載。

ファイル差分（概略）

system/history.js : 既存を整理 → HistoryManager 実装 + export

system/event-bus.js : 'command.apply' 等イベントを統一して受け渡し可能に

system/layer-system.js : create/delete/move/merge の明確API（副作用はここだけ）

system/drawing-clipboard.js : クリップボード関連コマンド化

ui/timeline-ui.js / ui-panels.js : 直接 state 書換え部分をコマンド経由に置換

core-runtime.js / core-engine.js : 起動時に HistoryManager を初期化し、UI へ参照を渡す

ベストプラクティス / 注意点

UI は状態を直接書き換えない：必ず Command を通す。読み取りだけは直接OK。

イベント発火は idempotent（副作用が一度だけ起こる）にする。Command の execute() は副作用が1回のみ起きる事を守る。

重いビットマップコピーは避け、替わりに「参照（textureId）」＋「必要時に再生成」を多用する。

Command の undo は必ず execute の逆作用を行うこと（エッジケース：execute が非同期処理を伴う場合は Promise 統一が必要）。

非undoable操作（例：ログ収集など）を履歴に入れないフラグを用意すること。

リスクと対応策

メモリ急増（ビットマップコピーが多い）→ 差分化／上限（maxEntries）を厳格に設定。重要な状態のみ保存。

非同期処理中のUndo/Redo競合→ コマンドを同期化するか、Promiseベースで完了を待つ設計にする（ただし UI ブロッキングは最小化）。

既存コードが密結合で分離困難→ 段階的リファクタ（ラッパー関数で一旦吸収）を行い、徐々に置換。

テストケース（最小必須）

単純描画を1本描き、undo→レイヤー上から消える。redo→復活する。

レイヤー作成→ストローク描画→レイヤー削除→undoでレイヤーとストローク両方復元。

CUTの挿入/削除/順序変更を行い、複合的にundo/redoして整合性が保たれること。

大量コマンド（>1000）を実行してもメモリ上限でクラッシュしない（maxEntries の効果）。

クリップボード paste → undo で元に戻る（クリップの参照が壊れない）。

移行チェックリスト（作業時）

 全ての UI イベントハンドラをスキャンし、直接状態変更している箇所をリスト化したか

 system/history.js の既存関数を保ちつつ新 HistoryManager を導入したか（段階的移行）

 Command の命名規則ドキュメント（CreateXCommand 等）を用意したか

 ストロークは可能ならベクタで保存する方針に移行したか（短期で難しければラスタ参照戦略で暫定対応）

 undo/redo ボタンの状態（enable/disable）は HistoryManager.onChange で一元更新しているか

実装テンプレート（最小・現場で使えるスニペット）

// グローバル初期化（core-runtime.js 等）
window.APP = window.APP || {};
APP.history = new HistoryManager(300);
APP.eventBus = EventBus.get(); // 既存の event-bus
// UI ボタンと紐づけ
document.getElementById('btnUndo').addEventListener('click', function(){ APP.history.undo(); });
document.getElementById('btnRedo').addEventListener('click', function(){ APP.history.redo(); });
APP.history.onChange = function(){ updateUndoRedoUI(APP.history); };


運用方針（開発中）

開発中は maxEntries を小さく（50）にして挙動確認 → 本番向けに調整。

重大な操作（例：レイヤー結合やフルエクスポート）はユーザ確認ダイアログを必須にしてからコマンドを適用。

将来的に「履歴保存（セッション復元）」をする場合は、Command の serialize/deserialize を実装して JSON に変換できること（ただしセキュリティ考慮）。

まとめ（推奨）

これはリファクタ（中〜大規模）案件：現状の二重実装や責務分散を放置すると将来的なバグコストが大きくなる。段階的な移行でリスクを抑えつつ、まずは HistoryManager の骨格と「UI → Command → HistoryManager → Owner」フローを確立することを強く推奨する。

「どのデータを差分で保存するか」の決定（ストロークはベクタ／ラスタ保存のどちらか）は最初の設計合意で即決する。これが運用コストを大きく左右する。


---

