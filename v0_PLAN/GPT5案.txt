要点（先に結論）

①（History が増え続ける）原因推定
Undo/Redo 実行時に「元に戻す」処理がさらに History に新規 push を発生させている（＝undo の副作用を履歴に記録している）。典型的には「履歴登録関数が操作の起点/undo/redo を区別できていない」か「イベント発火で二重に push される」問題です。

対策（必須）
History 層に「記録抑止フラグ（suspend/recording）」を入れる。Undo/Redo 実行中は push を無効化する。あるいはコマンドパターン（Command オブジェクト）にして undo/redo の実行は履歴の push を呼ばないようにする。

②（全カット時間変更アイコン重なり）対策
UI 側でアイコンと数値入力を独立した要素（左右それぞれ）にして display:flex 相当（Pixi なら Container で位置を固定）で左右並べる。添付図のように左：アイコン、右：数値入力、アイコンは数値の外枠の内側に重ならないように余白を確保。

③（再生ショートカット Shift+Space が効かない）
競合の可能性があるため keydown ハンドラは e.code === 'Space' と e.shiftKey / e.ctrlKey を正確に判定し、e.preventDefault() を呼ぶ。ブラウザや他ライブラリに捕られている場合は別キー（例：Ctrl+Space）へ移行。

④（Shift+Ctrl+N がシークレットと競合）
ブラウザ（Chrome）の Ctrl+Shift+N (シークレット) はブラウザ側で優先され、ページスクリプトから確実にキャンセルできない。同様に Ctrl+N（新規ウィンドウ）も上位にある。したがってブラウザ予約ショートカットを“キャンセル”することは原則不可。代替案として Alt+Shift+N や Ctrl+Alt+N を推奨（競合が少ない）。

⑤（CUT追加を Shift+N にする）
実装は簡単。ショートカット管理ロジックで e.shiftKey && e.code === 'KeyN' を捕まえて追加処理を呼ぶ。ただし Shift+N が OS/IME による影響を受けないか試験要。

具体的改修プラン（優先度付き）

優先度は「致命度／再現性／簡単さ」を勘案しています。

優先度★（最重要） — history.js（①修正）

目的：Undo/Redo 実行中に history.push が入らないようにする。

変更方針

history オブジェクトに suspended（boolean） と withSuspend(fn) ユーティリティを追加。

push() 実行時は if (this.suspended) return;

undo() と redo() の内部で withSuspend(() => { /* 実処理 */ }) を使う。

パッチ例（history.js）

// --- history.js ---
const History = {
  entries: [],
  index: -1, // 現在位置
  suspended: false,

  withSuspend(fn) {
    const prev = this.suspended;
    this.suspended = true;
    try { return fn(); } finally { this.suspended = prev; }
  },

  push(entry) {
    if (this.suspended) return; // ← 重要: undo/redo 中は記録しない
    // 切り詰め
    this.entries = this.entries.slice(0, this.index + 1);
    this.entries.push(entry);
    this.index++;
    // optional: cap length
    if (this.entries.length > 1000) this.entries.shift(), this.index--;
  },

  undo() {
    if (this.index < 0) return;
    const entry = this.entries[this.index];
    // entry は {undo: fn, redo: fn, meta: {...}} という形推奨
    this.withSuspend(() => {
      if (entry && typeof entry.undo === 'function') entry.undo();
      this.index--;
    });
    // 注意：undo によって layer-system 等が自身で push しないよう併せて修正
  },

  redo() {
    if (this.index + 1 >= this.entries.length) return;
    const entry = this.entries[this.index + 1];
    this.withSuspend(() => {
      if (entry && typeof entry.redo === 'function') entry.redo();
      this.index++;
    });
  }
};


補足

entry は単にスナップショットではなくコマンド（undo/redo を持つ）にすることを強く推奨。スナップショット方式なら undo の実行前に状態を差し替えるが、その際も withSuspend で push を抑制する。

layer-system や animation-system で state 変更時に history.push() を呼んでいる箇所を全部見つけ、「外部からの undo/redo 実行時は push を行わない」 仕様に整合させる（つまり push を呼ぶ前に if (History.suspended) return; でも OK）。

優先度★★ — layer-system.js / コマンド化（防御的）

目的：レイヤー/CUT の作成・削除・時間変更などを 必ず Command オブジェクト経由で行う。これにより undo/redo の副作用を局所化できる。

サンプル Command パターン

function createLayerCommand(layerProps) {
  let layerId;
  return {
    redo() {
      layerId = LayerSystem.create(layerProps); // 実際の create は id を返す
    },
    undo() {
      LayerSystem.remove(layerId);
    }
  };
}

// 呼び出し例
const cmd = createLayerCommand({name:'L1'});
cmd.redo();
History.push(cmd);


理由

どの操作がどの undo/redo と対応するか明確。

undo/redo 実行時に push が呼ばれなくなる（History.withSuspend と合わせる）。

優先度★★ — timeline-ui.js（② レイアウト修正）

目的：全カット時間変更 UI のアイコンと数値入力が重ならないように並べる。

実装案（Pixi 上）

const container = new PIXI.Container();

const timeInput = createNumberInput(...); （既存）

const leftIcon = createIconSprite('clock-left');

const rightIcon = createIconSprite('clock-right');

レイアウト：leftIcon.x = 0; timeInput.x = leftIcon.x + leftIcon.width + padding; rightIcon.x = timeInput.x + timeInput.width + padding;

全体幅を container.width にして、必要なら container.pivot で中央揃え。

HTML/CSS（もしDOM要素を使っているなら）

<div class="cut-duration-row">
  <button class="icon left">⏷</button>
  <input class="duration-input" type="number" />
  <button class="icon right">⏵</button>
</div>

.cut-duration-row { display: flex; gap: 8px; align-items: center; }
.duration-input { width: 60px; }


ポイント

「数字入力の大枠（枠線）」と「アイコン」は別要素にする（重ねない）。

アイコンのクリック処理はそれぞれ独立にバインド。

優先度★★ — キーバインド実装修正（③/④/⑤）

目的：ショートカットの安定化とブラウザ予約ショートカット回避案提示。

汎用キーハンドラ（window）

window.addEventListener('keydown', (e) => {
  // 再生/停止: Ctrl+Space (推奨)
  if (e.ctrlKey && e.code === 'Space') {
    e.preventDefault();
    togglePlayPause();
    return;
  }

  // 新規レイヤー: Ctrl+Alt+N (代替: Ctrl+Alt でブラウザ予約回避)
  if (e.ctrlKey && e.altKey && e.code === 'KeyN') {
    e.preventDefault();
    LayerSystem.createNewLayer();
    return;
  }

  // CUT追加: Shift+N
  if (e.shiftKey && !e.ctrlKey && !e.altKey && e.code === 'KeyN') {
    e.preventDefault();
    CutSystem.addCutAtCurrent();
    return;
  }

  // undo/redo: Ctrl+Z / Ctrl+Shift+Z
  if (e.ctrlKey && e.code === 'KeyZ') {
    e.preventDefault();
    if (e.shiftKey) History.redo(); else History.undo();
    return;
  }
});


ブラウザ予約ショートカットについて（重要）

Ctrl+Shift+N（シークレット）や Ctrl+N（新規ウィンドウ）はブラウザが優先するため、ページスクリプトから確実に抑止することはできません。ユーザー側（あなた）には 予約されていないキー を割り当てることを推奨します（例：Ctrl+Alt+N、Alt+Shift+N、F2 など）。

企業向けアプリや Electron の場合はブラウザ外で変更可能ですが、純ブラウザ環境では不可。

改修工程（ファイル／作業リスト）

system/history.js — suspended フラグ実装 + withSuspend + push/undo/redo 修正。（必須）

system/layer-system.js — レイヤー作成/削除を Command 化 or push 呼び出し箇所に if (History.suspended) return; を追加。（必須）

system/animation-system.js / system/gif-exporter.js — animation/timechange の履歴記録箇所を確認・修正。（推奨）

ui/timeline-ui.js — 全カット時間変更 UI を左右独立化してレイアウトを調整。添付図を再現する。（推奨）

core-runtime.js or core-engine.js — キーイベントの集中管理を作成（上で示した汎用ハンドラを採用）。既存の複数箇所に keydown が散らばっているなら統合する。（重要）

ドキュメント更新：README に「ショートカット一覧」「history のコマンド仕様」を明記。（必須）

テスト項目（検証手順）

（各変更後に必ず行う）

新規レイヤー作成 → Undo を何回か実行 → レイヤー数が正しく増減し、History.entries.length が不必要に増えないことを確認。

CUT 追加（Shift+N）/削除 → Undo/Redo を複数回 → 同上。

再生/停止（Ctrl+Space）を押す → 競合なく再生状態が toggle されること。既存の Shift+Space は無効化しておく。

ブラウザのシークレット（Ctrl+Shift+N）を押してもブラウザ側が優先されることを確認（＝ページで抑止できないことを確認して代替ショートカットをデフォルトに設定）。

タイムラインの「全カット時間」UI がアイコンと数値入力で左右分離され、どの画面幅でも重ならないこと。

追加アドバイス（可読性／将来改修しやすくするため）

履歴は Command（undo/redo メソッドを持つオブジェクト）で統一すると、複雑な state も安定して扱える。push は History.push(command) だけに限定。

イベントバスを使っているなら（system/event-bus.js）、History に関するイベントは 単方向（操作 → 履歴） に限定し、undo/redo は直接 History.undo() を呼ぶだけにする。イベント発火で二重記録されないように。

キー定義は設定可能に。ハードコードせず、ユーザー設定（JSON）で keyBindings を読み込むと将来便利。

console.log を減らす（要件どおり）。ただし history のトレース用に開発ビルドでのみ出るデバッグフラグは残すとデバッグしやすい。