改修計画書（プレーンテキスト）
対象ツール：ブラウザお絵かきツール（PixiJS v8.13）
出力形式：.txt（以下そのままコピペ可）
作成日：2025-10-05

--- 概要 ---
現象（報告）
1) Undo が「何もしていないのにHistoryを1消費する」 → 2画で描いたものを1回しか戻せない（実際は複数のHistoryエントリが不要に発生）
2) レイヤー新規作成で History が 2 個増える
3) ショートカットが分散（Shift+Space が二重で再生/停止を持つなど）。キー割当が複数ファイルに散らばっている
4) V（アクティブレイヤー移動）押下が「押しっぱなしで動作が忙しい」：現在は押し続け中に継続的に切替/解除的な動きになっている
5) V（移動モード）で垂直・水平ボタンやショートカット（V+H, V+Shift+H）が効かない

目的
- History の正確さ・一貫性を取り戻す（ユーザー体験と心理的満足度回復）
- ショートカット割当を集中させ、衝突を防ぐ（index.html/config.js/UI/各モジュールで散らばらない）
- Vキーの動作をトグル方式（1回押してON、再度押してOFF）に変更
- Vモード内の垂直・水平操作ショートカットを確実に動作させる
- 全体のAPI・命名の整備、暗黙の状態依存を減らす

--- 根本原因（推定） ---
（ソースを直接精査しての確定ではなく、コード構造と問題発生箇所の典型パターンからの推定）
A) History システムの「粒度」が粗く、複数の内部処理が個別に push している
   - 例：レイヤー作成処理で「レイヤー配列追加」＋「UI選択変更」などでそれぞれ push している
   - 描画時も「stroke開始」「stroke点追加」「stroke終了」などで複数 push され、Undo 単位が分散している
B) 複数モジュールが keydown/keyup を個別に登録している（index.html、config.js、ui パネル、core-runtime 等）
   - その結果、同じキーに対して複数ハンドラが同時に動き、二重実行や競合が発生
C) Vキーは現在「keydown: enable, keyup: disable」などの設計で、押しっぱなしで反復イベントや状態遷移が出る実装になっている
D) V+H 等が効かないのは「モーダル状態のフラグ」や「イベントリスナの検査順」「modifier判定が異なるタイミング（keydown vs keyup）」が原因
E) レイヤー移動コマンドが UI ボタンとキーバインドで別コードパスになっており、移動処理で期待する state（activeLayerId 等）を参照できていない

--- 改修方針（設計原則） ---
1) History は「ユーザー操作単位」で push する（内部で細かく push されたらバッチ化する）
   - History API にトランザクション機能を追加（beginTransaction/commit/rollback）
   - 自動バッチング：同一マクロ操作内の複数 push は1個にまとめる
2) キーバインドは一元管理する（KeybindingManager）
   - 全てのショートカット定義は config.js に集約
   - 各モジュールは KeybindingManager にイベント名（'play-toggle','layer-move','move-vertical' など）を登録するだけ
   - KeybindingManager は modifier を正規化し、keydown/keyup の差を吸収する
3) Vキーは「トグル方式（短押しで ON / 再押下で OFF）」に変更
   - 既存の「押下中だけ有効」方式はオプションとして残す場合でもデフォルトはトグル
4) UI ボタンとショートカットは共通のコマンドAPIを呼ぶ（UI と入力ハンドラは同じ関数を呼ぶ）
   - 例：layerSystem.moveActiveLayer(direction, amount) を直接呼ぶ
5) 命名とAPIを厳格化。操作を表すイベント名・履歴の action.type を統一

--- 優先度付き改修タスク（高→低）---
A. 致命：History のバッチ化（高）
   1. 既存 history.js に Transaction API を追加
      - history.beginTransaction(label?)
      - history.push(action)  ← トランザクション中はバッファに積む
      - history.commitTransaction()  ← バッファをまとめて 1 action としてpush（必要なら合成payload）
      - history.rollbackTransaction()
   2. レイヤー作成・削除・アクティブ変更・ペンの stroke 操作等、ユーザー操作の入り口でトランザクションで括る
   3. 描画（ペン）処理は、stroke 単位で 1 action を作る（開始: beginTransaction, 各点はバッファ, 終了: commit）
   4. レイヤー作成で2回増える件：createLayer処理全体を1トランザクションで囲む
   5. 既存の push を全検索し、ユーザー操作か内部 bookkeeping かで分類。bookkeeping は history.push しないか、内部 action にまとめる
   6. テスト：描画 1 ストロークで history.length が +1、レイヤー作成で +1 を確認

B. キー管理の集中（高）
   1. 新規ファイル system/keybinding-manager.js を追加
      - public API:
         KeybindingManager.define('play-toggle', {key: 'Space', modifiers:['Shift'] /* or 'Shift+Space' style */})
         KeybindingManager.on('play-toggle', handler)
         KeybindingManager.remove(...)
      - 内部: 単一の window.addEventListener('keydown', ...) と 'keyup' を持つ。重複登録を防ぐ
      - modifier 正規化（Shift/Ctrl/Alt/Meta）と同時押し検出
   2. config.js に全ショートカット定義を移行（例: keyBindings: { playToggle: 'Shift+Space', vMoveToggle: 'KeyV', ... }）
   3. 各モジュールは keybinding に直接 add せず、KeybindingManager.on('命令名', handler) で購読
   4. index.html の inline ハンドラを削除または KeybindingManager に移行
   5. テスト：Shift+Space が一回だけ再生/停止を発行。重複発生が無いことを確認

C. Vキーのトグル化 + ショートカット組み合わせ修正（中）
   1. KeybindingManager で 'KeyV' 押下でトグル命令 'layer-move-toggle' を発火
      - 実装: keydown で既にトグル状態遷移済みなら無視。keyup はトグルロジックに影響させない
   2. V+H / V+Shift+H の判定：KeybindingManager は「現在のモード（layer-move active）」を参照せずとも、'layer-move-vertical' のキーバインドは常に受け取り、内部 handler が mode 確認して無効なら ignore（→ 私的モード一貫性）
   3. 現状 '押しっぱなし' の挙動が生じる原因は key repeats; KeybindingManager で repeat を抑止（keydownで e.repeat をチェックして初回のみ扱う or トグル用は repeat を無視）
   4. テスト：V を押すとモード入、もう一度押すと抜ける。長押ししても1回しかトグルしない。V+H で垂直移動が動作する

D. アクティブレイヤー移動ロジック修正（中）
   1. layer-system.js に moveActiveLayer(axis, amount) （または moveActiveLayer(dx,dy)）を公開する
   2. UI ボタン（垂直/水平）と Keybinding の handler はこの API を呼ぶだけ（副作用を UI 側に置かない）
   3. 移動処理は 1 回の履歴アクションとしてまとめる（history.beginTransaction / commit）
   4. V+H が効かない原因が「イベントが keyup でしか拾っていない」「modifier 判定ミスマッチ」「activeLayer が null」等なら、
      - handler は activeLayer の有無をチェックし、無ければ user-feedback（軽い console.warn は許容）を出すだけで終了
   5. テスト：V モードで水平ボタン→ layer.x が期待値分変わる。History +1

E. 既存コードのリファクタ（低→中）
   1. 各モジュールの console.log を減らす（デバッグ用は debug flag で出す）
   2. 命名規約（action.type, command names, event names）をドキュメント化（短い表を README 形式で追加）
   3. 重要な API の JSDoc コメント追加（今後AIが読みやすくするため）

--- 具体的変更候補コード（抜粋・概念実装）---
（※実際は該当ファイルに合わせて軽微に調整してください。ここは改修方針を示す疑似実装）

1) history.js に Transaction を追加（概念）
function beginTransaction(label){
  if(this._inTransaction) { /* nested support: increase counter */ }
  this._inTransaction = true;
  this._txBuffer = [];
  this._txLabel = label || 'transaction';
}
function push(action){
  if(this._inTransaction){
    this._txBuffer.push(action);
    return;
  }
  _pushToStack(action); // 既存の単発push
}
function commitTransaction(){
  if(!this._inTransaction) return;
  // 合成ルール：複数 push を 1 action にまとめる
  const combined = { type: this._txLabel, payload: this._txBuffer };
  _pushToStack(combined);
  this._txBuffer = [];
  this._inTransaction = false;
}
function rollbackTransaction(){ this._txBuffer=[]; this._inTransaction=false; }

適用例（レイヤー作成）
history.beginTransaction('create-layer');
// 内部で複数の push が呼ばれてもバッファ化される
layerSystem._createLayerInternal(...);
ui.selectLayer(newLayerId);
history.commitTransaction();

2) keybinding-manager.js（概念）
const KeybindingManager = (function(){
  const listeners = new Map(); // name => [handlers]
  const map = {}; // key combo => name
  window.addEventListener('keydown', (e) => {
    const combo = normalizeKey(e); // e.g. 'Shift+Space' or 'KeyV'
    if(e.repeat && map[combo]?.ignoreRepeats) return;
    const name = map[combo];
    if(name) emit(name, e);
  });
  return {
    define(name, combo, opts){ map[combo] = { name, ...opts }; },
    on(name, handler){ listeners.has(name)||listeners.set(name,[]); listeners.get(name).push(handler); },
    emit(name, e){ (listeners.get(name)||[]).forEach(h=>h(e)); },
    // helper to register from config
  };
})();

config.js 変更例
keyBindings: {
  playToggle: 'Shift+Space',
  vMoveToggle: 'KeyV',
  moveVertical: 'KeyH', // with V mode check in handler
  // ...
}

3) Vトグル handler（概念）
KeybindingManager.on('vMoveToggle', (e) => {
  if(e.repeat) return; // ignore repeats
  const newMode = !state.isLayerMoveMode;
  state.isLayerMoveMode = newMode;
  eventBus.emit('layer-move:mode', newMode);
});

4) 移動コマンドの共通化
// layer-system.js
function moveActiveLayer(dx, dy){
  const layer = getActiveLayer();
  if(!layer) return;
  history.beginTransaction('move-active-layer');
  layer.x += dx; layer.y += dy;
  history.push({ type:'layer-moved', payload:{id:layer.id, dx, dy} });
  history.commitTransaction();
}

--- テスト計画（手順）---
優先度順に自動/手動で確認
1) 描画（1 stroke）→ Undo を 1 回で戻る / Redo で再現
2) 2 stroke 描画 → Undo 2 回で両方戻る
3) レイヤー新規作成 → history +1 だけ増える
4) Shift+Space を複数押下 → 再生/停止が二重にならない（1動作のみ）
5) V 押下で移動モード ON、再押下で OFF（長押しで複数トグルしない）
6) V モード中に H キー（および Shift+H）で垂直/水平移動が正しく動く
7) UI ボタン（垂直/水平）を押したときに history が +1 だけ増える

--- リスクと回避 ---
- 既存コードに深く組み込まれた history.push 呼び出しの全面検出と分類が必須。見落とすと不整合を残す → 改修時に全 push を grep して一覧化する
- トランザクション化で undo の意味合いが変わる可能性（細かく戻したい場合）→ 必要なら小さい粒度の user action と内部 bookkeeping を明確に区別する
- Keybinding 一元化で想定外のショートカット競合が発生する可能性→ config に全定義を書き、コンフリクト検出機能（起動時に同一 combo の複数定義を警告）を入れる

--- 作業工数見積（参考：改修・テスト含む、開発者1名）---
（注：あなたの要望により作業はここで完了せず、実装段階で微調整が必要）
- history トランザクション導入・既存 push 検査：1.5〜2.5日
- keybinding manager 実装 + config 移行：1.0〜1.5日
- V トグル + 移動 API 修正：0.75〜1.0日
- テスト＋バグ潰し：0.75〜1.5日
合計（目安）：4〜6.5 日

--- 優先度（短期推奨順）---
1) History トランザクション化（必須、UX直結）
2) Keybinding 一元化（再発防止）
3) V トグル化 + 移動 API（操作性改善）
4) UI の小修正、ログ削減、命名改善

--- 変更ファイル一覧（作業候補、修正箇所）---
優先度高ファイル
- system/history.js           ← トランザクション追加・push 呼び出し点の整理
- system/layer-system.js      ← レイヤー作成/移動処理のトランザクション化・公開API追加
- system/drawing-clipboard.js ← stroke 単位で history を push するよう修正
- system/animation-system.js  ← (Shift+Space 冲突確認)
- core-runtime.js / core-engine.js ← keybinding 統制点の調整（KeybindingManager 経由へ）
- index.html / config.js      ← キー定義を config.js に移動し、index.html の inline ハンドラは削除
- ui/timeline-ui.js / ui-panels.js / timeline-thumbnail-utils.js ← UIが history を直接触っている場合はコマンド経由に変更
- system/event-bus.js / system/state-manager.js ← mode フラグやイベント命名の整理

--- デリバブル（最終）---
1) 修正パッチ（diff / patch ファイル）
2) 修正後の README（変更点・キー一覧・Undo/Redo の仕様）
3) テスト手順書（上記テスト計画を手順化）
4) 必要なら短いコードコメントでの設計説明（history.transaction の使い方例）

--- 補足（運用上の提案）---
- History の可視化ツール（開発モード）：現在の undo stack を一時的に見られる dev-ui を作ると調査が速くなる
- キー割当の一覧は config.js にコメント付きで残す（エンドユーザー用ヘルプとしても有用）
- 将来：history の action を「undoable: true/false」でマークできるようにすると内部処理をさらに柔軟に扱える

--- 結び ---
上記はソースツリー構成と問題報告に基づく調査と実務的な改修計画です。まずは「system/history.js のトランザクション追加」と「KeybindingManager の導入」を同時に進めることで多くの不整合が解消されます。  
必要なら、私の側で該当ファイルの差分（パッチ）を作成して提示します。その場合は修正済みファイルを1つずつ提示しますので、どのファイルから出力して欲しいか指定してください（例：まず system/history.js の変更diffを出します）。

以上
