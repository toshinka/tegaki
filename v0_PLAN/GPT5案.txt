要約（短く）

エラー reading 'worldContainer' と Required systems not loaded within timeout：
システム登録（System ファイル → CoreEngine へ）が正しく伝播しておらず、CoreEngine が worldContainer を作る前に DrawingApp が参照している、または CoreEngine が想定する必須システムが未登録のままタイムアウトしているのが主原因です。

原因パターン：スクリプト読み込み順、グローバル登録API の不一致（Phase1b4 と Phase2e で「どうやって system を CoreEngine に渡すか」が変わっている）、各 system ファイルのエクスポート（グローバル）方法の不統一。

対処方針：CoreEngine に「登録待ち」受け口を実装し、システム側は厳格なシグネチャ（name, required, init(engine), start()）で登録する。さらに CoreEngine は PIXI 存在チェック・バージョンチェック、worldContainer の明確な生成・公開を行う。これで phase1b4 と同等の機能を満たしつつ、分割後の system ファイルでも確実に動く構成にします。

すぐに置き換える（差し替え用）：4 ファイル全文

これらをそのまま core-engine.js、systems/camera-system.js、systems/layer-system.js、systems/drawing-clipboard.js に貼り替えてください（既存を上書き）。
ES非モジュール（<script>インクルード）前提、window グローバルを使います。PixiJS は index.html で CDN から読み込まれている前提です。

core-engine.js
/* core-engine.js
   CoreEngine: シンプルで堅牢なシステム登録・初期化フレームワーク
   API:
     CoreEngine.registerSystem(name, systemFactoryOrObject)
     CoreEngine.initialize(options) -> returns Promise
   System 要件:
     - object.name (string)
     - object.required (array of system-names) optional
     - object.init(engine) -> sync/async
     - object.start(engine) -> sync/async optional
*/
(function(window){
  'use strict';

  // PIXI バージョンチェック（任意だが有用）
  if (!window.PIXI) {
    console.error('CoreEngine: PIXI not found. Make sure PixiJS is loaded before core-engine.js');
  } else {
    try {
      const v = (PIXI.VERSION || '');
      if (!v.startsWith('8.13')) {
        console.warn(`CoreEngine: Expected PixiJS v8.13, found ${v}. Behavior may differ.`);
      }
    } catch(e){}
  }

  // シングルトン CoreEngine
  const CoreEngine = {
    _systems: {},           // name -> system instance/object
    _systemFactories: {},   // name -> factory/object (registered before init)
    _loaded: false,
    _engineContext: null,
    _requiredSystemsList: [],

    registerSystem: function(name, factoryOrObject){
      if (!name) throw new Error('registerSystem requires name');
      this._systemFactories[name] = factoryOrObject;
      // For debug minimal log — keep it small per rule
      // console.debug(`CoreEngine: system registered: ${name}`);
    },

    // internal: ingest any pending window.__PENDING_SYSTEMS placed by system files
    _ingestPendingSystems: function(){
      if (window.__PENDING_SYSTEMS){
        for (const k in window.__PENDING_SYSTEMS){
          if (!this._systemFactories[k]) this._systemFactories[k] = window.__PENDING_SYSTEMS[k];
        }
        // clear to avoid duplicate
        window.__PENDING_SYSTEMS = null;
      }
    },

    initialize: async function(options = {}){
      // minimal options:
      //   requiredSystems: ['camera','layer', ...]
      //   pixiApp: existing PIXI.Application instance (optional)
      //   timeoutMs: how long to wait for required systems registration
      this._ingestPendingSystems();
      const timeoutMs = options.timeoutMs || 3000;
      this._requiredSystemsList = options.requiredSystems || [];

      // create engine context
      const app = options.pixiApp || this._createPixiAppIfNeeded();
      const ctx = {
        app: app,
        stage: app.stage,
        renderer: app.renderer,
        // worldContainer will be created and attached to stage
        worldContainer: null,
        systems: this._systems,
        registerSystem: this.registerSystem.bind(this),
      };
      this._engineContext = ctx;

      // create canonical world container and attach to stage
      ctx.worldContainer = new PIXI.Container();
      ctx.worldContainer.name = 'worldContainer';
      ctx.stage.addChild(ctx.worldContainer);
      this.worldContainer = ctx.worldContainer; // expose on CoreEngine

      // wait for required systems to be registered
      const self = this;
      await this._waitForSystemsRegistered(timeoutMs);

      // instantiate systems
      for (const name in this._systemFactories){
        // if already instantiated skip
        if (this._systems[name]) continue;
        try {
          const factory = this._systemFactories[name];
          let instance = (typeof factory === 'function') ? factory() : factory;
          // allow factory to return an object or require a call to .create()
          if (typeof instance === 'function') instance = instance();
          // final guard: ensure has name
          instance = instance || {};
          if (!instance.name) instance.name = name;
          this._systems[name] = instance;
        } catch (e){
          console.error('CoreEngine: failed to instantiate system', name, e);
        }
      }

      // call init on systems (in any order) but await if returns promise
      const initPromises = [];
      for (const name in this._systems){
        const s = this._systems[name];
        if (typeof s.init === 'function'){
          try {
            const p = s.init(this._engineContext);
            if (p && typeof p.then === 'function') initPromises.push(p);
          } catch(e){
            console.error('CoreEngine: system init error', name, e);
          }
        }
      }
      await Promise.all(initPromises);

      // start systems (non-blocking, but await if promise returned)
      for (const name in this._systems){
        const s = this._systems[name];
        if (typeof s.start === 'function'){
          try {
            const p = s.start(this._engineContext);
            if (p && typeof p.then === 'function') await p;
          } catch(e){
            console.error('CoreEngine: system start error', name, e);
          }
        }
      }

      this._loaded = true;
      return this._engineContext;
    },

    _waitForSystemsRegistered: function(timeoutMs){
      const required = this._requiredSystemsList || [];
      if (!required.length) return Promise.resolve();

      const self = this;
      return new Promise(function(resolve, reject){
        const start = Date.now();
        (function tick(){
          let allHere = true;
          for (let i = 0; i < required.length; ++i){
            const name = required[i];
            // registered either in factories or already instantiated
            if (!self._systemFactories[name] && !self._systems[name]){
              allHere = false; break;
            }
          }
          if (allHere) return resolve();
          if (Date.now() - start > timeoutMs){
            console.error('❌ System loading timeout. Available systems: ', Object.keys(self._systemFactories));
            return reject(new Error('Required systems not loaded within timeout'));
          }
          setTimeout(tick, 50);
        })();
      });
    },

    getSystem: function(name){
      return this._systems[name] || null;
    },

    _createPixiAppIfNeeded: function(){
      if (window._CORE_ENGINE_APP) return window._CORE_ENGINE_APP;
      // create a minimal PIXI.Application suitable for file:// usage
      const app = new PIXI.Application({
        width: 800, height: 600, backgroundAlpha: 0, antialias: true
      });
      // attach to body if nothing provided
      document.body.appendChild(app.view);
      window._CORE_ENGINE_APP = app;
      return app;
    }
  };

  // expose CoreEngine
  window.CoreEngine = CoreEngine;

  // If systems were placed into window.__PENDING_SYSTEMS by system files, ingest now
  CoreEngine._ingestPendingSystems();

})(window);

systems/camera-system.js
/* camera-system.js
   シンプルなカメラ（viewport）システム。
   必要最低限の API:
     - name: 'camera'
     - required: []
     - init(engineContext) -> set up engine.camera and engine.camera.container (a PIXI.Container)
     - start(engineContext)
*/
(function(window){
  'use strict';

  function createCameraSystem(){
    return {
      name: 'camera',
      required: [],
      init: function(engine){
        // engine: { app, stage, renderer, worldContainer, systems }
        this.engine = engine;
        // container under worldContainer that will hold drawable layers
        this.container = new PIXI.Container();
        this.container.name = 'cameraContainer';
        // Expose as camera.container so other systems can add children to camera.container
        if (!engine.worldContainer) {
          throw new Error('camera-system: engine.worldContainer is not available');
        }
        engine.worldContainer.addChild(this.container);

        // camera state
        this.state = { x:0, y:0, scale:1, rotation:0 };
        // provide simple API
        engine.camera = {
          container: this.container,
          setPosition: (x,y) => { this.state.x = x; this.container.position.set(x,y); },
          setScale: (s) => { this.state.scale = s; this.container.scale.set(s); },
          getState: () => ({...this.state}),
        };

        // Optional: setup interaction for panning (minimal)
        const view = engine.app.view;
        // keep interaction off by default; tools can enable it
        return Promise.resolve();
      },

      start: function(engine){
        // nothing blocking
      }
    };
  }

  // register: try CoreEngine.registerSystem; otherwise place into pending bucket
  if (window.CoreEngine && typeof window.CoreEngine.registerSystem === 'function'){
    window.CoreEngine.registerSystem('camera', createCameraSystem);
  } else {
    window.__PENDING_SYSTEMS = window.__PENDING_SYSTEMS || {};
    window.__PENDING_SYSTEMS['camera'] = createCameraSystem;
  }

})(window);

systems/layer-system.js
/* layer-system.js
   レイヤー管理を LayerSystem に集中させる。
   シンプル API:
     engine.layerSystem.createLayer({name, width, height})
     engine.layerSystem.getLayer(nameOrId)
     engine.layerSystem.reorderLayer(id, newIndex)
     engine.layerSystem.transformLayer(id, {x,y,rotation,scaleX,scaleY})
*/
(function(window){
  'use strict';

  function createLayerSystem(){
    return {
      name: 'layer',
      required: ['camera'], // camera.container を想定
      init: function(engine){
        this.engine = engine;
        this._layers = []; // ordered list
        this._map = {}; // id/name -> layer object

        const camera = engine.camera;
        if (!camera || !camera.container){
          throw new Error('layer-system: camera.container required');
        }
        this.host = camera.container;

        // API exposed to engine
        engine.layerSystem = {
          createLayer: this.createLayer.bind(this),
          getLayer: this.getLayer.bind(this),
          reorderLayer: this.reorderLayer.bind(this),
          transformLayer: this.transformLayer.bind(this),
          list: () => this._layers.slice()
        };
      },

      createLayer: function({id, name, width=0, height=0} = {}){
        const layerId = id || ('layer_' + (Object.keys(this._map).length+1));
        const layerName = name || layerId;
        const container = new PIXI.Container();
        container.name = layerName;
        container._layerId = layerId;

        // default a transparent Graphics backing if needed for hit test (optional)
        // const bg = new PIXI.Graphics();
        // bg.beginFill(0x000000, 0);
        // bg.drawRect(0,0,width,height);
        // bg.endFill();
        // container.addChild(bg);

        this.host.addChild(container);
        const entry = { id: layerId, name: layerName, container: container };
        this._layers.push(entry);
        this._map[layerId] = entry;
        this._map[layerName] = entry;
        return entry;
      },

      getLayer: function(idOrName){
        return this._map[idOrName] || null;
      },

      reorderLayer: function(idOrName, newIndex){
        const entry = this.getLayer(idOrName);
        if (!entry) return false;
        const curIndex = this._layers.indexOf(entry);
        if (curIndex === -1) return false;
        this._layers.splice(curIndex, 1);
        this._layers.splice(newIndex, 0, entry);
        // apply to host display list
        this.host.removeChild(entry.container);
        // re-append in order
        for (let i = 0; i < this._layers.length; ++i){
          const e = this._layers[i];
          if (this.host.children.indexOf(e.container) !== i) {
            // ensure correct index by remove/insert cycle:
            // Since PIXI doesn't have insertAt, use addChildAt if available
            if (typeof this.host.addChildAt === 'function'){
              this.host.addChildAt(e.container, i);
            } else {
              this.host.addChild(e.container);
            }
          }
        }
        return true;
      },

      transformLayer: function(idOrName, {x,y,rotation,scaleX,scaleY} = {}){
        const entry = this.getLayer(idOrName);
        if (!entry) return false;
        const c = entry.container;
        if (typeof x === 'number') c.position.x = x;
        if (typeof y === 'number') c.position.y = y;
        if (typeof rotation === 'number') c.rotation = rotation;
        if (typeof scaleX === 'number') c.scale.x = scaleX;
        if (typeof scaleY === 'number') c.scale.y = scaleY;
        return true;
      }
    };
  }

  if (window.CoreEngine && typeof window.CoreEngine.registerSystem === 'function'){
    window.CoreEngine.registerSystem('layer', createLayerSystem);
  } else {
    window.__PENDING_SYSTEMS = window.__PENDING_SYSTEMS || {};
    window.__PENDING_SYSTEMS['layer'] = createLayerSystem;
  }

})(window);

systems/drawing-clipboard.js
/* drawing-clipboard.js
   軽量なクリップボード（レイヤー or PIXI.Container 単位）
   API:
     engine.clipboard.copyLayer(idOrName)
     engine.clipboard.pasteLayer({targetLayerId, newName})
*/
(function(window){
  'use strict';

  function createClipboardSystem(){
    return {
      name: 'clipboard',
      required: ['layer'],
      init: function(engine){
        this.engine = engine;
        this._storage = null; // simple in-memory
        engine.clipboard = {
          copyLayer: this.copyLayer.bind(this),
          pasteLayer: this.pasteLayer.bind(this),
          getStored: () => this._storage
        };
      },

      copyLayer: function(idOrName){
        const ls = this.engine.layerSystem;
        if (!ls) throw new Error('clipboard: layerSystem required');
        const layer = ls.getLayer(idOrName);
        if (!layer) return false;
        // simple shallow clone: clone children into a new container
        const src = layer.container;
        const clone = new PIXI.Container();
        clone.name = (layer.name || 'clipboard_clone');
        // Deep copy basic display objects minimally (Graphics, Sprite)
        for (let i=0;i<src.children.length;++i){
          const ch = src.children[i];
          try {
            if (ch instanceof PIXI.Sprite){
              const s = new PIXI.Sprite(ch.texture);
              s.position.copyFrom(ch.position);
              s.scale.copyFrom(ch.scale);
              s.rotation = ch.rotation;
              clone.addChild(s);
            } else if (ch instanceof PIXI.Graphics){
              // graphics cannot be trivially cloned; draw to texture could be used later.
              // For now we store a reference to graphics (non-destructive)
              // WARNING: shared reference — editor should treat paste as grouped reference.
              clone.addChild(ch.clone ? ch.clone() : ch);
            } else {
              // fallback: try shallow copy by container serialization if any
              if (ch.clone) clone.addChild(ch.clone());
            }
          } catch(e){
            // skip problematic children
            console.warn('clipboard: copy child failed', e);
          }
        }
        this._storage = { layerName: layer.name, container: clone };
        return true;
      },

      pasteLayer: function({ targetLayerId, newName } = {}){
        if (!this._storage) return false;
        const ls = this.engine.layerSystem;
        if (!ls) throw new Error('clipboard: layerSystem required for paste');
        // if target provided, add to that layer, else create a new layer and add
        let target = targetLayerId ? ls.getLayer(targetLayerId) : null;
        if (!target){
          const newLayer = ls.createLayer({ name: newName || `${this._storage.layerName}_paste` });
          target = newLayer;
        }
        // add children of stored container to target.container (clone reference)
        const src = this._storage.container;
        // clone children where possible, but if they are shared references we append them (risky)
        for (let i = 0; i < src.children.length; ++i){
          const ch = src.children[i];
          try {
            if (typeof ch.clone === 'function') {
              target.container.addChild(ch.clone());
            } else {
              target.container.addChild(ch);
            }
          } catch(e){
            console.warn('clipboard: paste child failed', e);
          }
        }
        return true;
      }
    };
  }

  if (window.CoreEngine && typeof window.CoreEngine.registerSystem === 'function'){
    window.CoreEngine.registerSystem('clipboard', createClipboardSystem);
  } else {
    window.__PENDING_SYSTEMS = window.__PENDING_SYSTEMS || {};
    window.__PENDING_SYSTEMS['clipboard'] = createClipboardSystem;
  }

})(window);

使い方と確認手順（短い）

上の 4 ファイルをそれぞれ上書き保存。

index.html の <script> 読み込み順は (1) PixiJS CDN → (2) core-engine.js → (3) systems/*.js → (4) その他（core-runtime.js, drawingApp 等） が安全。ただし上の実装は __PENDING_SYSTEMS を吸い上げるので システムファイルを core-engine の後に置いても動きます（CoreEngine が pending を ingest する）。しかし最も確実なのは「Pixi → core-engine → systems → core-runtime / app」。

index.html を開いてコンソールのエラーが消えることを確認してください。CoreEngine が worldContainer を作っているはずです。

動かなければコンソールで Object.keys(CoreEngine._systemFactories) と Object.keys(CoreEngine._systems) を確認してください（登録状況）。

なぜこれで直るのか（