短めに結論→原因→優先修正（実際の差分／パッチ）→検証手順→追加改善案、の順でお送りします。まず結論：

短い結論（TL;DR）

Canvas が出ない主原因は（1）PIXI.Application の初期化ミス（this.pixiApp.init(...) を呼んでいる点）で例外が出て初期化が途中で止まること、（2）分割後のグローバル／API 名の不一致（CONFIG / TEGAKI_CONFIG や座標API名の混在など）で checkDependencies() が失敗すること、です。これらを直せばまずキャンバスは表示されます。関連ファイルを確認しました。参考：core-engine.js（Phase2）、CoordinateSystem、Layer, DrawingClipboard。 
GitHub
+3
GitHub
+3
GitHub
+3

1) 発見した問題（要点）

以下は実際にソースから確認した問題点の要約です。

PIXI 初期化の誤り

現在のコードは this.pixiApp = new PIXI.Application(); await this.pixiApp.init({...}) の形になっていますが、Pixi v8 の通常 API では Application に init() の非同期メソッドは存在せず（new PIXI.Application(options) の形を使います）。this.pixiApp.init が undefined → TypeError → initialize() が throw されキャンバスが作られません。実コード箇所確認済み。 
GitHub

グローバル名 / 期待する依存の不一致

CoreEngine.checkDependencies() が window.CONFIG や window.TegakiRuntime などを探していますが、実際の Phase2 の設定ファイルでは window.TEGAKI_CONFIG や window.TEGAKI_UTILS が使われています（名前の差）。そのため依存チェックで Missing と判定されて init が止まります。具体的には checkDependencies() の期待値と config.js のグローバル名が合っていない。 
GitHub
+1

座標APIの呼び方が混在している（API 名の不一致）

CoordinateSystem は Phase2 で screenToCanvas, screenToWorld 等を提供していますが、モジュール群のなかで screenToCanvas と screenToCanvasForDrawing や screenToWorld の混用、あるいは誤呼出し（例：描画系が screenToCanvas を期待するところで screenToWorld を使っている、逆に screenToCanvas を使うべきところで screenToCanvas を呼ばない）等の不整合が見られます。これが（表示されても）描画位置ズレやマウス操作不整合の原因になります。具体例：DrawingEngine.screenToWorld が CoordinateSystem.screenToCanvas を呼んでいる — 意図が不明瞭。 
GitHub
+1

レイヤー API の断片化・互換性差

Phase1 側で使われていたレイヤーデータ構造（layer.layerData 等）と、Phase2 の LayerManager の layer オブジェクト構造が微妙に設計違いです。分割前のコードを引き継ぐ場合、互換アダプタ／shim を用意して旧 API を呼ぶコードに影響を与えないようにする必要があります。 
GitHub
+1

EventBus（またはシステム間通知）の統合が不完全

分割の目的が各システムの独立化であれば、軽量な EventBus（on/emit/off）を window.TegakiEventBus として用意し、各システムの直接 DOM 参照やグローバル関数呼び出しを減らすべきです。現状は各モジュールが DOM イベントや window.TegakiUI に直接依存していて結合度が高めです。該当箇所は CoreEngine の cross refs や UI 連携部分。 
GitHub
+1

2) 優先修正（必須） — まずこれを当ててください

下のパッチは core-engine.js の 即効で効く修正（PIXI 初期化、依存名修正、CoordinateSystem への参照設定）です。該当部分を置換してください。

A. initializePixiApp() の修正（必須）
現在（問題）:

this.pixiApp = new PIXI.Application();
await this.pixiApp.init({
  width: screenWidth, height: screenHeight, backgroundAlpha: 0, resolution: window.devicePixelRatio || 1, antialias: true, eventMode: 'static'
});


修正後（推奨）:

// 正しい Pixi v8 の初期化パターン
this.pixiApp = new PIXI.Application({
  width: screenWidth,
  height: screenHeight,
  backgroundAlpha: 0,
  resolution: window.devicePixelRatio || 1,
  antialias: true
});
// Pixi v8 の Canvas イベントモードは canvas.eventMode を使う（後で設定）
this.pixiApp.view.style.display = 'block';
this.pixiApp.view.style.position = 'absolute';
this.pixiApp.view.style.top = '0';
this.pixiApp.view.style.left = '0';
if (this.canvasElement && this.canvasElement.parentNode) {
  this.canvasElement.parentNode.replaceChild(this.pixiApp.view, this.canvasElement);
} else {
  document.body.appendChild(this.pixiApp.view);
}
// stage / world container
this.worldContainer = new PIXI.Container();
this.worldContainer.label = 'worldContainer';
this.worldContainer.eventMode = 'static';
this.pixiApp.stage.addChild(this.worldContainer);
// set canvas element ref for other systems
this.pixiApp.canvas = this.pixiApp.view; // 既存コードが canvas を参照するので互換性確保
this.setupResize();
console.log('✅ PixiJS Application initialized (fixed)');


理由：new PIXI.Application(options) が正しい。init() 呼出は未定義で即例外になります。上の修正で pixiApp.view（canvas要素）を this.pixiApp.canvas に割り当て互換も保っています。 
GitHub

B. 依存チェックの修正（checkDependencies()）
現在 checkDependencies() が探しているキー（window.CONFIG など）を実際の Phase2 名に合わせます。config.js は window.TEGAKI_CONFIG を定義しているので checkDependencies()を以下のように変更してください（抜粋）:

const required = [
  { path: 'window.TEGAKI_CONFIG', name: 'TEGAKI_CONFIG' },
  { path: 'window.CoordinateSystem', name: 'CoordinateSystem' },
  { path: 'window.TegakiUI', name: 'TegakiUI' }, // ui-panels がこれを出す想定
  { path: 'window.TegakiCameraSeparated.CameraSystem', name: 'CameraSystem' },
  { path: 'window.TegakiLayerSeparated.LayerManager', name: 'LayerManager' },
  { path: 'window.TegakiDrawingClipboardSeparated.DrawingClipboardSystem', name: 'DrawingClipboardSystem' }
];


さらに getNestedObject() が path を window 付きで受け取る実装なので、そのまま使えます（設計上 path を window.SOMETHING の形式に揃えるのが簡潔）。これで不一致による False Negative を防ぎます。 
GitHub
+1

C. CoordinateSystem に安全参照を供給（必須）
CoordinateSystem は setContainers() を持つので、Pixi 初期化後に必ず呼んでおくと安全です。initialize() の setupCrossReferences() 内で以下を入れてください：

// after this.worldContainer and this.pixiApp exist
if (window.CoordinateSystem && typeof window.CoordinateSystem.setContainers === 'function') {
  try {
    // canvasContainerがある場合は渡す（Phase1互換で canvasContainer label を使うコードがあるため）
    const canvasContainer = this.worldContainer.children.find(c => c.label === 'canvasContainer') || null;
    window.CoordinateSystem.setContainers({ app: this.pixiApp, worldContainer: this.worldContainer, canvasContainer });
  } catch (e) {
    console.warn('CoordinateSystem.setContainers failed:', e);
  }
}


これで座標系の「安全参照」が整い、以降の screenToCanvas 等が安定します。 
GitHub

3) 中期的／追加の修正（推奨）

優先度は高→低の順です。

座標APIをプロジェクト標準に固定する。

推奨：CoordinateSystem.screenToCanvas() を「描画（キャンバス）用」入力で使い、CoordinateSystem.screenToWorld() を「カメラ／レイヤー操作用」に使う。各システムの screenTo* 呼び出しを走査して統一する（DrawingEngine と CameraSystem が混在しているので修正）。該当呼び出しを一覧化して一括修正してください。 
GitHub
+1

Layer API の互換 shim を作る

既存（Phase1）コードが layer.layerData 等を期待するなら、LayerManager.createLayer() の戻りオブジェクトに layer.layerData 等を付けて互換を保つアダプタを作ります。こうすることで Phase1 のロジックをほとんど手直しせずに移行できます。 
GitHub
+1

軽量 EventBus を導入してシステム間の依存を緩める

例：

window.TegakiEventBus = {
  _map: new Map(),
  on(k, fn) { if(!this._map.has(k)) this._map.set(k, []); this._map.get(k).push(fn); },
  off(k, fn) { if(!this._map.has(k)) return; this._map.set(k, this._map.get(k).filter(f=>f!==fn)); },
  emit(k, ...args) { (this._map.get(k)||[]).forEach(f=>{ try{f(...args);}catch(e){console.error(e);} }); }
};


各システムは window.TegakiEventBus.on('layer.add', ...) のように subscribe します。これで window.TegakiUI 等の存在チェックを減らせます。

ログ／デバッグの整備（最小限）

window.TEGAKI_CONFIG.debug を中心にログを出す仕組みにし、console spam を避ける。重大エラーは CoreEngine.getInitializationError() で可視化できるようにする（既に用意あり）。

4) 具体的な検証手順（実行して確認する順番）

上の A（PIXI 初期化）と B（依存名）と C（CoordinateSystem.setContainers）を core-engine.js に適用する。

ブラウザで index.html を file:// で直開きし、Console を開く。

期待するログ（成功時の抜粋）

✅ core-engine.js loaded (Phase2 integrated)

✅ PixiJS Application initialized (fixed)

✅ Separated systems initialized

✅ CameraSystem initialized　等。 
GitHub
+1

window.TegakiCore.CoreEngine を確認（console.log(window.TegakiCore.CoreEngine)）してクラスが存在すること。

new window.TegakiCore.CoreEngine(document.getElementById('canvas-placeholder')) を作り .initialize() を呼ぶ（または index の起動処理に従う）。初期化成功後、キャンバスが visible か確認。

マウスで描画してズレや不具合があれば、Console で window.CoordinateSystem.diagnoseReferences() と window.CoordinateSystem.testCoordinateAccuracy(window.drawingApp?.pixiApp)（DEBUG mode の場合）を実行して座標系を検査。 
GitHub

5) 追加で注意すべき点（設計／運用）

API 名の厳格化：screenToCanvas, screenToWorld, worldToScreen, layerToWorld 等、1つの名に統一してプロジェクト規約をドキュメント化してください。命名が一度ぶれると分割したときに確実にバグの温床になります。

グローバル名の命名規則：window.TEGAKI_CONFIG のように全ファイルで同じキーを参照する。CoreEngine.checkDependencies() はこの規約を参照するように。

テスト用のデバッグモード：TEGAKI_CONFIG.debug = true を一時的に入れ、座標ログを取るとすばやくズレ原因がわかります。

分割方針：システム毎に init(pixiApp, worldContainer, options) を必須化しておくと、CoreEngine が責任をもって依存注入でき、分割後の結合ミスを防げます。


最小限 A〜C（Pixi初期化修正／依存チェック修正／CoordinateSystem参照設定） をまとめた短めコード例です。

// === core-engine.js 抜粋 修正版 ===
window.TegakiCore = window.TegakiCore || {};

class CoreEngine {
  constructor(canvasElement) {
    this.canvasElement = canvasElement;
    this.pixiApp = null;
    this.worldContainer = null;
  }

  async initialize() {
    try {
      this.initializePixiApp();
      this.setupCrossReferences();
      console.log("✅ CoreEngine initialized");
    } catch (e) {
      console.error("CoreEngine init failed:", e);
    }
  }

  initializePixiApp() {
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;

    // PixiJS v8 正しい初期化
    this.pixiApp = new PIXI.Application({
      width: screenWidth,
      height: screenHeight,
      backgroundAlpha: 0,
      resolution: window.devicePixelRatio || 1,
      antialias: true
    });

    this.worldContainer = new PIXI.Container();
    this.worldContainer.label = "worldContainer";
    this.worldContainer.eventMode = "static";
    this.pixiApp.stage.addChild(this.worldContainer);

    // view(canvas)をDOMに反映
    const view = this.pixiApp.view;
    view.style.position = "absolute";
    view.style.top = "0";
    view.style.left = "0";
    document.body.appendChild(view);

    // 互換性: 他コードが pixiApp.canvas を参照する
    this.pixiApp.canvas = view;
  }

  setupCrossReferences() {
    // CoordinateSystemにPixi参照を渡す
    if (window.CoordinateSystem?.setContainers) {
      window.CoordinateSystem.setContainers({
        app: this.pixiApp,
        worldContainer: this.worldContainer
      });
    }
  }

  checkDependencies() {
    const required = [
      { path: "window.TEGAKI_CONFIG", name: "TEGAKI_CONFIG" },
      { path: "window.CoordinateSystem", name: "CoordinateSystem" },
      { path: "window.TegakiUI", name: "TegakiUI" },
      { path: "window.TegakiCameraSeparated.CameraSystem", name: "CameraSystem" },
      { path: "window.TegakiLayerSeparated.LayerManager", name: "LayerManager" },
      { path: "window.TegakiDrawingClipboardSeparated.DrawingClipboardSystem", name: "DrawingClipboardSystem" }
    ];
    required.forEach(r => {
      if (!eval(r.path)) {
        throw new Error("Missing dependency: " + r.name);
      }
    });
  }
}

window.TegakiCore.CoreEngine = CoreEngine;

この短縮版コードのポイント

PIXI.Application → init() を削除し、正しい初期化方法に修正。

this.pixiApp.view を canvas として保持（Phase1 互換）。

CoordinateSystem.setContainers() に pixiApp と worldContainer を渡す。

checkDependencies() の依存名を Phase2 のグローバル名に合わせた。