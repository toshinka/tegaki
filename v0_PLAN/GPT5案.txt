要約（1行）

現在のHistoryは 「スナップショット（state 全体）をイベント/外部呼び出しで保存する」方式 で、履歴の取得は他モジュール（描画・レイヤ系・アニメ系）が適切なタイミングで History.saveState() / History.saveStateFull() を呼ぶ/あるいは特定イベントを発行することに依存しているため、呼び出しの漏れや非同期タイミングのズレで「記録されない・カウントがおかしい・遅延が生じる」などの問題が発生しやすい実装です。 
GitHub

実装の要点（history.js より）

MAX_HISTORY = 50、undoStack / redoStack に Command（doFn, undoFn, metadata）を格納する。各 Command はタイムスタンプを持つ。 
GitHub

State の取得方法：saveState() → 現カットの getLayers() を列挙し各 layer の layerData.paths 等をコピーして layer-state を作る。saveStateFull() → アニメ全体の cuts / 各 cut の layers を丸ごと取り出す（full snapshot）。いずれもスナップショットを作り、undo 用の undoFn（＝そのスナップショットを復元する関数）を持つ Command を undoStack に push する。 
GitHub

イベント依存：history 自体は TegakiEventBus の特定イベント（animation:cut-deleted, cut:pasted-* 等）を監視して saveStateFull() を呼ぶ場合がある。だが多くの操作（描画の1ストローク、レイヤ移動、レイヤの追加など）が自動的に記録される仕組みではない（外部が History.saveState() を呼ぶことを想定）。 
GitHub

Undo / Redo の流れの注意点：undo() 実行時にまず currentState = _captureFullState() を取り、const command = undoStack.pop(); command.undo(); を実行し、currentState（呼び出し前の状態）を redo 用 Command として redoStack.push() する。つまり redo/undo の整合は「undo 実行時に正常に fullState が取れるか」に依存する。失敗すると redoCommand を作れない（スタックカウントがズレる）。 
GitHub

観測されうる問題（ユーザー報告と突き合わせ）

大量に描いたのに History に記録されない（＝Undo できない）

レイヤーを移動したのに記録されない

CUT の増減（カット追加/削除）に対する History のカウントが遅い / 緩慢

Undo したのに履歴カウントが減っている（でも画面は変わっていない） / 逆に 何も戻っていないのにカウントだけ減っている

Undo/Redo の一貫性（ある操作だけ Redo ができない、stack が不整合になる）

これらは実装の仕様・同期タイミング・呼び出し漏れにより説明できます。以下、原因の深掘りと再現しやすいパターンを示します。

原因分析（コードから読み取れるポイント）
A. 「History は自動で全てを拾わない」点（外部呼び出し依存）

saveState() / saveStateFull() は 他モジュールが呼ぶことを想定した API になっている。つまり「描画処理側がストローク終了時に History.saveState() を呼ばない」場合、そのストロークは履歴に残らない。これが “いっぱい描いたのに記録されてない” の一番ありうる原因。 
GitHub

B. 「スナップショットを取るタイミングと非同期 setTimeout」によるズレ

一部イベント（例：animation:cut-deleted）で setTimeout(() => this.saveStateFull(), 50) のように遅延して保存を実行している。タイムアウトや他の処理順序によっては UI 変化→履歴保存の順が逆になったり、別処理で状態が変わりスナップショットが古い/新しいタイミングで取られるため表示と履歴のカウントが一致しなくなる可能性がある。 
GitHub

C. 「Undo/Redo の実装に非対称性がある」点

saveState() は new Command(() => {}, () => this._restoreState(state), metadata) のように doFn は空、undoFn に復元処理のみを持つ Command を push する。つまり単体の Command をそのまま再実行（redo）しても何もしない（doFn が無い）ため、redo は undo() 実行時に作られる redoCommand（doFn が復元）に依存している。
→ したがって undo の際に currentState = _captureFullState() が失敗すると redoCommand が作られずスタックの整合が取れない（カウントだけ変わる）恐れがある。 
GitHub

D. 「参照/コピーの扱いと後からの変更」

_captureLayerState は path.points などを plain object にマッピングしてコピーしている（参照切り替えはある程度ケアされている）が、もし描画中に layerData.paths が同じ配列参照に対して逐次追加/変更され、保存が描画途中で呼ばれた場合は不完全なスナップショットが取られる場合がある（これが稀に “何も戻ってないのにカウントが減る” などの見た目不整合の原因になりうる）。 
GitHub

E. 「大きなスナップショット = メモリ/遅延の問題」

saveStateFull() は全 cut/cut の layers/paths を全て複製するため、頻繁に呼ぶと重くなる。実際には描画が速く多発する操作（ペンの終了直後など）を都度 full snapshot にすると 処理時間が伸び、UI 側での変更確認と保存結果通知のタイミング差 が問題を引き起こす。イベントで setTimeout を使うのは遅延による副作用の原因になりやすい。 
GitHub

再現しやすいパターン（推定）

描画モジュールが「pointerdown で path を開始、pointermove で points を push、pointerup で path を確定」しているが、pointerup で History.saveState() を呼んでいない → 多数のストロークが undo に残らない。

レイヤ移動（transform の変更）を UI 側で行うが、その移動アクションが TegakiEventBus に layer:moved のようなイベントを出しておらず History.saveState() を呼ばない → 移動は記録されない。

カットの追加/削除で animation 系はイベントを出すが history 側は setTimeout(50ms) で saveStateFull() を呼ぶため、処理順の変動でカウント表示が遅れる／一時的にズレる。 
GitHub

推奨対策（優先度つき）

以下は 最短で問題を観察・改善できる順 に書きます。改修は「まず軽微なログ／イベント追加で原因を確実に把握」→「API レベルで記録の一貫性を保証」→「必要なら差分コマンド化へ」 の流れが安全です。

短期（すぐ試せる・低侵襲）

描画ストローク後に必ず History.saveState() を呼ぶ（pointerup）

描画モジュール（core-engine / drawing 系）で、ストローク終了（pointerup）時に History.saveState() を呼ぶようにする。これで「1画で1ヒストリーポイント」になる。

重要：pointerdown/pointermove では呼ばない（大量に溜まる） → pointerup のみで一回。

これだけで「描いたのに残らない」問題の多くは解消されるはず。 
GitHub

レイヤ移動／リサイズ／表示切替などの操作で History.saveState() or TegakiEventBus.emit('history:save') を明示的に発行

レイヤ操作系（layer-system.js）にフックを入れ、操作完了時（カーソル放した時など）に saveState を呼ぶ。

若干面倒だが、操作ごとに明示的呼び出しがないと History は保存しない実装なので必要。

デバッグ用に一時的に history:changed と history:getDebugInfo() を監視して差異を追う（下にコマンドあり）

まずは何がいつ入っているかを把握します。恒常的に console を増やすのは避ける（あなたのルール）が、短期間のデバッグログは有効。

中期（設計改善）

保存タイミングの標準化（イベント名を決めて全体で使う）

例えば TegakiEventBus.emit('history:record-stroke') / 'history:record-transform' / 'history:record-full' のようにイベント名を定義し、各モジュールはそのイベントを発行するだけにする。history.js はそのイベントを受けて saveState()／saveStateFull() を実行する。これにより「どのモジュールが履歴を取るか」が明確になる。

Command を「スナップショットだけ」ではなく「差分（do/undo）を明示的に保持する」設計への移行（必要なら）

今は undo 用のみの undoFn を持つ Command が push されるため、redo の作成が undo 実行時にしか行われない（non-robust）。可能なら 保存時に doFn と undoFn を両方生成するか、描画操作などは「差分コマンド（path-add, path-remove, layer-transform）」で記録する方式に変えるとスタック操作がより堅牢で軽量になります（実装コストは中）。 
GitHub

setTimeout をやめ、同期的／確定イベントで記録する

setTimeout(..., 50) のような遅延は順序不整合を生むので、可能ならイベントフロー内で同期的に記録する（または promise/await を使いイベント完了後に確実に実行）に変える。

長期（性能・UX改善）

履歴サイズやメモリを削るための差分圧縮（パス単位で記録）

フルスナップショットは簡単だが重い。多くの操作（ペン）を細かく記録する場合は、path 単位での add/remove をコマンドにしてスタックに入れる方が速く、Undo/Redo の反映も軽快になります。

実際に動かして確認するための「短いチェックリスト」／コンソールコマンド

（※デバッグのための一時的な実行推奨。普段はログ最小にする方針に従ってください）

現状の履歴スタック情報取得

// 現行: undo/redo のサイズ、最近の項目を確認
History.getHistoryInfo();    // {stackSize, undoCount, redoCount, ...}
History.getDebugInfo();      // {undoStackSize, redoStackSize, recentUndo, recentRedo, ...}


イベント発行の監視（何がいつ発火しているか）

window.TegakiEventBus.on('history:changed', (data) => console.log('history:changed', data));
window.TegakiEventBus.on('animation:cut-deleted', () => console.log('cut-deleted event'));
// 必要に応じて他のイベントも監視


動作テストの手順（再現しやすくする）

新規カットを作る → History.getDebugInfo() を取る（記録されるか）

レイヤでペン1ストローク（pointerdown→pointermove→pointerup）→ History.getDebugInfo() を取る

レイヤ移動（ドラッグ終了）→ History.getDebugInfo() を取る
→ これで「どのアクションで undoStack に増えるか」が判る。

一時的な監査追加（もし必要なら）

描画モジュールの pointerup にだけ一行 History.saveState(); を入れて試す（効果確認後はコメントアウトまたはイベント化する）。

優先的に直すべき小さなコード変更（すぐ効く）

描画側（pointerup）で History.saveState() を呼ぶ（1行追加で大きく改善）

レイヤ移動完了で History.saveState() を呼ぶ（または TegakiEventBus.emit('layer:moved-complete') を投げ、それを history が監視）

undo() 実行時の currentState 取得失敗をログ化し再現時に原因を特定（短期のみ）

// history.js の undo() の try-catch で currentState が null の場合は console.warn で出すなど


（恒久的なログは避けつつ、原因特定用に一時的に出す）

なぜ「1画で1ポイント」になっていないことが多いか（結論）

実装方針が「外部からの呼び出しでスナップショットを作る」方式だから。描画モジュールが pointerup で History.saveState() を呼んでいなければ、そのストロークは記録されない。

また undo/redo の内部ロジックが snapshot/redo の作成に依存していて、タイミング依存（capture が成功したかどうか）で再現性が崩れる。つまり「保存を確実に起こす」か「差分コマンド化で独立させる」どちらかをやる必要があります。 
GitHub

最後に：推奨次アクション（優先順）

描画ストロークの終了（pointerup）に History.saveState() を追加して挙動を確認。

レイヤ系の操作完了にも History.saveState() を追加（あるいは TegakiEventBus に適切なイベントを追加）して、一貫して履歴が増えるか確認。

それでも不整合があるなら、History.getDebugInfo() を使って undo/redo 実行時の currentState 取得可否を検証し、失敗パス（null を返す箇所）を修正。

中期的に、パス単位の差分コマンドへ移行する検討（より複雑だが UX と性能面で有利）。