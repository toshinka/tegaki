================================================================================
WebGL2ãƒãƒªã‚´ãƒ³ãƒšãƒ³åº§æ¨™ã‚ºãƒ¬ãƒ»å¤‰å½¢å•é¡Œ æ”¹ä¿®è¨ˆç”»æ›¸
================================================================================
ä½œæˆæ—¥: 2025-02-XX
å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³: webgl2_v15
çŠ¶æ…‹: å•é¡Œè¨ºæ–­å®Œäº†ãƒ»æ”¹ä¿®è¨ˆç”»ç­–å®š

ã€ç¾è±¡ã€‘
âš ï¸ ãƒšãƒ³å…¥åŠ›ä½ç½®ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ä½ç½®ãŒã‚ºãƒ¬ã‚‹
âš ï¸ é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã§æç”»ãŒç¸¦æ¨ªã«å¤‰å½¢ã™ã‚‹ï¼ˆæ³•å‰‡æ€§ã‚ã‚Šï¼‰
âš ï¸ ç­†åœ§ãŒç„¡è¦–ã•ã‚Œã‚‹ï¼ˆåº§æ¨™å®‰å®šåŒ–å¾Œã«å¯¾å¿œï¼‰
âŒ æ¶ˆã—ã‚´ãƒ ãŒåŠ¹ã‹ãªã„ï¼ˆãƒšãƒ³å®‰å®šåŒ–å¾Œã«å¯¾å¿œï¼‰

ã€ç›®æ¨™ã€‘
âœ… ãƒãƒªã‚´ãƒ³ãƒšãƒ³ã®å®Œå…¨å®‰å®šåŒ–ï¼ˆPerfectFreehand + WebGL2 Meshï¼‰
âœ… åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Œå…¨ä¸€æœ¬åŒ–
âœ… DPR=1å›ºå®šã€Pixiã¯ UI ã®ã¿ã€WebGL2 ãŒæç”»ã‚ªãƒ¼ãƒŠãƒ¼

================================================================================
â–  Phase 1: ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ãƒ»ä¾å­˜é–¢ä¿‚ãƒ»å•é¡Œç®‡æ‰€ã®è¾å…¸åŒ–
================================================================================

### ğŸ“ ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ï¼ˆåº§æ¨™å¤‰æ›ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆãƒ»æç”»ã‚¨ãƒ³ã‚¸ãƒ³ï¼‰

ã€coordinate-system.jsã€‘v8.14.0 WebGL2å¯¾å¿œç‰ˆ
  è²¬å‹™: åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ Screen â†’ Canvas â†’ World â†’ Local ã®çµ±ä¸€ç®¡ç†
  è¦ªä¾å­˜: config.js, event-bus.js, camera-system.js
  å­ä¾å­˜: drawing-engine.js, stroke-recorder.js, pointer-handler.js
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - screenClientToCanvas(clientX, clientY) â†’ {canvasX, canvasY}
    - canvasToWorld(canvasX, canvasY) â†’ {worldX, worldY}
    - worldToLocal(worldX, worldY, container) â†’ {localX, localY}
  
  ğŸ” å•é¡Œç®‡æ‰€:
    - canvasToWorld(): PixiJS v8 worldTransform.applyInverse() ä½¿ç”¨
    - worldToLocal(): æ‰‹å‹•é€†å¤‰æ›å®Ÿè£…ï¼ˆPIXI toLocal()ç¦æ­¢ï¼‰
    - _getWorldContainer(): worldContainerå‚ç…§ãŒè¤‡æ•°ç®‡æ‰€ã‹ã‚‰å–å¾—å¯èƒ½ã§ä¸å®‰å®š
  
  âš ï¸ æ½œåœ¨çš„å•é¡Œ:
    - worldContainer.worldTransform ãŒæ›´æ–°ã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ï¼ˆPixi Tickeråœæ­¢æ™‚ï¼‰
    - Fallbackæ‰‹å‹•å¤‰æ›ã®rotation/scale/pivotè¨ˆç®—é †åº


ã€drawing-engine.jsã€‘v8.14.1 WebGL2ç§»è¡Œç‰ˆ
  è²¬å‹™: PointerEventå—ä¿¡ãƒ»åº§æ¨™å¤‰æ›å®Ÿè¡Œãƒ»BrushCoreã¸ã®æç”»å‘½ä»¤å§”è­²
  è¦ªä¾å­˜: coordinate-system.js, camera-system.js, layer-system.js, brush-core.js, pointer-handler.js
  å­ä¾å­˜: core-engine.jsï¼ˆåˆæœŸåŒ–å‘¼ã³å‡ºã—å…ƒï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - _handlePointerDown/Move/Up(e): PointerEventå‡¦ç†
    - _transformPointerToLocal(e) â†’ {localX, localY, worldX, worldY, canvasX, canvasY}
    - flushPendingPoints(): ãƒãƒƒãƒå‡¦ç†
  
  ğŸ” å•é¡Œç®‡æ‰€:
    - _transformPointerToLocal()å†…ã§åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ
      PointerEvent.clientX/Y â†’ screenClientToCanvas() â†’ canvasToWorld() â†’ worldToLocal()
    - activeLayerå–å¾—: this.layerManager.getActiveLayer()
    - worldToLocal()ã«activeLayerã‚’æ¸¡ã—ã¦ã„ã‚‹ãŒã€layeræ§‹é€ ãŒæ­£ã—ã„ã‹è¦ç¢ºèª
  
  âš ï¸ æ½œåœ¨çš„å•é¡Œ:
    -åº§æ¨™å¤‰æ›ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã§NaN/Infinityæ··å…¥ã®å¯èƒ½æ€§
    - activeLayerã®parent chainãŒworldContainerã¾ã§æ­£ã—ãç¹‹ãŒã£ã¦ã„ã‚‹ã‹ä¸æ˜


ã€stroke-recorder.jsã€‘Phase 0å®Œæˆç‰ˆ
  è²¬å‹™: Localåº§æ¨™ãƒã‚¤ãƒ³ãƒˆè¨˜éŒ²å°‚ç”¨ï¼ˆåº§æ¨™å¤‰æ›ã¯ä¸€åˆ‡è¡Œã‚ãªã„ï¼‰
  è¦ªä¾å­˜: drawing-engine.jsï¼ˆLocalåº§æ¨™å–å¾—å…ƒï¼‰
  å­ä¾å­˜: brush-core.jsï¼ˆstartStroke/updateStroke/endStrokeå‘¼ã³å‡ºã—ï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - startStroke(localX, localY, pressure, options)
    - addPoint(localX, localY, pressure, tiltX, tiltY)
    - getRawPoints() â†’ Array<{x, y, pressure, tiltX, tiltY, timestamp, ...}>
  
  âœ… æ­£å¸¸: åº§æ¨™å¤‰æ›ã‚’ä¸€åˆ‡è¡Œã‚ãšã€å—ã‘å–ã£ãŸLocalåº§æ¨™ã‚’ãã®ã¾ã¾è¨˜éŒ²
  âœ… æ­£å¸¸: PerfectFreehandäº’æ›å½¢å¼ + æ‹¡å¼µãƒ‡ãƒ¼ã‚¿ä¿æŒ


ã€brush-core.jsã€‘Phase 2.2 åº§æ¨™ã‚ºãƒ¬å®Œå…¨ä¿®æ­£ç‰ˆ
  è²¬å‹™: ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å‡¦ç†çµ±åˆãƒ»ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»ãƒ»æœ€çµ‚æç”»ãƒ»æ¶ˆã—ã‚´ãƒ å‡¦ç†
  è¦ªä¾å­˜: stroke-recorder.js, gl-stroke-processor.js, gl-msdf-pipeline.js, gl-texture-bridge.js, gl-mask-layer.js, layer-system.js, history.js, event-bus.js
  å­ä¾å­˜: drawing-engine.jsï¼ˆstartStroke/updateStrokeå‘¼ã³å‡ºã—å…ƒï¼‰, core-engine.jsï¼ˆrenderPreviewå‘¼ã³å‡ºã—å…ƒï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - startStroke(localX, localY, pressure): ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯é–‹å§‹
    - updateStroke(localX, localY, pressure): ãƒã‚¤ãƒ³ãƒˆè¿½åŠ 
    - renderPreview(): ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»ï¼ˆthrottle 100msï¼‰
    - _updatePreview(points): å†…éƒ¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†
    - finalizeStroke(): æœ€çµ‚ç¢ºå®šæç”»
    - _finalizeMSDFStroke(points, activeLayer): MSDFç”Ÿæˆãƒ»Spriteé…ç½®
  
  ğŸ” å•é¡Œç®‡æ‰€ï¼ˆPhase 2.2ã§ä¿®æ­£æ¸ˆã¿ã ãŒå†ç¢ºèªå¿…è¦ï¼‰:
    - _updatePreview()å†…:
      * glStrokeProcessor.createPolygonVertexBuffer(points, size)
      * glMSDFPipeline.generateMSDF(edgeBuffer, bounds, ...)
      * Spriteé…ç½®: sprite.x/y = bounds.minX/minY, width/height = bounds.width/height
    
    - _finalizeMSDFStroke()å†…ã‚‚åŒæ§˜
  
  âš ï¸ Phase 2.2ä¿®æ­£å†…å®¹:
    âœ… Spriteã‚¹ã‚±ãƒ¼ãƒ«ä¿®æ­£: 512å›ºå®š â†’ bounds.width/height
    âœ… ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é€æ˜åº¦: å®Ÿéš›ã®å€¤ã«ä¿®æ­£
  
  ğŸ” è¿½åŠ å•é¡Œã®å¯èƒ½æ€§:
    - boundsè¨ˆç®—ã®åº§æ¨™ç³»ãŒæ­£ã—ã„ã‹ï¼Ÿï¼ˆLocalåº§æ¨™å‰æï¼‰
    - Spriteé…ç½®å…ˆã®containerãŒactiveLayerã®drawingContainerã‹ç¢ºèª
    - Sprite.x/yã«è¨­å®šã™ã‚‹bounds.minX/minYãŒLocalåº§æ¨™ç³»ã§ä¸€è‡´ã—ã¦ã„ã‚‹ã‹


================================================================================
### ğŸ“ WebGL2æç”»ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

ã€gl-stroke-processor.jsã€‘Phase 1.6å®Œå…¨ä¿®æ­£ç‰ˆ
  è²¬å‹™: PerfectFreehandå‡ºåŠ›â†’GPUé ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆãƒ»Earcutä¸‰è§’å½¢åˆ†å‰²ãƒ»EdgeBufferç”Ÿæˆãƒ»Boundsè¨ˆç®—
  è¦ªä¾å­˜: libs/perfect-freehand-1.2.0.min.js, system/earcut-triangulator.js, config.js, webgl2-drawing-layer.js
  å­ä¾å­˜: brush-core.jsï¼ˆcreatePolygonVertexBuffer/createEdgeBufferå‘¼ã³å‡ºã—å…ƒï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - createPolygonVertexBuffer(points, baseSize) â†’ {buffer: Float32Array, vertexCount, bounds}
    - createEdgeBuffer(points, baseSize) â†’ {buffer: Float32Array, edgeCount, bounds}
    - calculateBounds(points, margin) â†’ {minX, minY, maxX, maxY, width, height}
    - uploadToGPU(data, usage, elementStrideBytes) â†’ {glBuffer, elementCount, data}
  
  ğŸ”§ Phase 1.6ä¿®æ­£å†…å®¹:
    âœ… é ‚ç‚¹åº§æ¨™ã‚’boundsã«å¯¾ã™ã‚‹ç›¸å¯¾åº§æ¨™ã«å¤‰æ›
      - Localåº§æ¨™ã‹ã‚‰bounds.minX/minYã‚’å¼•ã„ã¦æ­£è¦åŒ–
      - ãƒ†ã‚¯ã‚¹ãƒãƒ£ç©ºé–“ [0, bounds.width] x [0, bounds.height] ã«å¤‰æ›
    âœ… åº§æ¨™å¤‰æ›ã‚’å®Œå…¨ã«çµ±ä¸€
  
  ğŸ” é‡è¦ãƒã‚¤ãƒ³ãƒˆ:
    - _normalizePoints(points): å…¥åŠ›ãƒã‚¤ãƒ³ãƒˆå½¢å¼ã‚’çµ±ä¸€ï¼ˆ{x,y,pressure}å½¢å¼ã¸ï¼‰
    - _calculateBoundsFromPoints(points, margin): å‹•çš„marginè¨ˆç®—
    - createPolygonVertexBuffer()å†…ã®flaté…åˆ—ç”Ÿæˆ:
      ```
      flat.push(
        outlinePoints[i][0] - bounds.minX,  // boundsãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã«å¤‰æ›
        outlinePoints[i][1] - bounds.minY
      );
      ```
    - é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ: [posX, posY, texU, texV, reserved1, reserved2, reserved3] = 7 floats/vertex
  
  âš ï¸ å•é¡Œã®å¯èƒ½æ€§:
    - å…¥åŠ›pointsãŒLocalåº§æ¨™ã§ã‚ã‚‹ã“ã¨ã‚’å‰æã¨ã—ã¦ã„ã‚‹ãŒã€å®Ÿéš›ã«Localåº§æ¨™ã‹è¦æ¤œè¨¼
    - boundsè¨ˆç®—æ™‚ã®marginå€¤ãŒé©åˆ‡ã‹ï¼ˆå‹•çš„è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯è¦ç¢ºèªï¼‰
    - PerfectFreehandå®Ÿè¡Œæ™‚ã®config.perfectFreehandã‚ªãƒ—ã‚·ãƒ§ãƒ³å€¤


ã€gl-msdf-pipeline.jsã€‘Phase 1.8 Rollbackä¿®æ­£ç‰ˆ
  è²¬å‹™: MSDFè·é›¢å ´ç”Ÿæˆï¼ˆJFA: Jump Flooding Algorithmï¼‰ãƒ»WebGLTextureå‡ºåŠ›
  è¦ªä¾å­˜: webgl2-drawing-layer.js, gl-stroke-processor.js
  å­ä¾å­˜: brush-core.jsï¼ˆgenerateMSDFå‘¼ã³å‡ºã—å…ƒï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - generateMSDF(edgeBufferData, bounds, existingMSDF, settings, vertexBufferData, vertexCount, edgeCount) â†’ {texture, width, height}
    - seedInitPass/jfaPass/encodePass/renderPass: ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å„æ®µéš
  
  ğŸ”§ Phase 1.8ä¿®æ­£å†…å®¹:
    âš ï¸ Phase 1.7ã®éå‰°ä¿®æ­£ã‚’å–ã‚Šæ¶ˆã—
    âœ… aPositionã¯æ—¢ã«[0, bounds.width/height]åº§æ¨™ï¼ˆgl-stroke-processorå‡¦ç†æ¸ˆã¿ï¼‰
    âœ… render.vert.glsl: aPosition / uResolution ã§æ­£è¦åŒ–
    âœ… uBoundsSizeå‰Šé™¤ï¼ˆä¸è¦ï¼‰
  
  ğŸ” Vertex Shaderé‡è¦éƒ¨åˆ†ï¼ˆrender.vert.glslç›¸å½“ï¼‰:
    ```glsl
    // âœ… aPositionã¯æ—¢ã«[0, bounds.width/height]
    vec2 normalized = aPosition / uResolution;  // uResolution = 512x512
    vec2 clipSpace = normalized * 2.0 - 1.0;
    clipSpace.y = -clipSpace.y;
    gl_Position = vec4(clipSpace, 0.0, 1.0);
    ```
  
  ğŸ” _drawStroke()ãƒ¡ã‚½ãƒƒãƒ‰:
    - Vertex Buffer Binding: 7 floats/vertex (stride = 28 bytes)
    - Attribute Layout: aPosition(2), aTexCoord(2), aReserved(3)
    - uResolutionè¨­å®š: gl.uniform2f(uResolution, resolution.width, resolution.height)
  
  âš ï¸ å•é¡Œã®å¯èƒ½æ€§:
    - textureSizeå›ºå®š512x512ãŒé©åˆ‡ã‹ï¼Ÿï¼ˆbounds.width/heightã¨ä¸ä¸€è‡´æ™‚ï¼‰
    - uResolutionã«æ¸¡ã™resolution.width/heightã®å€¤ãŒä½•ã‹ï¼Ÿï¼ˆ512å›ºå®šï¼Ÿboundså€¤ï¼Ÿï¼‰
    - clipSpace.yåè»¢ã®å¿…è¦æ€§ç¢ºèª


ã€webgl2-drawing-layer.jsã€‘ï¼ˆè©³ç´°æœªå–å¾—ã ãŒæ§‹é€ æ¨æ¸¬ï¼‰
  è²¬å‹™: WebGL2ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ãƒ»FBO/Textureç®¡ç†ãƒ»ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ«ãƒ¼ãƒ—
  è¦ªä¾å­˜: ãªã—ï¼ˆWebGL2 APIç›´æ¥ä½¿ç”¨ï¼‰
  å­ä¾å­˜: gl-stroke-processor.js, gl-msdf-pipeline.js, gl-texture-bridge.js, gl-mask-layer.js
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ¨æ¸¬ï¼‰:
    - getGL() â†’ WebGL2RenderingContext
    - getCanvas() â†’ HTMLCanvasElement
    - createFBO(width, height, options) â†’ {fbo, texture, width, height}
    - deleteFBO(fbo)
  
  ğŸ” é‡è¦ç¢ºèªé …ç›®:
    - WebGL2ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚µã‚¤ã‚ºã¨Pixiã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚µã‚¤ã‚ºä¸€è‡´
    - DPR=1å›ºå®šã•ã‚Œã¦ã„ã‚‹ã‹
    - Viewportè¨­å®šãŒæ­£ã—ã„ã‹


================================================================================
â–  Phase 2: å•é¡Œã®æ ¹æœ¬åŸå› åˆ†æ

### ğŸ” åº§æ¨™ã‚ºãƒ¬ã®åŸå› å€™è£œ

ã€å€™è£œ1ã€‘åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ã®åº§æ¨™ç³»æ··åœ¨
  ç—‡çŠ¶: ãƒšãƒ³å…¥åŠ›ä½ç½®ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ä½ç½®ãŒã‚ºãƒ¬ã‚‹
  
  æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ:
    âœ“ drawing-engine._transformPointerToLocal()ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã§console.log
    âœ“ screenClientToCanvas()ã§æ­£ã—ãDPIè£œæ­£ã•ã‚Œã¦ã„ã‚‹ã‹
    âœ“ canvasToWorld()ã§worldTransform.applyInverse()ãŒæ­£å¸¸å‹•ä½œã—ã¦ã„ã‚‹ã‹
    âœ“ worldToLocal()ã§activeLayerã¾ã§ã®è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ãŒæ­£ã—ã„ã‹
  
  åŸå› ä»®èª¬:
    âš ï¸ worldContainerã®worldTransformãŒæ›´æ–°ã•ã‚Œã¦ã„ãªã„
      â†’ PixiJSã®TickerãŒåœæ­¢ã—ã¦ã„ã‚‹å ´åˆã€transformæ›´æ–°ãŒé…å»¶ã™ã‚‹
      â†’ æ‰‹å‹•ã§worldContainer.updateTransform()ã‚’å‘¼ã¶å¿…è¦ãŒã‚ã‚‹å¯èƒ½æ€§
    
    âš ï¸ activeLayerã®parent chainãŒworldContainerã¾ã§ç¹‹ãŒã£ã¦ã„ãªã„
      â†’ worldToLocal()ã®è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ã§ä¸å®Œå…¨ãªå¤‰æ›ãŒç™ºç”Ÿ
    
    âš ï¸ DPI/DPRè¨ˆç®—ã®ä¸ä¸€è‡´
      â†’ canvas.width/height vs rect.width/height ã®æ¯”ç‡è¨ˆç®—ãƒŸã‚¹


ã€å€™è£œ2ã€‘Boundsè¨ˆç®—ã¨Spriteé…ç½®ã®åº§æ¨™ç³»ä¸ä¸€è‡´
  ç—‡çŠ¶: é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã§å¤‰å½¢ã™ã‚‹
  
  æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ:
    âœ“ gl-stroke-processor.calculateBounds()ã®å…¥åŠ›pointsãŒLocalåº§æ¨™ã‹ç¢ºèª
    âœ“ boundsã®{minX, minY, maxX, maxY}ãŒLocalåº§æ¨™ç³»ã§è¨ˆç®—ã•ã‚Œã¦ã„ã‚‹ã‹
    âœ“ brush-core._updatePreview()ã§ã®sprite.x/yè¨­å®šå€¤ãŒLocalåº§æ¨™ã‹ç¢ºèª
    âœ“ Spriteã®parentï¼ˆcontainerï¼‰ãŒactiveLayerã®drawingContainerã‹ç¢ºèª
  
  åŸå› ä»®èª¬:
    âš ï¸ boundsãŒWorldåº§æ¨™ç³»ã§è¨ˆç®—ã•ã‚Œã¦ã„ã‚‹
      â†’ stroke-recorderã«æ¸¡ã•ã‚Œã‚‹pointsã¯Localåº§æ¨™ã ãŒã€
         boundsè¨ˆç®—æ™‚ã«Worldåº§æ¨™ãŒæ··å…¥ã—ã¦ã„ã‚‹å¯èƒ½æ€§
    
    âš ï¸ Spriteé…ç½®å…ˆã®containerã®transformãŒè€ƒæ…®ã•ã‚Œã¦ã„ãªã„
      â†’ sprite.x = bounds.minX ã¯æ­£ã—ã„ãŒã€containerã®ä½ç½®ãŒãšã‚Œã¦ã„ã‚‹
    
    âš ï¸ ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚º512x512ã¨bounds.width/heightã®æ¯”ç‡ä¸ä¸€è‡´
      â†’ gl-msdf-pipeline.renderPass()ã§uResolutionã«ä½•ã‚’æ¸¡ã—ã¦ã„ã‚‹ã‹ä¸æ˜ç¢º


ã€å€™è£œ3ã€‘WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã®åº§æ¨™å¤‰æ›ãƒŸã‚¹
  ç—‡çŠ¶: æç”»ãŒå¤‰å½¢ã™ã‚‹ï¼ˆç‰¹ã«é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼‰
  
  æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ:
    âœ“ gl-msdf-pipeline.renderPass()ã®uResolutionå€¤
    âœ“ render.vert.glslã§ã®aPositionæ­£è¦åŒ–è¨ˆç®—
    âœ“ textureSize(512x512)ã¨bounds.width/heightã®é–¢ä¿‚
  
  åŸå› ä»®èª¬:
    âš ï¸ uResolutionã«512x512ã‚’æ¸¡ã—ã¦ã„ã‚‹ãŒã€boundsã‚µã‚¤ã‚ºã¨ä¸ä¸€è‡´
      â†’ aPosition / uResolution ã®æ­£è¦åŒ–ãŒä¸æ­£ç¢º
      â†’ ç‰¹ã«bounds.width > 512 ã®å ´åˆã«å¤‰å½¢ç™ºç”Ÿ
    
    ğŸ”§ ä¿®æ­£æ¡ˆ:
      - textureSize = max(bounds.width, bounds.height) ã«å‹•çš„å¤‰æ›´
      - ã¾ãŸã¯ã€aPositionã‚’[0, 1]æ­£è¦åŒ–ã—ã¦ã‹ã‚‰clipSpaceå¤‰æ›


ã€å€™è£œ4ã€‘PerfectFreehandã®å‡ºåŠ›åº§æ¨™ç³»å•é¡Œ
  ç—‡çŠ¶: ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å½¢çŠ¶ãŒãŠã‹ã—ã„
  
  æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ:
    âœ“ PerfectFreehandå®Ÿè¡Œå‰ã®pointsé…åˆ—ãŒLocalåº§æ¨™ã‹ç¢ºèª
    âœ“ config.perfectFreehandã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³å€¤ï¼ˆthinning, smoothingç­‰ï¼‰
    âœ“ PerfectFreehandå‡ºåŠ›ã®outlinePointsãŒLocalåº§æ¨™ç³»ã§è¿”ã•ã‚Œã¦ã„ã‚‹ã‹
  
  åŸå› ä»®èª¬:
    âš ï¸ PerfectFreehandã¸ã®å…¥åŠ›åº§æ¨™ãŒä¸æ­£ç¢º
      â†’ stroke-recorderã«è¨˜éŒ²ã•ã‚Œã‚‹åº§æ¨™ãŒå®Ÿã¯Localåº§æ¨™ã§ã¯ãªã„
    
    âš ï¸ PerfectFreehandã®sizeè¨­å®šãŒä¸é©åˆ‡
      â†’ ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å¹…ãŒå¤§ãã™ãã‚‹/å°ã•ã™ãã‚‹


================================================================================
â–  Phase 3: æ”¹ä¿®æ–¹é‡ï¼ˆå„ªå…ˆé †ä½é †ï¼‰

### ğŸ”§ æ”¹ä¿®1: åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Œå…¨æ¤œè¨¼ãƒ»ä¿®æ­£ï¼ˆæœ€å„ªå…ˆï¼‰

ã€å®Ÿæ–½å†…å®¹ã€‘
  1. ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
     - drawing-engine._transformPointerToLocal()ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã§ãƒ­ã‚°å‡ºåŠ›
     - coordinate-system.jsã®å„ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ãƒ­ã‚°å‡ºåŠ›
     - NaN/Infinityæ¤œå‡º
  
  2. worldContainer.worldTransformæ›´æ–°ä¿è¨¼
     - coordinate-system.canvasToWorld()å†…ã§
       worldContainer.updateTransform()ã‚’æ˜ç¤ºçš„ã«å‘¼ã¶
  
  3. activeLayerå–å¾—ãƒ»parent chainæ¤œè¨¼
     - layerManager.getActiveLayer()ã®æˆ»ã‚Šå€¤ã‚’å³å¯†ãƒã‚§ãƒƒã‚¯
     - activeLayer.parent â†’ parent.parent â†’ ... â†’ worldContainer ã®çµŒè·¯ç¢ºèª
     - worldToLocal()ã®è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ãƒ­ã‚°è¿½åŠ 
  
  4. DPI/DPRè¨ˆç®—ã®å†ç¢ºèª
     - screenClientToCanvas()ã®scaleX/scaleYè¨ˆç®—ã‚’æ¤œè¨¼
     - canvas.width/height, rect.width/height ã®å€¤ã‚’ãƒ­ã‚°å‡ºåŠ›

ã€æœŸå¾…åŠ¹æœã€‘
  âœ… åº§æ¨™ã‚ºãƒ¬ã®æ ¹æœ¬åŸå› ç‰¹å®š
  âœ… åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä¿¡é ¼æ€§ç¢ºä¿


### ğŸ”§ æ”¹ä¿®2: Boundsè¨ˆç®—ãƒ»Spriteé…ç½®ã®åº§æ¨™ç³»çµ±ä¸€

ã€å®Ÿæ–½å†…å®¹ã€‘
  1. gl-stroke-processor.calculateBounds()æ¤œè¨¼
     - å…¥åŠ›pointsãŒLocalåº§æ¨™ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
     - boundså€¤ã‚’ãƒ­ã‚°å‡ºåŠ›
     - marginè¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯å†ç¢ºèª
  
  2. brush-core._updatePreview()/_finalizeMSDFStroke()ä¿®æ­£
     - boundsè¨ˆç®—å¾Œã€ä»¥ä¸‹ã‚’ç¢ºèª:
       ```javascript
       console.log('Bounds (Localåº§æ¨™):', bounds);
       console.log('Spriteé…ç½®:', { x: bounds.minX, y: bounds.minY, width: bounds.width, height: bounds.height });
       console.log('Container:', container.position, container.scale, container.rotation);
       ```
     - Spriteã®parentãŒcontainerï¼ˆactiveLayer.drawingContainerï¼‰ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼
  
  3. ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã¨boundsã®é–¢ä¿‚æ˜ç¢ºåŒ–
     - gl-msdf-pipeline.textureSize ã‚’å‹•çš„åŒ–ï¼ˆPhase 3ã§å®Ÿè£…äºˆå®šã¨è¨˜è¼‰ã‚ã‚Šï¼‰
     - å½“é¢ã¯512å›ºå®šã ãŒã€uResolutionã«ä½•ã‚’æ¸¡ã™ã¹ãã‹æ˜ç¢ºåŒ–

ã€æœŸå¾…åŠ¹æœã€‘
  âœ… Spriteé…ç½®ã®æ­£ç¢ºæ€§å‘ä¸Š
  âœ… å¤‰å½¢å•é¡Œã®è§£æ¶ˆ


### ğŸ”§ æ”¹ä¿®3: WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã®åº§æ¨™æ­£è¦åŒ–ä¿®æ­£

ã€å®Ÿæ–½å†…å®¹ã€‘
  1. gl-msdf-pipeline.renderPass()ä¿®æ­£
     - uResolutionã«æ¸¡ã™å€¤ã‚’æ˜ç¢ºåŒ–:
       ```javascript
       // ç¾åœ¨: gl.uniform2f(uResolution, width, height);  // width/height = 512å›ºå®š
       // ä¿®æ­£æ¡ˆ: gl.uniform2f(uResolution, bounds.width, bounds.height);
       ```
     
     - ãŸã ã—ã€textureSize = 512å›ºå®šãªã®ã§ã€ä»¥ä¸‹ã®ã„ãšã‚Œã‹:
       A) textureSize = bounds.width/height ã«å¤‰æ›´ï¼ˆPhase 3å®Ÿè£…ï¼‰
       B) aPositionåº§æ¨™ã‚’äº‹å‰ã«[0, 512]ã«ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆgl-stroke-processorå´ï¼‰
       C) render.vert.glslã§ã®æ­£è¦åŒ–è¨ˆç®—ã‚’ä¿®æ­£
  
  2. render.vert.glslä¿®æ­£æ¡ˆï¼ˆæ¡ˆCæ¡ç”¨ã®å ´åˆï¼‰
     ```glsl
     uniform vec2 uResolution;        // ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£åƒåº¦ï¼ˆ512x512ï¼‰
     uniform vec2 uBoundsSize;        // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯bounds.width/height
     
     void main() {
       // aPositionã¯[0, bounds.width/height]åº§æ¨™
       // 1. boundsã‚µã‚¤ã‚ºã§æ­£è¦åŒ– â†’ [0, 1]
       vec2 normalized = aPosition / uBoundsSize;
       // 2. ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£åƒåº¦ã«ã‚¹ã‚±ãƒ¼ãƒ« â†’ [0, 512]
       vec2 texPos = normalized * uResolution;
       // 3. ã‚¯ãƒªãƒƒãƒ—ç©ºé–“å¤‰æ›
       vec2 clipSpace = (texPos / uResolution) * 2.0 - 1.0;
       clipSpace.y = -clipSpace.y;
       gl_Position = vec4(clipSpace, 0.0, 1.0);
     }
     ```
  
  3. _drawStroke()ãƒ¡ã‚½ãƒƒãƒ‰ä¿®æ­£
     - uBoundsSize uniformè¿½åŠ ãƒ»è¨­å®š:
       ```javascript
       const uBoundsSize = gl.getUniformLocation(program, 'uBoundsSize');
       if (uBoundsSize) {
         gl.uniform2f(uBoundsSize, bounds.width, bounds.height);
       }
       ```

ã€æœŸå¾…åŠ¹æœã€‘
  âœ… WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã®åº§æ¨™å¤‰æ›ã®æ­£ç¢ºæ€§å‘ä¸Š
  âœ… é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã§ã®å¤‰å½¢å•é¡Œè§£æ¶ˆ


### ğŸ”§ æ”¹ä¿®4: PerfectFreehandå…¥åŠ›åº§æ¨™ãƒ»ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ¤œè¨¼

ã€å®Ÿæ–½å†…å®¹ã€‘
  1. stroke-recorder.getRawPoints()ã®å‡ºåŠ›ç¢ºèª
     - ãƒ­ã‚°ã§pointsé…åˆ—ã®åº§æ¨™å€¤ã‚’ç¢ºèª
     - Localåº§æ¨™ç¯„å›²ï¼ˆé€šå¸¸0ï½ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºï¼‰å†…ã‹æ¤œè¨¼
  
  2. config.perfectFreehandã‚ªãƒ—ã‚·ãƒ§ãƒ³èª¿æ•´
     - ç¾åœ¨ã®è¨­å®š:
       ```javascript
       thinning: 0.7,
       smoothing: 0.4,
       streamline: 0.3
       ```
     - å¿…è¦ã«å¿œã˜ã¦èª¿æ•´ï¼ˆç‰¹ã«smoothing/streamlineãŒåº§æ¨™è£œé–“ã«å½±éŸ¿ï¼‰
  
  3. gl-stroke-processor._executePerfectFreehand()æ¤œè¨¼
     - å…¥åŠ›strokePointsé…åˆ—ã‚’ãƒ­ã‚°å‡ºåŠ›
     - å‡ºåŠ›outlinePointsé…åˆ—ã‚’ãƒ­ã‚°å‡ºåŠ›
     - åº§æ¨™å€¤ã®å¦¥å½“æ€§ç¢ºèª

ã€æœŸå¾…åŠ¹æœã€‘
  âœ… PerfectFreehandå®Ÿè¡Œã®æ­£ç¢ºæ€§ä¿è¨¼
  âœ… ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å½¢çŠ¶ã®å®‰å®šåŒ–


================================================================================
â–  Phase 4: æ”¹ä¿®å®Ÿæ–½é †åº

ã€Step 1ã€‘ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ ãƒ»å•é¡Œç‰¹å®šï¼ˆ1æ—¥ç›®ï¼‰
  ãƒ•ã‚¡ã‚¤ãƒ«: coordinate-system.js, drawing-engine.js, brush-core.js, gl-stroke-processor.js
  ä½œæ¥­:
    - åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã§console.logè¿½åŠ 
    - NaN/Infinityæ¤œå‡º
    - worldContainer.worldTransform, activeLayer.parent chainç¢ºèª
    - boundså€¤ã€Spriteé…ç½®å€¤ã®ãƒ­ã‚°å‡ºåŠ›
  
  ç¢ºèªæ–¹æ³•:
    - ãƒ–ãƒ©ã‚¦ã‚¶ã§ãƒšãƒ³æç”»ã—ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’ç›£è¦–
    - åº§æ¨™å€¤ã®ç•°å¸¸ã‚’ç‰¹å®š


ã€Step 2ã€‘åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä¿®æ­£ï¼ˆ2æ—¥ç›®ï¼‰
  ãƒ•ã‚¡ã‚¤ãƒ«: coordinate-system.js, drawing-engine.js
  ä½œæ¥­:
    - worldContainer.updateTransform()æ˜ç¤ºçš„å‘¼ã³å‡ºã—è¿½åŠ 
    - worldToLocal()ã®è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ãƒ­ã‚¸ãƒƒã‚¯å†ç¢ºèª
    - DPI/DPRè¨ˆç®—ã®ä¿®æ­£ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
  
  ç¢ºèªæ–¹æ³•:
    - ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã§åº§æ¨™å¤‰æ›ã®å„ã‚¹ãƒ†ãƒƒãƒ—ãŒæ­£å¸¸ã‹ç¢ºèª
    - ãƒšãƒ³å…¥åŠ›ä½ç½®ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ä½ç½®ã®ã‚ºãƒ¬è§£æ¶ˆã‚’ç¢ºèª


ã€Step 3ã€‘Boundsãƒ»Spriteé…ç½®ä¿®æ­£ï¼ˆ3æ—¥ç›®ï¼‰
  ãƒ•ã‚¡ã‚¤ãƒ«: brush-core.js, gl-stroke-processor.js
  ä½œæ¥­:
    - boundsè¨ˆç®—ã®åº§æ¨™ç³»ç¢ºèªãƒ»ä¿®æ­£
    - Spriteé…ç½®ãƒ­ã‚¸ãƒƒã‚¯ç¢ºèªãƒ»ä¿®æ­£
    - Containerå–å¾—ãƒ­ã‚¸ãƒƒã‚¯ç¢ºèª
  
  ç¢ºèªæ–¹æ³•:
    - é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æç”»ã§å¤‰å½¢ãŒèµ·ããªã„ã‹ç¢ºèª
    - Spriteä½ç½®ãŒãƒšãƒ³è»Œè·¡ã¨ä¸€è‡´ã—ã¦ã„ã‚‹ã‹ç¢ºèª


ã€Step 4ã€‘WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¿®æ­£ï¼ˆ4æ—¥ç›®ï¼‰
  ãƒ•ã‚¡ã‚¤ãƒ«: gl-msdf-pipeline.js
  ä½œæ¥­:
    - render.vert.glslä¿®æ­£ï¼ˆuBoundsSizeè¿½åŠ ï¼‰
    - _drawStroke()ãƒ¡ã‚½ãƒƒãƒ‰ä¿®æ­£ï¼ˆuBoundsSizeè¨­å®šï¼‰
    - renderPass()ä¿®æ­£ï¼ˆboundså¼•æ•°åˆ©ç”¨ï¼‰
  
  ç¢ºèªæ–¹æ³•:
    - WebGL2ãƒ†ã‚¯ã‚¹ãƒãƒ£å‡ºåŠ›ãŒæ­£ç¢ºã‹ç¢ºèª
    - å¤‰å½¢å•é¡Œã®å®Œå…¨è§£æ¶ˆç¢ºèª


ã€Step 5ã€‘ç·åˆãƒ†ã‚¹ãƒˆãƒ»å¾®èª¿æ•´ï¼ˆ5æ—¥ç›®ï¼‰
  ä½œæ¥­:
    - æ§˜ã€…ãªã‚µã‚¤ã‚ºãƒ»é•·ã•ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã§ãƒ†ã‚¹ãƒˆ
    - ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ“ä½œä¸‹ã§ã®ãƒ†ã‚¹ãƒˆ
    - ç­†åœ§å¯¾å¿œæº–å‚™ï¼ˆæ¬¡ãƒ•ã‚§ãƒ¼ã‚ºï¼‰
    - ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã®å‰Šé™¤ãƒ»ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  
  ç¢ºèªæ–¹æ³•:
    - ãƒšãƒ³å…¥åŠ›ãŒå®Œå…¨ã«å®‰å®šã—ã¦ã„ã‚‹ã‹
    - åº§æ¨™ã‚ºãƒ¬ãƒ»å¤‰å½¢ãŒå®Œå…¨ã«è§£æ¶ˆã•ã‚Œã¦ã„ã‚‹ã‹


================================================================================
â–  Phase 5: å®Ÿè£…è©³ç´°ï¼ˆClaudeå®Ÿè£…ç”¨ã‚¬ã‚¤ãƒ‰ï¼‰

### ğŸ”§ coordinate-system.jsä¿®æ­£

ã€ä¿®æ­£ç®‡æ‰€1ã€‘canvasToWorld()ãƒ¡ã‚½ãƒƒãƒ‰
  ```javascript
  canvasToWorld(canvasX, canvasY) {
    const worldContainer = this._getWorldContainer();
    if (!worldContainer) {
      return { worldX: canvasX, worldY: canvasY };
    }
    
    // âœ… è¿½åŠ : worldTransformæ›´æ–°ä¿è¨¼
    worldContainer.updateTransform();
    
    const worldTransform = worldContainer.worldTransform;
    if (worldTransform && typeof worldTransform.applyInverse === 'function') {
      try {
        const point = worldTransform.applyInverse({ x: canvasX, y: canvasY });
        
        // âœ… è¿½åŠ : NaNæ¤œå‡º
        if (isNaN(point.x) || isNaN(point.y)) {
          console.error('[CoordinateSystem] canvasToWorld returned NaN', { canvasX, canvasY, point });
          return this._fallbackCanvasToWorld(canvasX, canvasY, worldContainer);
        }
        
        return { worldX: point.x, worldY: point.y };
      } catch (error) {
        console.error('[CoordinateSystem] worldTransform.applyInverse() error:', error);
        return this._fallbackCanvasToWorld(canvasX, canvasY, worldContainer);
      }
    }
    
    return this._fallbackCanvasToWorld(canvasX, canvasY, worldContainer);
  }
  
  // âœ… è¿½åŠ : Fallbackæ‰‹å‹•å¤‰æ›ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‚’åˆ†é›¢ï¼‰
  _fallbackCanvasToWorld(canvasX, canvasY, worldContainer) {
    const pos = worldContainer.position || { x: 0, y: 0 };
    const scale = worldContainer.scale || { x: 1, y: 1 };
    const pivot = worldContainer.pivot || { x: 0, y: 0 };
    const rotation = worldContainer.rotation || 0;
    
    let x = canvasX - pos.x;
    let y = canvasY - pos.y;
    
    if (Math.abs(rotation) > 1e-6) {
      const cos = Math.cos(-rotation);
      const sin = Math.sin(-rotation);
      const rx = x * cos - y * sin;
      const ry = x * sin + y * cos;
      x = rx;
      y = ry;
    }
    
    if (Math.abs(scale.x) > 1e-6) x = x / scale.x;
    if (Math.abs(scale.y) > 1e-6) y = y / scale.y;
    
    x = x + pivot.x;
    y = y + pivot.y;
    
    return { worldX: x, worldY: y };
  }
  ```

ã€ä¿®æ­£ç®‡æ‰€2ã€‘worldToLocal()ãƒ¡ã‚½ãƒƒãƒ‰
  ```javascript
  worldToLocal(worldX, worldY, container) {
    if (!container) {
      console.warn('[CoordinateSystem] worldToLocal: container is null');
      return { localX: worldX, localY: worldY };
    }
    
    // âœ… è¿½åŠ : ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼ˆé–‹ç™ºæ™‚ã®ã¿æœ‰åŠ¹åŒ–ï¼‰
    const DEBUG_COORD = false;
    if (DEBUG_COORD) {
      console.log('[worldToLocal] Input:', { worldX, worldY, containerLabel: container.label || container.name });
    }
    
    let transforms = [];
    let node = container;
    const worldContainer = this._getWorldContainer();
    
    // âœ… è¿½åŠ : ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
    let depth = 0;
    const MAX_DEPTH = 20;
    
    while (node && node !== worldContainer && node !== null) {
      if (depth++ > MAX_DEPTH) {
        console.error('[CoordinateSystem] worldToLocal: parent chain too deep (infinite loop?)');
        break;
      }
      
      transforms.push({
        pos: node.position || { x: 0, y: 0 },
        scale: node.scale || { x: 1, y: 1 },
        rotation: node.rotation || 0,
        pivot: node.pivot || { x: 0, y: 0 },
        label: node.label || node.name || 'unknown'
      });
      node = node.parent;
    }
    
    if (DEBUG_COORD) {
      console.log('[worldToLocal] Transform chain:', transforms.map(t => t.label));
    }
    
    let x = worldX;
    let y = worldY;
    
    for (let i = transforms.length - 1; i >= 0; i--) {
      const t = transforms[i];
      
      x -= t.pos.x;
      y -= t.pos.y;
      
      if (Math.abs(t.rotation) > 1e-6) {
        const cos = Math.cos(-t.rotation);
        const sin = Math.sin(-t.rotation);
        const rx = x * cos - y * sin;
        const ry = x * sin + y * cos;
        x = rx;
        y = ry;
      }
      
      if (Math.abs(t.scale.x) > 1e-6) x /= t.scale.x;
      if (Math.abs(t.scale.y) > 1e-6) y /= t.scale.y;
      
      x += t.pivot.x;
      y += t.pivot.y;
    }
    
    // âœ… è¿½åŠ : NaNæ¤œå‡º
    if (isNaN(x) || isNaN(y)) {
      console.error('[CoordinateSystem] worldToLocal returned NaN', {
        input: { worldX, worldY },
        output: { x, y },
        transforms: transforms
      });
      return { localX: worldX, localY: worldY };
    }
    
    if (DEBUG_COORD) {
      console.log('[worldToLocal] Output:', { localX: x, localY: y });
    }
    
    return { localX: x, localY: y };
  }
}


### ğŸ”§ drawing-engine.jsä¿®æ­£

ã€ä¿®æ­£ç®‡æ‰€ã€‘_transformPointerToLocal()ãƒ¡ã‚½ãƒƒãƒ‰
  ```javascript
  _transformPointerToLocal(e) {
    const coordSys = window.CoordinateSystem;
    if (!coordSys) {
      console.error('[DrawingEngine] CoordinateSystem not found');
      return null;
    }

    // âœ… è¿½åŠ : ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼ˆé–‹ç™ºæ™‚ã®ã¿æœ‰åŠ¹åŒ–ï¼‰
    const DEBUG_TRANSFORM = false;
    
    if (DEBUG_TRANSFORM) {
      console.log('[_transformPointerToLocal] Input:', { clientX: e.clientX, clientY: e.clientY });
    }

    // Step 1: Screen â†’ Canvas
    const canvasCoords = coordSys.screenClientToCanvas(e.clientX, e.clientY);
    if (!canvasCoords) {
      console.error('[DrawingEngine] screenClientToCanvas failed');
      return null;
    }
    
    if (DEBUG_TRANSFORM) {
      console.log('[_transformPointerToLocal] Canvas:', canvasCoords);
    }
    
    // âœ… è¿½åŠ : NaNæ¤œå‡º
    if (isNaN(canvasCoords.canvasX) || isNaN(canvasCoords.canvasY)) {
      console.error('[DrawingEngine] Canvas coords are NaN');
      return null;
    }

    // Step 2: Canvas â†’ World
    const worldCoords = coordSys.canvasToWorld(canvasCoords.canvasX, canvasCoords.canvasY);
    if (!worldCoords) {
      console.error('[DrawingEngine] canvasToWorld failed');
      return null;
    }
    
    if (DEBUG_TRANSFORM) {
      console.log('[_transformPointerToLocal] World:', worldCoords);
    }
    
    // âœ… è¿½åŠ : NaNæ¤œå‡º
    if (isNaN(worldCoords.worldX) || isNaN(worldCoords.worldY)) {
      console.error('[DrawingEngine] World coords are NaN');
      return null;
    }

    // Step 3: activeLayerå–å¾—
    const activeLayer = this.layerManager ? this.layerManager.getActiveLayer() : null;
    if (!activeLayer) {
      console.error('[DrawingEngine] No active layer');
      return null;
    }
    
    // âœ… è¿½åŠ : activeLayeræ¤œè¨¼
    if (DEBUG_TRANSFORM) {
      console.log('[_transformPointerToLocal] ActiveLayer:', {
        id: activeLayer.id,
        label: activeLayer.label || activeLayer.name,
        position: activeLayer.position,
        parent: activeLayer.parent?.label || activeLayer.parent?.name
      });
    }

    // Step 4: World â†’ Local
    const localCoords = coordSys.worldToLocal(
      worldCoords.worldX,
      worldCoords.worldY,
      activeLayer
    );

    if (!localCoords) {
      console.error('[DrawingEngine] worldToLocal failed');
      return null;
    }
    
    if (DEBUG_TRANSFORM) {
      console.log('[_transformPointerToLocal] Local:', localCoords);
    }
    
    // âœ… è¿½åŠ : NaNæ¤œå‡º
    if (isNaN(localCoords.localX) || isNaN(localCoords.localY)) {
      console.error('[DrawingEngine] Local coords are NaN', {
        canvasCoords,
        worldCoords,
        localCoords
      });
      return null;
    }

    return {
      localX: localCoords.localX,
      localY: localCoords.localY,
      worldX: worldCoords.worldX,
      worldY: worldCoords.worldY,
      canvasX: canvasCoords.canvasX,
      canvasY: canvasCoords.canvasY
    };
  }
  ```


### ğŸ”§ brush-core.jsä¿®æ­£

ã€ä¿®æ­£ç®‡æ‰€1ã€‘_updatePreview()ãƒ¡ã‚½ãƒƒãƒ‰ - ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
  ```javascript
  async _updatePreview(points) {
    if (!this.previewContainer || this.previewContainer.destroyed) {
      return;
    }

    this.isPreviewUpdating = true;

    try {
      // âœ… è¿½åŠ : ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
      const DEBUG_PREVIEW = false;
      if (DEBUG_PREVIEW) {
        console.log('[_updatePreview] Points count:', points.length);
        console.log('[_updatePreview] First point:', points[0]);
        console.log('[_updatePreview] Last point:', points[points.length - 1]);
      }

      const vertexResult = this.glStrokeProcessor.createPolygonVertexBuffer(
        points,
        this.currentSettings.size
      );
      if (!vertexResult?.buffer) {
        this.isPreviewUpdating = false;
        return;
      }
      
      // âœ… è¿½åŠ : Boundsæ¤œè¨¼
      if (DEBUG_PREVIEW) {
        console.log('[_updatePreview] Bounds (Localåº§æ¨™):', vertexResult.bounds);
      }

      const edgeResult = this.glStrokeProcessor.createEdgeBuffer(
        points,
        this.currentSettings.size
      );
      if (!edgeResult?.buffer) {
        this.isPreviewUpdating = false;
        return;
      }

      const uploadVertex = this.glStrokeProcessor.uploadToGPU(vertexResult.buffer, 'vertex', 7 * 4);
      const uploadEdge = this.glStrokeProcessor.uploadToGPU(edgeResult.buffer, 'storage', 8 * 4);

      const bounds = this.glStrokeProcessor.calculateBounds(points);
      const width = Math.ceil(bounds.maxX - bounds.minX);
      const height = Math.ceil(bounds.maxY - bounds.minY);

      if (width <= 0 || height <= 0) {
        console.warn('[_updatePreview] Invalid bounds size:', { width, height });
        this.isPreviewUpdating = false;
        return;
      }
      
      // âœ… è¿½åŠ : ã‚µã‚¤ã‚ºæ¤œè¨¼
      if (DEBUG_PREVIEW) {
        console.log('[_updatePreview] Texture size:', { width, height });
      }

      const previewSettings = {
        mode: this.currentSettings.mode,
        color: this.currentSettings.mode === 'eraser' ? '#ff0000' : this.currentSettings.color,
        opacity: this.currentSettings.mode === 'eraser' ? 0.3 : this.currentSettings.opacity,
        size: this.currentSettings.size
      };

      const msdfResult = await this.glMSDFPipeline.generateMSDF(
        uploadEdge.glBuffer,
        bounds,
        null,
        previewSettings,
        uploadVertex.glBuffer,
        vertexResult.vertexCount,
        edgeResult.edgeCount
      );

      if (!msdfResult || !msdfResult.texture) {
        console.warn('[_updatePreview] MSDF generation failed');
        this.isPreviewUpdating = false;
        return;
      }

      if (!this.previewSprite || this.previewSprite.destroyed) {
        const sprite = await this.textureBridge.createSpriteFromGLTexture(
          msdfResult.texture,
          msdfResult.width,
          msdfResult.height
        );

        if (!sprite || !this.previewContainer || this.previewContainer.destroyed) {
          sprite?.destroy({ children: true });
          this.isPreviewUpdating = false;
          return;
        }

        this.previewSprite = sprite;
        this.previewContainer.addChild(sprite);
      } else {
        const newTexture = await this.textureBridge.createSpriteFromGLTexture(
          msdfResult.texture,
          msdfResult.width,
          msdfResult.height
        );

        if (newTexture && newTexture.texture) {
          if (this.previewSprite.texture) {
            this.previewSprite.texture.destroy(true);
          }
          this.previewSprite.texture = newTexture.texture;
        }
      }

      // âœ… Phase 2.2é‡è¦ä¿®æ­£: Spriteã‚¹ã‚±ãƒ¼ãƒ«ã‚’å®Ÿéš›ã®boundsã‚µã‚¤ã‚ºã«
      this.previewSprite.x = bounds.minX;
      this.previewSprite.y = bounds.minY;
      this.previewSprite.width = bounds.width;
      this.previewSprite.height = bounds.height;
      this.previewSprite.alpha = previewSettings.opacity;
      
      // âœ… è¿½åŠ : Spriteé…ç½®æ¤œè¨¼
      if (DEBUG_PREVIEW) {
        console.log('[_updatePreview] Sprite placement:', {
          x: this.previewSprite.x,
          y: this.previewSprite.y,
          width: this.previewSprite.width,
          height: this.previewSprite.height,
          parent: this.previewContainer.label || this.previewContainer.name
        });
      }

    } catch (error) {
      console.error('[BrushCore] Preview failed:', error);
    } finally {
      this.isPreviewUpdating = false;
    }
  }
  ```

ã€ä¿®æ­£ç®‡æ‰€2ã€‘_ensurePreviewContainer()ãƒ¡ã‚½ãƒƒãƒ‰ - Containeræ¤œè¨¼å¼·åŒ–
  ```javascript
  _ensurePreviewContainer(activeLayer) {
    const container = this._getLayerContainer(activeLayer);
    if (!container) {
      console.error('[BrushCore] Cannot get layer container');
      return;
    }
    
    // âœ… è¿½åŠ : Containeræ¤œè¨¼
    if (container.destroyed) {
      console.error('[BrushCore] Layer container is destroyed');
      return;
    }

    if (this.previewContainer && this.previewContainer.destroyed) {
      this.previewContainer = null;
    }

    if (!this.previewContainer) {
      this.previewContainer = new PIXI.Container();
      this.previewContainer.name = 'preview_container';
      this.previewContainer.label = 'preview_container';
      container.addChild(this.previewContainer);
      
      // âœ… è¿½åŠ : Containeréšå±¤ç¢ºèª
      const DEBUG_CONTAINER = false;
      if (DEBUG_CONTAINER) {
        console.log('[_ensurePreviewContainer] Created preview container');
        console.log('  Parent:', container.label || container.name);
        console.log('  Parent position:', container.position);
        console.log('  Parent scale:', container.scale);
      }
    }
  }
  ```


### ğŸ”§ gl-stroke-processor.jsä¿®æ­£

ã€ä¿®æ­£ç®‡æ‰€ã€‘createPolygonVertexBuffer()ãƒ¡ã‚½ãƒƒãƒ‰ - ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
  ```javascript
  createPolygonVertexBuffer(points, baseSize = 10) {
    if (!this.initialized) throw new Error('[GLStrokeProcessor] Not initialized');
    if (!Array.isArray(points) || points.length === 0) {
      console.warn('[GLStrokeProcessor] Invalid points');
      return null;
    }

    // âœ… è¿½åŠ : ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
    const DEBUG_STROKE = false;
    if (DEBUG_STROKE) {
      console.log('[createPolygonVertexBuffer] Input points:', points.length);
      console.log('[createPolygonVertexBuffer] First point:', points[0]);
      console.log('[createPolygonVertexBuffer] Last point:', points[points.length - 1]);
    }

    const processedPoints = this._normalizePoints(points);
    
    if (processedPoints.length < 2) {
      console.warn('[GLStrokeProcessor] Need at least 2 points');
      return null;
    }
    
    // âœ… è¿½åŠ : åº§æ¨™ç¯„å›²ç¢ºèª
    if (DEBUG_STROKE) {
      const minX = Math.min(...processedPoints.map(p => p.x));
      const maxX = Math.max(...processedPoints.map(p => p.x));
      const minY = Math.min(...processedPoints.map(p => p.y));
      const maxY = Math.max(...processedPoints.map(p => p.y));
      console.log('[createPolygonVertexBuffer] Input range:', { minX, maxX, minY, maxY });
    }

    const bounds = this._calculateBoundsFromPoints(processedPoints, baseSize);
    
    if (DEBUG_STROKE) {
      console.log('[createPolygonVertexBuffer] Bounds:', bounds);
    }

    const outlinePoints = this._executePerfectFreehand(processedPoints, baseSize);
    
    if (!outlinePoints || outlinePoints.length < 3) {
      console.warn('[GLStrokeProcessor] PerfectFreehand returned insufficient points');
      return null;
    }
    
    if (DEBUG_STROKE) {
      console.log('[createPolygonVertexBuffer] PerfectFreehand output:', outlinePoints.length, 'points');
    }

    // âœ… Phase 1.6ä¿®æ­£: é ‚ç‚¹åº§æ¨™ã‚’boundsã«å¯¾ã™ã‚‹ç›¸å¯¾åº§æ¨™ã«å¤‰æ›
    const flat = [];
    for (let i = 0; i < outlinePoints.length; i++) {
      const relX = outlinePoints[i][0] - bounds.minX;  // boundsãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã«å¤‰æ›
      const relY = outlinePoints[i][1] - bounds.minY;
      flat.push(relX, relY);
    }
    
    // âœ… è¿½åŠ : ç›¸å¯¾åº§æ¨™ç¯„å›²ç¢ºèª
    if (DEBUG_STROKE) {
      const minRelX = Math.min(...flat.filter((_, i) => i % 2 === 0));
      const maxRelX = Math.max(...flat.filter((_, i) => i % 2 === 0));
      const minRelY = Math.min(...flat.filter((_, i) => i % 2 === 1));
      const maxRelY = Math.max(...flat.filter((_, i) => i % 2 === 1));
      console.log('[createPolygonVertexBuffer] Relative range:', {
        minRelX, maxRelX, minRelY, maxRelY,
        expectedWidth: bounds.width,
        expectedHeight: bounds.height
      });
    }

    const indices = window.EarcutTriangulator.triangulate(flat, null, 2);
    
    if (!indices || indices.length === 0 || indices.length % 3 !== 0) {
      console.warn('[GLStrokeProcessor] Triangulation failed');
      return null;
    }

    const floatsPerVertex = 7;
    const vertexCount = indices.length;
    const buffer = new Float32Array(vertexCount * floatsPerVertex);

    for (let vi = 0; vi < indices.length; vi++) {
      const idx = indices[vi];
      const x = flat[idx * 2];
      const y = flat[idx * 2 + 1];
      
      const base = vi * floatsPerVertex;
      buffer[base + 0] = x;
      buffer[base + 1] = y;
      buffer[base + 2] = 0.0;
      buffer[base + 3] = 0.0;
      buffer[base + 4] = 0.0;
      buffer[base + 5] = 0.0;
      buffer[base + 6] = 0.0;
    }

    return { buffer, vertexCount, bounds };
  }
  ```


### ğŸ”§ gl-msdf-pipeline.jsä¿®æ­£ï¼ˆé‡è¦ï¼‰

ã€ä¿®æ­£ç®‡æ‰€1ã€‘render.vert.glslç›¸å½“éƒ¨åˆ† - uBoundsSizeè¿½åŠ 
  ç¾çŠ¶ã®Vertex Shader:
  ```glsl
  uniform vec2 uResolution;    // ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£åƒåº¦ï¼ˆ512x512å›ºå®šï¼‰
  
  void main() {
    vec2 normalized = aPosition / uResolution;
    vec2 clipSpace = normalized * 2.0 - 1.0;
    clipSpace.y = -clipSpace.y;
    gl_Position = vec4(clipSpace, 0.0, 1.0);
  }
  ```
  
  âš ï¸ å•é¡Œ: aPositionã¯[0, bounds.width/height]åº§æ¨™ã ãŒã€
           uResolution = 512x512ã§æ­£è¦åŒ–ã™ã‚‹ã¨ã€bounds > 512ã®å ´åˆã«åº§æ¨™ãŒç¯„å›²å¤–ã«ãªã‚‹
  
  ğŸ”§ ä¿®æ­£æ¡ˆAï¼ˆæ¨å¥¨ï¼‰: uBoundsSizeã‚’è¿½åŠ 
  ```glsl
  uniform vec2 uResolution;    // ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£åƒåº¦ï¼ˆ512x512ï¼‰
  uniform vec2 uBoundsSize;    // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯bounds.width/height
  
  void main() {
    // Step 1: aPosition[0, bounds.width/height] â†’ [0, 1]æ­£è¦åŒ–
    vec2 normalized = aPosition / uBoundsSize;
    
    // Step 2: [0, 1] â†’ [-1, 1]ã‚¯ãƒªãƒƒãƒ—ç©ºé–“å¤‰æ›
    vec2 clipSpace = normalized * 2.0 - 1.0;
    clipSpace.y = -clipSpace.y;
    
    gl_Position = vec4(clipSpace, 0.0, 1.0);
    vTexCoord = normalized;
  }
  ```
  
  ğŸ”§ ä¿®æ­£æ¡ˆBï¼ˆæš«å®šï¼‰: textureSizeå‹•çš„å¤‰æ›´
    - gl-msdf-pipeline.textureSize = max(bounds.width, bounds.height)
    - ãŸã ã—ã€FBOå†ç”Ÿæˆã‚³ã‚¹ãƒˆãŒé«˜ã„ãŸã‚éæ¨å¥¨

ã€ä¿®æ­£ç®‡æ‰€2ã€‘_createRenderProgram()ãƒ¡ã‚½ãƒƒãƒ‰
  ```javascript
  async _createRenderProgram() {
    const vertexShader = `#version 300 es
      precision highp float;
      
      layout(location = 0) in vec2 aPosition;
      layout(location = 1) in vec2 aTexCoord;
      layout(location = 2) in vec3 aReserved;
      
      uniform vec2 uResolution;     // ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£åƒåº¦ï¼ˆ512x512ï¼‰
      uniform vec2 uBoundsSize;     // âœ… è¿½åŠ : ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯bounds.width/height
      
      out vec2 vTexCoord;
      
      void main() {
        // âœ… ä¿®æ­£: aPositionã‚’å®Ÿéš›ã®boundsSizeã§æ­£è¦åŒ–
        vec2 normalized = aPosition / uBoundsSize;
        vec2 clipSpace = normalized * 2.0 - 1.0;
        clipSpace.y = -clipSpace.y;
        
        gl_Position = vec4(clipSpace, 0.0, 1.0);
        vTexCoord = normalized;
      }
    `;
    
    // Fragment Shaderã¯å¤‰æ›´ãªã—
    const fragmentShader = `#version 300 es
      precision highp float;
      
      uniform sampler2D uMSDFTex;
      uniform vec4 uBrushColor;
      uniform float uOpacity;
      
      in vec2 vTexCoord;
      out vec4 fragColor;
      
      void main() {
        float dist = texture(uMSDFTex, vTexCoord).r;
        float alpha = smoothstep(0.4, 0.6, dist);
        
        fragColor = vec4(uBrushColor.rgb, alpha * uOpacity);
      }
    `;
    
    this.renderProgram = this._createShaderProgram(vertexShader, fragmentShader, 'Render Pass');
  }
  ```

ã€ä¿®æ­£ç®‡æ‰€3ã€‘_drawStroke()ãƒ¡ã‚½ãƒƒãƒ‰
  ```javascript
  _drawStroke(program, vbo, vertexCount, bounds, resolution) {
    const gl = this.gl;
    
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    
    const stride = 7 * 4;
    
    const aPosition = gl.getAttribLocation(program, 'aPosition');
    if (aPosition >= 0) {
      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, stride, 0);
    }
    
    const aTexCoord = gl.getAttribLocation(program, 'aTexCoord');
    if (aTexCoord >= 0) {
      gl.enableVertexAttribArray(aTexCoord);
      gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, stride, 8);
    }
    
    const aReserved = gl.getAttribLocation(program, 'aReserved');
    if (aReserved >= 0) {
      gl.enableVertexAttribArray(aReserved);
      gl.vertexAttribPointer(aReserved, 3, gl.FLOAT, false, stride, 16);
    }
    
    // âœ… ä¿®æ­£: uResolutionã¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºï¼ˆ512x512å›ºå®šï¼‰
    const uResolution = gl.getUniformLocation(program, 'uResolution');
    if (uResolution) {
      gl.uniform2f(uResolution, resolution.width, resolution.height);
    }
    
    // âœ… è¿½åŠ : uBoundsSizeã¯å®Ÿéš›ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯bounds
    const uBoundsSize = gl.getUniformLocation(program, 'uBoundsSize');
    if (uBoundsSize && bounds) {
      gl.uniform2f(uBoundsSize, bounds.width, bounds.height);
    } else if (uBoundsSize) {
      // Fallback: boundsãŒæ¸¡ã•ã‚Œãªã„å ´åˆã¯resolutionã‚’ä½¿ç”¨
      gl.uniform2f(uBoundsSize, resolution.width, resolution.height);
    }
    
    gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
    
    if (aPosition >= 0) gl.disableVertexAttribArray(aPosition);
    if (aTexCoord >= 0) gl.disableVertexAttribArray(aTexCoord);
    if (aReserved >= 0) gl.disableVertexAttribArray(aReserved);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  }
  ```


================================================================================
â–  Phase 6: ãƒ‡ãƒãƒƒã‚°ç”¨ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰

### ğŸ“Š åº§æ¨™å¤‰æ›ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰

ã€ã‚³ãƒãƒ³ãƒ‰1ã€‘åº§æ¨™å¤‰æ›ãƒ•ãƒ«ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ¤œè¨¼
  ```javascript
  // ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§å®Ÿè¡Œ
  TegakiDebug.coord.testFullPipeline(500, 300);
  // â†’ Screen(500,300) â†’ Canvas â†’ World â†’ Local â†’ é€†å¤‰æ›ã§æ¤œè¨¼
  ```

ã€ã‚³ãƒãƒ³ãƒ‰2ã€‘CoordinateSystemçŠ¶æ…‹ç¢ºèª
  ```javascript
  TegakiDebug.coord.inspectCoordSystem();
  // â†’ worldContainer, worldTransformç­‰ã®çŠ¶æ…‹ã‚’è¡¨ç¤º
  ```

ã€ã‚³ãƒãƒ³ãƒ‰3ã€‘activeLayerç¢ºèª
  ```javascript
  const layer = window.layerManager.getActiveLayer();
  console.log('ActiveLayer:', {
    id: layer.id,
    label: layer.label,
    position: layer.position,
    scale: layer.scale,
    rotation: layer.rotation,
    parent: layer.parent?.label,
    drawingContainer: layer.drawingContainer
  });
  ```

ã€ã‚³ãƒãƒ³ãƒ‰4ã€‘ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯åº§æ¨™ç¢ºèª
  ```javascript
  const points = window.strokeRecorder.getRawPoints();
  console.log('Stroke points:', points.length);
  console.log('First:', points[0]);
  console.log('Last:', points[points.length - 1]);
  console.log('Range:', {
    minX: Math.min(...points.map(p => p.x)),
    maxX: Math.max(...points.map(p => p.x)),
    minY: Math.min(...points.map(p => p.y)),
    maxY: Math.max(...points.map(p => p.y))
  });
  ```

ã€ã‚³ãƒãƒ³ãƒ‰5ã€‘ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹åŒ–
  ```javascript
  // coordinate-system.js, drawing-engine.js, brush-core.js, gl-stroke-processor.jså†…ã®
  // DEBUG_COORD, DEBUG_TRANSFORM, DEBUG_PREVIEW, DEBUG_STROKE ãƒ•ãƒ©ã‚°ã‚’trueã«å¤‰æ›´
  
  // å‹•çš„åˆ‡ã‚Šæ›¿ãˆï¼ˆå®Ÿè£…å¿…è¦ï¼‰:
  window.TegakiDebug.enableCoordDebug = true;
  window.TegakiDebug.enableTransformDebug = true;
  window.TegakiDebug.enablePreviewDebug = true;
  window.TegakiDebug.enableStrokeDebug = true;
  ```


================================================================================
â–  Phase 7: æœŸå¾…ã•ã‚Œã‚‹æ”¹ä¿®åŠ¹æœ

### âœ… åº§æ¨™ã‚ºãƒ¬å•é¡Œã®è§£æ¶ˆ
  - ãƒšãƒ³å…¥åŠ›ä½ç½®ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ä½ç½®ãŒå®Œå…¨ä¸€è‡´
  - worldTransformæ›´æ–°ä¿è¨¼ã«ã‚ˆã‚Šåº§æ¨™å¤‰æ›ã®æ­£ç¢ºæ€§å‘ä¸Š
  - NaN/Infinityæ¤œå‡ºã«ã‚ˆã‚Šç•°å¸¸å€¤ã®æ—©æœŸç™ºè¦‹

### âœ… é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å¤‰å½¢å•é¡Œã®è§£æ¶ˆ
  - Boundsè¨ˆç®—ã¨Spriteé…ç½®ã®åº§æ¨™ç³»çµ±ä¸€
  - WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã®åº§æ¨™æ­£è¦åŒ–ä¿®æ­£ï¼ˆuBoundsSizeè¿½åŠ ï¼‰
  - aPositionç›¸å¯¾åº§æ¨™ã¨bounds.width/heightã®é–¢ä¿‚æ˜ç¢ºåŒ–

### âœ… åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä¿¡é ¼æ€§å‘ä¸Š
  - å„ã‚¹ãƒ†ãƒƒãƒ—ã§ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
  - ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã«ã‚ˆã‚‹å•é¡Œç‰¹å®šå®¹æ˜“åŒ–
  - è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ã®ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢

### âœ… ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ãƒ»ä¿å®ˆæ€§å‘ä¸Š
  - åº§æ¨™ç³»ã®è²¬å‹™åˆ†é›¢æ˜ç¢ºåŒ–
  - ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã®ä½“ç³»åŒ–
  - ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰ã«ã‚ˆã‚‹å‹•çš„æ¤œè¨¼

### ğŸ”œ æ¬¡ãƒ•ã‚§ãƒ¼ã‚ºæº–å‚™å®Œäº†
  - ç­†åœ§å¯¾å¿œï¼ˆåº§æ¨™å®‰å®šå¾Œï¼‰
  - æ¶ˆã—ã‚´ãƒ çµ±åˆï¼ˆãƒšãƒ³å®‰å®šå¾Œï¼‰
  - SDF/WSDFå®Ÿè£…ï¼ˆãƒãƒªã‚´ãƒ³ãƒšãƒ³å®Œæˆå¾Œï¼‰


================================================================================
â–  Phase 8: æ®‹å­˜èª²é¡Œãƒ»å°†æ¥å®Ÿè£…

### ğŸ”œ Phase 2: ç­†åœ§å¯¾å¿œ
  å‰ææ¡ä»¶: ãƒãƒªã‚´ãƒ³ãƒšãƒ³åº§æ¨™å®Œå…¨å®‰å®šåŒ–
  å®Ÿè£…å†…å®¹:
    - pressure-handler.jsæ´»ç”¨
    - PerfectFreehand thinningãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
    - ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å¹…ã®å‹•çš„å¤‰åŒ–å®Ÿè£…

### ğŸ”œ Phase 3: æ¶ˆã—ã‚´ãƒ çµ±åˆ
  å‰ææ¡ä»¶: ãƒšãƒ³æç”»å®Œå…¨å®‰å®šåŒ–
  å®Ÿè£…å†…å®¹:
    - gl-mask-layer.jså®Œå…¨å®Ÿè£…
    - æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰ã®å®‰å®šåŒ–
    - GPU Maskå‡¦ç†æœ€é©åŒ–

### ğŸ”œ Phase 4: SDF/WSDFå®Ÿè£…
  å‰ææ¡ä»¶: ãƒãƒªã‚´ãƒ³ãƒšãƒ³å®Œå…¨å‹•ä½œ
  å®Ÿè£…å†…å®¹:
    - Jump Flooding Algorithmæœ€é©åŒ–
    - Multi-channel SDFå®Ÿè£…
    - æ°´å½©ãƒ»ã‚¨ã‚¢ãƒ–ãƒ©ã‚·ãƒ–ãƒ©ã‚·å®Ÿè£…

### ğŸ”œ Phase 5: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
  å®Ÿè£…å†…å®¹:
    - ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºå‹•çš„å¤‰æ›´ï¼ˆ512å›ºå®šâ†’å¯å¤‰ï¼‰
    - VBO/IBOå†åˆ©ç”¨
    - ãƒãƒƒãƒæç”»æœ€é©åŒ–
    - ãƒ¡ãƒ¢ãƒªç®¡ç†æ”¹å–„


================================================================================
â–  æ”¹ä¿®ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Step 1: ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ ï¼ˆ1æ—¥ç›®ï¼‰
  â–¡ coordinate-system.js ã«ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
  â–¡ drawing-engine.js ã«ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
  â–¡ brush-core.js ã«ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
  â–¡ gl-stroke-processor.js ã«ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
  â–¡ NaN/Infinityæ¤œå‡ºå®Ÿè£…
  â–¡ ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰å®Ÿè£…ãƒ»ãƒ†ã‚¹ãƒˆ

### Step 2: åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä¿®æ­£ï¼ˆ2æ—¥ç›®ï¼‰
  â–¡ coordinate-system.canvasToWorld() ã« worldContainer.updateTransform() è¿½åŠ 
  â–¡ coordinate-system.worldToLocal() ã«ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢è¿½åŠ 
  â–¡ drawing-engine._transformPointerToLocal() ã«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¿½åŠ 
  â–¡ activeLayer parent chain æ¤œè¨¼
  â–¡ åº§æ¨™å¤‰æ›ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰ã§æ¤œè¨¼

### Step 3: Boundsãƒ»Spriteé…ç½®ä¿®æ­£ï¼ˆ3æ—¥ç›®ï¼‰
  â–¡ gl-stroke-processor.calculateBounds() æ¤œè¨¼
  â–¡ brush-core._updatePreview() Spriteé…ç½®æ¤œè¨¼
  â–¡ brush-core._ensurePreviewContainer() Containeréšå±¤ç¢ºèª
  â–¡ é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æç”»ãƒ†ã‚¹ãƒˆ

### Step 4: WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¿®æ­£ï¼ˆ4æ—¥ç›®ï¼‰
  â–¡ gl-msdf-pipeline._createRenderProgram() ã« uBoundsSize è¿½åŠ 
  â–¡ gl-msdf-pipeline._drawStroke() ã« uBoundsSize è¨­å®šè¿½åŠ 
  â–¡ Vertex Shaderä¿®æ­£ãƒ†ã‚¹ãƒˆ
  â–¡ å¤‰å½¢å•é¡Œè§£æ¶ˆç¢ºèª

### Step 5: ç·åˆãƒ†ã‚¹ãƒˆï¼ˆ5æ—¥ç›®ï¼‰
  â–¡ çŸ­ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æç”»ãƒ†ã‚¹ãƒˆ
  â–¡ é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æç”»ãƒ†ã‚¹ãƒˆ
  â–¡ ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ“ä½œä¸‹ã§ã®æç”»ãƒ†ã‚¹ãƒˆ
  â–¡ è¤‡æ•°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã®æç”»ãƒ†ã‚¹ãƒˆ
  â–¡ åº§æ¨™ã‚ºãƒ¬å®Œå…¨è§£æ¶ˆç¢ºèª
  â–¡ å¤‰å½¢å•é¡Œå®Œå…¨è§£æ¶ˆç¢ºèª
  â–¡ ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°å‰Šé™¤ãƒ»ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—


================================================================================
â–  æœ€çµ‚ç¢ºèªäº‹é …

### âš ï¸ å¿…é ˆç¢ºèªé …ç›®
  1. worldContainer.updateTransform() ãŒé©åˆ‡ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å‘¼ã°ã‚Œã¦ã„ã‚‹ã‹
  2. activeLayer.parent chain ãŒ worldContainer ã¾ã§ç¹‹ãŒã£ã¦ã„ã‚‹ã‹
  3. Boundsè¨ˆç®—ãŒ Localåº§æ¨™ç³»ã§è¡Œã‚ã‚Œã¦ã„ã‚‹ã‹
  4. Spriteé…ç½®ãŒ Localåº§æ¨™ç³»ã§è¡Œã‚ã‚Œã¦ã„ã‚‹ã‹
  5. WebGL2 Vertex Shader ã§ uBoundsSize ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
  6. textureSize(512x512) ã¨ bounds.width/height ã®é–¢ä¿‚ãŒæ˜ç¢ºã‹
  7. NaN/Infinity ãŒä¸€åˆ‡ç™ºç”Ÿã—ã¦ã„ãªã„ã‹

### âœ… æˆåŠŸåŸºæº–
  - ãƒšãƒ³å…¥åŠ›ä½ç½®ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ä½ç½®ãŒ1pxä»¥å†…ã§ä¸€è‡´
  - é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼ˆ1000pxä»¥ä¸Šï¼‰ã§ã‚‚å¤‰å½¢ãªã—
  - ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ“ä½œä¸‹ã§ã‚‚æ­£ç¢ºã«æç”»
  - ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘ŠãŒç™ºç”Ÿã—ãªã„
  - ç­†åœ§å¯¾å¿œæº–å‚™å®Œäº†ï¼ˆæ¬¡ãƒ•ã‚§ãƒ¼ã‚ºï¼‰


================================================================================
â–  è£œè¶³: ãƒ•ã‚¡ã‚¤ãƒ«é–“ä¾å­˜é–¢ä¿‚å›³ï¼ˆClaudeå®Ÿè£…ç”¨å‚ç…§ï¼‰

### åº§æ¨™å¤‰æ›ãƒ•ãƒ­ãƒ¼ï¼ˆPointerEvent â†’ Localåº§æ¨™ï¼‰
```
PointerEvent.clientX/Y
    â†“
[drawing-engine.js] _transformPointerToLocal()
    â†“
[coordinate-system.js] screenClientToCanvas()
    â†“ {canvasX, canvasY}
[coordinate-system.js] canvasToWorld()
    â†“ {worldX, worldY}
    â†“ â† worldContainer.updateTransform() ğŸ”§è¿½åŠ å¿…è¦
[coordinate-system.js] worldToLocal(worldX, worldY, activeLayer)
    â†“ {localX, localY}
    â†“
[drawing-engine.js] â†’ BrushCore.startStroke/updateStroke
    â†“
[stroke-recorder.js] addPoint(localX, localY, pressure)
    â†“ pointsé…åˆ—ã«è“„ç©ï¼ˆåº§æ¨™å¤‰æ›ãªã—ï¼‰
[brush-core.js] renderPreview()
    â†“
[gl-stroke-processor.js] createPolygonVertexBuffer(points, size)
    â†“ PerfectFreehandå®Ÿè¡Œ
    â†“ outlinePoints[x, y] â†’ outlinePoints[x - bounds.minX, y - bounds.minY]
    â†“ Earcutä¸‰è§’å½¢åˆ†å‰²
    â†“ {buffer: Float32Array[7 floats/vertex], bounds}
[gl-msdf-pipeline.js] generateMSDF(edgeBuffer, bounds, ...)
    â†“ Seed Init â†’ JFA â†’ Encode â†’ Render
    â†“ Vertex Shader: aPosition / uBoundsSize â†’ [0,1] ğŸ”§ä¿®æ­£å¿…è¦
    â†“ {texture: WebGLTexture, width: 512, height: 512}
[gl-texture-bridge.js] createSpriteFromGLTexture(texture, width, height)
    â†“ {sprite: PIXI.Sprite}
[brush-core.js] spriteé…ç½®
    â†“ sprite.x = bounds.minX (Localåº§æ¨™)
    â†“ sprite.y = bounds.minY (Localåº§æ¨™)
    â†“ sprite.width = bounds.width ğŸ”§Phase 2.2ä¿®æ­£æ¸ˆã¿
    â†“ sprite.height = bounds.height ğŸ”§Phase 2.2ä¿®æ­£æ¸ˆã¿
    â†“ container.addChild(sprite)
æç”»å®Œäº†
```


### ä¸»è¦ãƒ•ã‚¡ã‚¤ãƒ«ä¾å­˜é–¢ä¿‚ãƒ„ãƒªãƒ¼
```
ğŸ“ index.html
    â”œâ”€ config.js
    â”œâ”€ coordinate-system.js
    â”‚   â””â”€ ä¾å­˜: config.js, event-bus.js, camera-system.js
    â”œâ”€ system/event-bus.js
    â”œâ”€ system/camera-system.js
    â”œâ”€ system/layer-system.js
    â”œâ”€ system/drawing/pointer-handler.js
    â”œâ”€ system/drawing/pressure-handler.js
    â”œâ”€ system/drawing/stroke-recorder.js
    â”‚   â””â”€ ä¾å­˜: ãªã—ï¼ˆå˜ç‹¬å‹•ä½œï¼‰
    â”œâ”€ system/drawing/webgl2/webgl2-drawing-layer.js
    â”‚   â””â”€ ä¾å­˜: ãªã—ï¼ˆWebGL2 APIç›´æ¥ä½¿ç”¨ï¼‰
    â”œâ”€ system/drawing/webgl2/gl-stroke-processor.js
    â”‚   â””â”€ ä¾å­˜: perfect-freehand, earcut, config.js, webgl2-drawing-layer.js
    â”œâ”€ system/drawing/webgl2/gl-msdf-pipeline.js
    â”‚   â””â”€ ä¾å­˜: webgl2-drawing-layer.js, gl-stroke-processor.js
    â”œâ”€ system/drawing/webgl2/gl-texture-bridge.js
    â”‚   â””â”€ ä¾å­˜: webgl2-drawing-layer.js, PixiJS
    â”œâ”€ system/drawing/brush-core.js
    â”‚   â””â”€ ä¾å­˜: stroke-recorder.js, gl-stroke-processor.js, gl-msdf-pipeline.js,
    â”‚             gl-texture-bridge.js, layer-system.js, history.js, event-bus.js
    â”œâ”€ system/drawing/drawing-engine.js
    â”‚   â””â”€ ä¾å­˜: coordinate-system.js, camera-system.js, layer-system.js,
    â”‚             brush-core.js, pointer-handler.js
    â””â”€ core-engine.js, core-initializer.js
        â””â”€ ä¾å­˜: ã™ã¹ã¦ã®ã‚·ã‚¹ãƒ†ãƒ ãƒ•ã‚¡ã‚¤ãƒ«
```


### ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼ï¼ˆEventBusçµŒç”±ï¼‰
```
ğŸ”€ æç”»é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
    pointer-handler.js
        â†’ ç™ºç«: ãªã—
        â†’ è³¼èª­: ãªã—ï¼ˆdrawing-engine.jsãŒç›´æ¥ãƒãƒ³ãƒ‰ãƒ©ç™»éŒ²ï¼‰
    
    drawing-engine.js
        â†’ ç™ºç«: ãªã—
        â†’ è³¼èª­: ãªã—
    
    brush-core.js
        â†’ ç™ºç«: 'layer:path-added', 'layer:transform-updated', 'layer:panel-update-requested', 'brush:mode-changed'
        â†’ è³¼èª­: 'brush:size-changed', 'brush:opacity-changed', 'brush:color-changed', 'tool:changed'
    
    coordinate-system.js
        â†’ ç™ºç«: ãªã—
        â†’ è³¼èª­: 'canvas:resize', 'camera:resized', 'camera:transform-changed', 
                'layer:transform-updated', 'layer:transform-changed'

ğŸ”€ åº§æ¨™å¤‰æ›ãƒ»ã‚«ãƒ¡ãƒ©é–¢é€£ã‚¤ãƒ™ãƒ³ãƒˆ
    camera-system.js
        â†’ ç™ºç«: 'camera:transform-changed', 'camera:resized'
        â†’ è³¼èª­: ãªã—
    
    layer-system.js
        â†’ ç™ºç«: 'layer:transform-updated', 'layer:panel-update-requested'
        â†’ è³¼èª­: ãªã—
```


### åº§æ¨™ç³»ãƒ»Transformé–¢é€£ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ä¸€è¦§
```
ğŸ“Š worldContainer (PIXI.Container)
    - position: {x, y}       // Worldç©ºé–“ã§ã®ä½ç½®
    - scale: {x, y}          // ã‚ºãƒ¼ãƒ å€ç‡
    - rotation: number       // å›è»¢ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
    - pivot: {x, y}          // åŸºæº–ç‚¹
    - worldTransform: Matrix // PixiJSè‡ªå‹•è¨ˆç®—ï¼ˆè¦updateTransform()ï¼‰

ğŸ“Š activeLayer (PIXI.Container)
    - position: {x, y}       // Localç©ºé–“ã§ã®ä½ç½®
    - scale: {x, y}          // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«
    - rotation: number       // ãƒ¬ã‚¤ãƒ¤ãƒ¼å›è»¢
    - pivot: {x, y}          // ãƒ¬ã‚¤ãƒ¤ãƒ¼åŸºæº–ç‚¹
    - parent: Container      // è¦ªContainerï¼ˆworldContainerã¾ã§é¡æŸ»ï¼‰
    - drawingContainer: Container  // æç”»ç”¨Container
    - container: Container   // ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬ä½“Container

ğŸ“Š Sprite (PIXI.Sprite)
    - x, y: number           // è¦ªContainerå†…ã§ã®Localåº§æ¨™
    - width, height: number  // è¡¨ç¤ºã‚µã‚¤ã‚º
    - scale: {x, y}          // ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆéæ¨å¥¨ã€width/heightä½¿ç”¨ï¼‰
    - alpha: number          // é€æ˜åº¦
    - parent: Container      // è¦ªContainerï¼ˆactiveLayer.drawingContainerï¼‰

ğŸ“Š Bounds (Localåº§æ¨™ç³»)
    - minX, minY: number     // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å·¦ä¸Šï¼ˆLocalåº§æ¨™ï¼‰
    - maxX, maxY: number     // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å³ä¸‹ï¼ˆLocalåº§æ¨™ï¼‰
    - width, height: number  // maxX-minX, maxY-minY

ğŸ“Š Vertex Buffer (ç›¸å¯¾åº§æ¨™ç³»)
    - aPosition: vec2        // [0, bounds.width] x [0, bounds.height]
    - åº§æ¨™å¤‰æ›: Localåº§æ¨™ - bounds.minX/minY â†’ ç›¸å¯¾åº§æ¨™
```


### ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—é †åºï¼ˆã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æç”»ï¼‰
```
1. [pointer-handler.js] PointerEvent 'pointerdown' æ¤œå‡º
    â†“
2. [drawing-engine.js] _handlePointerDown(e)
    â†“
3. [drawing-engine.js] _transformPointerToLocal(e)
    â”œâ”€ [coordinate-system.js] screenClientToCanvas(clientX, clientY)
    â”œâ”€ [coordinate-system.js] canvasToWorld(canvasX, canvasY)
    â”‚   â””â”€ ğŸ”§ worldContainer.updateTransform() è¿½åŠ å¿…è¦
    â””â”€ [coordinate-system.js] worldToLocal(worldX, worldY, activeLayer)
    â†“ {localX, localY}
4. [brush-core.js] startStroke(localX, localY, pressure)
    â†“
5. [stroke-recorder.js] startStroke(localX, localY, pressure, options)
    â””â”€ pointsé…åˆ—åˆæœŸåŒ–ã€åˆæœŸãƒã‚¤ãƒ³ãƒˆè¿½åŠ 
    â†“
6. [pointer-handler.js] PointerEvent 'pointermove' æ¤œå‡ºï¼ˆç¹°ã‚Šè¿”ã—ï¼‰
    â†“
7. [drawing-engine.js] _handlePointerMove(e)
    â†“
8. [drawing-engine.js] _transformPointerToLocal(e)
    â†“ {localX, localY}
9. [drawing-engine.js] pendingPoints.push({localX, localY, pressure, ...})
    â†“
10. [drawing-engine.js] flushPendingPoints() (maxPendingPoints=3ã§ç™ºç«)
    â†“
11. [brush-core.js] updateStroke(localX, localY, pressure)ï¼ˆè¤‡æ•°å›ï¼‰
    â†“
12. [stroke-recorder.js] addPoint(localX, localY, pressure)ï¼ˆè¤‡æ•°å›ï¼‰
    â””â”€ pointsé…åˆ—ã«è¿½åŠ ï¼ˆåº§æ¨™å¤‰æ›ãªã—ï¼‰
    â†“
13. [core-engine.js] _renderLoop() å†…ã§ renderPreview() å‘¼ã³å‡ºã—
    â†“
14. [brush-core.js] renderPreview()
    â”œâ”€ throttle 100ms ãƒã‚§ãƒƒã‚¯
    â””â”€ æ¡ä»¶æº€ãŸã›ã° _updatePreview(points) å®Ÿè¡Œ
    â†“
15. [brush-core.js] _updatePreview(points)
    â”œâ”€ [gl-stroke-processor.js] createPolygonVertexBuffer(points, size)
    â”‚   â”œâ”€ PerfectFreehandå®Ÿè¡Œ
    â”‚   â”œâ”€ outlinePointsåº§æ¨™å¤‰æ›ï¼ˆLocal â†’ ç›¸å¯¾ï¼‰
    â”‚   â”œâ”€ Earcutä¸‰è§’å½¢åˆ†å‰²
    â”‚   â””â”€ {buffer, vertexCount, bounds}
    â”œâ”€ [gl-stroke-processor.js] createEdgeBuffer(points, size)
    â”œâ”€ [gl-stroke-processor.js] uploadToGPU(buffer, ...)
    â”œâ”€ [gl-msdf-pipeline.js] generateMSDF(edgeBuffer, bounds, ...)
    â”‚   â”œâ”€ Seed Init Pass
    â”‚   â”œâ”€ JFA Passï¼ˆè¤‡æ•°å›ï¼‰
    â”‚   â”œâ”€ Encode Pass
    â”‚   â”œâ”€ Render Pass
    â”‚   â”‚   â””â”€ ğŸ”§ Vertex Shader: aPosition / uBoundsSize ä¿®æ­£å¿…è¦
    â”‚   â””â”€ {texture, width: 512, height: 512}
    â”œâ”€ [gl-texture-bridge.js] createSpriteFromGLTexture(texture, ...)
    â”‚   â””â”€ {sprite}
    â””â”€ Spriteé…ç½®
        â”œâ”€ sprite.x = bounds.minX (Localåº§æ¨™)
        â”œâ”€ sprite.y = bounds.minY (Localåº§æ¨™)
        â”œâ”€ sprite.width = bounds.width
        â”œâ”€ sprite.height = bounds.height
        â””â”€ previewContainer.addChild(sprite)
    â†“
16. [pointer-handler.js] PointerEvent 'pointerup' æ¤œå‡º
    â†“
17. [drawing-engine.js] _handlePointerUp(e)
    â†“
18. [drawing-engine.js] flushPendingPoints()
    â†“
19. [brush-core.js] finalizeStroke()
    â”œâ”€ _cleanupPreview() (ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‰Šé™¤)
    â””â”€ _finalizeMSDFStroke(points, activeLayer)
        â”œâ”€ åŒæ§˜ã®WebGL2ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ
        â”œâ”€ æœ€çµ‚Spriteç”Ÿæˆãƒ»é…ç½®
        â”œâ”€ layer.pathsé…åˆ—ã«è¿½åŠ 
        â”œâ”€ history.push() (Undo/Redo)
        â””â”€ EventBusç™ºç« ('layer:path-added', 'layer:transform-updated', ...)
    â†“
20. [stroke-recorder.js] endStroke()
    â””â”€ isRecording = false, pointsä¿æŒ
    â†“
æç”»å®Œäº†
```


================================================================================
â–  é‡è¦ãªå®Ÿè£…ãƒã‚¤ãƒ³ãƒˆï¼ˆClaudeå¿…èª­ï¼‰

### ğŸš¨ åº§æ¨™ç³»ã®å³å¯†ãªåŒºåˆ¥
  - **Screenåº§æ¨™**: PointerEvent.clientX/Yï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦åŸºæº–ï¼‰
  - **Canvasåº§æ¨™**: WebGL2ã‚­ãƒ£ãƒ³ãƒã‚¹å†…åº§æ¨™ï¼ˆDPIè£œæ­£å¾Œï¼‰
  - **Worldåº§æ¨™**: worldContaineråŸºæº–ã®åº§æ¨™ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³é©ç”¨å‰ï¼‰
  - **Localåº§æ¨™**: activeLayeråŸºæº–ã®åº§æ¨™ï¼ˆãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰å½¢é©ç”¨å‰ï¼‰
  - **ç›¸å¯¾åº§æ¨™**: boundsåŸºæº–ã®åº§æ¨™ [0, bounds.width/height]ï¼ˆWebGL2å†…éƒ¨ï¼‰

### ğŸš¨ äºŒé‡å¤‰æ›ã®å³ç¦
  - drawing-engine.js ã§åº§æ¨™å¤‰æ›ã‚’å®Œçµã•ã›ã‚‹
  - stroke-recorder.js ã¯å—ã‘å–ã£ãŸåº§æ¨™ã‚’ãã®ã¾ã¾è¨˜éŒ²
  - brush-core.js ã¯ stroke-recorder ã‹ã‚‰åº§æ¨™ã‚’å–å¾—
  - gl-stroke-processor.js ã¯å—ã‘å–ã£ãŸåº§æ¨™ã‚’ç›¸å¯¾åº§æ¨™ã«å¤‰æ›
  - **ã©ã®æ®µéšã§ã‚‚å†å¤‰æ›ã—ã¦ã¯ãªã‚‰ãªã„**

### ğŸš¨ Boundsè¨ˆç®—ã®åº§æ¨™ç³»
  - gl-stroke-processor.calculateBounds() ã®å…¥åŠ›: **Localåº§æ¨™**
  - bounds.minX/minY/maxX/maxY: **Localåº§æ¨™ç³»ã®å€¤**
  - Sprite.x/y ã«è¨­å®šã™ã‚‹å€¤: **bounds.minX/minYï¼ˆLocalåº§æ¨™ï¼‰**
  - Vertex Buffer aPosition: **ç›¸å¯¾åº§æ¨™ [0, bounds.width/height]**

### ğŸš¨ WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®åº§æ¨™æ­£è¦åŒ–
  - aPositionå…¥åŠ›: **[0, bounds.width] x [0, bounds.height]**
  - uBoundsSize: **bounds.width/height ã‚’æ¸¡ã™**
  - uResolution: **ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚º 512x512 ã‚’æ¸¡ã™**
  - æ­£è¦åŒ–è¨ˆç®—: `normalized = aPosition / uBoundsSize` â†’ [0, 1]
  - ã‚¯ãƒªãƒƒãƒ—ç©ºé–“å¤‰æ›: `clipSpace = normalized * 2.0 - 1.0` â†’ [-1, 1]

### ğŸš¨ worldTransformæ›´æ–°ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°
  - PixiJS Tickeråœæ­¢æ™‚ã¯ worldTransform ãŒè‡ªå‹•æ›´æ–°ã•ã‚Œãªã„
  - coordinate-system.canvasToWorld() å†…ã§æ˜ç¤ºçš„ã«å‘¼ã¶:
    ```javascript
    worldContainer.updateTransform();
    ```
  - ã“ã‚Œã«ã‚ˆã‚Š worldTransform.applyInverse() ãŒæ­£ã—ãå‹•ä½œ

### ğŸš¨ NaN/Infinityæ¤œå‡ºã®é‡è¦æ€§
  - åº§æ¨™å¤‰æ›ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã§ isNaN() ãƒã‚§ãƒƒã‚¯å¿…é ˆ
  - NaNæ··å…¥æ™‚ã¯å³åº§ã«ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°å‡ºåŠ›
  - Fallbackå‡¦ç†ã¾ãŸã¯å‡¦ç†ä¸­æ–­ã‚’é¸æŠ
  - ç„¡è¦–ã—ã¦é€²ã‚ã‚‹ã¨æç”»ãŒå®Œå…¨ã«ç ´ç¶»ã™ã‚‹

### ğŸš¨ Spriteé…ç½®å…ˆContainerã®ç¢ºèª
  - Sprite.parent ã¯ activeLayer.drawingContainer ã§ã‚ã‚‹ã¹ã
  - drawingContainer ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ activeLayer.container
  - Containeréšå±¤: worldContainer > activeLayer.container > drawingContainer > sprite
  - éšå±¤ãŒæ­£ã—ããªã„ã¨åº§æ¨™ç³»ãŒãšã‚Œã‚‹


================================================================================
â–  ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ï¼ˆæƒ³å®šã•ã‚Œã‚‹å•é¡Œã¨å¯¾å‡¦æ³•ï¼‰

### âŒ å•é¡Œ1: åº§æ¨™å¤‰æ›ã§NaNãŒç™ºç”Ÿã™ã‚‹
  åŸå› å€™è£œ:
    - worldContainer.worldTransform ãŒæœªæ›´æ–°
    - activeLayer.parent chain ãŒ worldContainer ã¾ã§ç¹‹ãŒã£ã¦ã„ãªã„
    - scale.x/scale.y ãŒ 0 ã«ãªã£ã¦ã„ã‚‹
    - rotation ãŒç•°å¸¸å€¤ï¼ˆInfinityç­‰ï¼‰
  
  å¯¾å‡¦æ³•:
    1. worldContainer.updateTransform() å‘¼ã³å‡ºã—è¿½åŠ 
    2. activeLayer.parent é¡æŸ»ãƒ­ã‚°ã‚’ç¢ºèª
    3. scale/rotation å€¤ã‚’æ¤œè¨¼
    4. isNaN() ãƒã‚§ãƒƒã‚¯å®Ÿè£…

### âŒ å•é¡Œ2: SpriteãŒæç”»ã•ã‚Œãªã„
  åŸå› å€™è£œ:
    - Sprite.x/y ãŒç”»é¢å¤–ï¼ˆboundsè¨ˆç®—ãƒŸã‚¹ï¼‰
    - Sprite.alpha ãŒ 0
    - Sprite.visible ãŒ false
    - Containeréšå±¤ãŒä¸æ­£
  
  å¯¾å‡¦æ³•:
    1. boundså€¤ã‚’ãƒ­ã‚°å‡ºåŠ›ã—ã¦ç¢ºèª
    2. Sprite.alpha, visible ã‚’ç¢ºèª
    3. container.children ã«SpriteãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    4. Container.worldTransform ã‚’ç¢ºèª

### âŒ å•é¡Œ3: SpriteãŒå¤‰å½¢ã™ã‚‹
  åŸå› å€™è£œ:
    - uBoundsSize ãŒæœªè¨­å®šï¼ˆuResolutionã®ã¿ä½¿ç”¨ï¼‰
    - Sprite.width/height ãŒ 512 å›ºå®šï¼ˆPhase 2.2å‰ï¼‰
    - aPositionåº§æ¨™ãŒä¸æ­£ç¢º
  
  å¯¾å‡¦æ³•:
    1. gl-msdf-pipeline._drawStroke() ã§ uBoundsSize è¨­å®šç¢ºèª
    2. brush-core.js ã§ sprite.width/height = bounds.width/height ç¢ºèª
    3. gl-stroke-processor.js ã§ç›¸å¯¾åº§æ¨™å¤‰æ›ã‚’ç¢ºèª

### âŒ å•é¡Œ4: é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã§æç”»ãŒåˆ‡ã‚Œã‚‹
  åŸå› å€™è£œ:
    - boundsè¨ˆç®—ã®marginãŒä¸è¶³
    - ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚º 512x512 ã‚’è¶…ãˆã¦ã„ã‚‹
  
  å¯¾å‡¦æ³•:
    1. gl-stroke-processor._calculateBoundsFromPoints() ã® marginè¨ˆç®—ã‚’ç¢ºèª
    2. å‹•çš„marginè¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ã‚’èª¿æ•´
    3. textureSize ã‚’å‹•çš„å¤‰æ›´ï¼ˆPhase 3å®Ÿè£…äºˆå®šï¼‰

### âŒ å•é¡Œ5: ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ“ä½œå¾Œã«åº§æ¨™ãŒãšã‚Œã‚‹
  åŸå› å€™è£œ:
    - worldContainer.worldTransform ãŒæ›´æ–°ã•ã‚Œã¦ã„ãªã„
    - canvasToWorld() ãŒå¤ã„transformã‚’ä½¿ç”¨
  
  å¯¾å‡¦æ³•:
    1. worldContainer.updateTransform() è¿½åŠ 
    2. camera-system.js ã§ transformå¤‰æ›´æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ç¢ºèª
    3. coordinate-system.js ã§ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ç¢ºèª


================================================================================
â–  æœ€çµ‚ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆï¼ˆæ”¹ä¿®å®Œäº†åˆ¤å®šåŸºæº–ï¼‰

### âœ… åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
  â–¡ worldContainer.updateTransform() ãŒ canvasToWorld() å†…ã§å‘¼ã°ã‚Œã¦ã„ã‚‹
  â–¡ worldToLocal() ã®è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ãŒæ­£å¸¸å‹•ä½œ
  â–¡ å„ã‚¹ãƒ†ãƒƒãƒ—ã§NaN/Infinityæ¤œå‡ºãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
  â–¡ activeLayer.parent chain ãŒ worldContainer ã¾ã§ç¹‹ãŒã£ã¦ã„ã‚‹
  â–¡ DPI/DPRè¨ˆç®—ãŒæ­£ç¢ºï¼ˆcanvas.width/height ã¨ rect.width/height ã®æ¯”ç‡ï¼‰

### âœ… Boundsè¨ˆç®—ãƒ»Spriteé…ç½®
  â–¡ gl-stroke-processor.calculateBounds() ãŒLocalåº§æ¨™ç³»ã§è¨ˆç®—
  â–¡ bounds.minX/minY ãŒLocalåº§æ¨™å€¤
  â–¡ Sprite.x/y = bounds.minX/minY ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹
  â–¡ Sprite.width/height = bounds.width/height ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹
  â–¡ Sprite.parent ãŒ activeLayer.drawingContainer ã§ã‚ã‚‹

### âœ… WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  â–¡ render.vert.glsl ã« uBoundsSize uniform ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹
  â–¡ _drawStroke() ã§ uBoundsSize ã« bounds.width/height ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹
  â–¡ aPosition / uBoundsSize ã§ [0, 1] æ­£è¦åŒ–ã•ã‚Œã¦ã„ã‚‹
  â–¡ clipSpace å¤‰æ›ãŒæ­£ã—ã„ï¼ˆyè»¸åè»¢å«ã‚€ï¼‰

### âœ… ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½
  â–¡ DEBUG_COORD, DEBUG_TRANSFORM, DEBUG_PREVIEW, DEBUG_STROKE ãƒ•ãƒ©ã‚°å®Ÿè£…
  â–¡ TegakiDebug.coord.testFullPipeline() å®Ÿè£…
  â–¡ TegakiDebug.coord.inspectCoordSystem() å®Ÿè£…
  â–¡ ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œè¨¼å¯èƒ½

### âœ… æç”»å“è³ª
  â–¡ ãƒšãƒ³å…¥åŠ›ä½ç½®ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ä½ç½®ãŒ1pxä»¥å†…ã§ä¸€è‡´
  â–¡ çŸ­ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼ˆ10pxï½100pxï¼‰ãŒæ­£ç¢ºã«æç”»ã•ã‚Œã‚‹
  â–¡ é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼ˆ1000pxä»¥ä¸Šï¼‰ã§ã‚‚å¤‰å½¢ã—ãªã„
  â–¡ ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ“ä½œä¸‹ã§ã‚‚æ­£ç¢ºã«æç”»ã•ã‚Œã‚‹
  â–¡ è¤‡æ•°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§æç”»ã—ã¦ã‚‚å•é¡Œãªã„

### âœ… ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
  â–¡ ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«ã‚¨ãƒ©ãƒ¼ãŒå‡ºãªã„
  â–¡ NaN/Infinity ãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã«é©åˆ‡ã«ãƒ­ã‚°å‡ºåŠ›
  â–¡ ç•°å¸¸å€¤ç™ºç”Ÿæ™‚ã«Fallbackå‡¦ç†ãŒå‹•ä½œ
  â–¡ æç”»å¤±æ•—æ™‚ã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ãªã„


================================================================================
â–  æ”¹ä¿®è¨ˆç”»æ›¸ã®ä½¿ã„æ–¹ï¼ˆClaudeå®Ÿè£…ã‚¬ã‚¤ãƒ‰ï¼‰

### ğŸ“– ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æ§‹æˆ
  - Phase 1: ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ãƒ»ä¾å­˜é–¢ä¿‚ã®è¾å…¸åŒ–ï¼ˆç†è§£ç”¨ï¼‰
  - Phase 2: å•é¡Œã®æ ¹æœ¬åŸå› åˆ†æï¼ˆè¨ºæ–­ç”¨ï¼‰
  - Phase 3: æ”¹ä¿®æ–¹é‡ï¼ˆå®Ÿè£…è¨ˆç”»ï¼‰
  - Phase 4: æ”¹ä¿®å®Ÿæ–½é †åºï¼ˆä½œæ¥­æ‰‹é †ï¼‰
  - Phase 5: å®Ÿè£…è©³ç´°ï¼ˆã‚³ãƒ¼ãƒ‰ä¾‹ä»˜ãï¼‰
  - Phase 6: ãƒ‡ãƒãƒƒã‚°ç”¨ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰ï¼ˆæ¤œè¨¼ç”¨ï¼‰
  - Phase 7: æœŸå¾…ã•ã‚Œã‚‹æ”¹ä¿®åŠ¹æœï¼ˆç›®æ¨™ç¢ºèªï¼‰
  - Phase 8: æ®‹å­˜èª²é¡Œãƒ»å°†æ¥å®Ÿè£…ï¼ˆæ¬¡ãƒ•ã‚§ãƒ¼ã‚ºæº–å‚™ï¼‰

### ğŸ”§ Claudeå®Ÿè£…æ™‚ã®æ¨å¥¨æ‰‹é †
  1. Phase 1ã‚’èª­ã¿ã€ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ãƒ»ä¾å­˜é–¢ä¿‚ã‚’æŠŠæ¡
  2. Phase 2ã§å•é¡Œã®æ ¹æœ¬åŸå› ã‚’ç†è§£
  3. Phase 4ã®æ”¹ä¿®å®Ÿæ–½é †åºã«å¾“ã£ã¦ä½œæ¥­
  4. Phase 5ã®å®Ÿè£…è©³ç´°ã‚’å‚ç…§ã—ã¦ã‚³ãƒ¼ãƒ‰ä¿®æ­£
  5. Phase 6ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰ã§æ¤œè¨¼
  6. Phase 7ã®æœŸå¾…åŠ¹æœãŒé”æˆã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
  7. æœ€çµ‚ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã§å®Œäº†åˆ¤å®š

### ğŸ“ æ”¹ä¿®æ™‚ã®æ³¨æ„äº‹é …
  - **ä¸€åº¦ã«å…¨ãƒ•ã‚¡ã‚¤ãƒ«ä¿®æ­£ã›ãšã€Stepå˜ä½ã§é€²ã‚ã‚‹**
  - **å„Stepã§å‹•ä½œç¢ºèªã—ã€å•é¡ŒãŒã‚ã‚Œã°å‰Stepã«æˆ»ã‚‹**
  - **ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã¯å‰Šé™¤ã›ãšã€ãƒ•ãƒ©ã‚°ã§åˆ¶å¾¡ã™ã‚‹**
  - **æ”¹ä¿®å¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ˜ãƒƒãƒ€ãƒ¼ã«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒ»å¤‰æ›´å†…å®¹ã‚’è¨˜è¼‰**
  - **ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã¯é–‹ç™ºæ™‚ã®ã¿æœ‰åŠ¹åŒ–ã—ã€æœ¬ç•ªã§ã¯ç„¡åŠ¹åŒ–**

### ğŸš€ æ”¹ä¿®å®Œäº†å¾Œã®æ¬¡ã‚¹ãƒ†ãƒƒãƒ—
  1. ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆãƒ•ãƒ©ã‚°falseåŒ–ï¼‰
  2. ä¸è¦ãªã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’å‰Šé™¤
  3. ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ•´ç†ï¼ˆTODOå‰Šé™¤ã€é‡è¦äº‹é …ã®ã¿æ®‹ã™ï¼‰
  4. ãƒ•ã‚¡ã‚¤ãƒ«ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›´æ–°ï¼ˆPhaseç•ªå·ã€å®Œäº†æ—¥è¨˜è¼‰ï¼‰
  5. æ¬¡ãƒ•ã‚§ãƒ¼ã‚ºæº–å‚™ï¼ˆç­†åœ§å¯¾å¿œãƒ»æ¶ˆã—ã‚´ãƒ çµ±åˆï¼‰


================================================================================
æ”¹ä¿®è¨ˆç”»æ›¸ END
ä½œæˆè€…: Claude (Anthropic)
å¯¾è±¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: WebGL2 Polygon Pen Drawing Tool
ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v15 Phase 1 åº§æ¨™ã‚ºãƒ¬ãƒ»å¤‰å½¢å•é¡Œä¿®æ­£ç‰ˆ
================================================================================================================================================================
WebGL2ãƒãƒªã‚´ãƒ³ãƒšãƒ³åº§æ¨™ã‚ºãƒ¬ãƒ»å¤‰å½¢å•é¡Œ æ”¹ä¿®è¨ˆç”»æ›¸
================================================================================
ä½œæˆæ—¥: 2025-02-XX
å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³: webgl2_v15
çŠ¶æ…‹: å•é¡Œè¨ºæ–­å®Œäº†ãƒ»æ”¹ä¿®è¨ˆç”»ç­–å®š

ã€ç¾è±¡ã€‘
âš ï¸ ãƒšãƒ³å…¥åŠ›ä½ç½®ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ä½ç½®ãŒã‚ºãƒ¬ã‚‹
âš ï¸ é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã§æç”»ãŒç¸¦æ¨ªã«å¤‰å½¢ã™ã‚‹ï¼ˆæ³•å‰‡æ€§ã‚ã‚Šï¼‰
âš ï¸ ç­†åœ§ãŒç„¡è¦–ã•ã‚Œã‚‹ï¼ˆåº§æ¨™å®‰å®šåŒ–å¾Œã«å¯¾å¿œï¼‰
âŒ æ¶ˆã—ã‚´ãƒ ãŒåŠ¹ã‹ãªã„ï¼ˆãƒšãƒ³å®‰å®šåŒ–å¾Œã«å¯¾å¿œï¼‰

ã€ç›®æ¨™ã€‘
âœ… ãƒãƒªã‚´ãƒ³ãƒšãƒ³ã®å®Œå…¨å®‰å®šåŒ–ï¼ˆPerfectFreehand + WebGL2 Meshï¼‰
âœ… åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Œå…¨ä¸€æœ¬åŒ–
âœ… DPR=1å›ºå®šã€Pixiã¯ UI ã®ã¿ã€WebGL2 ãŒæç”»ã‚ªãƒ¼ãƒŠãƒ¼

================================================================================
â–  Phase 1: ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ãƒ»ä¾å­˜é–¢ä¿‚ãƒ»å•é¡Œç®‡æ‰€ã®è¾å…¸åŒ–
================================================================================

### ğŸ“ ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ï¼ˆåº§æ¨™å¤‰æ›ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆãƒ»æç”»ã‚¨ãƒ³ã‚¸ãƒ³ï¼‰

ã€coordinate-system.jsã€‘v8.14.0 WebGL2å¯¾å¿œç‰ˆ
  è²¬å‹™: åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ Screen â†’ Canvas â†’ World â†’ Local ã®çµ±ä¸€ç®¡ç†
  è¦ªä¾å­˜: config.js, event-bus.js, camera-system.js
  å­ä¾å­˜: drawing-engine.js, stroke-recorder.js, pointer-handler.js
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - screenClientToCanvas(clientX, clientY) â†’ {canvasX, canvasY}
    - canvasToWorld(canvasX, canvasY) â†’ {worldX, worldY}
    - worldToLocal(worldX, worldY, container) â†’ {localX, localY}
  
  ğŸ” å•é¡Œç®‡æ‰€:
    - canvasToWorld(): PixiJS v8 worldTransform.applyInverse() ä½¿ç”¨
    - worldToLocal(): æ‰‹å‹•é€†å¤‰æ›å®Ÿè£…ï¼ˆPIXI toLocal()ç¦æ­¢ï¼‰
    - _getWorldContainer(): worldContainerå‚ç…§ãŒè¤‡æ•°ç®‡æ‰€ã‹ã‚‰å–å¾—å¯èƒ½ã§ä¸å®‰å®š
  
  âš ï¸ æ½œåœ¨çš„å•é¡Œ:
    - worldContainer.worldTransform ãŒæ›´æ–°ã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ï¼ˆPixi Tickeråœæ­¢æ™‚ï¼‰
    - Fallbackæ‰‹å‹•å¤‰æ›ã®rotation/scale/pivotè¨ˆç®—é †åº


ã€drawing-engine.jsã€‘v8.14.1 WebGL2ç§»è¡Œç‰ˆ
  è²¬å‹™: PointerEventå—ä¿¡ãƒ»åº§æ¨™å¤‰æ›å®Ÿè¡Œãƒ»BrushCoreã¸ã®æç”»å‘½ä»¤å§”è­²
  è¦ªä¾å­˜: coordinate-system.js, camera-system.js, layer-system.js, brush-core.js, pointer-handler.js
  å­ä¾å­˜: core-engine.jsï¼ˆåˆæœŸåŒ–å‘¼ã³å‡ºã—å…ƒï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - _handlePointerDown/Move/Up(e): PointerEventå‡¦ç†
    - _transformPointerToLocal(e) â†’ {localX, localY, worldX, worldY, canvasX, canvasY}
    - flushPendingPoints(): ãƒãƒƒãƒå‡¦ç†
  
  ğŸ” å•é¡Œç®‡æ‰€:
    - _transformPointerToLocal()å†…ã§åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ
      PointerEvent.clientX/Y â†’ screenClientToCanvas() â†’ canvasToWorld() â†’ worldToLocal()
    - activeLayerå–å¾—: this.layerManager.getActiveLayer()
    - worldToLocal()ã«activeLayerã‚’æ¸¡ã—ã¦ã„ã‚‹ãŒã€layeræ§‹é€ ãŒæ­£ã—ã„ã‹è¦ç¢ºèª
  
  âš ï¸ æ½œåœ¨çš„å•é¡Œ:
    -åº§æ¨™å¤‰æ›ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã§NaN/Infinityæ··å…¥ã®å¯èƒ½æ€§
    - activeLayerã®parent chainãŒworldContainerã¾ã§æ­£ã—ãç¹‹ãŒã£ã¦ã„ã‚‹ã‹ä¸æ˜


ã€stroke-recorder.jsã€‘Phase 0å®Œæˆç‰ˆ
  è²¬å‹™: Localåº§æ¨™ãƒã‚¤ãƒ³ãƒˆè¨˜éŒ²å°‚ç”¨ï¼ˆåº§æ¨™å¤‰æ›ã¯ä¸€åˆ‡è¡Œã‚ãªã„ï¼‰
  è¦ªä¾å­˜: drawing-engine.jsï¼ˆLocalåº§æ¨™å–å¾—å…ƒï¼‰
  å­ä¾å­˜: brush-core.jsï¼ˆstartStroke/updateStroke/endStrokeå‘¼ã³å‡ºã—ï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - startStroke(localX, localY, pressure, options)
    - addPoint(localX, localY, pressure, tiltX, tiltY)
    - getRawPoints() â†’ Array<{x, y, pressure, tiltX, tiltY, timestamp, ...}>
  
  âœ… æ­£å¸¸: åº§æ¨™å¤‰æ›ã‚’ä¸€åˆ‡è¡Œã‚ãšã€å—ã‘å–ã£ãŸLocalåº§æ¨™ã‚’ãã®ã¾ã¾è¨˜éŒ²
  âœ… æ­£å¸¸: PerfectFreehandäº’æ›å½¢å¼ + æ‹¡å¼µãƒ‡ãƒ¼ã‚¿ä¿æŒ


ã€brush-core.jsã€‘Phase 2.2 åº§æ¨™ã‚ºãƒ¬å®Œå…¨ä¿®æ­£ç‰ˆ
  è²¬å‹™: ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å‡¦ç†çµ±åˆãƒ»ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»ãƒ»æœ€çµ‚æç”»ãƒ»æ¶ˆã—ã‚´ãƒ å‡¦ç†
  è¦ªä¾å­˜: stroke-recorder.js, gl-stroke-processor.js, gl-msdf-pipeline.js, gl-texture-bridge.js, gl-mask-layer.js, layer-system.js, history.js, event-bus.js
  å­ä¾å­˜: drawing-engine.jsï¼ˆstartStroke/updateStrokeå‘¼ã³å‡ºã—å…ƒï¼‰, core-engine.jsï¼ˆrenderPreviewå‘¼ã³å‡ºã—å…ƒï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - startStroke(localX, localY, pressure): ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯é–‹å§‹
    - updateStroke(localX, localY, pressure): ãƒã‚¤ãƒ³ãƒˆè¿½åŠ 
    - renderPreview(): ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»ï¼ˆthrottle 100msï¼‰
    - _updatePreview(points): å†…éƒ¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†
    - finalizeStroke(): æœ€çµ‚ç¢ºå®šæç”»
    - _finalizeMSDFStroke(points, activeLayer): MSDFç”Ÿæˆãƒ»Spriteé…ç½®
  
  ğŸ” å•é¡Œç®‡æ‰€ï¼ˆPhase 2.2ã§ä¿®æ­£æ¸ˆã¿ã ãŒå†ç¢ºèªå¿…è¦ï¼‰:
    - _updatePreview()å†…:
      * glStrokeProcessor.createPolygonVertexBuffer(points, size)
      * glMSDFPipeline.generateMSDF(edgeBuffer, bounds, ...)
      * Spriteé…ç½®: sprite.x/y = bounds.minX/minY, width/height = bounds.width/height
    
    - _finalizeMSDFStroke()å†…ã‚‚åŒæ§˜
  
  âš ï¸ Phase 2.2ä¿®æ­£å†…å®¹:
    âœ… Spriteã‚¹ã‚±ãƒ¼ãƒ«ä¿®æ­£: 512å›ºå®š â†’ bounds.width/height
    âœ… ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é€æ˜åº¦: å®Ÿéš›ã®å€¤ã«ä¿®æ­£
  
  ğŸ” è¿½åŠ å•é¡Œã®å¯èƒ½æ€§:
    - boundsè¨ˆç®—ã®åº§æ¨™ç³»ãŒæ­£ã—ã„ã‹ï¼Ÿï¼ˆLocalåº§æ¨™å‰æï¼‰
    - Spriteé…ç½®å…ˆã®containerãŒactiveLayerã®drawingContainerã‹ç¢ºèª
    - Sprite.x/yã«è¨­å®šã™ã‚‹bounds.minX/minYãŒLocalåº§æ¨™ç³»ã§ä¸€è‡´ã—ã¦ã„ã‚‹ã‹


================================================================================
### ğŸ“ WebGL2æç”»ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

ã€gl-stroke-processor.jsã€‘Phase 1.6å®Œå…¨ä¿®æ­£ç‰ˆ
  è²¬å‹™: PerfectFreehandå‡ºåŠ›â†’GPUé ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ç”Ÿæˆãƒ»Earcutä¸‰è§’å½¢åˆ†å‰²ãƒ»EdgeBufferç”Ÿæˆãƒ»Boundsè¨ˆç®—
  è¦ªä¾å­˜: libs/perfect-freehand-1.2.0.min.js, system/earcut-triangulator.js, config.js, webgl2-drawing-layer.js
  å­ä¾å­˜: brush-core.jsï¼ˆcreatePolygonVertexBuffer/createEdgeBufferå‘¼ã³å‡ºã—å…ƒï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - createPolygonVertexBuffer(points, baseSize) â†’ {buffer: Float32Array, vertexCount, bounds}
    - createEdgeBuffer(points, baseSize) â†’ {buffer: Float32Array, edgeCount, bounds}
    - calculateBounds(points, margin) â†’ {minX, minY, maxX, maxY, width, height}
    - uploadToGPU(data, usage, elementStrideBytes) â†’ {glBuffer, elementCount, data}
  
  ğŸ”§ Phase 1.6ä¿®æ­£å†…å®¹:
    âœ… é ‚ç‚¹åº§æ¨™ã‚’boundsã«å¯¾ã™ã‚‹ç›¸å¯¾åº§æ¨™ã«å¤‰æ›
      - Localåº§æ¨™ã‹ã‚‰bounds.minX/minYã‚’å¼•ã„ã¦æ­£è¦åŒ–
      - ãƒ†ã‚¯ã‚¹ãƒãƒ£ç©ºé–“ [0, bounds.width] x [0, bounds.height] ã«å¤‰æ›
    âœ… åº§æ¨™å¤‰æ›ã‚’å®Œå…¨ã«çµ±ä¸€
  
  ğŸ” é‡è¦ãƒã‚¤ãƒ³ãƒˆ:
    - _normalizePoints(points): å…¥åŠ›ãƒã‚¤ãƒ³ãƒˆå½¢å¼ã‚’çµ±ä¸€ï¼ˆ{x,y,pressure}å½¢å¼ã¸ï¼‰
    - _calculateBoundsFromPoints(points, margin): å‹•çš„marginè¨ˆç®—
    - createPolygonVertexBuffer()å†…ã®flaté…åˆ—ç”Ÿæˆ:
      ```
      flat.push(
        outlinePoints[i][0] - bounds.minX,  // boundsãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã«å¤‰æ›
        outlinePoints[i][1] - bounds.minY
      );
      ```
    - é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ: [posX, posY, texU, texV, reserved1, reserved2, reserved3] = 7 floats/vertex
  
  âš ï¸ å•é¡Œã®å¯èƒ½æ€§:
    - å…¥åŠ›pointsãŒLocalåº§æ¨™ã§ã‚ã‚‹ã“ã¨ã‚’å‰æã¨ã—ã¦ã„ã‚‹ãŒã€å®Ÿéš›ã«Localåº§æ¨™ã‹è¦æ¤œè¨¼
    - boundsè¨ˆç®—æ™‚ã®marginå€¤ãŒé©åˆ‡ã‹ï¼ˆå‹•çš„è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯è¦ç¢ºèªï¼‰
    - PerfectFreehandå®Ÿè¡Œæ™‚ã®config.perfectFreehandã‚ªãƒ—ã‚·ãƒ§ãƒ³å€¤


ã€gl-msdf-pipeline.jsã€‘Phase 1.8 Rollbackä¿®æ­£ç‰ˆ
  è²¬å‹™: MSDFè·é›¢å ´ç”Ÿæˆï¼ˆJFA: Jump Flooding Algorithmï¼‰ãƒ»WebGLTextureå‡ºåŠ›
  è¦ªä¾å­˜: webgl2-drawing-layer.js, gl-stroke-processor.js
  å­ä¾å­˜: brush-core.jsï¼ˆgenerateMSDFå‘¼ã³å‡ºã—å…ƒï¼‰
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:
    - generateMSDF(edgeBufferData, bounds, existingMSDF, settings, vertexBufferData, vertexCount, edgeCount) â†’ {texture, width, height}
    - seedInitPass/jfaPass/encodePass/renderPass: ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å„æ®µéš
  
  ğŸ”§ Phase 1.8ä¿®æ­£å†…å®¹:
    âš ï¸ Phase 1.7ã®éå‰°ä¿®æ­£ã‚’å–ã‚Šæ¶ˆã—
    âœ… aPositionã¯æ—¢ã«[0, bounds.width/height]åº§æ¨™ï¼ˆgl-stroke-processorå‡¦ç†æ¸ˆã¿ï¼‰
    âœ… render.vert.glsl: aPosition / uResolution ã§æ­£è¦åŒ–
    âœ… uBoundsSizeå‰Šé™¤ï¼ˆä¸è¦ï¼‰
  
  ğŸ” Vertex Shaderé‡è¦éƒ¨åˆ†ï¼ˆrender.vert.glslç›¸å½“ï¼‰:
    ```glsl
    // âœ… aPositionã¯æ—¢ã«[0, bounds.width/height]
    vec2 normalized = aPosition / uResolution;  // uResolution = 512x512
    vec2 clipSpace = normalized * 2.0 - 1.0;
    clipSpace.y = -clipSpace.y;
    gl_Position = vec4(clipSpace, 0.0, 1.0);
    ```
  
  ğŸ” _drawStroke()ãƒ¡ã‚½ãƒƒãƒ‰:
    - Vertex Buffer Binding: 7 floats/vertex (stride = 28 bytes)
    - Attribute Layout: aPosition(2), aTexCoord(2), aReserved(3)
    - uResolutionè¨­å®š: gl.uniform2f(uResolution, resolution.width, resolution.height)
  
  âš ï¸ å•é¡Œã®å¯èƒ½æ€§:
    - textureSizeå›ºå®š512x512ãŒé©åˆ‡ã‹ï¼Ÿï¼ˆbounds.width/heightã¨ä¸ä¸€è‡´æ™‚ï¼‰
    - uResolutionã«æ¸¡ã™resolution.width/heightã®å€¤ãŒä½•ã‹ï¼Ÿï¼ˆ512å›ºå®šï¼Ÿboundså€¤ï¼Ÿï¼‰
    - clipSpace.yåè»¢ã®å¿…è¦æ€§ç¢ºèª


ã€webgl2-drawing-layer.jsã€‘ï¼ˆè©³ç´°æœªå–å¾—ã ãŒæ§‹é€ æ¨æ¸¬ï¼‰
  è²¬å‹™: WebGL2ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ãƒ»FBO/Textureç®¡ç†ãƒ»ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ«ãƒ¼ãƒ—
  è¦ªä¾å­˜: ãªã—ï¼ˆWebGL2 APIç›´æ¥ä½¿ç”¨ï¼‰
  å­ä¾å­˜: gl-stroke-processor.js, gl-msdf-pipeline.js, gl-texture-bridge.js, gl-mask-layer.js
  
  ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ¨æ¸¬ï¼‰:
    - getGL() â†’ WebGL2RenderingContext
    - getCanvas() â†’ HTMLCanvasElement
    - createFBO(width, height, options) â†’ {fbo, texture, width, height}
    - deleteFBO(fbo)
  
  ğŸ” é‡è¦ç¢ºèªé …ç›®:
    - WebGL2ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚µã‚¤ã‚ºã¨Pixiã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚µã‚¤ã‚ºä¸€è‡´
    - DPR=1å›ºå®šã•ã‚Œã¦ã„ã‚‹ã‹
    - Viewportè¨­å®šãŒæ­£ã—ã„ã‹


================================================================================
â–  Phase 2: å•é¡Œã®æ ¹æœ¬åŸå› åˆ†æ

### ğŸ” åº§æ¨™ã‚ºãƒ¬ã®åŸå› å€™è£œ

ã€å€™è£œ1ã€‘åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ã®åº§æ¨™ç³»æ··åœ¨
  ç—‡çŠ¶: ãƒšãƒ³å…¥åŠ›ä½ç½®ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ä½ç½®ãŒã‚ºãƒ¬ã‚‹
  
  æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ:
    âœ“ drawing-engine._transformPointerToLocal()ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã§console.log
    âœ“ screenClientToCanvas()ã§æ­£ã—ãDPIè£œæ­£ã•ã‚Œã¦ã„ã‚‹ã‹
    âœ“ canvasToWorld()ã§worldTransform.applyInverse()ãŒæ­£å¸¸å‹•ä½œã—ã¦ã„ã‚‹ã‹
    âœ“ worldToLocal()ã§activeLayerã¾ã§ã®è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ãŒæ­£ã—ã„ã‹
  
  åŸå› ä»®èª¬:
    âš ï¸ worldContainerã®worldTransformãŒæ›´æ–°ã•ã‚Œã¦ã„ãªã„
      â†’ PixiJSã®TickerãŒåœæ­¢ã—ã¦ã„ã‚‹å ´åˆã€transformæ›´æ–°ãŒé…å»¶ã™ã‚‹
      â†’ æ‰‹å‹•ã§worldContainer.updateTransform()ã‚’å‘¼ã¶å¿…è¦ãŒã‚ã‚‹å¯èƒ½æ€§
    
    âš ï¸ activeLayerã®parent chainãŒworldContainerã¾ã§ç¹‹ãŒã£ã¦ã„ãªã„
      â†’ worldToLocal()ã®è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ã§ä¸å®Œå…¨ãªå¤‰æ›ãŒç™ºç”Ÿ
    
    âš ï¸ DPI/DPRè¨ˆç®—ã®ä¸ä¸€è‡´
      â†’ canvas.width/height vs rect.width/height ã®æ¯”ç‡è¨ˆç®—ãƒŸã‚¹


ã€å€™è£œ2ã€‘Boundsè¨ˆç®—ã¨Spriteé…ç½®ã®åº§æ¨™ç³»ä¸ä¸€è‡´
  ç—‡çŠ¶: é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã§å¤‰å½¢ã™ã‚‹
  
  æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ:
    âœ“ gl-stroke-processor.calculateBounds()ã®å…¥åŠ›pointsãŒLocalåº§æ¨™ã‹ç¢ºèª
    âœ“ boundsã®{minX, minY, maxX, maxY}ãŒLocalåº§æ¨™ç³»ã§è¨ˆç®—ã•ã‚Œã¦ã„ã‚‹ã‹
    âœ“ brush-core._updatePreview()ã§ã®sprite.x/yè¨­å®šå€¤ãŒLocalåº§æ¨™ã‹ç¢ºèª
    âœ“ Spriteã®parentï¼ˆcontainerï¼‰ãŒactiveLayerã®drawingContainerã‹ç¢ºèª
  
  åŸå› ä»®èª¬:
    âš ï¸ boundsãŒWorldåº§æ¨™ç³»ã§è¨ˆç®—ã•ã‚Œã¦ã„ã‚‹
      â†’ stroke-recorderã«æ¸¡ã•ã‚Œã‚‹pointsã¯Localåº§æ¨™ã ãŒã€
         boundsè¨ˆç®—æ™‚ã«Worldåº§æ¨™ãŒæ··å…¥ã—ã¦ã„ã‚‹å¯èƒ½æ€§
    
    âš ï¸ Spriteé…ç½®å…ˆã®containerã®transformãŒè€ƒæ…®ã•ã‚Œã¦ã„ãªã„
      â†’ sprite.x = bounds.minX ã¯æ­£ã—ã„ãŒã€containerã®ä½ç½®ãŒãšã‚Œã¦ã„ã‚‹
    
    âš ï¸ ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚º512x512ã¨bounds.width/heightã®æ¯”ç‡ä¸ä¸€è‡´
      â†’ gl-msdf-pipeline.renderPass()ã§uResolutionã«ä½•ã‚’æ¸¡ã—ã¦ã„ã‚‹ã‹ä¸æ˜ç¢º


ã€å€™è£œ3ã€‘WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã®åº§æ¨™å¤‰æ›ãƒŸã‚¹
  ç—‡çŠ¶: æç”»ãŒå¤‰å½¢ã™ã‚‹ï¼ˆç‰¹ã«é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼‰
  
  æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ:
    âœ“ gl-msdf-pipeline.renderPass()ã®uResolutionå€¤
    âœ“ render.vert.glslã§ã®aPositionæ­£è¦åŒ–è¨ˆç®—
    âœ“ textureSize(512x512)ã¨bounds.width/heightã®é–¢ä¿‚
  
  åŸå› ä»®èª¬:
    âš ï¸ uResolutionã«512x512ã‚’æ¸¡ã—ã¦ã„ã‚‹ãŒã€boundsã‚µã‚¤ã‚ºã¨ä¸ä¸€è‡´
      â†’ aPosition / uResolution ã®æ­£è¦åŒ–ãŒä¸æ­£ç¢º
      â†’ ç‰¹ã«bounds.width > 512 ã®å ´åˆã«å¤‰å½¢ç™ºç”Ÿ
    
    ğŸ”§ ä¿®æ­£æ¡ˆ:
      - textureSize = max(bounds.width, bounds.height) ã«å‹•çš„å¤‰æ›´
      - ã¾ãŸã¯ã€aPositionã‚’[0, 1]æ­£è¦åŒ–ã—ã¦ã‹ã‚‰clipSpaceå¤‰æ›


ã€å€™è£œ4ã€‘PerfectFreehandã®å‡ºåŠ›åº§æ¨™ç³»å•é¡Œ
  ç—‡çŠ¶: ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å½¢çŠ¶ãŒãŠã‹ã—ã„
  
  æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ:
    âœ“ PerfectFreehandå®Ÿè¡Œå‰ã®pointsé…åˆ—ãŒLocalåº§æ¨™ã‹ç¢ºèª
    âœ“ config.perfectFreehandã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³å€¤ï¼ˆthinning, smoothingç­‰ï¼‰
    âœ“ PerfectFreehandå‡ºåŠ›ã®outlinePointsãŒLocalåº§æ¨™ç³»ã§è¿”ã•ã‚Œã¦ã„ã‚‹ã‹
  
  åŸå› ä»®èª¬:
    âš ï¸ PerfectFreehandã¸ã®å…¥åŠ›åº§æ¨™ãŒä¸æ­£ç¢º
      â†’ stroke-recorderã«è¨˜éŒ²ã•ã‚Œã‚‹åº§æ¨™ãŒå®Ÿã¯Localåº§æ¨™ã§ã¯ãªã„
    
    âš ï¸ PerfectFreehandã®sizeè¨­å®šãŒä¸é©åˆ‡
      â†’ ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å¹…ãŒå¤§ãã™ãã‚‹/å°ã•ã™ãã‚‹


================================================================================
â–  Phase 3: æ”¹ä¿®æ–¹é‡ï¼ˆå„ªå…ˆé †ä½é †ï¼‰

### ğŸ”§ æ”¹ä¿®1: åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Œå…¨æ¤œè¨¼ãƒ»ä¿®æ­£ï¼ˆæœ€å„ªå…ˆï¼‰

ã€å®Ÿæ–½å†…å®¹ã€‘
  1. ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
     - drawing-engine._transformPointerToLocal()ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã§ãƒ­ã‚°å‡ºåŠ›
     - coordinate-system.jsã®å„ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ãƒ­ã‚°å‡ºåŠ›
     - NaN/Infinityæ¤œå‡º
  
  2. worldContainer.worldTransformæ›´æ–°ä¿è¨¼
     - coordinate-system.canvasToWorld()å†…ã§
       worldContainer.updateTransform()ã‚’æ˜ç¤ºçš„ã«å‘¼ã¶
  
  3. activeLayerå–å¾—ãƒ»parent chainæ¤œè¨¼
     - layerManager.getActiveLayer()ã®æˆ»ã‚Šå€¤ã‚’å³å¯†ãƒã‚§ãƒƒã‚¯
     - activeLayer.parent â†’ parent.parent â†’ ... â†’ worldContainer ã®çµŒè·¯ç¢ºèª
     - worldToLocal()ã®è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ãƒ­ã‚°è¿½åŠ 
  
  4. DPI/DPRè¨ˆç®—ã®å†ç¢ºèª
     - screenClientToCanvas()ã®scaleX/scaleYè¨ˆç®—ã‚’æ¤œè¨¼
     - canvas.width/height, rect.width/height ã®å€¤ã‚’ãƒ­ã‚°å‡ºåŠ›

ã€æœŸå¾…åŠ¹æœã€‘
  âœ… åº§æ¨™ã‚ºãƒ¬ã®æ ¹æœ¬åŸå› ç‰¹å®š
  âœ… åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä¿¡é ¼æ€§ç¢ºä¿


### ğŸ”§ æ”¹ä¿®2: Boundsè¨ˆç®—ãƒ»Spriteé…ç½®ã®åº§æ¨™ç³»çµ±ä¸€

ã€å®Ÿæ–½å†…å®¹ã€‘
  1. gl-stroke-processor.calculateBounds()æ¤œè¨¼
     - å…¥åŠ›pointsãŒLocalåº§æ¨™ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
     - boundså€¤ã‚’ãƒ­ã‚°å‡ºåŠ›
     - marginè¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯å†ç¢ºèª
  
  2. brush-core._updatePreview()/_finalizeMSDFStroke()ä¿®æ­£
     - boundsè¨ˆç®—å¾Œã€ä»¥ä¸‹ã‚’ç¢ºèª:
       ```javascript
       console.log('Bounds (Localåº§æ¨™):', bounds);
       console.log('Spriteé…ç½®:', { x: bounds.minX, y: bounds.minY, width: bounds.width, height: bounds.height });
       console.log('Container:', container.position, container.scale, container.rotation);
       ```
     - Spriteã®parentãŒcontainerï¼ˆactiveLayer.drawingContainerï¼‰ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼
  
  3. ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã¨boundsã®é–¢ä¿‚æ˜ç¢ºåŒ–
     - gl-msdf-pipeline.textureSize ã‚’å‹•çš„åŒ–ï¼ˆPhase 3ã§å®Ÿè£…äºˆå®šã¨è¨˜è¼‰ã‚ã‚Šï¼‰
     - å½“é¢ã¯512å›ºå®šã ãŒã€uResolutionã«ä½•ã‚’æ¸¡ã™ã¹ãã‹æ˜ç¢ºåŒ–

ã€æœŸå¾…åŠ¹æœã€‘
  âœ… Spriteé…ç½®ã®æ­£ç¢ºæ€§å‘ä¸Š
  âœ… å¤‰å½¢å•é¡Œã®è§£æ¶ˆ


### ğŸ”§ æ”¹ä¿®3: WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã®åº§æ¨™æ­£è¦åŒ–ä¿®æ­£

ã€å®Ÿæ–½å†…å®¹ã€‘
  1. gl-msdf-pipeline.renderPass()ä¿®æ­£
     - uResolutionã«æ¸¡ã™å€¤ã‚’æ˜ç¢ºåŒ–:
       ```javascript
       // ç¾åœ¨: gl.uniform2f(uResolution, width, height);  // width/height = 512å›ºå®š
       // ä¿®æ­£æ¡ˆ: gl.uniform2f(uResolution, bounds.width, bounds.height);
       ```
     
     - ãŸã ã—ã€textureSize = 512å›ºå®šãªã®ã§ã€ä»¥ä¸‹ã®ã„ãšã‚Œã‹:
       A) textureSize = bounds.width/height ã«å¤‰æ›´ï¼ˆPhase 3å®Ÿè£…ï¼‰
       B) aPositionåº§æ¨™ã‚’äº‹å‰ã«[0, 512]ã«ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆgl-stroke-processorå´ï¼‰
       C) render.vert.glslã§ã®æ­£è¦åŒ–è¨ˆç®—ã‚’ä¿®æ­£
  
  2. render.vert.glslä¿®æ­£æ¡ˆï¼ˆæ¡ˆCæ¡ç”¨ã®å ´åˆï¼‰
     ```glsl
     uniform vec2 uResolution;        // ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£åƒåº¦ï¼ˆ512x512ï¼‰
     uniform vec2 uBoundsSize;        // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯bounds.width/height
     
     void main() {
       // aPositionã¯[0, bounds.width/height]åº§æ¨™
       // 1. boundsã‚µã‚¤ã‚ºã§æ­£è¦åŒ– â†’ [0, 1]
       vec2 normalized = aPosition / uBoundsSize;
       // 2. ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£åƒåº¦ã«ã‚¹ã‚±ãƒ¼ãƒ« â†’ [0, 512]
       vec2 texPos = normalized * uResolution;
       // 3. ã‚¯ãƒªãƒƒãƒ—ç©ºé–“å¤‰æ›
       vec2 clipSpace = (texPos / uResolution) * 2.0 - 1.0;
       clipSpace.y = -clipSpace.y;
       gl_Position = vec4(clipSpace, 0.0, 1.0);
     }
     ```
  
  3. _drawStroke()ãƒ¡ã‚½ãƒƒãƒ‰ä¿®æ­£
     - uBoundsSize uniformè¿½åŠ ãƒ»è¨­å®š:
       ```javascript
       const uBoundsSize = gl.getUniformLocation(program, 'uBoundsSize');
       if (uBoundsSize) {
         gl.uniform2f(uBoundsSize, bounds.width, bounds.height);
       }
       ```

ã€æœŸå¾…åŠ¹æœã€‘
  âœ… WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã®åº§æ¨™å¤‰æ›ã®æ­£ç¢ºæ€§å‘ä¸Š
  âœ… é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã§ã®å¤‰å½¢å•é¡Œè§£æ¶ˆ


### ğŸ”§ æ”¹ä¿®4: PerfectFreehandå…¥åŠ›åº§æ¨™ãƒ»ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ¤œè¨¼

ã€å®Ÿæ–½å†…å®¹ã€‘
  1. stroke-recorder.getRawPoints()ã®å‡ºåŠ›ç¢ºèª
     - ãƒ­ã‚°ã§pointsé…åˆ—ã®åº§æ¨™å€¤ã‚’ç¢ºèª
     - Localåº§æ¨™ç¯„å›²ï¼ˆé€šå¸¸0ï½ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºï¼‰å†…ã‹æ¤œè¨¼
  
  2. config.perfectFreehandã‚ªãƒ—ã‚·ãƒ§ãƒ³èª¿æ•´
     - ç¾åœ¨ã®è¨­å®š:
       ```javascript
       thinning: 0.7,
       smoothing: 0.4,
       streamline: 0.3
       ```
     - å¿…è¦ã«å¿œã˜ã¦èª¿æ•´ï¼ˆç‰¹ã«smoothing/streamlineãŒåº§æ¨™è£œé–“ã«å½±éŸ¿ï¼‰
  
  3. gl-stroke-processor._executePerfectFreehand()æ¤œè¨¼
     - å…¥åŠ›strokePointsé…åˆ—ã‚’ãƒ­ã‚°å‡ºåŠ›
     - å‡ºåŠ›outlinePointsé…åˆ—ã‚’ãƒ­ã‚°å‡ºåŠ›
     - åº§æ¨™å€¤ã®å¦¥å½“æ€§ç¢ºèª

ã€æœŸå¾…åŠ¹æœã€‘
  âœ… PerfectFreehandå®Ÿè¡Œã®æ­£ç¢ºæ€§ä¿è¨¼
  âœ… ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å½¢çŠ¶ã®å®‰å®šåŒ–


================================================================================
â–  Phase 4: æ”¹ä¿®å®Ÿæ–½é †åº

ã€Step 1ã€‘ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ ãƒ»å•é¡Œç‰¹å®šï¼ˆ1æ—¥ç›®ï¼‰
  ãƒ•ã‚¡ã‚¤ãƒ«: coordinate-system.js, drawing-engine.js, brush-core.js, gl-stroke-processor.js
  ä½œæ¥­:
    - åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã§console.logè¿½åŠ 
    - NaN/Infinityæ¤œå‡º
    - worldContainer.worldTransform, activeLayer.parent chainç¢ºèª
    - boundså€¤ã€Spriteé…ç½®å€¤ã®ãƒ­ã‚°å‡ºåŠ›
  
  ç¢ºèªæ–¹æ³•:
    - ãƒ–ãƒ©ã‚¦ã‚¶ã§ãƒšãƒ³æç”»ã—ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’ç›£è¦–
    - åº§æ¨™å€¤ã®ç•°å¸¸ã‚’ç‰¹å®š


ã€Step 2ã€‘åº§æ¨™å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä¿®æ­£ï¼ˆ2æ—¥ç›®ï¼‰
  ãƒ•ã‚¡ã‚¤ãƒ«: coordinate-system.js, drawing-engine.js
  ä½œæ¥­:
    - worldContainer.updateTransform()æ˜ç¤ºçš„å‘¼ã³å‡ºã—è¿½åŠ 
    - worldToLocal()ã®è¦ªãƒã‚§ãƒ¼ãƒ³é¡æŸ»ãƒ­ã‚¸ãƒƒã‚¯å†ç¢ºèª
    - DPI/DPRè¨ˆç®—ã®ä¿®æ­£ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
  
  ç¢ºèªæ–¹æ³•:
    - ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã§åº§æ¨™å¤‰æ›ã®å„ã‚¹ãƒ†ãƒƒãƒ—ãŒæ­£å¸¸ã‹ç¢ºèª
    - ãƒšãƒ³å…¥åŠ›ä½ç½®ã¨ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ä½ç½®ã®ã‚ºãƒ¬è§£æ¶ˆã‚’ç¢ºèª


ã€Step 3ã€‘Boundsãƒ»Spriteé…ç½®ä¿®æ­£ï¼ˆ3æ—¥ç›®ï¼‰
  ãƒ•ã‚¡ã‚¤ãƒ«: brush-core.js, gl-stroke-processor.js
  ä½œæ¥­:
    - boundsè¨ˆç®—ã®åº§æ¨™ç³»ç¢ºèªãƒ»ä¿®æ­£
    - Spriteé…ç½®ãƒ­ã‚¸ãƒƒã‚¯ç¢ºèªãƒ»ä¿®æ­£
    - Containerå–å¾—ãƒ­ã‚¸ãƒƒã‚¯ç¢ºèª
  
  ç¢ºèªæ–¹æ³•:
    - é•·ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æç”»ã§å¤‰å½¢ãŒèµ·ããªã„ã‹ç¢ºèª
    - Spriteä½ç½®ãŒãƒšãƒ³è»Œè·¡ã¨ä¸€è‡´ã—ã¦ã„ã‚‹ã‹ç¢ºèª


ã€Step 4ã€‘WebGL2ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¿®æ­£ï¼ˆ4æ—¥ç›®ï¼‰
  ãƒ•ã‚¡ã‚¤ãƒ«: gl-msdf-pipeline.js
  ä½œæ¥­:
    - render.vert.glslä¿®æ­£ï¼ˆuBoundsSizeè¿½åŠ ï¼‰
    - _drawStroke()ãƒ¡ã‚½ãƒƒãƒ‰ä¿®æ­£ï¼ˆuBoundsSizeè¨­å®šï¼‰
    - renderPass()ä¿®æ­£ï¼ˆboundså¼•æ•°åˆ©ç”¨ï¼‰
  
  ç¢ºèªæ–¹æ³•:
    - WebGL2ãƒ†ã‚¯ã‚¹ãƒãƒ£å‡ºåŠ›ãŒæ­£ç¢ºã‹ç¢ºèª
    - å¤‰å½¢å•é¡Œã®å®Œå…¨è§£æ¶ˆç¢ºèª


ã€Step 5ã€‘ç·åˆãƒ†ã‚¹ãƒˆãƒ»å¾®èª¿æ•´ï¼ˆ5æ—¥ç›®ï¼‰
  ä½œæ¥­:
    - æ§˜ã€…ãªã‚µã‚¤ã‚ºãƒ»é•·ã•ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã§ãƒ†ã‚¹ãƒˆ
    - ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ“ä½œä¸‹ã§ã®ãƒ†ã‚¹ãƒˆ
    - ç­†åœ§å¯¾å¿œæº–å‚™ï¼ˆæ¬¡ãƒ•ã‚§ãƒ¼ã‚ºï¼‰
    - ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã®å‰Šé™¤ãƒ»ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  
  ç¢ºèªæ–¹æ³•:
    - ãƒšãƒ³å…¥åŠ›ãŒå®Œå…¨ã«å®‰å®šã—ã¦ã„ã‚‹ã‹
    - åº§æ¨™ã‚ºãƒ¬ãƒ»å¤‰å½¢ãŒå®Œå…¨ã«è§£æ¶ˆã•ã‚Œã¦ã„ã‚‹ã‹


================================================================================
â–  Phase 5: å®Ÿè£…è©³ç´°ï¼ˆClaudeå®Ÿè£…ç”¨ã‚¬ã‚¤ãƒ‰ï¼‰

### ğŸ”§ coordinate-system.jsä¿®æ­£

ã€ä¿®æ­£ç®‡æ‰€1ã€‘canvasToWorld()ãƒ¡ã‚½ãƒƒãƒ‰
  ```javascript
  canvasToWorld(canvasX, canvasY) {
    const worldContainer = this._getWorldContainer();
    if (!worldContainer) {
      return { worldX: canvasX, worldY: canvasY };
    }
    
    // âœ… è¿½åŠ : worldTransformæ›´æ–°ä¿è¨¼
    worldContainer.updateTransform();
    
    const worldTransform = worldContainer.worldTransform;
    if (worldTransform && typeof worldTransform.applyInverse === 'function') {
      try {
        const point = worldTransform.applyInverse({ x: canvasX, y: canvasY });
        
        // âœ… è¿½åŠ : NaNæ¤œå‡º
        if (isNaN(point.x) || isNaN(point.y)) {
          console.error('[CoordinateSystem] canvasToWorld returned NaN', { canvasX, canvasY, point });
          return this._fallbackCanvasToWorld(canvasX, canvasY, worldContainer);
        }
        
        return { worldX: point.x, worldY: point.y };
      } catch (error) {
        console.error('[CoordinateSystem] worldTransform.applyInverse() error:', error);
        return this._fallbackCanvasToWorld(canvasX, canvasY, worldContainer);
      }
    }
    
    return this._fallbackCanvasToWorld(canvasX, canvasY, worldContainer);
  }
  
  // âœ… è¿½åŠ : Fallbackæ‰‹å‹•å¤‰æ›ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‚’åˆ†é›¢ï¼‰
  _fallbackCanvasToWorld(canvasX, canvasY, worldContainer) {
    const pos = worldContainer.position || { x: 0, y: 0 };
    const scale = worldContainer.scale || { x: 1, y: 1 };
    const pivot = worldContainer.pivot || { x: 0, y: 0 };
    const rotation = worldContainer.rotation || 0;
    
    let x = canvasX - pos.x;
    let y = canvasY - pos.y;
    
    if (Math.abs(rotation) > 1e-6) {
      const cos = Math.cos(-rotation);
      const sin = Math.sin(-rotation);
      const rx = x * cos - y * sin;
      const ry = x * sin + y * cos;
      x = rx;
      y = ry;
    }
    
    if (Math.abs(scale.x) > 1e-6) x = x / scale.x;
    if (Math.abs(scale.y) > 1e-6) y = y / scale.y;
    
    x = x + pivot.x;
    y = y + pivot.y;
    
    return { worldX: x, worldY: y };
  }
  ```

ã€ä¿®æ­£ç®‡æ‰€2ã€‘worldToLocal()ãƒ¡ã‚½ãƒƒãƒ‰
  ```javascript
  worldToLocal(worldX, worldY, container) {
    if (!container) {
      console.warn('[CoordinateSystem] worldToLocal: container is null');
      return { localX: worldX, localY: worldY };
    }
    
    // âœ… è¿½åŠ : ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼ˆé–‹ç™ºæ™‚ã®ã¿æœ‰åŠ¹åŒ–ï¼‰
    const DEBUG_COORD = false;
    if (DEBUG_COORD) {
      console.log('[worldToLocal] Input:', { worldX, worldY, containerLabel: container.label || container.name });
    }
    
    let transforms = [];
    let node = container;
    const worldContainer = this._getWorldContainer();
    
    // âœ… è¿½åŠ : ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
    let depth = 0;
    const MAX_DEPTH = 20;
    
    while (node && node !== worldContainer && node !== null) {
      if (depth++ > MAX_DEPTH) {
        console.error('[CoordinateSystem] worldToLocal: parent chain too deep (infinite loop?)');
        break;
      }
      
      transforms.push({
        pos: node.position || { x: 0, y: 0 },
        scale: node.scale || { x: 1, y: 1 },
        rotation: node.rotation || 0,
        pivot: node.pivot || { x: 0, y: 0 },
        label: node.label || node.name || 'unknown'
      });
      node = node.parent;
    }
    
    if (DEBUG_COORD) {
      console.log('[worldToLocal] Transform chain:', transforms.map(t => t.label));
    }
    
    let x = worldX;
    let y = worldY;
    
    for (let i = transforms.length - 1; i >= 0; i--) {
      const t = transforms[i];
      
      x -= t.pos.x;
      y -= t.pos.y;
      
      if (Math.abs(t.rotation) > 1e-6) {
        const cos = Math.cos(-t.rotation);
        const sin = Math.sin(-t.rotation);
        const rx = x * cos - y * sin;
        const ry = x * sin + y * cos;
        x = rx;
        y = ry;
      }
      
      if (Math.abs(t.scale.x) > 1e-6) x /= t.scale.x;
      if (Math.abs(t.scale.y) > 1e-6) y /= t.scale.y;
      
      x += t.pivot.x;
      y += t.pivot.y;
    }
    
    // âœ… è¿½åŠ : NaNæ¤œå‡º
    if (isNaN(x) || isNaN(y)) {
      console.error('[CoordinateSystem] worldToLocal returned NaN', {
        input: { worldX, worldY },
        output: { x, y },
        transforms: transforms
      });
      return { localX: worldX, localY: worldY };
    }
    
    if (DEBUG_COORD) {
      console.log('[worldToLocal] Output:', { localX: x, localY: y });
    }
    
    return { localX: x, localY: y };
  }