================================================================================
Tegaki v8.13 - サムネイル問題 段階的改修計画書 v3.0
================================================================================

## 📋 問題の根本原因

### 1. ThumbnailSystemの二重実装
- `_renderLayerThumbnail()` が同一ファイル内に2つ存在
  - 1つ目: ファイル先頭（フレーム全体レンダリング方式）
  - 2つ目: ファイル後半（バウンディングボックス方式）
- どちらを使うべきか不明確で混乱を招く

### 2. layer-system.jsの独自サムネイル実装
- `updateThumbnail()` メソッドが存在し独自実装
- レイヤーを一時コンテナに移動する破壊的処理
- Transform一時リセット→復元時にズレが発生

### 3. イベントフロー断絶
```
layer-transform.js → layer:transform-updated 発火
  ├→ layer-panel-renderer.js ✅ 購読あり
  ├→ timeline-thumbnail-utils.js ✅ 購読あり
  └→ layer-system.js ❌ 購読なし（独自updateThumbnail使用）
```

### 4. Vモード時の反転機能の問題
- Vモード時の反転ボタンがdisabled状態のまま
- ショートカット（H/Shift+H）も効かない
- layer-transform.js自体は正常に動作


================================================================================
## 🗺️ フロー図

### サムネイル更新の全体フロー（現状）

```
[ユーザー操作]
  ↓
[layer-transform.js] applyTransform()
  ↓ gsap.delayedCall(0.016)
  ↓
  ├→ layer:transform-updated 発火
  │    ├→ timeline-thumbnail-utils.js ✅
  │    └→ layer-panel-renderer.js ✅
  │
  └→ thumbnail:layer-updated 発火
       ├→ timeline-thumbnail-utils.js ✅
       └→ layer-panel-renderer.js ✅

❌ layer-system.js は購読せず、独自の updateThumbnail() を使用
```

### 理想のフロー（改修後）

```
[ユーザー操作]
  ↓
[layer-transform.js] applyTransform()
  ↓ gsap.delayedCall(0.016)
  ↓
layer:transform-updated 発火
  ↓
  ├→ [ThumbnailSystem] キャッシュクリア
  ├→ [layer-panel-renderer.js] サムネイル更新
  └→ [timeline-thumbnail-utils.js] サムネイル更新

✅ すべてThumbnailSystemに統一
✅ layer-system.jsの独自実装を削除
```


================================================================================
## 📚 メソッド・シンボル辞典

### ThumbnailSystem
```
generateLayerThumbnail(layer, w, h) → Promise<Canvas>
  レイヤーサムネイル生成のエントリポイント
  
_renderLayerThumbnail(layer, w, h) → Promise<Canvas>
  ❌ 問題: 同一ファイル内に2つ存在
  
_generateBackgroundThumbnail(layer, w, h) → Promise<Canvas>
  背景レイヤー専用サムネイル
  
_resizeRenderTextureToCanvas(rt, w, h) → Promise<Canvas>
  RenderTextureをCanvasにリサイズ
  
_invalidateLayerCacheByLayerId(layerId) → void
  レイヤーIDでキャッシュクリア
  
clearAllCache() → void
  全キャッシュクリア
```

### LayerSystem
```
updateThumbnail(layerIndex) → void
  ❌ 独自実装（削除対象）
  
requestThumbnailUpdate(layerIndex) → void
  サムネイル更新をキューに追加
  
processThumbnailUpdates() → void
  キューを処理してupdateThumbnail()呼び出し
```

### LayerTransform
```
applyTransform(layer, transform, cx, cy) → void
  Transform適用 + GSAP同期
  gsap.delayedCall(0.016) で _emitTransformUpdated() を呼ぶ
  
_emitTransformUpdated(layerId, layer) → void
  layer:transform-updated 発火（throttle付き）
  
flipLayer(layer, direction) → void
  反転処理
  
_updateFlipButtonsAvailability(isVMode) → void
  Vモード時のボタンdisabled制御
```

### LayerPanelRenderer
```
updateLayerThumbnail(layerIndex) → Promise<void>
  ThumbnailSystemからサムネイル取得→DOM更新
  
_generateAndDisplayThumbnail(layer, index, img) → Promise<void>
  サムネイル生成・表示
```

### EventBus
```
on(event, callback, priority=0) → void
  イベント購読（priority指定可能）
  
emit(event, data) → void
  イベント発火
```

### 主要イベント
```
keyboard:vkey-pressed        Vキー押下
keyboard:vkey-released       Vキー離した
layer:transform-updated      Transform更新（throttle付き）
thumbnail:layer-updated      サムネイル更新リクエスト
```


================================================================================
## 🎯 段階的改修計画

### Phase 1: ThumbnailSystemの二重実装撲滅【最優先】
**目的:** `_renderLayerThumbnail()` の重複を削除し単一実装に統一

**改修ファイル:**
- `system/drawing/thumbnail-system.js`

**参考ファイル:**
- `📊 座標系とサムネイル生成 - 全体構造分析ドキュメント.txt`

**処理内容:**
1. ファイル先頭の `_renderLayerThumbnail()` を削除
   - 1-80行目あたりの実装を削除
   
2. ファイル後半の `_renderLayerThumbnail()` を残す
   - バウンディングボックス方式の実装（Phase 4完全版）
   
3. 削除する実装の特徴:
   ```javascript
   // ❌ 削除対象
   async _renderLayerThumbnail(layer, width, height) {
       const frameContainer = layer.parent;
       // 他のレイヤーを非表示化
       const siblingVisibility = new Map();
       frameContainer.children.forEach(sibling => {
           if (sibling !== layer) {
               siblingVisibility.set(sibling, sibling.visible);
               sibling.visible = false;
           }
       });
       // ...
   }
   ```

4. 残す実装の特徴:
   ```javascript
   // ✅ これを残す
   async _renderLayerThumbnail(layer, width, height) {
       const bounds = layer.getLocalBounds();
       // バウンディングボックス方式
       // tempContainerを使用
   }
   ```

**DRY/SOLID準拠:**
- 単一責任原則: 1つのメソッドが1つの実装のみ
- 重複排除: 同名メソッドの二重定義を撲滅


---

### Phase 2: layer-system.jsの独自実装削除【最優先】
**目的:** ThumbnailSystemに完全統一

**改修ファイル:**
- `system/layer-system.js`

**参考ファイル:**
- `system/drawing/thumbnail-system.js`
- `ui/layer-panel-renderer.js`

**処理内容:**
1. `updateThumbnail(layerIndex)` メソッドを完全削除
   - 破壊的な一時コンテナ移動処理を削除
   
2. `requestThumbnailUpdate(layerIndex)` を修正
   ```javascript
   // ❌ 現状
   requestThumbnailUpdate(layerIndex) {
       this.thumbnailUpdateQueue.add(layerIndex);
       // ... updateThumbnail()を呼ぶ
   }
   
   // ✅ 修正後
   requestThumbnailUpdate(layerIndex) {
       if (this.eventBus) {
           this.eventBus.emit('thumbnail:layer-updated', {
               component: 'layer-system',
               action: 'update-requested',
               data: { layerIndex, immediate: false }
           });
       }
   }
   ```

3. `processThumbnailUpdates()` メソッドを削除
   - もはや不要

4. `_startThumbnailUpdateProcess()` を削除
   - setIntervalで定期実行していた処理を削除

**DRY/SOLID準拠:**
- 単一責任原則: LayerSystemはレイヤー管理のみ、サムネイルはThumbnailSystem
- 重複排除: 独自実装を削除し既存のThumbnailSystemに統一


---

### Phase 3: イベントフロー統合【重要】
**目的:** すべてのサムネイル更新をThumbnailSystemに集約

**改修ファイル:**
- `system/layer-system.js`

**参考ファイル:**
- `system/event-bus.js`
- `system/drawing/thumbnail-system.js`

**処理内容:**
1. layer-system.js に `layer:transform-updated` 購読を追加
   ```javascript
   _setupEventListeners() {
       // 既存のイベント購読に追加
       this.eventBus.on('layer:transform-updated', ({ data }) => {
           const { layerIndex, layerId } = data || {};
           if (layerIndex !== undefined) {
               // Phase 2で修正した requestThumbnailUpdate() を呼ぶ
               this.requestThumbnailUpdate(layerIndex);
           }
       });
   }
   ```

2. flipActiveLayer() に明示的なイベント発火を追加（既に実装済み確認）
   ```javascript
   flipActiveLayer(direction) {
       if (!this.transform) return;
       const activeLayer = this.getActiveLayer();
       if (activeLayer) {
           this.transform.flipLayer(activeLayer, direction);
           this.requestThumbnailUpdate(this.activeLayerIndex);
           
           // ✅ 既に実装されている
           if (this.eventBus) {
               this.eventBus.emit('layer:transform-updated', { 
                   layerId: activeLayer.layerData.id 
               });
           }
       }
   }
   ```

**DRY/SOLID準拠:**
- イベント駆動設計: すべての更新がEventBus経由
- 疎結合: 各モジュールが直接依存せずイベントで連携


---

### Phase 4: Vモード時の反転機能修復【必須】
**目的:** Vモード時に反転ボタン/ショートカットを有効化

**改修ファイル:**
- `system/layer-transform.js`

**参考ファイル:**
- `ui/keyboard-handler.js`
- `system/layer-system.js`

**処理内容:**
1. `_updateFlipButtonsAvailability(isVMode)` を確認
   - 既に実装済みを確認
   - `enterMoveMode()` で呼ばれているか確認
   
2. ボタンのHTML/CSS確認
   ```javascript
   // layer-transform.js の _setupTransformPanel() で
   flipHorizontalBtn.setAttribute('disabled', 'true');
   // ↓ Vモード時に
   flipHorizontalBtn.removeAttribute('disabled');
   ```

3. ショートカット処理確認
   - keyboard-handler.jsの`LAYER_FLIP_HORIZONTAL`アクション
   - `isVKeyPressed` の条件判定を確認
   
4. layer-system.js の `flipActiveLayer()` 呼び出しパス確認
   - keyboard-handler → layer-system.flipActiveLayer()
   - layer-transform.onFlipRequest → layer-system.flipActiveLayer()

**フロー確認:**
```
[Vキー押下]
  → keyboard:vkey-pressed
  → layer-system._setupVKeyEvents()
  → layer-transform.enterMoveMode()
  → _updateFlipButtonsAvailability(true) ← ここでボタン有効化

[Hキー押下（Vモード中）]
  → keyboard-handler.handleKeyDown()
  → action = LAYER_FLIP_HORIZONTAL
  → layer-system.flipActiveLayer('horizontal')
  → layer-transform.flipLayer(layer, 'horizontal')
```

**検証ポイント:**
- Vキー押下時に`_updateFlipButtonsAvailability(true)`が呼ばれているか
- ボタンの`disabled`属性が正しく削除されているか
- keyboard-handlerの`vKeyPressed`フラグが正しく設定されているか


---

### Phase 5: Canvas2D依存の完全撲滅【品質向上】
**目的:** すべてのサムネイル生成をPixiJS RenderTextureに統一

**改修ファイル:**
- `system/drawing/thumbnail-system.js`

**参考ファイル:**
- `ui/layer-panel-renderer.js`
- `ui/timeline-thumbnail-utils.js`

**処理内容:**
1. `_generateBackgroundThumbnail()` の確認
   ```javascript
   // 現状: Canvas2Dを使用
   const canvas = document.createElement('canvas');
   const ctx = canvas.getContext('2d');
   ctx.fillRect(0, 0, width, height);
   
   // ✅ 問題なし: 背景レイヤーは単色塗りつぶしなのでCanvas2D許容
   // または PixiJS Graphics で代替可能
   ```

2. すべてのサムネイル生成パスを確認
   - `generateLayerThumbnail()` → RenderTexture使用 ✅
   - `generateFrameThumbnail()` → RenderTexture使用 ✅
   - `_renderFrameThumbnailPixiJS()` → RenderTexture使用 ✅

3. DataURL変換は許容
   ```javascript
   // ✅ 問題なし: Canvas.toDataURL()は最終出力なので許容
   const dataURL = canvas.toDataURL('image/png');
   ```

**Canvas2D使用箇所の分類:**
- ❌ 禁止: 描画処理・変形処理でのCanvas2D使用
- ✅ 許容: 最終出力（toDataURL）、背景単色塗りつぶし

**DRY/SOLID準拠:**
- 技術スタック統一: PixiJS中心のアーキテクチャ維持


---

### Phase 6: 最終検証・デバッグ【品質保証】
**目的:** すべての問題が解決したことを確認

**検証項目:**

1. **レイヤーサムネイルの即座更新**
   - Vモードでレイヤー移動・回転・拡縮
   - サムネイルが即座に更新されるか
   - 非アクティブレイヤーも正しく更新されるか

2. **タイムラインサムネイルの即座更新**
   - Vモードでレイヤー変形
   - タイムラインサムネイルが即座に更新されるか
   - 初回でも正しく反映されるか

3. **Vモード時の反転機能**
   - パネル内の反転ボタンがクリック可能か
   - Hキーで水平反転できるか
   - Shift+Hキーで垂直反転できるか

4. **デバッグコマンド実行**
   ```javascript
   // ブラウザコンソールで実行
   window.ThumbnailSystem.getDebugInfo()
   // → キャッシュサイズ、Vモード状態などを確認
   
   window.TegakiUI.LayerPanelRenderer.prototype.debugPrintCacheInfo()
   // → パネル側のキャッシュ状態を確認
   ```

5. **イベントフロー確認**
   ```javascript
   // event-bus.js で debug を有効化
   window.TegakiEventBus.setDebug(true);
   
   // layer:transform-updated が正しく発火しているか
   // thumbnail:layer-updated が正しく発火しているか
   ```


================================================================================
## 📊 改修前後の比較

### 改修前（現状）
```
[サムネイル生成の実装箇所]
├─ ThumbnailSystem._renderLayerThumbnail() ❌ 2つ存在
├─ layer-system.updateThumbnail() ❌ 独自実装
└─ layer-panel-renderer._generateAndDisplayThumbnail() ✅

[イベントフロー]
layer:transform-updated
├→ layer-panel-renderer ✅
├→ timeline-thumbnail-utils ✅
└→ layer-system ❌ 購読なし
```

### 改修後（目標）
```
[サムネイル生成の実装箇所]
├─ ThumbnailSystem._renderLayerThumbnail() ✅ 単一実装
└─ layer-panel-renderer._generateAndDisplayThumbnail() ✅

[イベントフロー]
layer:transform-updated
├→ ThumbnailSystem ✅ キャッシュクリア
├→ layer-panel-renderer ✅ サムネイル更新
├→ timeline-thumbnail-utils ✅ サムネイル更新
└→ layer-system ✅ requestThumbnailUpdate()
```


================================================================================
## ⚠️ 注意事項

### DRY/SOLID原則チェックリスト
- [ ] 同名メソッドの二重実装がないか
- [ ] 座標変換処理の重複がないか
- [ ] イベント購読の漏れがないか
- [ ] Canvas2Dの不要な使用がないか
- [ ] 破壊的な処理（レイヤー移動）がないか

### Canvas2D使用判定基準
- ❌ 禁止: レンダリング、Transform適用、描画処理
- ✅ 許容: toDataURL（最終出力）、背景単色塗りつぶし

### イベント命名規則
```
component:action
例: layer:transform-updated
    thumbnail:layer-updated
    keyboard:vkey-pressed
```

### データフロー原則
```
PointerEvent → CoordinateSystem → DrawingEngine → StrokeRecorder
              ↓
        Transform適用
              ↓
        ThumbnailSystem ← EventBus経由で更新通知
```


================================================================================
## 🚀 改修順序の重要性

1. **Phase 1優先:** 二重実装撲滅は最優先（後続Phaseの前提条件）
2. **Phase 2優先:** 独自実装削除で統一アーキテクチャ確立
3. **Phase 3:** イベントフロー統合で全体連携完成
4. **Phase 4:** UI機能修復（ユーザー体験向上）
5. **Phase 5:** 技術スタック統一（品質向上）
6. **Phase 6:** 最終検証（品質保証）

**Phase 1-3は必須、Phase 4-6は品質向上**


================================================================================
改修計画書 v3.0 完
================================================================================