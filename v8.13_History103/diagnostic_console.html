<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>P/E+ドラッグ診断ツール</title>
<style>
body {
  font-family: 'Consolas', 'Monaco', monospace;
  background: #1e1e1e;
  color: #d4d4d4;
  padding: 20px;
  margin: 0;
}
.container {
  max-width: 1200px;
  margin: 0 auto;
}
h1 {
  color: #4fc3f7;
  font-size: 24px;
  margin-bottom: 20px;
}
.section {
  background: #252526;
  border: 1px solid #3e3e42;
  border-radius: 4px;
  padding: 15px;
  margin-bottom: 15px;
}
.section-title {
  color: #4ec9b0;
  font-size: 16px;
  font-weight: bold;
  margin-bottom: 10px;
  border-bottom: 1px solid #3e3e42;
  padding-bottom: 5px;
}
button {
  background: #0e639c;
  color: white;
  border: none;
  padding: 8px 16px;
  margin: 5px;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
}
button:hover {
  background: #1177bb;
}
button:active {
  background: #0d5689;
}
.output {
  background: #1e1e1e;
  border: 1px solid #3e3e42;
  border-radius: 3px;
  padding: 10px;
  margin-top: 10px;
  white-space: pre-wrap;
  font-size: 13px;
  max-height: 400px;
  overflow-y: auto;
}
.key {
  color: #9cdcfe;
}
.value {
  color: #ce9178;
}
.true {
  color: #4ec9b0;
}
.false {
  color: #f48771;
}
.null {
  color: #808080;
}
.number {
  color: #b5cea8;
}
.error {
  color: #f48771;
  background: #3e1e1e;
  padding: 5px;
  border-radius: 3px;
  margin: 5px 0;
}
.success {
  color: #4ec9b0;
}
.warning {
  color: #dcdcaa;
}
.instruction {
  background: #264f78;
  padding: 10px;
  border-radius: 3px;
  margin-bottom: 15px;
  border-left: 4px solid #4fc3f7;
}
</style>
</head>
<body>
<div class="container">
  <h1>🔍 P/E+ドラッグ機能 診断ツール</h1>
  
  <div class="instruction">
    <strong>使い方:</strong><br>
    1. 「初期状態診断」で現在の状態を確認<br>
    2. アプリでP+ドラッグを実行（ペンサイズを変更）<br>
    3. 「ドラッグ後診断」でイベントフローを確認<br>
    4. 問題があれば「修復試行」を実行
  </div>

  <div class="section">
    <div class="section-title">📊 基本診断</div>
    <button onclick="diagnoseInitial()">初期状態診断</button>
    <button onclick="diagnoseAfterDrag()">ドラッグ後診断</button>
    <button onclick="diagnoseEventFlow()">イベントフロー診断</button>
    <div id="basic-output" class="output"></div>
  </div>

  <div class="section">
    <div class="section-title">🔬 詳細診断</div>
    <button onclick="diagnoseDrawingEngine()">DrawingEngine詳細</button>
    <button onclick="diagnoseToolSizeManager()">ToolSizeManager詳細</button>
    <button onclick="diagnoseBrushSettings()">BrushSettings詳細</button>
    <button onclick="diagnoseEventBus()">EventBus診断</button>
    <div id="detail-output" class="output"></div>
  </div>

  <div class="section">
    <div class="section-title">🧪 テスト実行</div>
    <button onclick="testManualSizeChange()">手動サイズ変更テスト</button>
    <button onclick="testEventEmit()">イベント発火テスト</button>
    <button onclick="simulateDrag()">ドラッグシミュレーション</button>
    <div id="test-output" class="output"></div>
  </div>

  <div class="section">
    <div class="section-title">🔧 修復・監視</div>
    <button onclick="attemptFix()">修復試行</button>
    <button onclick="startMonitoring()">イベント監視開始</button>
    <button onclick="stopMonitoring()">監視停止</button>
    <button onclick="clearLogs()">ログクリア</button>
    <div id="fix-output" class="output"></div>
  </div>
</div>

<script>
let monitoringActive = false;
let eventLog = [];

function log(target, message, type = 'info') {
  const output = document.getElementById(target);
  const timestamp = new Date().toLocaleTimeString();
  let color = '#d4d4d4';
  if (type === 'error') color = '#f48771';
  if (type === 'success') color = '#4ec9b0';
  if (type === 'warning') color = '#dcdcaa';
  
  output.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
  output.scrollTop = output.scrollHeight;
}

function clear(target) {
  document.getElementById(target).innerHTML = '';
}

function formatValue(val) {
  if (val === null) return '<span class="null">null</span>';
  if (val === undefined) return '<span class="null">undefined</span>';
  if (typeof val === 'boolean') return `<span class="${val}">${val}</span>`;
  if (typeof val === 'number') return `<span class="number">${val}</span>`;
  if (typeof val === 'string') return `<span class="value">"${val}"</span>`;
  if (typeof val === 'function') return '<span class="value">[Function]</span>';
  if (typeof val === 'object') return JSON.stringify(val, null, 2);
  return String(val);
}

// ===== 基本診断 =====
function diagnoseInitial() {
  clear('basic-output');
  log('basic-output', '=== 初期状態診断 ===', 'success');
  
  // DrawingEngine確認
  const de = window.drawingEngine || window.coreEngine?.drawingEngine;
  if (!de) {
    log('basic-output', '❌ DrawingEngine not found', 'error');
    return;
  }
  
  log('basic-output', '\n📍 DrawingEngine:');
  log('basic-output', `  - Instance: ${!!de ? '✅' : '❌'}`);
  log('basic-output', `  - Has settings: ${!!de.settings ? '✅' : '❌'}`);
  log('basic-output', `  - Has brushSize property: ${'brushSize' in de ? '⚠️ 古いバージョン' : '✅ 新バージョン'}`);
  log('basic-output', `  - currentTool: ${formatValue(de.currentTool)}`);
  
  if (de.settings) {
    const size = de.settings.getBrushSize?.() || de.settings.size;
    const opacity = de.settings.getBrushOpacity?.() || de.settings.opacity;
    log('basic-output', `  - settings.size: ${formatValue(size)}`);
    log('basic-output', `  - settings.opacity: ${formatValue(opacity)}`);
  }
  
  if ('brushSize' in de) {
    log('basic-output', `  - brushSize (deprecated): ${formatValue(de.brushSize)}`, 'warning');
  }
  
  // ToolSizeManager確認
  log('basic-output', '\n📍 ToolSizeManager:');
  const tsm = window.toolSizeManager;
  if (!tsm) {
    log('basic-output', '  ❌ Not found', 'error');
  } else {
    log('basic-output', `  - Instance: ✅`);
    log('basic-output', `  - currentTool: ${formatValue(tsm.currentTool)}`);
    if (tsm.toolStates) {
      log('basic-output', `  - pen.size: ${formatValue(tsm.toolStates.pen?.size)}`);
      log('basic-output', `  - pen.opacity: ${formatValue(tsm.toolStates.pen?.opacity)}`);
      log('basic-output', `  - eraser.size: ${formatValue(tsm.toolStates.eraser?.size)}`);
      log('basic-output', `  - eraser.opacity: ${formatValue(tsm.toolStates.eraser?.opacity)}`);
    }
  }
  
  // EventBus確認
  log('basic-output', '\n📍 EventBus:');
  const eb = window.TegakiEventBus;
  if (!eb) {
    log('basic-output', '  ❌ Not found', 'error');
  } else {
    log('basic-output', `  - Instance: ✅`);
    const listeners = eb.getListenerCount?.('tool:size-opacity-changed') || 0;
    log('basic-output', `  - tool:size-opacity-changed listeners: ${formatValue(listeners)}`);
  }
}

function diagnoseAfterDrag() {
  clear('basic-output');
  log('basic-output', '=== ドラッグ後診断 ===', 'success');
  log('basic-output', '👉 この診断の前に、アプリでP+ドラッグを実行してください\n');
  
  const de = window.drawingEngine || window.coreEngine?.drawingEngine;
  const tsm = window.toolSizeManager;
  
  if (!de || !tsm) {
    log('basic-output', '❌ 必要なコンポーネントが見つかりません', 'error');
    return;
  }
  
  log('basic-output', '📊 現在の値:');
  
  // ToolSizeManagerの状態
  if (tsm.toolStates?.pen) {
    log('basic-output', `\n🎨 ToolSizeManager (pen):`);
    log('basic-output', `  - size: ${formatValue(tsm.toolStates.pen.size)}`);
    log('basic-output', `  - opacity: ${formatValue(tsm.toolStates.pen.opacity)}`);
    log('basic-output', `  - startSize: ${formatValue(tsm.toolStates.pen.startSize)}`);
    log('basic-output', `  - startOpacity: ${formatValue(tsm.toolStates.pen.startOpacity)}`);
  }
  
  // BrushSettingsの状態
  if (de.settings) {
    const size = de.settings.getBrushSize?.() || de.settings.size;
    const opacity = de.settings.getBrushOpacity?.() || de.settings.opacity;
    log('basic-output', `\n🖌️ BrushSettings:`);
    log('basic-output', `  - size: ${formatValue(size)}`);
    log('basic-output', `  - opacity: ${formatValue(opacity)}`);
  }
  
  // DrawingEngineの状態（古いバージョンの場合）
  if ('brushSize' in de) {
    log('basic-output', `\n⚠️ DrawingEngine (deprecated properties):`);
    log('basic-output', `  - brushSize: ${formatValue(de.brushSize)}`);
    log('basic-output', `  - brushOpacity: ${formatValue(de.brushOpacity)}`);
  }
  
  // 整合性チェック
  log('basic-output', `\n✅ 整合性チェック:`);
  const tsmSize = tsm.toolStates?.pen?.size || 0;
  const bsSize = de.settings?.getBrushSize?.() || de.settings?.size || 0;
  const deSize = de.brushSize || bsSize;
  
  if (Math.abs(tsmSize - bsSize) < 0.01) {
    log('basic-output', `  ✅ ToolSizeManager ⇔ BrushSettings: 一致`, 'success');
  } else {
    log('basic-output', `  ❌ ToolSizeManager(${tsmSize}) ≠ BrushSettings(${bsSize})`, 'error');
  }
  
  if ('brushSize' in de && Math.abs(deSize - bsSize) > 0.01) {
    log('basic-output', `  ⚠️ DrawingEngine.brushSize(${deSize}) ≠ settings(${bsSize})`, 'warning');
    log('basic-output', `     → 古いバージョンのDrawingEngineが使用されています`, 'warning');
  }
}

function diagnoseEventFlow() {
  clear('basic-output');
  log('basic-output', '=== イベントフロー診断 ===', 'success');
  
  const eb = window.TegakiEventBus;
  if (!eb) {
    log('basic-output', '❌ EventBus not found', 'error');
    return;
  }
  
  // イベントリスナー数確認
  const events = [
    'tool:drag-size-start',
    'tool:drag-size-update',
    'tool:size-opacity-changed',
    'tool:drag-size-end',
    'brushSizeChanged',
    'brushOpacityChanged'
  ];
  
  log('basic-output', '📡 EventBus登録状況:\n');
  events.forEach(evt => {
    const count = eb.getListenerCount?.(evt) || 0;
    const status = count > 0 ? '✅' : '❌';
    log('basic-output', `  ${status} ${evt}: ${count} listeners`);
  });
  
  // DrawingEngineのイベント購読確認
  log('basic-output', '\n🔍 DrawingEngine.subscribeToSettings() 確認:');
  const de = window.drawingEngine || window.coreEngine?.drawingEngine;
  if (de) {
    const hasOldCheck = de.subscribeToSettings.toString().includes('tool === this.currentTool');
    if (hasOldCheck) {
      log('basic-output', '  ❌ 古いバージョン: ツールチェックあり（問題の原因）', 'error');
      log('basic-output', '     → tool:size-opacity-changedが条件付きで無視される', 'error');
    } else {
      log('basic-output', '  ✅ 新しいバージョン: ツールチェックなし', 'success');
    }
  }
}

// ===== 詳細診断 =====
function diagnoseDrawingEngine() {
  clear('detail-output');
  log('detail-output', '=== DrawingEngine 詳細診断 ===', 'success');
  
  const de = window.drawingEngine || window.coreEngine?.drawingEngine;
  if (!de) {
    log('detail-output', '❌ DrawingEngine not found', 'error');
    return;
  }
  
  log('detail-output', '\n📦 Properties:');
  const props = [
    'settings', 'currentTool', 'isDrawing', 'cameraSystem', 'layerManager',
    'eventBus', 'recorder', 'renderer', 'pressureHandler', 'transformer',
    'brushSize', 'brushColor', 'brushOpacity'
  ];
  
  props.forEach(prop => {
    if (prop in de) {
      const val = de[prop];
      log('detail-output', `  - ${prop}: ${formatValue(val)}`);
    }
  });
  
  log('detail-output', '\n🔧 Methods:');
  const methods = ['setBrushSize', 'setBrushOpacity', 'setTool', 'subscribeToSettings'];
  methods.forEach(method => {
    log('detail-output', `  - ${method}: ${typeof de[method] === 'function' ? '✅' : '❌'}`);
  });
  
  if (de.getDebugInfo) {
    log('detail-output', '\n📊 Debug Info:');
    try {
      const info = de.getDebugInfo();
      log('detail-output', JSON.stringify(info, null, 2));
    } catch (e) {
      log('detail-output', `  Error: ${e.message}`, 'error');
    }
  }
}

function diagnoseToolSizeManager() {
  clear('detail-output');
  log('detail-output', '=== ToolSizeManager 詳細診断 ===', 'success');
  
  const tsm = window.toolSizeManager;
  if (!tsm) {
    log('detail-output', '❌ ToolSizeManager not found', 'error');
    return;
  }
  
  log('detail-output', '\n📦 State:');
  log('detail-output', `  currentTool: ${formatValue(tsm.currentTool)}`);
  
  if (tsm.toolStates) {
    log('detail-output', '\n  toolStates:');
    Object.entries(tsm.toolStates).forEach(([tool, state]) => {
      log('detail-output', `    ${tool}:`);
      Object.entries(state).forEach(([key, val]) => {
        log('detail-output', `      ${key}: ${formatValue(val)}`);
      });
    });
  }
  
  log('detail-output', '\n⚙️ Settings:');
  log('detail-output', `  sizeSensitivity: ${formatValue(tsm.sizeSensitivity)}`);
  log('detail-output', `  opacitySensitivity: ${formatValue(tsm.opacitySensitivity)}`);
  log('detail-output', `  size range: [${tsm.sizeMin}, ${tsm.sizeMax}]`);
  log('detail-output', `  opacity range: [${tsm.opacityMin}, ${tsm.opacityMax}]`);
  
  if (tsm.getDebugInfo) {
    log('detail-output', '\n📊 Debug Info:');
    const info = tsm.getDebugInfo();
    log('detail-output', JSON.stringify(info, null, 2));
  }
}

function diagnoseBrushSettings() {
  clear('detail-output');
  log('detail-output', '=== BrushSettings 詳細診断 ===', 'success');
  
  const de = window.drawingEngine || window.coreEngine?.drawingEngine;
  const bs = de?.settings;
  
  if (!bs) {
    log('detail-output', '❌ BrushSettings not found', 'error');
    return;
  }
  
  log('detail-output', '\n📦 Current Values:');
  const props = ['size', 'color', 'opacity', 'thinning', 'smoothing', 'streamline'];
  props.forEach(prop => {
    if (prop in bs) {
      log('detail-output', `  ${prop}: ${formatValue(bs[prop])}`);
    }
  });
  
  log('detail-output', '\n🔧 Methods:');
  const getSize = bs.getBrushSize?.();
  const getOpacity = bs.getBrushOpacity?.();
  log('detail-output', `  getBrushSize(): ${formatValue(getSize)}`);
  log('detail-output', `  getBrushOpacity(): ${formatValue(getOpacity)}`);
  
  if (bs.getCurrentSettings) {
    log('detail-output', '\n📊 Full Settings:');
    const settings = bs.getCurrentSettings();
    log('detail-output', JSON.stringify(settings, null, 2));
  }
}

function diagnoseEventBus() {
  clear('detail-output');
  log('detail-output', '=== EventBus 診断 ===', 'success');
  
  const eb = window.TegakiEventBus;
  if (!eb) {
    log('detail-output', '❌ EventBus not found', 'error');
    return;
  }
  
  log('detail-output', '\n📡 All Event Listeners:');
  const eventNames = eb.getEventNames?.() || [];
  
  if (eventNames.length === 0) {
    log('detail-output', '  (no events registered)', 'warning');
  } else {
    eventNames.forEach(name => {
      const count = eb.getListenerCount(name);
      log('detail-output', `  ${name}: ${count} listener(s)`);
    });
  }
}

// ===== テスト実行 =====
function testManualSizeChange() {
  clear('test-output');
  log('test-output', '=== 手動サイズ変更テスト ===', 'success');
  
  const de = window.drawingEngine || window.coreEngine?.drawingEngine;
  if (!de?.settings) {
    log('test-output', '❌ DrawingEngine.settings not found', 'error');
    return;
  }
  
  const testSize = 25;
  const testOpacity = 0.7;
  
  log('test-output', `\n🧪 テスト実行:`);
  log('test-output', `  サイズを ${testSize} に変更...`);
  
  try {
    de.settings.setBrushSize(testSize);
    const result = de.settings.getBrushSize();
    
    if (Math.abs(result - testSize) < 0.01) {
      log('test-output', `  ✅ 成功: ${result}`, 'success');
    } else {
      log('test-output', `  ❌ 失敗: 期待${testSize}, 実際${result}`, 'error');
    }
  } catch (e) {
    log('test-output', `  ❌ エラー: ${e.message}`, 'error');
  }
  
  log('test-output', `\n  不透明度を ${testOpacity} に変更...`);
  
  try {
    de.settings.setBrushOpacity(testOpacity);
    const result = de.settings.getBrushOpacity();
    
    if (Math.abs(result - testOpacity) < 0.01) {
      log('test-output', `  ✅ 成功: ${result}`, 'success');
    } else {
      log('test-output', `  ❌ 失敗: 期待${testOpacity}, 実際${result}`, 'error');
    }
  } catch (e) {
    log('test-output', `  ❌ エラー: ${e.message}`, 'error');
  }
}

function testEventEmit() {
  clear('test-output');
  log('test-output', '=== イベント発火テスト ===', 'success');
  
  const eb = window.TegakiEventBus;
  if (!eb) {
    log('test-output', '❌ EventBus not found', 'error');
    return;
  }
  
  const testSize = 30;
  const testOpacity = 0.8;
  
  log('test-output', `\n🧪 tool:size-opacity-changed を発火...`);
  log('test-output', `  tool: pen, size: ${testSize}, opacity: ${testOpacity}`);
  
  // 発火前の値を記録
  const de = window.drawingEngine || window.coreEngine?.drawingEngine;
  const beforeSize = de?.settings?.getBrushSize() || 0;
  const beforeOpacity = de?.settings?.getBrushOpacity() || 0;
  
  log('test-output', `\n  発火前: size=${beforeSize}, opacity=${beforeOpacity}`);
  
  try {
    eb.emit('tool:size-opacity-changed', {
      tool: 'pen',
      size: testSize,
      opacity: testOpacity
    });
    
    setTimeout(() => {
      const afterSize = de?.settings?.getBrushSize() || 0;
      const afterOpacity = de?.settings?.getBrushOpacity() || 0;
      
      log('test-output', `  発火後: size=${afterSize}, opacity=${afterOpacity}`);
      
      if (Math.abs(afterSize - testSize) < 0.01 && Math.abs(afterOpacity - testOpacity) < 0.01) {
        log('test-output', `\n  ✅ イベントが正しく反映されました`, 'success');
      } else {
        log('test-output', `\n  ❌ イベントが反映されていません`, 'error');
        log('test-output', `     期待: size=${testSize}, opacity=${testOpacity}`, 'error');
        log('test-output', `     実際: size=${afterSize}, opacity=${afterOpacity}`, 'error');
      }
    }, 100);
  } catch (e) {
    log('test-output', `  ❌ エラー: ${e.message}`, 'error');
  }
}

function simulateDrag() {
  clear('test-output');
  log('test-output', '=== ドラッグシミュレーション ===', 'success');
  
  const eb = window.TegakiEventBus;
  const tsm = window.toolSizeManager;
  const de = window.drawingEngine || window.coreEngine?.drawingEngine;
  
  if (!eb || !tsm || !de) {
    log('test-output', '❌ 必要なコンポーネントが見つかりません', 'error');
    return;
  }
  
  const startSize = de.settings?.getBrushSize() || 10;
  const startOpacity = de.settings?.getBrushOpacity() || 0.85;
  
  log('test-output', `\n🎬 シミュレーション開始:`);
  log('test-output', `  初期値: size=${startSize}, opacity=${startOpacity}`);
  
  // 1. drag-start
  log('test-output', `\n  1️⃣ tool:drag-size-start 発火...`);
  eb.emit('tool:drag-size-start', {
    tool: 'pen',
    startSize,
    startOpacity
  });
  
  setTimeout(() => {
    // 2. drag-update (右に50px、上に30px移動)
    log('test-output', `  2️⃣ tool:drag-size-update 発火 (deltaX=50, deltaY=-30)...`);
    eb.emit('tool:drag-size-update', {
      tool: 'pen',
      deltaX: 50,
      deltaY: -30
    });
    
    setTimeout(() => {
      const afterSize = de.settings?.getBrushSize() || 0;
      const afterOpacity = de.settings?.getBrushOpacity() || 0;
      
      log('test-output', `\n  📊 結果:`);
      log('test-output', `    size: ${startSize} → ${afterSize}`);
      log('test-output', `    opacity: ${startOpacity} → ${afterOpacity}`);
      
      const expectedSize = startSize + 50 * (tsm.sizeSensitivity || 0.1);
      const expectedOpacity = startOpacity - (-30) * (tsm.opacitySensitivity || 0.005);
      
      log('test-output', `\n  期待値:`);
      log('test-output', `    size: ${expectedSize.toFixed(2)}`);
      log('test-output', `    opacity: ${expectedOpacity.toFixed(3)}`);
      
      if (Math.abs(afterSize - expectedSize) < 0.5 && Math.abs(afterOpacity - expectedOpacity) < 0.01) {
        log('test-output', `\n  ✅ シミュレーション成功`, 'success');
      } else {
        log('test-output', `\n  ❌ 期待値と異なります`, 'error');
      }
      
      // 3. drag-end
      setTimeout(() => {
        log('test-output', `\n  3️⃣ tool:drag-size-end 発火...`);
        eb.emit('tool:drag-size-end');
      }, 100);
    }, 100);
  }, 100);
}

// ===== 修復・監視 =====
function attemptFix() {
  clear('fix-output');
  log('fix-output', '=== 修復試行 ===', 'success');
  
  const de = window.drawingEngine || window.coreEngine?.drawingEngine;
  
  if (!de) {
    log('fix-output', '❌ DrawingEngine not found', 'error');
    return;
  }
  
  log('fix-output', '\n🔧 問題のチェック...\n');
  
  // 問題1: 古いbrushSizeプロパティが残っている
  if ('brushSize' in de) {
    log('fix-output', '⚠️ 問題1: DrawingEngine.brushSize (deprecated) が存在', 'warning');
    log('fix-output', '  → 新しいDrawingEngineに差し替えが必要です', 'warning');
    log('fix-output', '  → artifactの修正版を使用してください\n');
  } else {
    log('fix-output', '✅ 問題1: なし (新しいバージョン)\n', 'success');
  }
  
  // 問題2: subscribeToSettingsにツールチェックが残っている
  if (de.subscribeToSettings) {
    const source = de.subscribeToSettings.toString();
    if (source.includes('tool === this.currentTool')) {
      log('fix-output', '❌ 問題2: subscribeToSettings にツールチェックあり', 'error');
      log('fix-output', '  → これが原因でP/E+ドラッグが反映されません', 'error');
      log('fix-output', '  → artifactの修正版を使用してください\n');
    } else {
      log('fix-output', '✅ 問題2: なし (ツールチェック削除済み)\n', 'success');
    }
  }
  
  // 問題3: ToolSizeManagerの状態が更新されていない
  const tsm = window.toolSizeManager;
  if (tsm && tsm.toolStates) {
    const penSize = tsm.toolStates.pen?.size || 0;
    const bsSize = de.settings?.getBrushSize() || 0;
    
    if (Math.abs(penSize - bsSize) > 1) {
      log('fix-output', '⚠️ 問題3: ToolSizeManager と BrushSettings が不一致', 'warning');
      log('fix-output', `  ToolSizeManager.pen.size: ${penSize}`, 'warning');
      log('fix-output', `  BrushSettings.size: ${bsSize}`, 'warning');
      log('fix-output', '\n  🔧 同期を試みます...');
      
      try {
        tsm.toolStates.pen.size = bsSize;
        tsm.toolStates.pen.opacity = de.settings.getBrushOpacity();
        log('fix-output', '  ✅ 同期完了\n', 'success');
      } catch (e) {
        log('fix-output', `  ❌ 同期失敗: ${e.message}\n`, 'error');
      }
    } else {
      log('fix-output', '✅ 問題3: なし (値が一致)\n', 'success');
    }
  }
  
  // 問題4: EventBusリスナー不足
  const eb = window.TegakiEventBus;
  if (eb) {
    const listeners = eb.getListenerCount?.('tool:size-opacity-changed') || 0;
    if (listeners === 0) {
      log('fix-output', '❌ 問題4: tool:size-opacity-changed のリスナーなし', 'error');
      log('fix-output', '  → DrawingEngineが正しく初期化されていません\n', 'error');
    } else {
      log('fix-output', `✅ 問題4: なし (${listeners} listeners)\n`, 'success');
    }
  }
  
  log('fix-output', '\n📋 修復サマリー:');
  log('fix-output', '  DrawingEngineが古いバージョンの場合:');
  log('fix-output', '  1. artifactの修正版をダウンロード');
  log('fix-output', '  2. system/drawing/drawing-engine.js を差し替え');
  log('fix-output', '  3. ページをリロード');
}

let monitorListeners = [];

function startMonitoring() {
  if (monitoringActive) {
    log('fix-output', '⚠️ 既に監視中です', 'warning');
    return;
  }
  
  clear('fix-output');
  log('fix-output', '=== イベント監視開始 ===', 'success');
  log('fix-output', '👉 アプリでP+ドラッグを実行してください\n');
  
  const eb = window.TegakiEventBus;
  if (!eb) {
    log('fix-output', '❌ EventBus not found', 'error');
    return;
  }
  
  monitoringActive = true;
  eventLog = [];
  
  const events = [
    'tool:drag-size-start',
    'tool:drag-size-update',
    'tool:size-opacity-changed',
    'tool:drag-size-end',
    'brushSizeChanged',
    'brushOpacityChanged'
  ];
  
  events.forEach(eventName => {
    const listener = (data) => {
      const timestamp = new Date().toLocaleTimeString() + '.' + new Date().getMilliseconds();
      const logEntry = {
        time: timestamp,
        event: eventName,
        data: data
      };
      eventLog.push(logEntry);
      
      log('fix-output', `[${timestamp}] 📡 ${eventName}`);
      if (data) {
        Object.entries(data).forEach(([key, val]) => {
          log('fix-output', `    ${key}: ${formatValue(val)}`);
        });
      }
      
      // BrushSettingsの現在値も表示
      if (eventName === 'tool:size-opacity-changed' || eventName === 'brushSizeChanged' || eventName === 'brushOpacityChanged') {
        const de = window.drawingEngine || window.coreEngine?.drawingEngine;
        if (de?.settings) {
          const size = de.settings.getBrushSize();
          const opacity = de.settings.getBrushOpacity();
          log('fix-output', `    → 反映後: size=${size}, opacity=${opacity}`, 'success');
        }
      }
    };
    
    eb.on(eventName, listener);
    monitorListeners.push({ event: eventName, listener });
  });
  
  log('fix-output', `\n✅ 監視中... (${events.length} events)`, 'success');
}

function stopMonitoring() {
  if (!monitoringActive) {
    log('fix-output', '⚠️ 監視していません', 'warning');
    return;
  }
  
  const eb = window.TegakiEventBus;
  if (eb) {
    monitorListeners.forEach(({ event, listener }) => {
      eb.off(event, listener);
    });
  }
  
  monitorListeners = [];
  monitoringActive = false;
  
  log('fix-output', `\n✅ 監視停止 (${eventLog.length} events recorded)`, 'success');
  
  if (eventLog.length > 0) {
    log('fix-output', '\n📊 イベントサマリー:');
    const summary = {};
    eventLog.forEach(entry => {
      summary[entry.event] = (summary[entry.event] || 0) + 1;
    });
    Object.entries(summary).forEach(([evt, count]) => {
      log('fix-output', `  ${evt}: ${count}回`);
    });
  }
}

function clearLogs() {
  ['basic-output', 'detail-output', 'test-output', 'fix-output'].forEach(id => {
    clear(id);
  });
  eventLog = [];
}

// 初期メッセージ
window.addEventListener('DOMContentLoaded', () => {
  log('basic-output', '診断ツール準備完了', 'success');
  log('basic-output', '「初期状態診断」ボタンをクリックして開始してください');
});
</script>
</body>
</html>