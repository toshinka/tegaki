import { Ticker, utils } from '@pixi/core';
import { Container } from '@pixi/display';
import { Graphics } from '@pixi/graphics';
import { List } from './List.mjs';
import { Trackpad } from './utils/trackpad/Trackpad.mjs';
import { Signal } from 'typed-signals';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ScrollBox extends Container {
  /**
   * @param options
   * @param {number} options.background - background color of the ScrollBox.
   * @param {number} options.width - width of the ScrollBox.
   * @param {number} options.height - height of the ScrollBox.
   * @param {number} options.radius - radius of the ScrollBox and its masks corners.
   * @param {number} options.elementsMargin - margin between elements.
   * @param {number} options.vertPadding - vertical padding of the ScrollBox.
   * @param {number} options.horPadding - horizontal padding of the ScrollBox.
   * @param {number} options.padding - padding of the ScrollBox (same horizontal and vertical).
   * @param {boolean} options.disableDynamicRendering - disables dynamic rendering of the ScrollBox,
   * so even elements the are not visible will be rendered. Be careful with this options as it can impact performance.
   * @param {boolean} [options.globalScroll=true] - if true, the ScrollBox will scroll even if the mouse is not over it.
   * @param {boolean} [options.shiftScroll=false] - if true, the ScrollBox will only scroll horizontally if the shift key
   * is pressed, and the type is set to 'horizontal'.
   */
  constructor(options) {
    super();
    __publicField(this, "background");
    __publicField(this, "borderMask");
    __publicField(this, "lastWidth");
    __publicField(this, "lastHeight");
    __publicField(this, "__width", 0);
    __publicField(this, "__height", 0);
    __publicField(this, "_dimensionChanged", false);
    __publicField(this, "list");
    __publicField(this, "_trackpad");
    __publicField(this, "isDragging", 0);
    __publicField(this, "interactiveStorage", []);
    __publicField(this, "visibleItems", []);
    __publicField(this, "pressedChild");
    __publicField(this, "ticker", Ticker.shared);
    __publicField(this, "options");
    __publicField(this, "stopRenderHiddenItemsTimeout");
    __publicField(this, "onMouseScrollBinding", this.onMouseScroll.bind(this));
    __publicField(this, "dragStarTouchPoint");
    __publicField(this, "isOver", false);
    __publicField(this, "proximityRange");
    __publicField(this, "proximityStatusCache", []);
    __publicField(this, "lastScrollX");
    __publicField(this, "lastScrollY");
    __publicField(this, "proximityCheckFrameCounter", 0);
    __publicField(this, "onProximityChange", new Signal());
    __publicField(this, "onScroll", new Signal());
    if (options) {
      this.init(options);
    }
    this.ticker.add(this.update, this);
  }
  /**
   * Initiates ScrollBox.
   * @param options
   * @param {number} options.background - background color of the ScrollBox.
   * @param {number} options.width - width of the ScrollBox.
   * @param {number} options.height - height of the ScrollBox.
   * @param {number} options.radius - radius of the ScrollBox and its masks corners.
   * @param {number} options.elementsMargin - margin between elements.
   * @param {number} options.vertPadding - vertical padding of the ScrollBox.
   * @param {number} options.horPadding - horizontal padding of the ScrollBox.
   * @param {number} options.padding - padding of the ScrollBox (same horizontal and vertical).
   * @param {boolean} options.disableDynamicRendering - disables dynamic rendering of the ScrollBox,
   * so even elements the are not visible will be rendered. Be careful with this options as it can impact performance.
   * @param {boolean} [options.globalScroll=true] - if true, the ScrollBox will scroll even if the mouse is not over it.
   * @param {boolean} [options.shiftScroll=false] - if true, the ScrollBox will only scroll horizontally if the shift key
   */
  init(options) {
    this.options = options;
    this.setBackground(options.background);
    this.__width = options.width | this.background.width;
    this.__height = options.height | this.background.height;
    this.proximityRange = options.proximityRange ?? 0;
    if (!this.list) {
      this.list = new List();
      super.addChild(this.list);
    }
    this.list.init({
      type: options.type,
      elementsMargin: options.elementsMargin,
      padding: options.padding,
      vertPadding: options.vertPadding,
      horPadding: options.horPadding,
      topPadding: options.topPadding,
      bottomPadding: options.bottomPadding,
      leftPadding: options.leftPadding,
      rightPadding: options.rightPadding
    });
    this.addItems(options.items);
    if (this.hasBounds) {
      this.addMask();
      this.makeScrollable();
    }
    this._trackpad.xAxis.value = 0;
    this._trackpad.yAxis.value = 0;
    this.options.globalScroll = options.globalScroll ?? true;
    this.options.shiftScroll = options.shiftScroll ?? false;
    this.resize();
  }
  get hasBounds() {
    return !!this.__width || !!this.__height;
  }
  onChildrenChange() {
  }
  /**
   *  Adds array of items to a scrollable list.
   * @param {Container[]} items - items to add.
   */
  addItems(items) {
    if (!items?.length)
      return;
    items.forEach((item) => this.addItem(item));
  }
  /** Remove all items from a scrollable list. */
  removeItems() {
    this.proximityStatusCache.length = 0;
    this.list.removeChildren();
  }
  /**
   * Adds one or more items to a scrollable list.
   * @param {Container} items - one or more items to add.
   */
  addItem(...items) {
    if (items.length > 1) {
      items.forEach((item) => this.addItem(item));
    } else {
      const child = items[0];
      if (!child.width || !child.height) {
        console.error("ScrollBox item should have size");
      }
      child.eventMode = "static";
      this.list.addChild(child);
      this.proximityStatusCache.push(false);
      if (!this.options.disableDynamicRendering) {
        child.renderable = this.isItemVisible(child);
      }
    }
    this.resize();
    return items[0];
  }
  /**
   * Removes an item from a scrollable list.
   * @param {number} itemID - id of the item to remove.
   */
  removeItem(itemID) {
    this.list.removeItem(itemID);
    this.proximityStatusCache.splice(itemID, 1);
    this.resize();
  }
  /**
   * Checks if the item is visible or scrolled out of the visible part of the view.* Adds an item to a scrollable list.
   * @param {Container} item - item to check.
   * @param padding - proximity padding to consider the item visible.
   */
  isItemVisible(item, padding = 0) {
    const isVertical = this.options.type === "vertical" || !this.options.type;
    let isVisible = false;
    const list = this.list;
    if (isVertical) {
      const posY = item.y + list.y;
      if (posY + item.height >= -padding && posY <= this.options.height + padding) {
        isVisible = true;
      }
    } else {
      const posX = item.x + list.x;
      if (posX + item.width >= -padding && posX <= this.options.width + padding) {
        isVisible = true;
      }
    }
    return isVisible;
  }
  /**
   * Returns all inner items in a list.
   * @returns {Array<Container> | Array} - list of items.
   */
  get items() {
    return this.list?.children ?? [];
  }
  /**
   * Set ScrollBox background.
   * @param {number | string} background - background color or texture.
   */
  setBackground(background) {
    if (this.background) {
      this.removeChild(this.background);
    }
    this.options.background = background;
    this.background = new Graphics();
    this.addChildAt(this.background, 0);
    this.resize();
  }
  addMask() {
    if (!this.borderMask) {
      this.borderMask = new Graphics();
      super.addChild(this.borderMask);
      this.mask = this.borderMask;
    }
    this.resize();
  }
  makeScrollable() {
    if (!this._trackpad) {
      this._trackpad = new Trackpad({
        disableEasing: this.options.disableEasing
      });
    }
    this.on("pointerdown", (e) => {
      this.renderAllItems();
      this.isDragging = 1;
      this.dragStarTouchPoint = this.worldTransform.applyInverse(e.global);
      this._trackpad.pointerDown(this.dragStarTouchPoint);
      const listTouchPoint = this.list.worldTransform.applyInverse(e.global);
      this.visibleItems.forEach((item) => {
        if (item.x < listTouchPoint.x && item.x + item.width > listTouchPoint.x && item.y < listTouchPoint.y && item.y + item.height > listTouchPoint.y) {
          this.pressedChild = item;
        }
      });
    });
    this.on("pointerup", () => {
      this.isDragging = 0;
      this._trackpad.pointerUp();
      this.restoreItemsInteractivity();
      this.pressedChild = null;
      this.stopRenderHiddenItems();
    });
    this.on("pointerover", () => {
      this.isOver = true;
    });
    this.on("pointerout", () => {
      this.isOver = false;
    });
    this.on("pointerupoutside", () => {
      this.isDragging = 0;
      this._trackpad.pointerUp();
      this.restoreItemsInteractivity();
      this.pressedChild = null;
      this.stopRenderHiddenItems();
    });
    this.on("globalpointermove", (e) => {
      if (!this.isDragging)
        return;
      const isVertical = this.options.type !== "horizontal";
      const touchPoint = this.worldTransform.applyInverse(e.global);
      if (this.dragStarTouchPoint) {
        const dragTrashHold = this.options.dragTrashHold ?? 10;
        if (this.options.type === "horizontal") {
          const xDist = touchPoint.x - this.dragStarTouchPoint.x;
          if (Math.abs(xDist) > dragTrashHold) {
            this.isDragging = 2;
          }
        } else {
          const yDist = touchPoint.y - this.dragStarTouchPoint.y;
          if (Math.abs(yDist) > dragTrashHold) {
            this.isDragging = 2;
          }
        }
      }
      if (this.dragStarTouchPoint && this.isDragging !== 2)
        return;
      this._trackpad.pointerMove(touchPoint);
      if (this.pressedChild) {
        this.revertClick(this.pressedChild);
        this.pressedChild = null;
      }
      this.onScroll?.emit(isVertical ? this.scrollY : this.scrollX);
    });
    document.addEventListener("wheel", this.onMouseScrollBinding, true);
  }
  setInteractive(interactive) {
    this.eventMode = interactive ? "static" : "auto";
  }
  get listHeight() {
    return this.list.height + this.list.topPadding + this.list.bottomPadding;
  }
  get listWidth() {
    return this.list.width + this.list.leftPadding + this.list.rightPadding;
  }
  /**
   * Controls item positions and visibility.
   * @param force
   */
  resize(force = false) {
    if (!this.hasBounds)
      return;
    this.renderAllItems();
    if (this.borderMask && (force || this._dimensionChanged || this.lastWidth !== this.listWidth || this.lastHeight !== this.listHeight)) {
      if (!this.options.width) {
        this.__width += this.listWidth;
      }
      if (!this.options.height) {
        this.__height += this.listHeight;
      }
      this.borderMask.clear().lineStyle(0).beginFill(16777215).drawRoundedRect(
        0,
        0,
        this.__width,
        this.__height,
        this.options.radius | 0
      );
      this.borderMask.eventMode = "none";
      this.background.clear().lineStyle(0);
      const color = this.options.background;
      this.background.beginFill(
        color ?? 0,
        color ? 1 : 1e-7
        // if color is not set, set alpha to 0 to be able to drag by click on bg
      );
      this.background.drawRoundedRect(
        0,
        0,
        this.__width,
        this.__height,
        this.options.radius | 0
      );
      if (this.options.type === "horizontal") {
        this.setInteractive(this.listWidth > this.__width);
      } else {
        this.setInteractive(this.listHeight > this.__height);
      }
      this.lastWidth = this.listWidth;
      this.lastHeight = this.listHeight;
    }
    if (this._trackpad) {
      const maxWidth = this.borderMask.width - this.list.width - this.list.leftPadding - this.list.rightPadding;
      const maxHeight = this.borderMask.height - this.list.height - this.list.topPadding - this.list.bottomPadding;
      if (this.options.type === "vertical") {
        this._trackpad.yAxis.max = -Math.abs(maxHeight);
      } else if (this.options.type === "horizontal") {
        this._trackpad.xAxis.max = -Math.abs(maxWidth);
      } else {
        this._trackpad.yAxis.max = -Math.abs(maxHeight);
        this._trackpad.xAxis.max = -Math.abs(maxWidth);
      }
    }
    if (this._dimensionChanged) {
      this.list.arrangeChildren();
      this.stopRenderHiddenItems();
      this._dimensionChanged = false;
    } else
      this.updateVisibleItems();
    this.lastScrollX = null;
    this.lastScrollY = null;
  }
  onMouseScroll(event) {
    if (!this.isOver && !this.options.globalScroll)
      return;
    this.renderAllItems();
    const scrollOnX = this.options.shiftScroll ? typeof event.deltaX !== "undefined" || typeof event.deltaY !== "undefined" : typeof event.deltaX !== "undefined";
    if (this.options.type === "horizontal" && scrollOnX) {
      const delta = this.options.shiftScroll ? event.deltaX : event.deltaY;
      const targetPos = this.list.x - delta;
      if (this.listWidth < this.__width) {
        this._trackpad.xAxis.value = 0;
      } else {
        const min = this.__width - this.listWidth;
        const max = 0;
        this._trackpad.xAxis.value = Math.min(max, Math.max(min, targetPos));
      }
      this.onScroll?.emit(this._trackpad.xAxis.value);
    } else if (typeof event.deltaY !== "undefined") {
      const targetPos = this.list.y - event.deltaY;
      if (this.listHeight < this.__height) {
        this._trackpad.yAxis.value = 0;
      } else {
        const min = this.__height - this.listHeight;
        const max = 0;
        this._trackpad.yAxis.value = Math.min(max, Math.max(min, targetPos));
      }
      this.onScroll?.emit(this._trackpad.yAxis.value);
    }
    this.stopRenderHiddenItems();
  }
  /** Makes it scroll down to the last element. */
  scrollBottom() {
    if (!this.interactive) {
      this.scrollTop();
    } else {
      this.scrollTo(this.list.children.length - 1);
    }
  }
  /** Makes it scroll up to the first element. */
  scrollTop() {
    this.renderAllItems();
    this._trackpad.xAxis.value = 0;
    this._trackpad.yAxis.value = 0;
    this.stopRenderHiddenItems();
  }
  renderAllItems() {
    clearTimeout(this.stopRenderHiddenItemsTimeout);
    this.stopRenderHiddenItemsTimeout = null;
    if (this.options.disableDynamicRendering) {
      return;
    }
    this.items.forEach((child) => {
      child.renderable = true;
    });
  }
  stopRenderHiddenItems() {
    if (this.options.disableDynamicRendering) {
      return;
    }
    if (this.stopRenderHiddenItemsTimeout) {
      clearTimeout(this.stopRenderHiddenItemsTimeout);
      this.stopRenderHiddenItemsTimeout = null;
    }
    this.stopRenderHiddenItemsTimeout = setTimeout(() => this.updateVisibleItems(), 2e3);
  }
  updateVisibleItems() {
    this.visibleItems.length = 0;
    this.items.forEach((child) => {
      child.renderable = this.isItemVisible(child);
      this.visibleItems.push(child);
    });
  }
  /**
   * Scrolls to the element with the given ID.
   * @param elementID
   */
  scrollTo(elementID) {
    if (!this.interactive) {
      return;
    }
    const target = this.list.children[elementID];
    if (!target) {
      return;
    }
    this.renderAllItems();
    this._trackpad.xAxis.value = this.options.type === "horizontal" ? this.__width - target.x - target.width - this.list.rightPadding : 0;
    this._trackpad.yAxis.value = !this.options.type || this.options.type === "vertical" ? this.__height - target.y - target.height - this.list.bottomPadding : 0;
    this.stopRenderHiddenItems();
  }
  /**
   * Scrolls to the given position.
   * @param position - x and y position object.
   * @param position.x - x position.
   * @param position.y - y position.
   */
  scrollToPosition({ x, y }) {
    if (x === void 0 && y === void 0)
      return;
    this.renderAllItems();
    if (x !== void 0)
      this.scrollX = -x;
    if (y !== void 0)
      this.scrollY = -y;
    this.stopRenderHiddenItems();
  }
  /** Gets component height. */
  get height() {
    return this.__height;
  }
  set height(value) {
    this.__height = value;
    this._dimensionChanged = true;
    this.resize();
    this.scrollTop();
  }
  /** Gets component width. */
  get width() {
    return this.__width;
  }
  set width(value) {
    this.__width = value;
    this._dimensionChanged = true;
    this.resize();
    this.scrollTop();
  }
  /** Gets the current raw scroll position on the x-axis (Negated Value). */
  get scrollX() {
    return this._trackpad.xAxis.value;
  }
  /** Sets the current raw scroll position on the x-axis (Negated Value). */
  set scrollX(value) {
    this._trackpad.xAxis.value = value;
  }
  /** Gets the current raw scroll position on the y-axis (Negated Value). */
  get scrollY() {
    return this._trackpad.yAxis.value;
  }
  /** Sets the current raw scroll position on the y-axis (Negated Value). */
  set scrollY(value) {
    this._trackpad.yAxis.value = value;
  }
  update() {
    if (!this.list)
      return;
    this._trackpad.update();
    const type = this.options.type === "horizontal" ? "x" : "y";
    if (this.list[type] !== this._trackpad[type]) {
      this.list[type] = this._trackpad[type];
    }
    if (!this.options.disableProximityCheck && (this._trackpad.x !== this.lastScrollX || this._trackpad.y !== this.lastScrollY)) {
      this.proximityCheckFrameCounter++;
      if (this.proximityCheckFrameCounter >= (this.options.proximityDebounce ?? 10)) {
        this.items.forEach((item, index) => {
          const inRange = this.isItemVisible(item, this.proximityRange);
          const wasInRange = this.proximityStatusCache[index];
          if (inRange !== wasInRange) {
            this.proximityStatusCache[index] = inRange;
            this.onProximityChange.emit({ item, index, inRange });
          }
        });
        this.lastScrollX = this._trackpad.x;
        this.lastScrollY = this._trackpad.y;
        this.proximityCheckFrameCounter = 0;
      }
    }
  }
  /**
   * Destroys the component.
   * @param {boolean | IDestroyOptions} [options] - Options parameter.
   * A boolean will act as if all options have been set to that value
   */
  destroy(options) {
    this.ticker.remove(this.update, this);
    document.removeEventListener("wheel", this.onMouseScrollBinding, true);
    this.background.destroy();
    this.list.destroy();
    super.destroy(options);
  }
  restoreItemsInteractivity() {
    this.interactiveStorage.forEach((element) => {
      element.item.eventMode = element.eventMode;
    });
    this.interactiveStorage.length = 0;
  }
  revertClick(item) {
    if (item.eventMode !== "auto") {
      utils.isMobile.any ? item.emit("pointerupoutside", null) : item.emit("mouseupoutside", null);
      this.interactiveStorage.push({
        item,
        eventMode: item.eventMode
      });
      item.eventMode = "auto";
    }
    if (item instanceof Container && item.children) {
      item.children.forEach((child) => this.revertClick(child));
    }
  }
  get scrollHeight() {
    return this.list.height;
  }
  get scrollWidth() {
    return this.list.width;
  }
}

export { ScrollBox };
//# sourceMappingURL=ScrollBox.mjs.map
