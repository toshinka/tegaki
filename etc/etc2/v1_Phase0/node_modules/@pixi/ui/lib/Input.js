'use strict';

var core = require('@pixi/core');
var display = require('@pixi/display');
var graphics = require('@pixi/graphics');
var meshExtras = require('@pixi/mesh-extras');
var sprite = require('@pixi/sprite');
var text = require('@pixi/text');
var typedSignals = require('typed-signals');
var view = require('./utils/helpers/view.js');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const SECURE_CHARACTER = "*";
class Input extends display.Container {
  /**
   * Creates an input.
   * @param { number } options - Options object to use.
   * @param { Sprite | Graphics | Texture | string } options.bg - Background of the Input.
   * @param { Partial<TextStyle> } options.textStyle - Text style of the Input.
   * @param { string } options.placeholder - Placeholder of the Input.
   * @param { string } options.value - Value of the Input.
   * @param { number } options.maxLength - Max length of the Input.
   * @param { 'left' | 'center' | 'right' } options.align - Align of the Input.
   * @param { Padding } options.padding - Padding of the Input.
   * @param { number } options.padding.top - Top padding of the Input.
   * @param { number } options.padding.right - Right padding of the Input.
   * @param { number } options.padding.bottom - Bottom padding of the Input.
   * @param { number } options.padding.left - Left padding of the Input.
   * @param { boolean } options.cleanOnFocus - Clean Input on focus.
   * @param { Array } options.nineSlicePlane - NineSlicePlane values for bg and fill ([number, number, number, number]).
   */
  constructor(options) {
    super();
    __publicField(this, "_bg");
    __publicField(this, "inputMask");
    __publicField(this, "_cursor");
    __publicField(this, "_value", "");
    __publicField(this, "_secure");
    __publicField(this, "inputField");
    __publicField(this, "placeholder");
    __publicField(this, "editing", false);
    __publicField(this, "tick", 0);
    __publicField(this, "lastInputData");
    __publicField(this, "activation", false);
    __publicField(this, "options");
    __publicField(this, "input");
    __publicField(this, "handleActivationBinding", this.handleActivation.bind(this));
    __publicField(this, "onKeyUpBinding", this.onKeyUp.bind(this));
    __publicField(this, "stopEditingBinding", this.stopEditing.bind(this));
    __publicField(this, "onInputBinding", this.onInput.bind(this));
    __publicField(this, "onPasteBinding", this.onPaste.bind(this));
    /** Fires when input loses focus. */
    __publicField(this, "onEnter");
    /** Fires every time input string is changed. */
    __publicField(this, "onChange");
    /** Top side padding */
    __publicField(this, "paddingTop", 0);
    /** Right side padding */
    __publicField(this, "paddingRight", 0);
    /** Bottom side padding */
    __publicField(this, "paddingBottom", 0);
    /** Left side padding */
    __publicField(this, "paddingLeft", 0);
    this.options = options;
    this.options = options;
    this.padding = options.padding;
    this._secure = options.secure ?? false;
    this.cursor = "text";
    this.eventMode = "static";
    this.on("pointertap", () => {
      this.activation = true;
      core.utils.isMobile.any && this.handleActivation();
    });
    window.addEventListener(core.isMobile.any ? "touchstart" : "click", this.handleActivationBinding);
    this.onEnter = new typedSignals.Signal();
    this.onChange = new typedSignals.Signal();
    core.Ticker.shared.add((delta) => this.update(delta));
    if (options.bg) {
      this.bg = options.bg;
    } else {
      console.error("Input: bg is not defined, please define it.");
    }
  }
  onInput(e) {
    this.lastInputData = e.data;
  }
  onKeyUp(e) {
    const key = e.key;
    const keysToSkip = [
      "Shift",
      "Control",
      "Alt",
      "Meta",
      "ArrowLeft",
      "ArrowRight",
      "ArrowUp",
      "ArrowDown",
      "CapsLock",
      "AltGraph",
      "Tab",
      "ContextMenu",
      "F1",
      "F2",
      "F3",
      "F4",
      "F5",
      "F6",
      "F7",
      "F8",
      "F9",
      "F10",
      "F11",
      "F12",
      "ScrollLock",
      "Pause",
      "Insert",
      "Delete",
      "Home",
      "End",
      "PageUp",
      "PageDown",
      "NumLock",
      "Dead"
    ];
    if (keysToSkip.includes(key))
      return;
    if (e.metaKey)
      return;
    if (e.ctrlKey)
      return;
    if (key === "Backspace") {
      this._delete();
    } else if (key === "Escape" || key === "Enter") {
      this.stopEditing();
    } else if (key.length === 1) {
      this._add(key);
    } else if (this.lastInputData && this.lastInputData.length === 1) {
      this._add(this.lastInputData);
    }
    if (this.input) {
      this.input.value = "";
    }
  }
  init() {
    const options = this.options;
    const defaultTextStyle = {
      fill: 0,
      align: "center"
    };
    this.options.textStyle = options.textStyle ?? defaultTextStyle;
    this.options.TextClass = options.TextClass ?? text.Text;
    const textStyle = { ...defaultTextStyle, ...options.textStyle };
    this.inputField = new this.options.TextClass("", textStyle);
    this._cursor = new sprite.Sprite(core.Texture.WHITE);
    if ("tint" in options.textStyle) {
      this._cursor.tint = options.textStyle.tint;
    } else if ("fill" in options.textStyle) {
      const fill = options.textStyle.fill;
      this._cursor.tint = typeof fill === "string" || typeof fill === "number" ? fill : 0;
    } else {
      this._cursor.tint = 0;
    }
    this._cursor.anchor.set(0.5);
    this._cursor.width = 2;
    this._cursor.height = this.inputField.height * 0.8;
    this._cursor.alpha = 0;
    this.placeholder = new this.options.TextClass(options.placeholder, textStyle ?? defaultTextStyle);
    this.placeholder.visible = !!options.placeholder;
    this.addChild(this.inputField, this.placeholder, this._cursor);
    this.value = options.value ?? "";
    this.align();
  }
  set bg(bg) {
    if (this._bg) {
      this._bg.destroy();
    }
    if (this.options?.nineSlicePlane) {
      if (typeof bg === "string") {
        this._bg = new meshExtras.NineSlicePlane(core.Texture.from(bg), ...this.options.nineSlicePlane);
      } else if (bg instanceof core.Texture) {
        this._bg = new meshExtras.NineSlicePlane(bg, ...this.options.nineSlicePlane);
      } else {
        console.warn("NineSlicePlane can not be used with views set as Container.");
      }
    }
    if (!this._bg) {
      this._bg = view.getView(bg);
    }
    this._bg.cursor = "text";
    this._bg.eventMode = "static";
    this.addChildAt(this._bg, 0);
    if (!this.inputField) {
      this.init();
    }
    this.createInputMask(bg);
  }
  get bg() {
    return this._bg;
  }
  _add(key) {
    if (!this.editing) {
      return;
    }
    if (this.options.maxLength && this.value.length >= this.options.maxLength) {
      return;
    }
    this.value = this.value + key;
    this.onChange.emit(this.value);
  }
  _delete() {
    const length = this.value.length;
    if (!this.editing || length === 0)
      return;
    this.value = this.value.substring(0, length - 1);
    this.onChange.emit(this.value);
  }
  _startEditing() {
    if (this.options.cleanOnFocus) {
      this.value = "";
    }
    this.tick = 0;
    this.editing = true;
    this.placeholder.visible = false;
    this._cursor.alpha = 1;
    this.createInputField();
    this.align();
  }
  createInputField() {
    if (this.input) {
      this.input.removeEventListener("blur", this.stopEditingBinding);
      this.input.removeEventListener("keydown", this.onKeyUpBinding);
      this.input.removeEventListener("input", this.onInputBinding);
      this.input.removeEventListener("paste", this.onPasteBinding);
      this.input?.blur();
      this.input?.remove();
      this.input = null;
    }
    const input = document.createElement("input");
    document.body.appendChild(input);
    input.style.position = "fixed";
    input.style.left = `${this.getGlobalPosition().x}px`;
    input.style.top = `${this.getGlobalPosition().y}px`;
    input.style.opacity = "0.0000001";
    input.style.width = `${this._bg.width}px`;
    input.style.height = `${this._bg.height}px`;
    input.style.border = "none";
    input.style.outline = "none";
    input.style.background = "white";
    if (core.utils.isMobile.android.device) {
      setTimeout(() => {
        input.focus();
        input.click();
      }, 100);
    } else {
      input.focus();
      input.click();
    }
    input.addEventListener("blur", this.stopEditingBinding);
    input.addEventListener("keydown", this.onKeyUpBinding);
    input.addEventListener("input", this.onInputBinding);
    input.addEventListener("paste", this.onPasteBinding);
    this.input = input;
    this.align();
  }
  handleActivation() {
    if (this.editing)
      return;
    this.stopEditing();
    if (this.activation) {
      this._startEditing();
      this.activation = false;
    }
  }
  stopEditing() {
    if (!this.editing)
      return;
    this._cursor.alpha = 0;
    this.editing = false;
    if (this.inputField.text === "") {
      this.placeholder.visible = true;
    }
    if (this.value.length === 0)
      this.placeholder.visible = true;
    this.input?.blur();
    this.input?.remove();
    this.input = null;
    this.align();
    this.onEnter.emit(this.value);
  }
  update(dt) {
    if (!this.editing)
      return;
    this.tick += dt * 0.1;
    this._cursor.alpha = Math.round(Math.sin(this.tick) * 0.5 + 0.5);
  }
  align() {
    if (!this._bg)
      return;
    const align = this.getAlign();
    this.inputField.anchor.set(align, 0.5);
    this.inputField.x = this._bg.width * align + (align === 1 ? -this.paddingRight : this.paddingLeft);
    this.inputField.y = this._bg.height / 2 + this.paddingTop - this.paddingBottom;
    this.placeholder.anchor.set(align, 0.5);
    this.placeholder.x = this._bg.width * align + (align === 1 ? -this.paddingRight : this.paddingLeft);
    this.placeholder.y = this._bg.height / 2;
    this._cursor.x = this.getCursorPosX();
    this._cursor.y = this.inputField.y;
  }
  getAlign() {
    const maxWidth = this._bg.width * 0.95;
    const paddings = this.paddingLeft + this.paddingRight - 10;
    const isOverflowed = this.inputField.width + paddings > maxWidth;
    if (isOverflowed) {
      return this.editing ? 1 : 0;
    }
    switch (this.options.align) {
      case "left":
        return 0;
      case "center":
        return 0.5;
      case "right":
        return 1;
      default:
        return 0;
    }
  }
  getCursorPosX() {
    const align = this.getAlign();
    switch (align) {
      case 0:
        return this.inputField.x + this.inputField.width;
      case 0.5:
        return this.inputField.x + this.inputField.width * 0.5;
      case 1:
        return this.inputField.x;
      default:
        return 0;
    }
  }
  /** Sets the input text. */
  set value(text) {
    const textLength = text.length;
    this._value = text;
    this.inputField.text = this.secure ? SECURE_CHARACTER.repeat(textLength) : text;
    if (textLength !== 0) {
      this.placeholder.visible = false;
    } else {
      this.placeholder.visible = !this.editing;
    }
    this.align();
  }
  /** Return text of the input. */
  get value() {
    return this._value;
  }
  set secure(val) {
    this._secure = val;
    this.value = this._value;
  }
  get secure() {
    return this._secure;
  }
  /**
   * Set paddings
   * @param value - number, array of 4 numbers or object with keys: top, right, bottom, left
   * or: [top, right, bottom, left]
   * or: [top&bottom, right&left]
   * or: {
   *  left: 10,
   *  right: 10,
   *  top: 10,
   *  bottom: 10,
   * }
   */
  set padding(value) {
    if (typeof value === "number") {
      this.paddingTop = value;
      this.paddingRight = value;
      this.paddingBottom = value;
      this.paddingLeft = value;
    }
    if (Array.isArray(value)) {
      this.paddingTop = value[0] ?? 0;
      this.paddingRight = value[1] ?? value[0] ?? 0;
      this.paddingBottom = value[2] ?? value[0] ?? 0;
      this.paddingLeft = value[3] ?? value[1] ?? value[0] ?? 0;
    } else if (typeof value === "object") {
      this.paddingTop = value.top ?? 0;
      this.paddingRight = value.right ?? 0;
      this.paddingBottom = value.bottom ?? 0;
      this.paddingLeft = value.left ?? 0;
    }
  }
  // Return array of paddings [top, right, bottom, left]
  get padding() {
    return [this.paddingTop, this.paddingRight, this.paddingBottom, this.paddingLeft];
  }
  destroy(options) {
    this.off("pointertap");
    window.removeEventListener(core.isMobile.any ? "touchstart" : "click", this.handleActivationBinding);
    super.destroy(options);
  }
  /**
   * Sets width of a Input.
   * If nineSlicePlane is set, then width will be set to nineSlicePlane.
   * If nineSlicePlane is not set, then width will control components width as Container.
   * @param width - Width value.
   */
  set width(width) {
    if (this.options?.nineSlicePlane) {
      if (this._bg) {
        this._bg.width = width;
      }
      this.updateInputMaskSize();
      this.align();
    } else {
      super.width = width;
    }
  }
  /** Gets width of Input. */
  get width() {
    return super.width;
  }
  /**
   * Sets height of a Input.
   * If nineSlicePlane is set, then height will be set to nineSlicePlane.
   * If nineSlicePlane is not set, then height will control components height as Container.
   * @param height - Height value.
   */
  set height(height) {
    if (this.options?.nineSlicePlane) {
      if (this._bg) {
        this._bg.height = height;
      }
      this.updateInputMaskSize();
      this.align();
    } else {
      super.height = height;
    }
  }
  /** Gets height of Input. */
  get height() {
    return super.height;
  }
  createInputMask(bg) {
    if (this.inputMask) {
      this.inputField.mask = null;
      this._cursor.mask = null;
      this.inputMask.destroy();
    }
    if (this.options?.nineSlicePlane && typeof bg === "string") {
      this.inputMask = new meshExtras.NineSlicePlane(core.Texture.from(bg), ...this.options.nineSlicePlane);
    } else if (bg instanceof sprite.Sprite) {
      this.inputMask = new sprite.Sprite(bg.texture);
    } else if (bg instanceof graphics.Graphics) {
      this.inputMask = bg.clone();
    } else {
      this.inputMask = view.getView(bg);
    }
    this.inputField.mask = this.inputMask;
    this._cursor.mask = this.inputMask;
    this.updateInputMaskSize();
    this.addChildAt(this.inputMask, 0);
  }
  updateInputMaskSize() {
    if (!this.inputMask || !this._bg)
      return;
    this.inputMask.width = this._bg.width - this.paddingLeft - this.paddingRight;
    this.inputMask.height = this._bg.height - this.paddingTop - this.paddingBottom;
    this.inputMask.position.set(this.paddingLeft, this.paddingTop);
  }
  onPaste(e) {
    e.preventDefault();
    const text = (e.clipboardData || window.clipboardData).getData("text");
    if (!text)
      return;
    this._add(text);
  }
}

exports.Input = Input;
//# sourceMappingURL=Input.js.map
