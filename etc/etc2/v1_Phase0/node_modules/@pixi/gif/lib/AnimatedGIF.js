'use strict';

var sprite = require('@pixi/sprite');
var core = require('@pixi/core');
var index = require('./external/gifuct-js/lib/index.js');

const _AnimatedGIF = class extends sprite.Sprite {
  constructor(frames, options) {
    super(core.Texture.EMPTY);
    this.animationSpeed = 1;
    this.loop = true;
    this.duration = 0;
    this.autoPlay = true;
    this.dirty = false;
    this._currentFrame = 0;
    this._autoUpdate = false;
    this._isConnectedToTicker = false;
    this._playing = false;
    this._currentTime = 0;
    const { scaleMode, width, height, ...rest } = Object.assign(
      {},
      _AnimatedGIF.defaultOptions,
      options
    );
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    canvas.width = width;
    canvas.height = height;
    this.texture = core.Texture.from(canvas, { scaleMode });
    this.duration = frames[frames.length - 1].end;
    this._frames = frames;
    this._context = context;
    this._playing = false;
    this._currentTime = 0;
    this._isConnectedToTicker = false;
    Object.assign(this, rest);
    this.currentFrame = 0;
    if (rest.autoPlay) {
      this.play();
    }
  }
  static fromBuffer(buffer, options) {
    if (!buffer || buffer.byteLength === 0) {
      throw new Error("Invalid buffer");
    }
    const validateAndFix = (gif2) => {
      let currentGce = null;
      for (const frame of gif2.frames) {
        currentGce = frame.gce ?? currentGce;
        if ("image" in frame && !("gce" in frame)) {
          frame.gce = currentGce;
        }
      }
    };
    const gif = index.parseGIF(buffer);
    validateAndFix(gif);
    const gifFrames = index.decompressFrames(gif, true);
    const frames = [];
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    const patchCanvas = document.createElement("canvas");
    const patchContext = patchCanvas.getContext("2d");
    canvas.width = gif.lsd.width;
    canvas.height = gif.lsd.height;
    let time = 0;
    let previousFrame = null;
    const { fps } = Object.assign({}, _AnimatedGIF.defaultOptions, options);
    const defaultDelay = 1e3 / fps;
    for (let i = 0; i < gifFrames.length; i++) {
      const {
        disposalType = 2,
        delay = defaultDelay,
        patch,
        dims: { width: width2, height: height2, left, top }
      } = gifFrames[i];
      patchCanvas.width = width2;
      patchCanvas.height = height2;
      patchContext.clearRect(0, 0, width2, height2);
      const patchData = patchContext.createImageData(width2, height2);
      patchData.data.set(patch);
      patchContext.putImageData(patchData, 0, 0);
      if (disposalType === 3) {
        previousFrame = context.getImageData(0, 0, canvas.width, canvas.height);
      }
      context.drawImage(patchCanvas, left, top);
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      if (disposalType === 2) {
        context.clearRect(0, 0, canvas.width, canvas.height);
      } else if (disposalType === 3) {
        context.putImageData(previousFrame, 0, 0);
      }
      frames.push({
        start: time,
        end: time + delay,
        imageData
      });
      time += delay;
    }
    canvas.width = canvas.height = 0;
    patchCanvas.width = patchCanvas.height = 0;
    const { width, height } = gif.lsd;
    return new _AnimatedGIF(frames, { width, height, ...options });
  }
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      core.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      core.Ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
    if (!this.loop && this.currentFrame === this._frames.length - 1) {
      this._currentTime = 0;
    }
  }
  get progress() {
    return this._currentTime / this.duration;
  }
  get playing() {
    return this._playing;
  }
  update(deltaTime) {
    if (!this._playing) {
      return;
    }
    const elapsed = this.animationSpeed * deltaTime / core.settings.TARGET_FPMS;
    const currentTime = this._currentTime + elapsed;
    const localTime = currentTime % this.duration;
    const localFrame = this._frames.findIndex((frame) => frame.start <= localTime && frame.end > localTime);
    if (currentTime >= this.duration) {
      if (this.loop) {
        this._currentTime = localTime;
        this.updateFrameIndex(localFrame);
        this.onLoop?.();
      } else {
        this._currentTime = this.duration;
        this.updateFrameIndex(this._frames.length - 1);
        this.onComplete?.();
        this.stop();
      }
    } else {
      this._currentTime = localTime;
      this.updateFrameIndex(localFrame);
    }
  }
  updateFrame() {
    if (!this.dirty) {
      return;
    }
    const { imageData } = this._frames[this._currentFrame];
    this._context.putImageData(imageData, 0, 0);
    this._context.fillStyle = "transparent";
    this._context.fillRect(0, 0, 0, 1);
    this.texture.update();
    this.dirty = false;
  }
  _render(renderer) {
    this.updateFrame();
    super._render(renderer);
  }
  _renderCanvas(renderer) {
    this.updateFrame();
    super._renderCanvas(renderer);
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        core.Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        core.Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
  get currentFrame() {
    return this._currentFrame;
  }
  set currentFrame(value) {
    this.updateFrameIndex(value);
    this._currentTime = this._frames[value].start;
  }
  updateFrameIndex(value) {
    if (value < 0 || value >= this._frames.length) {
      throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${value}`);
    }
    if (this._currentFrame !== value) {
      this._currentFrame = value;
      this.dirty = true;
      this.onFrameChange?.(value);
    }
  }
  get totalFrames() {
    return this._frames.length;
  }
  destroy() {
    this.stop();
    super.destroy(true);
    const forceClear = null;
    this._context = forceClear;
    this._frames = forceClear;
    this.onComplete = forceClear;
    this.onFrameChange = forceClear;
    this.onLoop = forceClear;
  }
  clone() {
    return new _AnimatedGIF([...this._frames], {
      autoUpdate: this._autoUpdate,
      loop: this.loop,
      autoPlay: this.autoPlay,
      scaleMode: this.texture.baseTexture.scaleMode,
      animationSpeed: this.animationSpeed,
      width: this._context.canvas.width,
      height: this._context.canvas.height,
      onComplete: this.onComplete,
      onFrameChange: this.onFrameChange,
      onLoop: this.onLoop
    });
  }
};
let AnimatedGIF = _AnimatedGIF;
AnimatedGIF.defaultOptions = {
  scaleMode: core.SCALE_MODES.LINEAR,
  fps: 30,
  loop: true,
  animationSpeed: 1,
  autoPlay: true,
  autoUpdate: true,
  onComplete: null,
  onFrameChange: null,
  onLoop: null
};

exports.AnimatedGIF = AnimatedGIF;
//# sourceMappingURL=AnimatedGIF.js.map
