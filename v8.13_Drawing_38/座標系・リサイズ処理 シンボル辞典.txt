# 座標系・リサイズ処理 シンボル辞典

## 🎯 問題の核心

**中央基準リサイズ時に、レイヤーサムネイルの描画位置がずれる**
- キャンバス表示: 正しく中央から上下左右等間隔にリサイズ
- レイヤーサムネイル: 左上または上基準でリサイズしているように見える

## 📊 座標系の種類と変換フロー

### 1. **Canvas座標系（描画座標）**
- **原点**: 左上 (0, 0)
- **範囲**: 0 ～ canvas.width, 0 ～ canvas.height
- **用途**: 描画データ（paths.points）の実座標
- **管理**: `layer.layerData.paths[].points[]`

### 2. **World座標系（表示座標）**
- **原点**: worldContainer基準
- **変換**: CameraSystemのpan/zoom/rotationが適用される
- **用途**: PixiJS表示位置
- **管理**: `worldContainer.position`, `worldContainer.scale`

### 3. **Screen座標系（マウス座標）**
- **原点**: ブラウザウィンドウ左上
- **用途**: ユーザー入力
- **変換**: `CameraSystem.screenToCanvas()`で Canvas座標系へ

### 4. **Layer座標系（レイヤー変形）**
- **原点**: レイヤーのpivot基準
- **変換**: position/rotation/scale/pivotが適用
- **用途**: Vキーモードでのレイヤー移動・変形
- **管理**: `LayerTransform.transforms Map`

## 🔄 リサイズ時の座標変換フロー

```
resize-popup.js: _applyResize()
  ↓
① offsetX/Y計算 (_calculateLayerCoordinateOffset)
  ↓
② 全フレーム・全レイヤーに座標変換適用
  (_applyCoordinateTransformToFrames)
  ↓
③ layer.position.x/y += offsetX/Y  ← PixiJS表示位置
  ↓
④ path.points[].x/y += offsetX/Y   ← Canvas座標系
  ↓
⑤ path.graphics再描画
  ↓
⑥ サムネイル更新要求
```

## 🗂️ ファイル別責務と座標系

### **resize-popup.js**
- **責務**: キャンバスリサイズUI・座標変換計算
- **座標系**: Canvas座標系のオフセット計算
- **重要メソッド**:
  - `_calculateLayerCoordinateOffset()`: 配置基準からオフセット計算
  - `_applyCoordinateTransformToFrames()`: 全データへ座標変換適用
  - `_applyResize()`: リサイズ実行とHistory管理

**問題点**: 
- `layer.position`への適用は正しい
- `path.points`への適用も正しい
- しかし、**サムネイル生成時に古い座標を参照している可能性**

---

### **coordinate-system.js**
- **責務**: 座標変換ユーティリティ（診断専用）
- **座標系**: World ↔ Screen, Layer ↔ World変換
- **重要メソッド**:
  - `applyLayerTransform()`: レイヤー変形の適用
  - `screenToWorld()`, `worldToScreen()`: 座標変換
  - `localToWorld()`, `worldToLocal()`: レイヤーローカル座標変換

**現状**: 
- リサイズ処理では**使用されていない**
- レイヤー変形（Vキーモード）でのみ使用
- 診断専用との明記あり

---

### **camera-system.js**
- **責務**: ビューポート制御（pan/zoom/rotation）
- **座標系**: Screen → Canvas変換
- **重要メソッド**:
  - `screenToCanvas()`: マウス座標をCanvas座標に変換
  - `resizeCanvas()`: キャンバスサイズ変更通知
  - `worldContainer`: ビューポート変形コンテナ

**座標変換の実装**:
```javascript
screenToCanvas(screenX, screenY) {
    const canvas = this._getSafeCanvas();
    const rect = canvas.getBoundingClientRect();
    const relativeX = screenX - rect.left;
    const relativeY = screenY - rect.top;
    return this.canvasContainer.toLocal({ 
        x: relativeX, 
        y: relativeY 
    });
}
```

---

### **layer-system.js**
- **責務**: レイヤー管理・RenderTexture管理
- **座標系**: Canvas座標系（paths.points）
- **重要メソッド**:
  - `renderFrameToTexture()`: フレーム全体をテクスチャ化
  - `updateThumbnail()`: レイヤー個別サムネイル生成
  - `safeRebuildLayer()`: paths.graphicsの再構築

**Phase2修正内容**:
```javascript
renderFrameToTexture(frameId, frameContainer) {
    // ★ 現在のcanvasサイズを取得
    const currentWidth = this.config.canvas.width;
    const currentHeight = this.config.canvas.height;
    
    // ★ 古いテクスチャを破棄
    const oldTexture = this.frameRenderTextures.get(frameId);
    if (oldTexture) oldTexture.destroy(true);
    
    // ★ 新しいサイズでテクスチャ再作成
    const renderTexture = PIXI.RenderTexture.create({
        width: currentWidth,
        height: currentHeight
    });
}
```

**updateThumbnail()の処理フロー**:
```javascript
1. レイヤーの変形状態を一時保存
2. position/scale/rotation/pivotをリセット
3. RenderTextureに描画
4. 元の変形状態を復元
5. Canvas2Dでリサイズしてサムネイル化
```

---

### **layer-panel-renderer.js**
- **責務**: レイヤーパネルDOM操作
- **座標系**: Canvas座標系から直接サムネイル生成
- **重要メソッド**:
  - `generateLayerThumbnailCanvas()`: paths.pointsから直接描画
  - `updateAllThumbnails()`: 全レイヤーサムネイル更新
  - `createThumbnail()`: サムネイル要素生成

**修正版の実装**:
```javascript
generateLayerThumbnailCanvas(layer) {
    // paths.pointsから直接座標を読み取り
    // Canvas2Dで描画してサムネイル生成
    // ★ paths.pointsの座標がリサイズ後の値であれば正しく描画される
}
```

---

### **layer-transform.js**
- **責務**: Vキーモード時のレイヤー変形
- **座標系**: Layer座標系（pivot中心の変形）
- **重要メソッド**:
  - `applyTransformToPaths()`: 変形確定時にpaths座標を変換
  - `_createTransformMatrix()`: PIXI.Matrixで変形行列作成
  - `_transformPoints()`: 行列でpoints座標を変換

**変形確定時の処理**:
```javascript
confirmTransform(layer) {
    // 1. 現在のpivot/position/rotation/scaleから変形行列作成
    // 2. paths.points全てに行列を適用
    // 3. PixiJS変形をリセット（position=0, scale=1, etc）
    // 4. Graphics再構築
}
```

---

### **animation-system.js**
- **責務**: フレーム管理・サムネイル生成
- **座標系**: Canvas座標系（フレーム単位）
- **重要メソッド**:
  - `generateFrameThumbnail()`: フレームサムネイル生成
  - `regenerateAllThumbnails()`: 全フレームサムネイル再生成
  - `handleCanvasResize()`: リサイズ時のテクスチャ削除

**リサイズ対応**:
```javascript
handleCanvasResize(newWidth, newHeight) {
    // 全フレームの古いRenderTextureを削除
    this.animationData.frames.forEach(frame => {
        this.layerSystem?.destroyFrameRenderTexture(frame.id);
    });
    
    // 新しいサイズで再生成
    setTimeout(() => {
        this.regenerateAllThumbnails();
    }, 200);
}
```

---

## 🔍 問題の原因分析

### **仮説1: サムネイル生成タイミングの問題**
- リサイズ後、paths.pointsは正しく更新されている
- しかし、サムネイル生成が**座標変換前の古いデータ**を参照している
- タイミング: `setTimeout(..., 100ms)`では不十分？

### **仮説2: RenderTextureキャッシュの問題**
- `layer-system.js`の`updateThumbnail()`が古いRenderTextureを使用
- リサイズ後も古いテクスチャサイズで描画
- **Phase2修正で対応済みのはず**だが...

### **仮説3: レイヤー変形状態の混在**
- `layer.position`はPixiJS表示位置（World座標系）
- `paths.points`はCanvas座標系
- サムネイル生成時、**どちらの座標を参照しているか不明確**

### **仮説4: 座標系の二重適用**
- リサイズ時に`layer.position += offset`
- さらに`paths.points += offset`
- サムネイル生成時に両方が適用され、**二重にオフセットされている**？

---

## 🎨 サムネイル生成の現在の処理

### **layer-system.js: updateThumbnail()**
```javascript
1. レイヤーの現在の変形状態を保存
   - position, scale, rotation, pivot
2. 変形をリセット
   - position=(0,0), scale=(1,1), rotation=0, pivot=(0,0)
3. tempContainerに追加してRenderTexture描画
4. 元の変形状態を復元
5. Canvas2DでリサイズしてDOM表示
```

**問題**: 
- Step2でposition=(0,0)にリセット
- **しかし、paths.pointsは既にoffset済みの座標**
- → サムネイル描画時にoffsetが無視される？

### **layer-panel-renderer.js: generateLayerThumbnailCanvas()**
```javascript
1. paths.pointsから直接座標を読み取り
2. minX/minY/maxX/maxYでバウンディングボックス計算
3. Canvas2Dで直接描画
4. サムネイルサイズにリサイズ
```

**問題**:
- paths.pointsを**そのまま使用**
- リサイズ後の座標が正しく反映されるはず
- **しかし、なぜずれる？**

---

## 🚨 決定的な問題点の発見

### **resize-popup.js の座標変換**
```javascript
_applyCoordinateTransformToFrames(frames, offsetX, offsetY) {
    frames.forEach((frame) => {
        const layers = frame.getLayers();
        
        layers.forEach((layer) => {
            // ① PixiJS表示位置を移動
            layer.position.x += offsetX;
            layer.position.y += offsetY;
            
            // ② paths座標も移動
            if (layer.layerData?.paths) {
                layer.layerData.paths.forEach((path) => {
                    path.points.forEach((point) => {
                        point.x += offsetX;
                        point.y += offsetY;
                    });
                    
                    // ③ graphicsを再描画
                    if (path.graphics) {
                        path.graphics.clear();
                        path.points.forEach((p) => {
                            path.graphics.circle(p.x, p.y, ...);
                        });
                    }
                });
            }
        });
    });
}
```

**問題点**:
- `layer.position`への適用: **表示位置のオフセット**
- `paths.points`への適用: **描画座標のオフセット**
- **両方が適用されると、サムネイル描画時に二重適用される！**

### **正しい処理**:
**Option A**: layer.positionのみ移動
- paths.pointsは変更しない
- サムネイル生成時にlayer.positionを考慮

**Option B**: paths.pointsのみ移動
- layer.positionは(0,0)のまま
- サムネイル生成時はpaths.pointsのみ使用

**現在の実装は両方やっている = 二重適用**

---

## ✅ 解決策

### **方針**: paths.pointsのみ移動、layer.positionは維持

リサイズは「キャンバスサイズの変更 + 描画内容の位置調整」であり、
レイヤー変形（Vキーモード）とは**異なる**。

```javascript
// resize-popup.js修正案
_applyCoordinateTransformToFrames(frames, offsetX, offsetY) {
    frames.forEach((frame) => {
        const layers = frame.getLayers();
        
        layers.forEach((layer) => {
            // layer.positionは変更しない（削除）
            // layer.position.x += offsetX;  ← 削除
            // layer.position.y += offsetY;  ← 削除
            
            // paths座標のみ移動
            if (layer.layerData?.paths) {
                layer.layerData.paths.forEach((path) => {
                    path.points.forEach((point) => {
                        point.x += offsetX;
                        point.y += offsetY;
                    });
                    
                    if (path.graphics) {
                        path.graphics.clear();
                        path.points.forEach((p) => {
                            path.graphics.circle(p.x, p.y, path.size / 2);
                            path.graphics.fill({
                                color: path.color,
                                alpha: path.opacity
                            });
                        });
                    }
                });
            }
            
            // 背景レイヤーの処理はそのまま
            if (layer.layerData?.isBackground && 
                layer.layerData.backgroundGraphics) {
                // 背景は新しいサイズで再描画
            }
        });
    });
}
```

### **検証ポイント**:
1. リサイズ後、メインキャンバス表示が正しいか
2. レイヤーサムネイルが正しい位置で表示されるか
3. Vキーモードでのレイヤー移動が正常か
4. Undo/Redoが正常に動作するか

---

## 📋 修正必要ファイル

1. **resize-popup.js**: `_applyCoordinateTransformToFrames()` 修正
2. **layer-system.js**: サムネイル生成ロジック確認（おそらく修正不要）
3. **layer-panel-renderer.js**: 修正不要（paths.pointsを正しく使用）

---

## 🔬 デバッグ方法

```javascript
// resize-popup.js の _applyResize() 内に追加
console.log('=== RESIZE DEBUG ===');
console.log('offsetX:', offsetX, 'offsetY:', offsetY);

frames.forEach((frame, fi) => {
    frame.getLayers().forEach((layer, li) => {
        console.log(`Frame${fi} Layer${li}:`, {
            position: {x: layer.position.x, y: layer.position.y},
            pathsCount: layer.layerData?.paths?.length || 0,
            firstPoint: layer.layerData?.paths?.[0]?.points?.[0]
        });
    });
});
```