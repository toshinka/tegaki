# システムアーキテクチャ診断レポート
**診断日**: 2025-10-21  
**対象**: PixiJS v8.13 お絵かきツール

---

## 🎯 総合評価

### ✅ 良好な点
1. **EventBus統合**: イベント駆動アーキテクチャが明確
2. **LayerTransform分離**: Phase 1改修で責務分離が適切
3. **PopupManager統一**: 今回の改修で統一され、見通し良好
4. **History統合**: Undo/Redo機構が一貫している

### ⚠️ 要注意点
1. **DrawingEngine二重実装**: 簡易版と完全版が共存
2. **座標変換経路の複雑化**: 3つの変換経路が混在
3. **DOM操作の散在**: UI更新ロジックが複数箇所に分散
4. **設定参照の不統一**: CONFIG直接参照とManager経由が混在

---

## 🔍 詳細診断

### 1. DrawingEngine の二重実装 🔴 **重大**

#### 問題点
**core-engine.js** と **system/drawing/drawing-engine.js** に異なる実装が存在

**core-engine.js (DrawingEngine)**:
```javascript
class DrawingEngine {
    constructor(cameraSystem, layerManager, eventBus, config) {
        // シンプルな実装
        this.currentTool = 'pen';
        this.brushSize = this.config.pen.size;
        this.pressureHandler = { getPressure: ... }; // 簡易実装
    }
    
    startDrawing(screenX, screenY, pressureOrEvent) {
        // 基本的な描画処理
        this.currentPath = {
            id: `path_${Date.now()}...`,
            graphics: new PIXI.Graphics(),
            points: [...],
            // ...
        };
    }
}
```

**system/drawing/drawing-engine.js (DrawingEngine)**:
```javascript
class DrawingEngine {
    constructor(cameraSystem, layerManager, eventBus, config) {
        // サブモジュール初期化
        this.settings = new window.TegakiDrawing.BrushSettings(...);
        this.recorder = new window.TegakiDrawing.StrokeRecorder();
        this.renderer = new window.TegakiDrawing.StrokeRenderer(...);
        this.pressureHandler = new window.TegakiDrawing.PressureHandler();
        this.transformer = new window.TegakiDrawing.StrokeTransformer(...);
    }
    
    startDrawing(screenX, screenY, pressureOrEvent) {
        // Phase 1-3統合版の高度な処理
        // Perfect Freehand + Simplify + Catmull-Rom Spline
    }
}
```

#### 影響
- **現在の描画経路**: `core-engine.js`の簡易版が使われている
- **未使用コード**: `system/drawing/drawing-engine.js`の高度な機能（筆圧補正、スムージング）が**動作していない**
- **設定UIの無効化**: `settings-popup.js`の筆圧・スムージング設定が**機能していない**

#### 解決策
```javascript
// core-engine.js を修正
class CoreEngine {
    constructor(app, config = {}) {
        // ❌ 削除
        // this.drawingEngine = new DrawingEngine(...);
        
        // ✅ 完全版を使用
        if (window.TegakiDrawing?.DrawingEngine) {
            this.drawingEngine = new window.TegakiDrawing.DrawingEngine(
                this.cameraSystem,
                this.layerSystem,
                this.eventBus,
                CONFIG
            );
        } else {
            throw new Error('TegakiDrawing.DrawingEngine not found');
        }
    }
}
```

---

### 2. 座標変換経路の複雑化 🟡 **中程度**

#### 現状の3つの経路

**経路1**: `CameraSystem.screenToCanvas()`
```javascript
// camera-system.js
screenToCanvas(screenX, screenY, options = {}) {
    const globalPoint = { x: screenX, y: screenY };
    const canvasPoint = this.canvasContainer.toLocal(globalPoint);
    return canvasPoint;
}
```

**経路2**: `CoordinateSystem` (coordinate-system.js)
```javascript
// 複数の変換メソッド
screenToCanvas(screenX, screenY) { ... }
canvasToLayer(canvasX, canvasY) { ... }
localToGlobal(container, point) { ... }
```

**経路3**: `DrawingEngine` 内部の変換
```javascript
// core-engine.js DrawingEngine
startDrawing(screenX, screenY, pressureOrEvent) {
    const canvasPoint = this.cameraSystem.screenToCanvas(screenX, screenY, { forDrawing: true });
    // ...
}
```

#### 問題点
- **API不一致**: 3つの座標変換APIが混在
- **責務の曖昧さ**: `CameraSystem`と`CoordinateSystem`の役割分担が不明確
- **Transform適用タイミング**: LayerTransformがいつ適用されるか追いにくい

#### 推奨
```javascript
// 座標変換は CameraSystem に一元化
class CameraSystem {
    screenToCanvas(screenX, screenY) { ... }
    canvasToWorld(canvasX, canvasY) { ... }
    worldToCanvas(worldX, worldY) { ... }
}

// CoordinateSystem は診断・デバッグ専用に特化
window.CoordinateSystem.diagnoseReferences();
```

---

### 3. 設定参照の混在 🟡 **中程度**

#### パターン1: CONFIG直接参照（多数）
```javascript
// camera-system.js
const scaleFactor = 1 + this.config.camera.wheelZoomSpeed;

// drawing-engine.js (core-engine.js版)
this.brushSize = this.config.pen.size;

// layer-system.js
bg.fill(this.config.background.color);
```

#### パターン2: SettingsManager経由（一部）
```javascript
// system/drawing/drawing-engine.js (完全版)
this.settings = new window.TegakiDrawing.BrushSettings(config, eventBus);
this.settings.setBrushSize(value);
const currentSettings = this.settings.getCurrentSettings();
```

#### 問題点
- **設定変更の反映**: CONFIG直接参照は動的変更に対応できない
- **EventBus統合の不完全性**: 設定変更イベントが一部でしか発火しない
- **リアクティブ性の欠如**: UI変更 → 設定反映の経路が不明確

#### 推奨統一パターン
```javascript
// すべての設定は SettingsManager 経由
class DrawingEngine {
    constructor(...) {
        this.settings = window.TegakiSettingsManager;
    }
    
    getBrushSize() {
        return this.settings.get('pen.size'); // ✅ 動的取得
    }
}

// EventBusで変更を通知
SettingsManager.set('pen.size', 10);
// → EventBus.emit('settings:pen-size-changed', { value: 10 });
```

---

### 4. DOM操作の散在 🟡 **中程度**

#### 散在箇所

**layer-system.js**:
```javascript
updateLayerPanelUI() {
    const layerList = document.getElementById('layer-list');
    layerList.innerHTML = '';
    // 200行以上のDOM生成ロジック
}
```

**ui-panels.js**:
```javascript
constructor(...) {
    this.setupSliders();
    this.setupCanvasResize();
    this.setupFlipButtons();
    // DOM操作がコンストラクタ内に散在
}
```

**camera-system.js**:
```javascript
updateTransformDisplay() {
    const element = document.getElementById('transform-info');
    element.textContent = `x:${x} y:${y} ...`;
}

updateCoordinates(x, y) {
    const element = document.getElementById('coordinates');
    element.textContent = `x: ${x}, y: ${y}`;
}
```

**album-popup.js**:
```javascript
_createPopupElement() {
    const popupDiv = document.createElement('div');
    popupDiv.innerHTML = `...`; // 100行以上のHTML文字列
}
```

#### 問題点
- **責務の混在**: ロジック層がDOM操作を直接実行
- **テスト困難**: DOM依存でユニットテストが書けない
- **重複コード**: 似たようなDOM操作が複数箇所に存在

#### 推奨改善
```javascript
// UIRenderer を分離
class LayerPanelRenderer {
    render(layers, activeIndex) {
        return layers.map(layer => this.renderLayerItem(layer)).join('');
    }
    
    renderLayerItem(layer) {
        return `<div class="layer-item">...</div>`;
    }
}

// layer-system.js
updateLayerPanelUI() {
    const html = this.uiRenderer.render(this.getLayers(), this.activeLayerIndex);
    document.getElementById('layer-list').innerHTML = html;
}
```

---

### 5. EventBus統合の不完全性 🟢 **軽度**

#### 統合済み（良好）
```javascript
// camera-system.js
this.eventBus.emit('camera:changed');
this.eventBus.emit('camera:resized', { width, height });

// layer-system.js
this.eventBus.emit('layer:activated', { layerIndex, layerId });
this.eventBus.emit('layer:deleted', { layerId, layerIndex });

// drawing-engine.js
this.eventBus.emit('drawing:completed', { pathId, pointCount });
```

#### 未統合（改善余地）
```javascript
// core-engine.js - DrawingEngine (簡易版)
// ❌ EventBus通知なし
setBrushSize(size) {
    this.brushSize = Math.max(0.1, Math.min(100, size));
    // EventBus通知がない
}

// camera-system.js
// ❌ 一部の状態変更でEventBus通知がない
_handleScaleRotateDrag(e) {
    // スケール・回転変更
    // → EventBus通知なし
}
```

#### 推奨
```javascript
// すべての状態変更でEventBusを発火
setBrushSize(size) {
    const oldSize = this.brushSize;
    this.brushSize = Math.max(0.1, Math.min(100, size));
    
    if (this.eventBus && oldSize !== this.brushSize) {
        this.eventBus.emit('drawing:brush-size-changed', {
            oldSize,
            newSize: this.brushSize
        });
    }
}
```

---

### 6. History統合の状態 ✅ **良好**

#### 統一パターン
```javascript
// layer-system.js, core-engine.js
const command = {
    name: 'action-name',
    do: () => { /* 実行 */ },
    undo: () => { /* 取り消し */ },
    meta: { /* メタ情報 */ }
};
window.History.push(command);
```

#### 対応済みアクション
- ✅ `draw-stroke` - ストローク描画
- ✅ `clear-layer` - レイヤークリア
- ✅ `layer-create` - レイヤー作成
- ✅ `layer-delete` - レイヤー削除
- ✅ `layer-reorder` - レイヤー順序変更
- ✅ `layer-transform` - レイヤー変形
- ✅ `layer-hierarchy-move` - レイヤー階層移動

---

## 📊 API境界の明確度

### 明確なAPI（✅）
1. **EventBus**: `emit()`, `on()`, `off()` - 統一されている
2. **PopupManager**: `show()`, `hide()`, `toggle()`, `get()` - 今回の改修で統一
3. **History**: `push()`, `undo()`, `redo()` - 一貫性が高い
4. **LayerTransform**: `getTransform()`, `setTransform()`, `applyTransform()` - Phase 1で整理済み

### 不明瞭なAPI（⚠️）
1. **DrawingEngine**: 2つの実装で異なるAPI
   - 簡易版: `startDrawing(x, y, pressure)`
   - 完全版: `startDrawing(x, y, pressureOrEvent)` + サブモジュール
2. **座標変換**: 3つのAPI（CameraSystem, CoordinateSystem, 内部変換）
3. **設定アクセス**: CONFIG直接 vs SettingsManager
4. **CoreRuntime.api**: 部分的に実装（PopupManager APIは追加済み）

---

## 🔄 データフローの可視性

### 描画フロー（現状）
```
[ユーザー操作]
    ↓
[core-engine.js - PointerEvent]
    ↓
[DrawingEngine (簡易版).startDrawing()]  ← ⚠️ 完全版が使われていない
    ↓
[CameraSystem.screenToCanvas()]
    ↓
[LayerSystem.addPathToActiveLayer()]
    ↓
[LayerTransform適用]
    ↓
[PIXI.Graphics描画]
    ↓
[History.push()]
    ↓
[EventBus.emit('drawing:completed')]
```

### 推奨フロー
```
[ユーザー操作]
    ↓
[CoreRuntime Pointer Events]  ← core-runtime.js で一元管理
    ↓
[DrawingEngine (完全版)]  ← Perfect Freehand + Simplify + Spline
    ├─ [BrushSettings]
    ├─ [StrokeRecorder]
    ├─ [StrokeRenderer]
    ├─ [PressureHandler]
    └─ [StrokeTransformer]
    ↓
[LayerSystem.addPathToActiveLayer()]
    ↓
[History + EventBus]
```

---

## 🚨 優先度別改修推奨

### 🔴 優先度: 高（即座に対応）
1. **DrawingEngine二重実装の解消**
   - `core-engine.js`の簡易版を削除
   - `system/drawing/drawing-engine.js`（完全版）に統一
   - 筆圧・スムージング機能を有効化
   
2. **core-runtime.js のPointerイベント統合**
   - 現在: `core-runtime.js`と`core-engine.js`で二重にイベント処理
   - 推奨: `core-runtime.js`に一元化

### 🟡 優先度: 中（計画的に対応）
3. **座標変換APIの統一**
   - `CameraSystem`に一元化
   - `CoordinateSystem`は診断専用に

4. **設定参照の統一**
   - CONFIG直接参照 → SettingsManager経由に統一
   - リアクティブな設定変更を実現

5. **DOM操作の分離**
   - UIRenderer層を作成
   - ロジック層からDOM操作を排除

### 🟢 優先度: 低（余裕があれば）
6. **EventBus統合の完全化**
   - すべての状態変更でイベント発火
   - イベント一覧ドキュメント作成

7. **CoreRuntime API拡張**
   - 描画API追加: `CoreRuntime.api.draw()`, `CoreRuntime.api.clear()`
   - 設定API拡充: すべての設定項目をAPI化

---

## 💡 具体的な改修手順

### Step 1: DrawingEngine統一（最重要）

**ファイル**: `core-engine.js`

```javascript
// ❌ 削除: class DrawingEngine { ... }

// ✅ 変更
class CoreEngine {
    constructor(app, config = {}) {
        // ...
        
        // 完全版DrawingEngineを使用
        if (!window.TegakiDrawing?.DrawingEngine) {
            throw new Error('TegakiDrawing.DrawingEngine not found');
        }
        
        this.drawingEngine = new window.TegakiDrawing.DrawingEngine(
            this.cameraSystem,
            this.layerSystem,
            this.eventBus,
            CONFIG
        );
        
        // ...
    }
}
```

**影響範囲**:
- ✅ 筆圧補正が動作
- ✅ スムージング（Simplify + Spline）が動作
- ✅ SettingsPopupの設定が有効化
- ⚠️ `core-runtime.js`のPointerイベント処理との競合を確認

---

### Step 2: Pointer Events統合

**ファイル**: `core-runtime.js`, `core-engine.js`

**現状の問題**:
```javascript
// core-runtime.js (Line 120-140)
stage.on('pointerdown', (event) => {
    this.handlePointerDown(event);  // ← ここで描画開始
});

// core-engine.js (Line 600-650)
canvas.addEventListener('pointerdown', (e) => {
    this.drawingEngine.startDrawing(x, y, e);  // ← ここでも描画開始
}, true);
```

**推奨**:
```javascript
// core-runtime.js
setupPointerEvents() {
    // ...
    
    stage.on('pointerdown', (event) => {
        // 描画処理は CoreEngine.drawingEngine に委譲
        if (this.internal.drawingEngine && !this.internal.layerManager?.isLayerMoveMode) {
            const screenX = event.global.x;
            const screenY = event.global.y;
            this.internal.drawingEngine.startDrawing(screenX, screenY, event);
        }
    });
}

// core-engine.js
// ❌ 削除: setupCanvasEvents() の pointerdown/move/up処理
```

---

### Step 3: 設定参照の統一

**対象ファイル**: 全ファイル

**置換パターン**:
```javascript
// ❌ Before
const size = this.config.pen.size;
const color = this.config.pen.color;

// ✅ After
const size = window.TegakiSettingsManager.get('pen.size');
const color = window.TegakiSettingsManager.get('pen.color');
```

**EventBus連携**:
```javascript
// SettingsManager内で
set(key, value) {
    this.settings[key] = value;
    this.eventBus.emit(`settings:${key}-changed`, { value });
}

// 購読側で
this.eventBus.on('settings:pen-size-changed', ({ value }) => {
    this.updateBrushSize(value);
});
```

---

## 📋 改修チェックリスト

### コア機能
- [ ] DrawingEngine二重実装の解消
- [ ] Pointer Eventsの統合（core-runtime.js に一元化）
- [ ] 座標変換APIの統一
- [ ] 設定参照の統一（SettingsManager経由）

### アーキテクチャ
- [ ] DOM操作の分離（UIRenderer層作成）
- [ ] EventBus統合の完全化
- [ ] API境界の明確化ドキュメント作成

### テスト・検証
- [ ] 描画機能テスト（筆圧・スムージング）
- [ ] レイヤー変形テスト
- [ ] Undo/Redoテスト
- [ ] ポップアップ動作テスト
- [ ] タイムライン・アニメーションテスト

---

## 🎯 改修後の期待効果

### パフォーマンス
- ✅ 不要なコード削除による軽量化
- ✅ イベント処理の一元化による効率化
- ✅ DOM操作の最適化

### 保守性
- ✅ 単一責任原則の徹底
- ✅ API境界の明確化
- ✅ Claude（AI）からの可読性向上

### 機能性
- ✅ 筆圧補正の有効化
- ✅ スムージング（Simplify + Spline）の有効化
- ✅ リアクティブな設定変更

### 拡張性
- ✅ 新規ツール追加が容易
- ✅ プラグイン機構の実装が可能
- ✅ ブックマークレット化がスムーズ

---

## 📖 まとめ

### 現状の評価
- **アーキテクチャ**: 🟡 中程度（部分的に整備済み）
- **見通し**: 🟡 中程度（一部で複雑）
- **保守性**: 🟡 中程度（改善の余地あり）

### 最優先改修項目
1. **DrawingEngine二重実装の解消** - 筆圧・スムージング機能を有効化
2. **Pointer Events統合** - イベント処理を一元化
3. **設定参照の統一** - SettingsManager経由に統一

これらを実施することで、**Claudeからの見通しが大幅に改善**し、今後の機能追加（バケツ塗りつぶし、テキストツール等）がスムーズになります。