# ブラウザお絵かきツール v8.13 - Canvas2D廃止・サムネイル統一改修計画

## 背景と問題点

現状コードベース(v8.13_Drawing_55)でのサムネイル実装：
- layer-panel-renderer.js: generateLayerThumbnailCanvas() で Canvas2D を使用
- timeline-thumbnail-utils.js: generateThumbnail() で Canvas2D を使用
- Canvas2D と PixiJS の DPI/色空間ズレにより、サムネイルが古い情報を表示
- Vモード編集（レイヤー変形）がレイヤーパネルに反映されない
- Vキー反転ショートカットが効いていない

根本原因：
- サムネイル生成が統一されていない（2つの別実装）
- Canvas2D で生成されたサムネイルが、PixiJS 内部の座標系と同期していない
- イベント購読と更新タイミングのズレ

改修方針（v2.2ガイドライン準拠）：
- Canvas2D 完全廃止
- PixiJS renderer.extract.imageBitmap() で統一
- 専用の thumbnail-system.js 作成（責務分離）
- EventBus イベント統合

---

## ファイル構成と現状分析

### 現在の問題コード位置

**layer-panel-renderer.js (69行～：generateLayerThumbnailCanvas)**
```
❌ Canvas2D を使用（ctx.fillStyle, ctx.drawImage等）
❌ 変形適用ロジックがあるが、古い情報を参照
❌ 座標計算で精度ロス
```

**timeline-thumbnail-utils.js (35行～：generateThumbnail)**
```
❌ Canvas2D を使用（thumbCtx.drawImage, putImageData等）
❌ renderer.extract.pixels を使うが、その後 Canvas2D で処理
❌ 二重変換による品質劣化
```

**layer-system.js（既存・継続使用）**
```
✅ requestThumbnailUpdate() で dirty フラグ管理
✅ layer:transform-updated イベント発火
⚠️ サムネイル更新のきっかけを統一する必要あり
```

**drawing-engine.js（既存・継続使用）**
```
✅ 座標系の正確な変換実装
✅ stroke:* イベント発火
✅ currentTool（pen/eraser）管理
⚠️ eraser の反転ロジックが layer:transform との連携不足
```

---

## Phase 1: 統一サムネイル生成システムの構築

### 目的
Canvas2D を廃止し、PixiJS 内部 API で統一されたサムネイル生成を実装

### 新規ファイル: thumbnail-system.js

**責務：**
- renderer.extract.imageBitmap() による高精度サムネイル生成
- サムネイルキャッシュ管理
- 座標系完全一致（DPI/色空間）

**依存：**
- coordinate-system.js（座標系参照のみ）
- event-bus.js（イベント購読）

**主要メソッド：**
```javascript
class ThumbnailSystem {
  constructor(app, coordinateSystem, config)
  
  init(eventBus)                           // 初期化、イベント購読
  
  generateLayerThumbnail(layer, width, height, dpi)
    → Returns: ImageBitmap
    用途：レイヤーパネル個別サムネイル
    処理：
      1. layer を対象に renderer.render({container: layer, target: rt})
      2. renderer.extract.imageBitmap(rt) で取得
      3. 変形済みの座標系が自動反映
  
  generateFrameThumbnail(frame, width, height)
    → Returns: ImageBitmap
    用途：タイムラインサムネイル
    処理：
      1. frame.container 全体をレンダリング
      2. renderer.extract.imageBitmap() で取得
      3. アスペクト比保持でリサイズ
  
  invalidateLayerCache(layerIndex)         // 指定レイヤーのキャッシュクリア
  invalidateFrameCache(frameIndex)         // 指定フレームのキャッシュクリア
  clearAllCache()                          // 全キャッシュクリア
  
  _convertImageBitmapToDataURL(bitmap, canvas)
    → Returns: DataURL (string)
    処理：
      1. canvas に bitmap を drawImage
      2. canvas.toDataURL('image/png')
      3. bitmap リソース破棄
}
```

**初期化順序（core-runtime.js で登録）：**
```
Phase 3: ThumbnailSystem.init(eventBus)
  ↓
  イベント購読：
  - 'layer:transform-updated'  → invalidateLayerCache + updateRequest
  - 'layer:path-added'          → invalidateLayerCache + updateRequest
  - 'layer:stroke-added'        → invalidateLayerCache + updateRequest
  - 'layer:flip-horizontal'     → invalidateLayerCache + updateRequest
  - 'layer:flip-vertical'       → invalidateLayerCache + updateRequest
  - 'animation:frame-updated'   → invalidateFrameCache + updateRequest
  - 'camera:resized'            → clearAllCache + regenerateAll
```

### 改修ファイル: layer-panel-renderer.js

**削除対象：**
- generateLayerThumbnailCanvas() 全体（69行～）
- createThumbnail() 内の Canvas2D ロジック

**新規実装：**
```javascript
async createThumbnail(layer, index, animationSystem) {
  const thumbnail = document.createElement('div');
  thumbnail.className = 'layer-thumbnail';
  
  if (layer.layerData?.isBackground) {
    // 背景レイヤーは従来通り色パッチ表示
    const swatch = document.createElement('div');
    swatch.style.backgroundColor = '#F0E0D6';
    thumbnail.appendChild(swatch);
    return thumbnail;
  }
  
  // ThumbnailSystem から ImageBitmap を取得
  const bitmap = await window.ThumbnailSystem.generateLayerThumbnail(
    layer,
    64,  // 幅
    64   // 高さ
  );
  
  if (bitmap) {
    const img = document.createElement('img');
    img.src = await window.ThumbnailSystem._convertImageBitmapToDataURL(bitmap, ...);
    img.alt = 'Layer thumbnail';
    img.style.objectFit = 'contain';
    thumbnail.appendChild(img);
  }
  
  return thumbnail;
}

_setupEventListeners() {
  // 従来のタイマーベース更新は削除
  // EventBus イベント購読に統一
  
  this.eventBus.on('thumbnail:layer-updated', ({ layerIndex }) => {
    this.updateLayerThumbnail(layerIndex);
  });
  
  this.eventBus.on('thumbnail:regenerate-all', () => {
    this.updateAllThumbnails();
  });
}
```

**改修ファイル詳細：**
- generateLayerThumbnailCanvas() の削除（69行～150行）
- createThumbnail() 簡略化（Canvas2D 計算ロジック削除）
- updateAllThumbnails() での async/await 対応
- _setupEventListeners() のイベント統一

### 改修ファイル: timeline-thumbnail-utils.js

**削除対象：**
- generateThumbnail() 内の Canvas2D ロジック（35行～100行）
- _cloneGraphics() が Graphics 再構築を複雑化

**新規実装：**
```javascript
async generateThumbnail(frame) {
  const cacheKey = `frame_${frame.id}`;
  
  if (this.thumbnailCache.has(cacheKey)) {
    return this.thumbnailCache.get(cacheKey);
  }
  
  // ThumbnailSystem から ImageBitmap を取得
  const bitmap = await window.ThumbnailSystem.generateFrameThumbnail(
    frame,
    150,  // maxWidth
    150   // maxHeight
  );
  
  if (bitmap) {
    const dataURL = await window.ThumbnailSystem._convertImageBitmapToDataURL(bitmap, ...);
    this.thumbnailCache.set(cacheKey, dataURL);
    return dataURL;
  }
  
  return null;
}

_setupCameraTransformListener() {
  // 従来のタイマーベース invalidate を削除
  this.eventBus.on('thumbnail:regenerate-all', () => {
    this._invalidateCache();
    // 非同期で再生成
    setTimeout(() => this.updateAllThumbnails(), 50);
  });
}
```

**改修ファイル詳細：**
- generateThumbnail() 内の renderTexture + pixels + Canvas2D ロジック削除
- _cloneGraphics() の削除（Graphics クローン不要）
- ThumbnailSystem の async インターフェース対応
- キャッシュ戦略の統一

---

## Phase 2: イベント統合と更新トリガー

### 目的
レイヤー変形・ペン描画・消しゴム操作がサムネイルに即座に反映されることを保証

### 改修ファイル: layer-system.js

**追加イベント発火ポイント：**

```javascript
flipActiveLayer(direction) {
  // 既存の反転ロジック...
  
  // 追加：サムネイル更新トリガー
  const activeIndex = this.activeLayerIndex;
  this.requestThumbnailUpdate(activeIndex);
  
  if (this.eventBus) {
    // layer:transform-updated は既存、さらに flip 専用も発火
    this.eventBus.emit('layer:flip-' + direction);
    this.eventBus.emit('thumbnail:layer-updated', { 
      layerIndex: activeIndex,
      layerId: this.getActiveLayer().layerData.id
    });
  }
}

onTransformComplete() {
  // Vキー変形完了時
  
  const layer = this.getActiveLayer();
  const layerIndex = this.activeLayerIndex;
  
  this.requestThumbnailUpdate(layerIndex);
  
  if (this.eventBus) {
    this.eventBus.emit('layer:transform-confirmed', {
      layerId: layer.layerData.id
    });
    
    // サムネイル更新トリガー（同期）
    this.eventBus.emit('thumbnail:layer-updated', {
      layerIndex: layerIndex,
      layerId: layer.layerData.id
    });
  }
  
  if (this.animationSystem?.generateFrameThumbnail) {
    const frameIndex = this.animationSystem.getCurrentFrameIndex();
    setTimeout(() => {
      this.animationSystem.generateFrameThumbnail(frameIndex);
    }, 100);
  }
}

addPathToActiveLayer(path) {
  // 既存のパス追加ロジック...
  
  // 追加：イベント統一
  this.eventBus.emit('layer:stroke-added', {
    layerIndex: this.activeLayerIndex,
    layerId: this.getActiveLayer().layerData.id
  });
  
  // サムネイル即時更新トリガー
  this.eventBus.emit('thumbnail:layer-updated', {
    layerIndex: this.activeLayerIndex,
    layerId: this.getActiveLayer().layerData.id
  });
}
```

### 改修ファイル: drawing-engine.js

**追加イベント発火ポイント：**

```javascript
stopDrawing() {
  // 既存のストローク確定ロジック...
  
  if (this.currentLayer && strokeData.points.length > 0) {
    const layerIndex = this.layerSystem.getLayerIndex(this.currentLayer);
    
    if (this.eventBus) {
      // 既存イベント
      this.eventBus.emit('stroke:finalized', { /* ... */ });
      
      // 追加：サムネイル更新トリガー（座標系完全同期）
      this.eventBus.emit('thumbnail:layer-updated', {
        layerIndex: layerIndex,
        layerId: this.currentLayer.layerData.id,
        tool: this.currentTool
      });
    }
  }
}

setTool(toolName) {
  this.currentTool = toolName;
  
  if (this.eventBus) {
    this.eventBus.emit('tool:changed', { tool: toolName });
    
    // 消しゴムツール切替時にプレビューとサムネイル更新
    if (toolName === 'eraser') {
      const activeLayer = this.layerSystem?.getActiveLayer?.();
      if (activeLayer) {
        const layerIndex = this.layerSystem.getLayerIndex(activeLayer);
        this.eventBus.emit('thumbnail:layer-updated', {
          layerIndex: layerIndex,
          layerId: activeLayer.layerData.id,
          tool: toolName
        });
      }
    }
  }
}
```

### 改修ファイル: layer-transform.js

**追加イベント発火ポイント（既存だが同期を強化）：**

```javascript
toggleMoveMode(layer) {
  // Vキー時の既存ロジック...
  
  if (this.isVKeyPressed) {
    // 終了時
    this.exitMoveMode(layer);
    
    if (this.eventBus) {
      // Vモード終了時の最終更新
      this.eventBus.emit('thumbnail:layer-updated', {
        layerIndex: this.layerManager?.getLayerIndex(layer),
        layerId: layer.layerData?.id
      });
    }
  } else {
    // 開始時
    this.enterMoveMode();
  }
}

updateTransform(layer, property, value) {
  // property: 'x', 'y', 'rotation', 'scaleX', 'scaleY'
  
  // 既存のスライダー更新ロジック...
  
  if (this.eventBus && !this.isDragging) {
    // ドラッグ中でないタイミングで更新（リアルタイムプレビュー用）
    this.eventBus.emit('thumbnail:layer-updated-live', {
      layerIndex: this.layerManager?.getLayerIndex(layer),
      layerId: layer.layerData?.id,
      property: property,
      value: value
    });
  }
}
```

### EventBus イベント名統一

**新規イベル定義（EventBus での発火）：**

| イベント名 | 発行元 | ペイロード | 用途 |
|-----------|--------|-----------|------|
| `thumbnail:layer-updated` | layer-system, drawing-engine, layer-transform | `{ layerIndex, layerId, tool? }` | レイヤーサムネイル更新リクエスト |
| `thumbnail:frame-updated` | animation-system | `{ frameIndex, frameId }` | フレームサムネイル更新リクエスト |
| `thumbnail:regenerate-all` | camera-system (resize) | なし | 全サムネイルキャッシュクリア + 再生成 |
| `thumbnail:layer-updated-live` | layer-transform | `{ layerIndex, layerId, property, value }` | リアルタイムプレビュー用（ドラッグ中） |

---

## Phase 3: 座標系精度テスト・検証

### 目的
Canvas2D 廃止後、サムネイルが正確に描画されることを確認

### テスト項目

**基本座標系テスト（既存テスト、Phase 1-2後の再検証）：**
1. ✅ 初期状態でペン位置と描画位置が一致
2. ✅ ズーム後も描画位置が正確（renderer.extract では DPI自動対応）
3. ✅ パン後も描画位置が正確
4. ✅ レイヤー移動後も描画位置が正確
5. ✅ Canvas resize 後も描画位置が正確
6. ✅ Retina/DPI 環境で描画位置が正確

**サムネイル統一テスト（Phase 1-2新規追加）：**

7. レイヤーサムネイルが最新情報を表示
   - 条件：ペン描画直後、サムネイルパネル確認
   - 期待：サムネイルに新規ストロークが即座に表示
   - 確認方法：layer-panel-renderer の updateLayerThumbnail() で再取得

8. Vモード編集がサムネイルに反映
   - 条件：Vキー → レイヤー回転/移動 → 確認
   - 期待：回転角度がサムネイルに反映
   - 確認方法：renderer.extract で回転行列が自動適用されることを確認

9. レイヤー反転がサムネイルに反映
   - 条件：レイヤー選択 → 反転ボタン押下
   - 期待：サムネイルが左右反転表示
   - 確認方法：scaleX/scaleY が変わり、renderer.extract で自動反映

10. タイムラインサムネイルが最新情報を表示
    - 条件：フレーム追加 → タイムラインパネル確認
    - 期待：タイムラインサムネイルに全レイヤー内容が表示
    - 確認方法：timeline-thumbnail-utils の updateThumbnailForFrame() で再取得

11. Canvas リサイズ後にサムネイル正確
    - 条件：キャンバスサイズ変更 → サムネイルパネル確認
    - 期待：サムネイル内容がリサイズに追従、スケール正確
    - 確認方法：RenderTexture の解像度が正しく適用されることを確認

12. DPI環境でサムネイルがぼやけない
    - 条件：Retina環境で描画 → サムネイル確認
    - 期待：サムネイルがシャープ（1px ズレなし）
    - 確認方法：renderer.extract が devicePixelRatio を自動対応

### テスト実行手順

```
Step 1: ペン描画 → サムネイル確認
  action: 新規レイヤー作成 → ペンツール → 黒線描画
  verify: layer-panel-renderer のサムネイルに黒線が見える

Step 2: Vキーモード → 回転 → キャンセル(Esc) → サムネイル確認
  action: Vキー → ドラッグで回転 → Esc
  verify: サムネイルが回転角度を保持

Step 3: レイヤー反転
  action: レイヤー選択 → 反転ボタン（UI）
  verify: サムネイルが左右反転表示

Step 4: 新規フレーム追加 → タイムラインサムネイル確認
  action: タイムライン上で + ボタン → 新フレーム作成
  verify: timeline-thumbnail-utils が新フレームのサムネイルを生成

Step 5: キャンバスリサイズ
  action: ウィンドウリサイズ、またはメニューでキャンバスサイズ変更
  verify: レイヤーパネルとタイムラインのサムネイルが自動更新
```

### 確認コード（デバッグ用）

```javascript
// Global デバッグ API
window.ThumbnailDebug = {
  // レイヤーサムネイル再生成（強制）
  async regenerateLayer(index) {
    const layers = window.layerManager?.getLayers?.();
    if (layers && layers[index]) {
      const bitmap = await window.ThumbnailSystem.generateLayerThumbnail(
        layers[index], 64, 64
      );
      console.log('✅ Regenerated layer', index, bitmap);
    }
  },
  
  // フレームサムネイル再生成（強制）
  async regenerateFrame(index) {
    const frames = window.animationSystem?.animationData?.cuts;
    if (frames && frames[index]) {
      const bitmap = await window.ThumbnailSystem.generateFrameThumbnail(
        frames[index], 150, 150
      );
      console.log('✅ Regenerated frame', index, bitmap);
    }
  },
  
  // キャッシュ確認
  inspectCache() {
    console.log('Layer cache:', window.ThumbnailSystem.layerThumbnailCache.size);
    console.log('Frame cache:', window.ThumbnailSystem.frameThumbnailCache.size);
  },
  
  // イベント購読確認
  monitorEvents() {
    const bus = window.TegakiEventBus;
    const events = [
      'thumbnail:layer-updated',
      'thumbnail:frame-updated',
      'thumbnail:regenerate-all',
      'layer:transform-updated',
      'layer:stroke-added'
    ];
    events.forEach(evt => {
      bus.on(evt, (data) => {
        console.log(`📡 Event: ${evt}`, data);
      });
    });
  }
};

// 使用例：
// await ThumbnailDebug.regenerateLayer(0);
// ThumbnailDebug.inspectCache();
// ThumbnailDebug.monitorEvents();
```

---

## 実装チェックリスト

### Phase 1: thumbnail-system.js 新規作成
- [ ] ファイル作成（system/drawing/thumbnail-system.js）
- [ ] 全メソッド実装（generateLayerThumbnail, generateFrameThumbnail等）
- [ ] キャッシュ管理（LayerThumbnailCache, FrameThumbnailCache）
- [ ] _convertImageBitmapToDataURL の実装
- [ ] EventBus 初期化と購読セットアップ
- [ ] DPI/解像度対応確認

### Phase 1: layer-panel-renderer.js 改修
- [ ] generateLayerThumbnailCanvas() 全削除
- [ ] createThumbnail() 簡略化（async 対応）
- [ ] _setupEventListeners() 統一
- [ ] updateAllThumbnails() で async 対応
- [ ] 旧 Canvas2D 計算ロジック削除（変形計算も不要）

### Phase 1: timeline-thumbnail-utils.js 改修
- [ ] generateThumbnail() 内の Canvas2D ロジック削除
- [ ] _cloneGraphics() 削除（Graphics 再構築不要）
- [ ] _setupCameraTransformListener() で thumbnail:regenerate-all 購読
- [ ] キャッシュ戦略統一（ThumbnailSystem と同期）

### Phase 2: layer-system.js 改修
- [ ] flipActiveLayer() 内に thumbnail:layer-updated 発火追加
- [ ] onTransformComplete() 内に thumbnail:layer-updated 発火追加
- [ ] addPathToActiveLayer() 内に thumbnail:layer-updated 発火追加
- [ ] EventBus イベント名統一確認

### Phase 2: drawing-engine.js 改修
- [ ] stopDrawing() 内に thumbnail:layer-updated 発火追加
- [ ] setTool() 内に thumbnail:layer-updated 発火追加（eraser 時）
- [ ] 座標系パラメータ名の明示化（localX, localY）

### Phase 2: layer-transform.js 改修
- [ ] toggleMoveMode() に thumbnail:layer-updated 発火追加
- [ ] updateTransform() に thumbnail:layer-updated-live 発火追加（非ドラッグ時）
- [ ] Vキー終了時の最終サムネイル更新確認

### Phase 2: core-runtime.js 改修
- [ ] Phase 3 初期化に ThumbnailSystem.init() 追加
- [ ] 初期化順序確認（LayerSystem → ThumbnailSystem）

### Phase 3: テスト実行
- [ ] ペン描画テスト → サムネイル確認
- [ ] Vモード回転テスト → サムネイル回転反映確認
- [ ] レイヤー反転テスト → サムネイル反転反映確認
- [ ] フレーム追加テスト → タイムラインサムネイル確認
- [ ] キャンバスリサイズテスト → サムネイル自動更新確認
- [ ] DPI 環境テスト → シャープネス確認

---

## 注意点・落とし穴

1. **async/await 対応**
   - generateLayerThumbnail, generateFrameThumbnail は async
   - layer-panel-renderer, timeline-thumbnail-utils で await 処理必須

2. **RenderTexture リソース管理**
   - renderer.extract 実行後は renderTexture.destroy(true) で破棄
   - メモリリーク防止

3. **キャッシュキー設計**
   - layerId + width + height + DPI でキャッシュキー生成
   - DPI変更時は自動キャッシュクリア必須

4. **EventBus イベント統一**
   - 旧イベント名（layer:thumbnail-need-update等）は削除
   - 新統一名（thumbnail:layer-updated）に統一
   - 既存購読 (on) ロジックで漏れなし確認

5. **Canvas2D 完全廃止**
   - generateLayerThumbnailCanvas() 削除時に Canvas2D 計算ロジックも削除
   - 変形（rotation, scale）計算も削除（renderer.extract で自動対応）

---

## ファイル改修サマリ

| ファイル | 改修内容 | 行数 | 新規/改修 |
|---------|--------|------|---------|
| system/drawing/thumbnail-system.js | 統一サムネイル生成システム全実装 | 300-400 | 新規 |
| ui/layer-panel-renderer.js | Canvas2D 廃止、ThumbnailSystem 統合 | -80行 | 改修 |
| ui/timeline-thumbnail-utils.js | Canvas2D 廃止、ThumbnailSystem 統合 | -60行 | 改修 |
| system/layer-system.js | イベント発火ポイント追加（3箇所） | +15行 | 改修 |
| system/drawing/drawing-engine.js | イベント発火ポイント追加（2箇所）、座標系名明示 | +10行 | 改修 |
| system/layer-transform.js | イベント発火ポイント追加（2箇所） | +10行 | 改修 |
| core-runtime.js | Phase 3 初期化追加 | +5行 | 改修 |

**総計：新規 300-400行、改修 全体で-150行（ネット +150行）**

---

## 後続 Claude への指示

このドキュメントを用いて以下を実施してください：

1. **Phase 1 実装**
   - thumbnail-system.js を新規作成（renderer.extract.imageBitmap 実装重視）
   - layer-panel-renderer, timeline-thumbnail-utils から Canvas2D ロジック削除
   - ThumbnailSystem との連携確認

2. **Phase 2 実装**
   - イベント発火ポイントをリストに従い追加
   - EventBus イベント名が統一されたことを確認
   - core-runtime.js で初期化順序確認

3. **Phase 3 テスト**
   - 上記テスト項目を実行
   - ThumbnailDebug コンソール API で検証
   - 各ステップで「✅ サムネイル確認」を実施