================================================================================
Phase 1: RenderTextureマスク基盤構築 - 改修計画書
PixiJS v8.13 Drawing Tool - Eraser Implementation Phase 1
================================================================================

【対象Claude】後続改修担当Claude
【前提知識】PixiJS v8.13 RenderTexture, BlendMode, Container/Graphics API
【所要時間】実装2-3時間、テスト1時間
【難易度】★☆☆

================================================================================
Phase 1 概要
================================================================================

目的: 動作する消しゴム機能の最短実装
方式: RenderTextureベースのマスク（白=表示、黒=非表示）
結果: ペンツールと並行して消しゴムツールが使える状態

実装フロー:
1. LayerModel: マスク初期化/破棄メソッド実装
2. LayerSystem: レイヤー作成時にマスク自動生成
3. DrawingEngine: 消しゴムツールの描画処理統合
4. History: Undo/Redo対応

================================================================================
Step 1: LayerModel マスク管理メソッド実装
================================================================================

ファイル: system/data-models.js
対象: LayerModel class
参照メソッド: destroyMask() (行55付近、既存実装)

────────────────────────────────────────
追加メソッド: initializeMask(width, height, renderer)
────────────────────────────────────────

処理概要:
- RenderTexture.create()でマスクテクスチャ生成
- 白矩形(0xFFFFFF)で全体塗りつぶし → 全表示状態
- PIXI.Sprite(maskTexture)生成
- プロパティ設定

実装ポイント:
```javascript
initializeMask(width, height, renderer) {
    // 既存マスク破棄
    if (this._maskInitialized) this.destroyMask();
    
    // RenderTexture生成
    this.maskTexture = PIXI.RenderTexture.create({ width, height });
    
    // 白矩形で初期化（全表示）
    const whiteRect = new PIXI.Graphics();
    whiteRect.rect(0, 0, width, height).fill({ color: 0xFFFFFF });
    
    // PixiJS v8.13構文
    renderer.render({ 
        container: whiteRect, 
        target: this.maskTexture, 
        clear: true 
    });
    whiteRect.destroy();
    
    // マスクスプライト生成
    this.maskSprite = new PIXI.Sprite(this.maskTexture);
    this.maskSprite.label = 'mask_sprite';
    this._maskInitialized = true;
    
    return true;
}
```

注意事項:
- clear: true で確実に初期化
- 白=表示、黒=非表示の規約
- renderer.render()はv8.13構文使用

────────────────────────────────────────
確認: hasMask()とdestroyMask()は実装済み
────────────────────────────────────────

hasMask(): 行49付近
destroyMask(): 行55付近

これらは既存実装を使用（変更不要）


================================================================================
Step 2: LayerSystem レイヤー作成時のマスク初期化
================================================================================

ファイル: system/layer-system.js
対象: createLayer(), setApp(), deleteLayer()

────────────────────────────────────────
2-1. setApp() - 既存レイヤーへのマスク追加
────────────────────────────────────────

対象メソッド: setApp(app) 行873-882
参照: init()のレイヤー作成パターン

処理概要:
- app.renderer取得確認
- 全レイヤー走査してhasMask()チェック
- 未初期化レイヤーにinitializeMask()実行
- maskSpriteをレイヤーの最初の子（index 0）に追加
- _applyMaskToLayerGraphics()でGraphicsにマスク適用

実装ポイント:
```javascript
setApp(app) {
    this.app = app;
    
    // 既存Transform初期化コード...
    
    // マスク初期化追加
    if (app && app.renderer) {
        const layers = this.getLayers();
        for (const layer of layers) {
            if (layer.layerData && !layer.layerData.hasMask()) {
                const ok = layer.layerData.initializeMask(
                    this.config.canvas.width,
                    this.config.canvas.height,
                    app.renderer
                );
                if (ok && layer.layerData.maskSprite) {
                    layer.addChildAt(layer.layerData.maskSprite, 0);
                    this._applyMaskToLayerGraphics(layer);
                }
            }
        }
    }
}
```

────────────────────────────────────────
2-2. _applyMaskToLayerGraphics() - 新規privateメソッド
────────────────────────────────────────

配置: setApp()の直後に追加

処理概要:
- レイヤー内の全Graphicsにマスク適用
- maskSprite自身とbackgroundGraphicsは除外

実装:
```javascript
_applyMaskToLayerGraphics(layer) {
    if (!layer.layerData?.maskSprite) return;
    
    for (const child of layer.children) {
        // 除外: maskSprite自身とbackground
        if (child === layer.layerData.maskSprite || 
            child === layer.layerData.backgroundGraphics) continue;
        
        if (child instanceof PIXI.Graphics) {
            child.mask = layer.layerData.maskSprite;
        }
    }
}
```

────────────────────────────────────────
2-3. createLayer() - 新規レイヤーのマスク初期化
────────────────────────────────────────

対象メソッド: createLayer(name, isBackground) 行686-738
参照: init()のレイヤー作成パターン

修正箇所: LayerModel作成直後、backgroundGraphics追加前

実装ポイント:
```javascript
createLayer(name, isBackground = false) {
    // LayerModel作成
    const layerModel = new window.TegakiDataModels.LayerModel({
        name: name || `レイヤー${this.currentCutContainer.children.length + 1}`,
        isBackground
    });
    
    // Container作成
    const layer = new PIXI.Container();
    layer.label = layerModel.id;
    layer.layerData = layerModel;
    
    // マスク初期化 ← 追加
    if (this.app?.renderer) {
        const ok = layerModel.initializeMask(
            this.config.canvas.width,
            this.config.canvas.height,
            this.app.renderer
        );
        if (ok && layerModel.maskSprite) {
            layer.addChild(layerModel.maskSprite);
        }
    }
    
    // 既存Transform設定...
    // 既存backgroundGraphics追加...
    
    // History記録修正（undo時のdestroyMask追加）
    const entry = {
        name: 'layer-create',
        do: () => {
            // 既存do処理...
        },
        undo: () => {
            this.currentCutContainer.removeChild(layer);
            layer.layerData?.destroyMask(); // ← 追加
            // 既存undo処理...
        }
    };
    // ...
}
```

────────────────────────────────────────
2-4. deleteLayer() - マスク破棄処理
────────────────────────────────────────

対象メソッド: deleteLayer(layerIndex) 行887-954

修正箇所: Historyのdo/undo

実装ポイント:
```javascript
deleteLayer(layerIndex) {
    // 既存検証処理...
    
    const entry = {
        name: 'layer-delete',
        do: () => {
            layer.layerData?.destroyMask(); // ← 追加
            this.currentCutContainer.removeChild(layer);
            // 既存処理...
        },
        undo: () => {
            // マスク再初期化 ← 追加
            if (layer.layerData && this.app?.renderer) {
                layer.layerData.initializeMask(
                    this.config.canvas.width,
                    this.config.canvas.height,
                    this.app.renderer
                );
                if (layer.layerData.maskSprite) {
                    layer.addChildAt(layer.layerData.maskSprite, 0);
                    this._applyMaskToLayerGraphics(layer);
                }
            }
            this.currentCutContainer.addChildAt(layer, layerIndex);
            // 既存処理...
        }
    };
    // ...
}
```

────────────────────────────────────────
2-5. addPathToActiveLayer() - 新規パスへのマスク適用
────────────────────────────────────────

対象メソッド: addPathToActiveLayer(path) 行241-264
参照: rebuildPathGraphics()

修正箇所: path.graphics生成後、addChild()前

実装ポイント:
```javascript
addPathToActiveLayer(path) {
    const activeLayer = this.getActiveLayer();
    // 既存paths配列追加...
    
    this.rebuildPathGraphics(path);
    
    if (path.graphics) {
        // マスク適用 ← 追加
        if (activeLayer.layerData?.maskSprite) {
            path.graphics.mask = activeLayer.layerData.maskSprite;
        }
        activeLayer.addChild(path.graphics);
    }
    
    // 既存処理...
}
```


================================================================================
Step 3: DrawingEngine 消しゴムツール統合
================================================================================

ファイル: system/drawing/drawing-engine.js
対象: constructor, stopDrawing(), finalizeStroke()

────────────────────────────────────────
3-1. constructor - EraserMaskRenderer初期化
────────────────────────────────────────

対象: constructor(app, layerSystem, cameraSystem, history) 行16-30
参照: strokeRenderer初期化パターン

追加プロパティ:
```javascript
constructor(app, layerSystem, cameraSystem, history) {
    this.app = app;
    this.layerSystem = layerSystem;
    // 既存初期化...
    
    this.strokeRenderer = new StrokeRenderer(app);
    this.eraserRenderer = new EraserMaskRenderer(app); // ← 追加
    
    // 既存プロパティ...
}
```

────────────────────────────────────────
3-2. stopDrawing() - 消しゴム処理分岐
────────────────────────────────────────

対象メソッド: stopDrawing() 行134-165
参照: finalizeStroke()のHistory記録パターン

処理フロー:
1. tool === 'eraser' 判定
2. layerData.hasMask()確認
3. eraserRenderer.renderEraserToMask()実行
4. History記録（before/after snapshot）
5. サムネイル更新

実装ポイント:
```javascript
stopDrawing() {
    if (!this.isDrawing) return;
    
    const strokeData = this.strokeRecorder.endStroke();
    this.clearPreview();
    this.clearEraserPreview();
    const tool = this.currentTool;
    
    // 消しゴム処理分岐 ← 追加
    if (tool === 'eraser' && this.currentLayer && strokeData.points.length > 0) {
        const layerData = this.currentLayer.layerData;
        
        if (layerData?.hasMask?.()) {
            const radius = this.currentSettings.size / 2;
            
            // スナップショット取得
            const beforeSnapshot = this.eraserRenderer.captureMaskSnapshot(layerData);
            
            // マスクに消しゴム描画
            const ok = this.eraserRenderer.renderEraserToMask(
                layerData,
                strokeData.points,
                radius
            );
            
            if (ok) {
                const afterSnapshot = this.eraserRenderer.captureMaskSnapshot(layerData);
                
                // History記録
                const entry = {
                    name: 'Erase',
                    do: async () => {
                        if (afterSnapshot) {
                            await this.eraserRenderer.restoreMaskSnapshot(
                                layerData, 
                                afterSnapshot
                            );
                        }
                        this.layerSystem.requestThumbnailUpdate(
                            this.layerSystem.activeLayerIndex
                        );
                    },
                    undo: async () => {
                        if (beforeSnapshot) {
                            await this.eraserRenderer.restoreMaskSnapshot(
                                layerData, 
                                beforeSnapshot
                            );
                        }
                        this.layerSystem.requestThumbnailUpdate(
                            this.layerSystem.activeLayerIndex
                        );
                    },
                    meta: { 
                        type: 'erase', 
                        layerId: layerData.id, 
                        tool: 'eraser' 
                    }
                };
                
                this.history?.push(entry);
                this.eventBus?.emit('layer:erased', { layerId: layerData.id });
                this.layerSystem.requestThumbnailUpdate(
                    this.layerSystem.activeLayerIndex
                );
            }
        }
    } else {
        // ペンツール: 既存の確定描画
        this.finalizeStroke(strokeData, tool);
    }
    
    // 既存クリーンアップ...
    this.isDrawing = false;
    this.currentLayer = null;
}
```

注意事項:
- History.push()はasync対応必須
- eraserRenderer.captureMaskSnapshot()は既存実装を使用
- eraserRenderer.renderEraserToMask()は既存実装を使用

────────────────────────────────────────
3-3. finalizeStroke() - ペンストロークへのマスク適用
────────────────────────────────────────

対象メソッド: finalizeStroke(strokeData, tool) 行241-258
参照: strokeRenderer.renderFinalStroke()

修正箇所: strokeObject生成後、layer.addChild()前

実装ポイント:
```javascript
finalizeStroke(strokeData, tool = null) {
    // 既存ストローク生成...
    const strokeObject = this.strokeRenderer.renderFinalStroke(
        strokeData, 
        this.currentSettings
    );
    
    // マスク適用 ← 追加
    const layerData = this.currentLayer.layerData;
    if (layerData?.hasMask?.() && layerData.maskSprite) {
        strokeObject.mask = layerData.maskSprite;
    }
    
    // 既存History記録...
    // 既存layer.addChild(strokeObject)...
}
```


================================================================================
Step 4: History async対応確認
================================================================================

ファイル: system/history.js
対象: push(), undo(), redo()

────────────────────────────────────────
確認事項: async/await対応状況
────────────────────────────────────────

チェック項目:
□ push()がasync entryを受け入れるか
□ undo()/redo()がasync entry.do/undoを実行できるか

必要な場合の修正:
```javascript
async undo() {
    if (this.currentIndex < 0) return false;
    const entry = this.entries[this.currentIndex];
    if (entry.undo) {
        await entry.undo(); // ← await追加
    }
    this.currentIndex--;
    return true;
}

async redo() {
    if (this.currentIndex >= this.entries.length - 1) return false;
    this.currentIndex++;
    const entry = this.entries[this.currentIndex];
    if (entry.do) {
        await entry.do(); // ← await追加
    }
    return true;
}
```

注意: 既存のsync entryも動作するようにする（後方互換）


================================================================================
検証手順
================================================================================

コンソールテスト:
```javascript
// 1. システム確認
const ls = window.layerSystem || window.coreEngine?.layerSystem;
console.log('LayerSystem:', ls);

// 2. マスク確認
ls.getLayers().forEach((layer, i) => {
    console.log(`Layer ${i}:`, {
        hasMask: layer.layerData?.hasMask(),
        maskTexture: !!layer.layerData?.maskTexture,
        maskSprite: !!layer.layerData?.maskSprite
    });
});

// 3. 消しゴムツール選択
window.TegakiEventBus?.emit('tool:select', { tool: 'eraser' });

// 4. DrawingEngine確認
const de = window.drawingEngine || window.coreEngine?.drawingEngine;
console.log('Current Tool:', de?.currentTool);
console.log('Eraser Renderer:', de?.eraserRenderer);
```

手動テスト項目:
□ ページリロード後、エラーなく起動
□ 既存レイヤーにマスクが自動作成される
□ 新規レイヤー作成時にマスクが自動作成される
□ ペンツールで描画できる（既存機能維持）
□ 消しゴムツールに切り替えられる
□ 消しゴムで描画した部分が消える
□ 消した部分から下のレイヤーが透けて見える
□ Ctrl+Z でUndo → 消しゴムが復元される
□ Ctrl+Shift+Z でRedo → 再び消える
□ レイヤー削除時にメモリリークなし（destroyMask動作）
□ 複数回の描画・消去を繰り返しても安定動作


================================================================================
トラブルシューティング
================================================================================

問題: マスクが表示されない
→ maskSpriteがaddChildAt(0)されているか確認

問題: 消しゴムで全体が消える
→ initializeMask()で白矩形(0xFFFFFF)塗りつぶし確認

問題: Undo/Redoでエラー
→ History.undo/redoがasync対応しているか確認

問題: メモリリーク
→ destroyMask()でdestroy(true)呼び出し確認

問題: PixiJS APIエラー
→ renderer.render({ container, target })構文使用確認


================================================================================
実装完了チェックリスト
================================================================================

□ Step 1: LayerModel.initializeMask()実装
□ Step 2-1: LayerSystem.setApp()修正
□ Step 2-2: LayerSystem._applyMaskToLayerGraphics()追加
□ Step 2-3: LayerSystem.createLayer()修正
□ Step 2-4: LayerSystem.deleteLayer()修正
□ Step 2-5: LayerSystem.addPathToActiveLayer()修正
□ Step 3-1: DrawingEngine.constructor修正
□ Step 3-2: DrawingEngine.stopDrawing()修正
□ Step 3-3: DrawingEngine.finalizeStroke()修正
□ Step 4: History async対応確認
□ 全コンソールテスト通過
□ 全手動テスト項目通過
□ メモリリークなし


================================================================================
参照ファイル一覧
================================================================================

改修対象:
- system/data-models.js (LayerModel)
- system/layer-system.js (LayerSystem)
- system/drawing/drawing-engine.js (DrawingEngine)
- system/history.js (History - async確認のみ)

既存参照（変更不要）:
- system/drawing/eraser-mask-renderer.js (完全実装済み)
- system/drawing/stroke-renderer.js (パターン参照)
- system/drawing/brush-settings.js (サイズ取得)


================================================================================
以上 Phase 1 改修計画
================================================================================