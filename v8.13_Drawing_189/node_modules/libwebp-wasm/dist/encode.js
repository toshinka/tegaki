import { initBindMap } from "./wasm";
export const encodeRGBA = async (data, width, height, quality = 80) => {
    const { wasmModule, _createBuffer, _encode } = await initBindMap();
    const p = _createBuffer(data.length);
    wasmModule.HEAP8.set(data, p);
    const resultPtr = _encode(p, width, height, quality);
    const resultView = new Uint32Array(wasmModule.HEAPU32.buffer, resultPtr, 2).slice();
    const ptr = resultView[0];
    const ptrLength = resultView[1];
    return new Uint8Array(wasmModule.HEAP8.buffer, ptr, ptrLength).slice();
};
export class Encoder {
    width;
    height;
    enc = 0;
    timestamp_ms = 0;
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    async init() {
        const api = await initBindMap();
        this.enc = api._createEnc(this.width, this.height);
    }
    async addFrame(fileBytes, duration) {
        const api = await initBindMap();
        const p = api._createBuffer(fileBytes.length);
        api.wasmModule.HEAP8.set(fileBytes, p);
        api._addFrame(this.enc, p, fileBytes.length, this.timestamp_ms);
        this.timestamp_ms += duration;
    }
    async save() {
        const api = await initBindMap();
        const r = api._saveEnc(this.enc, this.timestamp_ms);
        const rv = new Uint32Array(api.wasmModule.HEAP32.buffer, r, 2);
        const fileSize = rv[0];
        const filePtr = rv[1];
        const webp = new Uint8Array(api.wasmModule.HEAP8.buffer, filePtr, fileSize);
        return webp;
    }
}
export const encodeFiles = async (fileList, width, height, duration) => {
    const enc = new Encoder(width, height);
    await enc.init();
    for (const f of fileList) {
        enc.addFrame(f, duration);
    }
    return await enc.save();
};
//# sourceMappingURL=encode.js.map