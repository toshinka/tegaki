import { initBindMap } from "./wasm";
import { isWEBP } from "check-image-type";
export const decode = async (data) => {
    if (!isWEBP(data)) {
        throw new Error("decode file is not webp type");
    }
    const { _decode, wasmModule, _createBuffer } = await initBindMap();
    const p = _createBuffer(data.length);
    wasmModule.HEAP8.set(data, p);
    const resultPtr = _decode(p, data.length);
    const rv = new Uint32Array(wasmModule.HEAP32.buffer, resultPtr, 3).slice();
    const frameCount = rv[0];
    const width = rv[1];
    const height = rv[2];
    const rgbaPtrList = new Uint32Array(wasmModule.HEAP8.buffer, resultPtr + 4 * 3, frameCount).slice();
    const timeList = new Uint32Array(wasmModule.HEAP8.buffer, resultPtr + 4 * (3 + frameCount), frameCount).slice();
    const frameBufferSize = width * height * 4;
    const imageDataList = Array.from(rgbaPtrList).map((i) => {
        return new Uint8ClampedArray(wasmModule.HEAP8.buffer, i, frameBufferSize).slice();
    });
    const frameList = [];
    for (let i = 0; i < frameCount; i++) {
        frameList[i] = {
            data: imageDataList[i],
            timestamp: timeList[i],
        };
    }
    return { width, height, frameList };
};
export const getSize = async (data) => {
    if (!isWEBP(data)) {
        throw new Error("decode file is not webp type");
    }
    const { _getSize, wasmModule, _createBuffer } = await initBindMap();
    const p = _createBuffer(data.length);
    wasmModule.HEAP8.set(data, p);
    const resultPtr = _getSize(p, data.length);
    const rv = new Uint32Array(wasmModule.HEAP32.buffer, resultPtr, 2);
    const size = { width: rv[0], height: rv[1] };
    return size;
};
//# sourceMappingURL=decode.js.map