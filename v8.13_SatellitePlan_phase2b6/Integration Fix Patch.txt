// ===== Integration Fix Patch - Phase2b5 Complete Repair =====
// åˆ†å‰²ç‰ˆã®å•é¡Œã‚’ä¿®æ­£ã—ã€å…ƒç‰ˆã®æ©Ÿèƒ½ã‚’å®Œå…¨ç¶™æ‰¿

// === 1. Configçµ±ä¸€ãƒ‘ãƒƒãƒ ===
(function fixConfigReferences() {
    'use strict';
    
    console.log('ğŸ”§ Applying config reference unification patch...');
    
    // TegakiConfig -> TEGAKI_CONFIG çµ±ä¸€
    if (window.TEGAKI_CONFIG && !window.TegakiConfig) {
        window.TegakiConfig = window.TEGAKI_CONFIG;
        console.log('âœ… TegakiConfig reference unified');
    }
    
    // defaultWidth/Height ç¢ºä¿
    if (window.TEGAKI_CONFIG?.canvas) {
        if (!window.TEGAKI_CONFIG.canvas.defaultWidth) {
            window.TEGAKI_CONFIG.canvas.defaultWidth = window.TEGAKI_CONFIG.canvas.width;
        }
        if (!window.TEGAKI_CONFIG.canvas.defaultHeight) {
            window.TEGAKI_CONFIG.canvas.defaultHeight = window.TEGAKI_CONFIG.canvas.height;
        }
    }
})();

// === 2. CoordinateSystem çµ±åˆãƒ‘ãƒƒãƒ ===
(function fixCoordinateSystem() {
    'use strict';
    
    console.log('ğŸ”§ Applying coordinate system integration patch...');
    
    if (window.CoordinateSystem) {
        const originalClass = window.CoordinateSystem;
        
        // å…ƒç‰ˆäº’æ›ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 
        window.CoordinateSystem.prototype.screenToCanvasForDrawing = function(screenX, screenY) {
            // å…ƒç‰ˆã¨åŒã˜åº§æ¨™å¤‰æ›ã‚’å®Ÿè¡Œ
            const canvas = this.app.canvas || this.app.view;
            const rect = canvas.getBoundingClientRect();
            const localX = (screenX - rect.left) * (canvas.width / rect.width);
            const localY = (screenY - rect.top) * (canvas.height / rect.height);
            
            // canvasContainerãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãã‚Œã‚’é€šã—ã¦å¤‰æ›
            const canvasContainer = this._canvasContainer || this.getCanvasContainer?.();
            if (canvasContainer) {
                return canvasContainer.toLocal({ x: localX, y: localY });
            }
            
            return { x: localX, y: localY };
        };
        
        // è¨ºæ–­æ©Ÿèƒ½è¿½åŠ 
        window.CoordinateSystem.diagnoseReferences = function() {
            return {
                worldContainerRef: !!(window.CoordinateSystem._worldContainer || window.CoordinateSystem.getWorldContainer),
                canvasContainerRef: !!(window.CoordinateSystem._canvasContainer || window.CoordinateSystem.getCanvasContainer),
                appRef: !!window.CoordinateSystem._app,
                screenToWorldAvailable: !!window.CoordinateSystem.prototype.screenToWorld,
                screenToCanvasForDrawingAvailable: !!window.CoordinateSystem.prototype.screenToCanvasForDrawing
            };
        };
        
        console.log('âœ… CoordinateSystem integration patch applied');
    }
})();

// === 3. CameraSystem ä¿®æ­£ãƒ‘ãƒƒãƒ ===
(function fixCameraSystem() {
    'use strict';
    
    console.log('ğŸ”§ Applying camera system integration patch...');
    
    if (window.CameraSystem) {
        const originalClass = window.CameraSystem;
        
        // ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã«ä¿®æ­£ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 
        window.CameraSystem.prototype.screenToCanvasForDrawing = function(screenX, screenY) {
            if (this.canvasContainer) {
                const globalPoint = { x: screenX, y: screenY };
                return this.canvasContainer.toLocal(globalPoint);
            }
            
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šCoordinateSystemã‚’ä½¿ç”¨
            if (this.coord && this.coord.screenToCanvasForDrawing) {
                return this.coord.screenToCanvasForDrawing(screenX, screenY);
            }
            
            // æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            const canvas = this.app.canvas || this.app.view;
            const rect = canvas.getBoundingClientRect();
            const localX = screenX - rect.left;
            const localY = screenY - rect.top;
            return { x: localX, y: localY };
        };
        
        // å¢ƒç•Œãƒã‚§ãƒƒã‚¯ä¿®æ­£
        window.CameraSystem.prototype.isPointInExtendedCanvas = function(canvasPoint, margin = 50) {
            const config = window.TEGAKI_CONFIG || window.TegakiConfig;
            if (!config) return true;
            
            const width = config.canvas.defaultWidth || config.canvas.width || 400;
            const height = config.canvas.defaultHeight || config.canvas.height || 400;
            
            return canvasPoint.x >= -margin && 
                   canvasPoint.x <= width + margin &&
                   canvasPoint.y >= -margin && 
                   canvasPoint.y <= height + margin;
        };
        
        console.log('âœ… CameraSystem integration patch applied');
    }
})();

// === 4. DrawingSystem ä¿®æ­£ãƒ‘ãƒƒãƒ ===
(function fixDrawingSystem() {
    'use strict';
    
    console.log('ğŸ”§ Applying drawing system integration patch...');
    
    if (window.DrawingSystem) {
        const originalClass = window.DrawingSystem;
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿äº’æ›æ€§ãƒ‘ãƒƒãƒ
        window.DrawingSystem.prototype.addStrokeToActiveLayer = function(stroke) {
            const activeLayer = this.layerSystem?.getActiveLayer();
            if (!activeLayer) return;
            
            try {
                // å…ƒç‰ˆäº’æ›ã®layerData.pathsæ§‹é€ ã«è¿½åŠ 
                if (!activeLayer.layerData) {
                    activeLayer.layerData = {
                        id: activeLayer.id || activeLayer.label || `layer_${Date.now()}`,
                        name: activeLayer.name || 'Layer',
                        visible: true,
                        opacity: 1.0,
                        paths: []
                    };
                }
                
                if (!activeLayer.layerData.paths) {
                    activeLayer.layerData.paths = [];
                }
                
                // strokeã‚’pathå½¢å¼ã«å¤‰æ›ã—ã¦è¿½åŠ 
                const pathData = {
                    id: stroke.id,
                    points: [...stroke.points],
                    color: stroke.color,
                    size: stroke.size,
                    opacity: stroke.opacity,
                    isComplete: stroke.isComplete,
                    graphics: stroke.graphics
                };
                
                activeLayer.layerData.paths.push(pathData);
                
                // ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
                if (activeLayer.addChild && stroke.graphics) {
                    activeLayer.addChild(stroke.graphics);
                }
                
            } catch (error) {
                console.error('DrawingSystem stroke addition failed:', error);
            }
        };
        
        // APIçµ±ä¸€ãƒ‘ãƒƒãƒ
        if (window.DrawingSystem.prototype.startStroke && !window.DrawingSystem.prototype.startDrawing) {
            window.DrawingSystem.prototype.startDrawing = window.DrawingSystem.prototype.startStroke;
        }
        if (window.DrawingSystem.prototype.continueStroke && !window.DrawingSystem.prototype.continueDrawing) {
            window.DrawingSystem.prototype.continueDrawing = window.DrawingSystem.prototype.continueStroke;
        }
        if (window.DrawingSystem.prototype.endStroke && !window.DrawingSystem.prototype.endDrawing) {
            window.DrawingSystem.prototype.endDrawing = window.DrawingSystem.prototype.endStroke;
        }
        
        console.log('âœ… DrawingSystem integration patch applied');
    }
})();

// === 5. LayerSystem ä¿®æ­£ãƒ‘ãƒƒãƒ ===
(function fixLayerSystem() {
    'use strict';
    
    console.log('ğŸ”§ Applying layer system integration patch...');
    
    if (window.LayerSystem) {
        const originalClass = window.LayerSystem;
        
        // å…ƒç‰ˆäº’æ›ã®createLayerä¿®æ­£
        window.LayerSystem.prototype.createLayer = function(name, isBackground = false) {
            try {
                const layer = new PIXI.Container();
                const layerId = `layer_${this.layerCounter || 0}`;
                this.layerCounter = (this.layerCounter || 0) + 1;
                
                layer.label = layerId;
                layer.layerData = {
                    id: layerId,
                    name: name,
                    visible: true,
                    opacity: 1.0,
                    isBackground: isBackground,
                    paths: []
                };

                // layerTransformsåˆæœŸåŒ–
                if (!this.layerTransforms) {
                    this.layerTransforms = new Map();
                }
                this.layerTransforms.set(layerId, {
                    x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1
                });

                if (isBackground) {
                    const config = window.TEGAKI_CONFIG || window.TegakiConfig || { canvas: { width: 400, height: 400 }, background: { color: 0xf0e0d6 } };
                    const bg = new PIXI.Graphics();
                    bg.rect(0, 0, config.canvas.width, config.canvas.height);
                    bg.fill(config.background.color);
                    layer.addChild(bg);
                    layer.layerData.backgroundGraphics = bg;
                }

                if (!this.layers) this.layers = [];
                this.layers.push(layer);
                
                if (this.layersContainer) {
                    this.layersContainer.addChild(layer);
                }

                return { layer, index: this.layers.length - 1 };
                
            } catch (error) {
                console.error('LayerSystem.createLayer failed:', error);
                return null;
            }
        };
        
        // getActiveLayerç¢ºä¿
        if (!window.LayerSystem.prototype.getActiveLayer) {
            window.LayerSystem.prototype.getActiveLayer = function() {
                if (!this.layers || this.activeLayerIndex < 0 || this.activeLayerIndex >= this.layers.length) {
                    return null;
                }
                return this.layers[this.activeLayerIndex];
            };
        }
        
        // setActiveLayerç¢ºä¿
        if (!window.LayerSystem.prototype.setActiveLayer) {
            window.LayerSystem.prototype.setActiveLayer = function(index) {
                if (index >= 0 && index < this.layers.length) {
                    this.activeLayerIndex = index;
                    if (this.updateLayerPanelUI) this.updateLayerPanelUI();
                    if (this.updateStatusDisplay) this.updateStatusDisplay();
                }
            };
        }
        
        // ã‚µãƒ ãƒã‚¤ãƒ«æ›´æ–°ç¢ºä¿
        if (!window.LayerSystem.prototype.requestThumbnailUpdate) {
            window.LayerSystem.prototype.requestThumbnailUpdate = function(index) {
                if (!this.thumbnailUpdateQueue) this.thumbnailUpdateQueue = new Set();
                this.thumbnailUpdateQueue.add(index);
            };
        }
        
        if (!window.LayerSystem.prototype.processThumbnailUpdates) {
            window.LayerSystem.prototype.processThumbnailUpdates = function() {
                if (!this.thumbnailUpdateQueue || this.thumbnailUpdateQueue.size === 0) return;
                
                this.thumbnailUpdateQueue.forEach(layerIndex => {
                    console.log(`Processing thumbnail for layer: ${layerIndex}`);
                    // å®Ÿéš›ã®ã‚µãƒ ãƒã‚¤ãƒ«å‡¦ç†ã¯çœç•¥ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®ï¼‰
                });
                this.thumbnailUpdateQueue.clear();
            };
        }
        
        console.log('âœ… LayerSystem integration patch applied');
    }
})();

// === 6. UIçµ±åˆãƒ‘ãƒƒãƒ ===
(function fixUIIntegration() {
    'use strict';
    
    console.log('ğŸ”§ Applying UI integration patch...');
    
    // TegakiUIçµ±åˆç¢ºä¿
    if (!window.TegakiUI) {
        window.TegakiUI = {};
    }
    
    // updateLayerPanelUI åŸºæœ¬å®Ÿè£…
    if (!window.TegakiUI.updateLayerPanelUI) {
        window.TegakiUI.updateLayerPanelUI = function(layerManager) {
            const layerList = document.getElementById('layer-list');
            if (!layerList || !layerManager.layers) return;

            layerList.innerHTML = '';

            for (let i = layerManager.layers.length - 1; i >= 0; i--) {
                const layer = layerManager.layers[i];
                const layerItem = document.createElement('div');
                layerItem.className = `layer-item ${i === layerManager.activeLayerIndex ? 'active' : ''}`;
                layerItem.dataset.layerId = layer.layerData?.id || layer.label;
                layerItem.dataset.layerIndex = i;

                layerItem.innerHTML = `
                    <div class="layer-visibility ${layer.layerData?.visible !== false ? '' : 'hidden'}">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            ${layer.layerData?.visible !== false ? 
                                '<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>' :
                                '<path d="m15 18-.722-3.25"/><path d="m2 2 20 20"/>'}
                        </svg>
                    </div>
                    <div class="layer-opacity">100%</div>
                    <div class="layer-name">${layer.layerData?.name || 'Layer'}</div>
                    <div class="layer-thumbnail">
                        <div class="layer-thumbnail-placeholder"></div>
                    </div>
                `;

                layerItem.addEventListener('click', () => {
                    layerManager.setActiveLayer(i);
                });

                layerList.appendChild(layerItem);
            }
        };
    }
    
    // initializeSortable åŸºæœ¬å®Ÿè£…
    if (!window.TegakiUI.initializeSortable) {
        window.TegakiUI.initializeSortable = function(layerManager) {
            const layerList = document.getElementById('layer-list');
            if (!layerList || !window.Sortable) return;

            const sortable = window.Sortable.create(layerList, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                chosenClass: 'sortable-chosen',
                dragClass: 'sortable-drag',
                onEnd: function (evt) {
                    const oldIndex = layerManager.layers.length - 1 - evt.newIndex;
                    const newIndex = layerManager.layers.length - 1 - evt.oldIndex;
                    
                    if (oldIndex !== newIndex && layerManager.layers) {
                        // ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åºå¤‰æ›´
                        const [movedLayer] = layerManager.layers.splice(oldIndex, 1);
                        layerManager.layers.splice(newIndex, 0, movedLayer);
                        
                        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹èª¿æ•´
                        if (layerManager.activeLayerIndex === oldIndex) {
                            layerManager.activeLayerIndex = newIndex;
                        } else if (layerManager.activeLayerIndex === newIndex) {
                            layerManager.activeLayerIndex = oldIndex;
                        }
                        
                        layerManager.updateLayerPanelUI();
                    }
                }
            });
        };
    }
    
    console.log('âœ… UI integration patch applied');
})();

// === 7. CoreEngineçµ±åˆå¼·åŒ–ãƒ‘ãƒƒãƒ ===
(function enhanceCoreEngineIntegration() {
    'use strict';
    
    console.log('ğŸ”§ Applying core engine integration enhancement...');
    
    // CoreEngineåˆæœŸåŒ–æ™‚ã®ç›¸äº’å‚ç…§å¼·åŒ–
    if (window.TegakiCore?.CoreEngine) {
        const originalInitialize = window.TegakiCore.CoreEngine.prototype.initialize;
        
        window.TegakiCore.CoreEngine.prototype.initialize = function() {
            console.log('Enhanced CoreEngine initialization...');
            
            // å…ƒã®åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
            const result = originalInitialize.call(this);
            
            // è¿½åŠ ã®çµ±åˆå‡¦ç†
            try {
                // LayerManagerã«APIç¢ºä¿
                if (this.layerManager) {
                    if (!this.layerManager.updateLayerPanelUI && window.TegakiUI.updateLayerPanelUI) {
                        this.layerManager.updateLayerPanelUI = () => window.TegakiUI.updateLayerPanelUI(this.layerManager);
                    }
                    
                    if (!this.layerManager.updateStatusDisplay) {
                        this.layerManager.updateStatusDisplay = () => {
                            const statusElement = document.getElementById('current-layer');
                            if (statusElement && this.layerManager.activeLayerIndex >= 0) {
                                const layer = this.layerManager.layers[this.layerManager.activeLayerIndex];
                                statusElement.textContent = layer.layerData?.name || 'Layer';
                            }
                        };
                    }
                }
                
                // DrawingSystemã«ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ ãƒ­ã‚¸ãƒƒã‚¯å¼·åŒ–
                if (this.drawingEngine && this.drawingEngine.addStrokeToActiveLayer) {
                    const originalAddStroke = this.drawingEngine.addStrokeToActiveLayer;
                    this.drawingEngine.addStrokeToActiveLayer = function(stroke) {
                        const result = originalAddStroke.call(this, stroke);
                        // ã‚µãƒ ãƒã‚¤ãƒ«æ›´æ–°ã‚‚ç¢ºå®Ÿã«å®Ÿè¡Œ
                        if (this.layerSystem && this.layerSystem.requestThumbnailUpdate) {
                            this.layerSystem.requestThumbnailUpdate(this.layerSystem.activeLayerIndex);
                        }
                        return result;
                    };
                }
                
                console.log('âœ… Enhanced CoreEngine integration completed');
                
            } catch (error) {
                console.warn('CoreEngine enhancement failed:', error);
            }
            
            return result;
        };
    }
})();

// === ãƒ‘ãƒƒãƒé©ç”¨å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ===
console.log('ğŸ‰ Integration Fix Patch Applied Successfully!');
console.log('ğŸ“‹ Applied fixes:');
console.log('  âœ… Config reference unification (TegakiConfig â†” TEGAKI_CONFIG)');
console.log('  âœ… CoordinateSystem integration (screenToCanvasForDrawing)');
console.log('  âœ… CameraSystem coordinate fixes');
console.log('  âœ… DrawingSystem layer data compatibility');
console.log('  âœ… LayerSystem API completion');
console.log('  âœ… UI integration enhancements');
console.log('  âœ… CoreEngine cross-reference strengthening');
console.log('ğŸš€ Phase2b5 should now behave like Phase1b4!');