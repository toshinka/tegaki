
ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ã‚’åˆ†æã—ãŸçµæœã€ãƒšãƒ³æç”»ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§ãŒå¤±ã‚ã‚Œã¦ã„ã‚‹ä¸»è¦åŸå› ã‚’ç‰¹å®šã—ã¾ã—ãŸã€‚
ğŸ”´ ä¸»è¦å•é¡Œç‚¹

    stroke-renderer.js: renderStroke()ãŒå®Œæˆã—ãŸã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã—ã‹æç”»ã—ã¦ã„ãªã„
    drawing-engine.js: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿæ§‹ãŒå­˜åœ¨ã—ãªã„
    ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼: stroke:pointæ™‚ã«ä½•ã‚‚æç”»æ›´æ–°ã—ã¦ã„ãªã„

âœ… è§£æ±ºæ–¹é‡

ã€Œç¢ºå®šå‰ã®è»½é‡ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€ã¨ã€Œç¢ºå®šå¾Œã®é«˜å“è³ªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã€ã®2æ®µéšæç”»ã‚’æ˜ç¢ºã«åˆ†é›¢ã—ã¾ã™ã€‚


ğŸ¯ ãƒšãƒ³æç”»ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ–°è¨ˆç”»æ›¸
ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åŸå‰‡

ã€åº§æ¨™ç³»çµ±ä¸€ã€‘
å…¥åŠ›(screen) â†’ camera-system(å¤‰æ›) â†’ ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ â†’ æç”»ãƒ»ä¿å­˜

ã€ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã€‘
PointerEvent â†’ StrokeRecorder(è¨˜éŒ²) â†’ DrawingEngine(åˆ¶å¾¡) 
            â†’ StrokeRenderer(æç”») â†’ History(ä¿å­˜)

ã€è²¬å‹™åˆ†é›¢ã€‘
- StrokeRecorder: åº§æ¨™ãƒ»åœ§åŠ›ã®è¨˜éŒ²ã®ã¿
- PressureHandler: åœ§åŠ›è£œæ­£ã®ã¿
- StrokeRenderer: æç”»å®Ÿè¡Œã®ã¿
- DrawingEngine: ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ãƒ»PIXIçµ±åˆ

Phase 1: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å¾©æ—§ï¼ˆæœ€å„ªå…ˆï¼‰
ç›®æ¨™

ãƒã‚¤ãƒ³ã‚¿ãƒ¼ç§»å‹•æ™‚ã«å³åº§ã«ç·šãŒè¦‹ãˆã‚‹çŠ¶æ…‹ã«æˆ»ã™
å®Ÿè£…å†…å®¹
1.1 DrawingEngineæ”¹ä¿®
javascript

class DrawingEngine {
  constructor() {
    this.currentPreview = null; // PIXI.Graphicsï¼ˆè»½é‡ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ï¼‰
    this.isDrawing = false;
  }

  // stroke:pointæ™‚ã«å‘¼ã°ã‚Œã‚‹
  updatePreview(points, color, size) {
    if (!this.currentPreview) {
      this.currentPreview = new PIXI.Graphics();
      this.currentLayer.addChild(this.currentPreview);
    }
    
    // å‰ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ã‚¯ãƒªã‚¢
    this.currentPreview.clear();
    
    // ã‚·ãƒ³ãƒ—ãƒ«ãªlineStyleæç”»ï¼ˆé«˜é€Ÿï¼‰
    this.currentPreview.lineStyle({
      width: size,
      color: color,
      cap: PIXI.LINE_CAP.ROUND,
      join: PIXI.LINE_JOIN.ROUND
    });
    
    if (points.length === 1) {
      // å˜ç‹¬ç‚¹ã¯å††
      this.currentPreview.drawCircle(points[0].x, points[0].y, size / 2);
    } else {
      // è¤‡æ•°ç‚¹ã¯ç·š
      this.currentPreview.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        this.currentPreview.lineTo(points[i].x, points[i].y);
      }
    }
  }

  // stroke:endæ™‚ã«å‘¼ã°ã‚Œã‚‹
  finalizeStroke(strokeData) {
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å‰Šé™¤
    if (this.currentPreview) {
      this.currentPreview.destroy();
      this.currentPreview = null;
    }
    
    // é«˜å“è³ªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆPhase 2ã§å®Ÿè£…ï¼‰
    this.strokeRenderer.renderFinalStroke(strokeData);
  }
}

1.2 EventBusé€£æºä¿®æ­£
javascript

// drawing-engine.jså†…
EventBus.on('stroke:point', ({ points, settings }) => {
  this.updatePreview(points, settings.color, settings.size);
});

EventBus.on('stroke:end', ({ strokeData }) => {
  this.finalizeStroke(strokeData);
});

æ¤œè¨¼é …ç›®

    ãƒã‚¤ãƒ³ã‚¿ãƒ¼ç§»å‹•æ™‚ã«å³åº§ã«ç·šãŒè¡¨ç¤ºã•ã‚Œã‚‹
    60FPSä»¥ä¸Šã‚’ç¶­æŒï¼ˆChrome DevTools Performanceï¼‰
    ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãªã—ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‰Šé™¤ç¢ºèªï¼‰

Phase 2: åœ§åŠ›ã‚·ã‚¹ãƒ†ãƒ åŸºç›¤æ•´å‚™
2.1 PressureHandlerç´”åŒ–

å½¹å‰²: ç”Ÿåœ§åŠ›å€¤ã®è£œæ­£ã®ã¿
javascript

class PressureHandler {
  constructor() {
    this.baseline = 0;
    this.baselineSamples = [];
    this.BASELINE_SAMPLE_COUNT = 5;
  }

  // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯é–‹å§‹æ™‚ã«å‘¼ã¶
  startStroke() {
    this.baseline = 0;
    this.baselineSamples = [];
  }

  // ç”Ÿåœ§åŠ›ã‚’è£œæ­£åœ§åŠ›ã«å¤‰æ›
  getCalibratedPressure(rawPressure) {
    // baselineç®—å‡ºä¸­
    if (this.baselineSamples.length < this.BASELINE_SAMPLE_COUNT) {
      this.baselineSamples.push(rawPressure);
      
      if (this.baselineSamples.length === this.BASELINE_SAMPLE_COUNT) {
        this.baseline = Math.min(...this.baselineSamples);
      }
      
      return 0; // baselineç®—å‡ºä¸­ã¯0ã‚’è¿”ã™
    }

    // baselineè£œæ­£
    const calibrated = Math.max(0, rawPressure - this.baseline) / (1 - this.baseline);
    return Math.min(1, calibrated);
  }
}

2.2 StrokeRecorderç´”åŒ–

å½¹å‰²: åº§æ¨™ãƒ»åœ§åŠ›ãƒ»æ™‚åˆ»ã®è¨˜éŒ²ã®ã¿
javascript

class StrokeRecorder {
  constructor(pressureHandler) {
    this.pressureHandler = pressureHandler;
    this.points = [];
  }

  startStroke(screenX, screenY, rawPressure) {
    this.points = [];
    this.pressureHandler.startStroke();
    
    // ã‚«ãƒ¡ãƒ©å¤‰æ›ï¼ˆcamera-system.jsã‚’ä½¿ç”¨ï¼‰
    const localPoint = cameraSystem.screenToLayer(screenX, screenY);
    
    this.addPoint(localPoint.x, localPoint.y, rawPressure);
  }

  addPoint(screenX, screenY, rawPressure) {
    const localPoint = cameraSystem.screenToLayer(screenX, screenY);
    const pressure = this.pressureHandler.getCalibratedPressure(rawPressure);
    
    this.points.push({
      x: localPoint.x,
      y: localPoint.y,
      pressure: pressure,
      time: performance.now()
    });
  }

  endStroke() {
    return {
      points: [...this.points],
      isSingleDot: this.points.length <= 2 && this.getTotalDistance() < 2
    };
  }

  getTotalDistance() {
    let dist = 0;
    for (let i = 1; i < this.points.length; i++) {
      const dx = this.points[i].x - this.points[i-1].x;
      const dy = this.points[i].y - this.points[i-1].y;
      dist += Math.sqrt(dx * dx + dy * dy);
    }
    return dist;
  }
}

Phase 3: é«˜å“è³ªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆperfect-freehandï¼‰
3.1 StrokeRendererå®Œå…¨æ›¸ãç›´ã—
javascript

class StrokeRenderer {
  constructor(resolution) {
    this.resolution = resolution;
    this.minPhysicalWidth = 1 / resolution; // devicePixelRatioå¯¾å¿œ
  }

  // ç¢ºå®šã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã®æç”»ï¼ˆMeshæ–¹å¼ï¼‰
  renderFinalStroke(strokeData, settings) {
    if (strokeData.isSingleDot) {
      return this.renderDot(strokeData.points[0], settings);
    }

    // perfect-freehandç”¨ã«å¤‰æ›
    const pfPoints = strokeData.points.map(p => [p.x, p.y, p.pressure]);
    
    const outline = getStroke(pfPoints, {
      size: settings.size,
      thinning: 0,
      smoothing: 0.5,
      streamline: 0.5,
      simulatePressure: false
    });

    return this.createMeshFromOutline(outline, settings.color);
  }

  renderDot(point, settings) {
    const graphics = new PIXI.Graphics();
    const radius = Math.max(this.minPhysicalWidth, settings.size * point.pressure / 2);
    
    graphics.beginFill(settings.color);
    graphics.drawCircle(point.x, point.y, radius);
    graphics.endFill();
    
    return graphics;
  }

  createMeshFromOutline(outline, color) {
    const vertices = [];
    const uvs = [];
    const indices = [];

    // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³â†’ä¸‰è§’ãƒ¡ãƒƒã‚·ãƒ¥å¤‰æ›
    for (let i = 0; i < outline.length; i++) {
      vertices.push(outline[i][0], outline[i][1]);
      uvs.push(i / outline.length, 0);
    }

    // Triangle strip indices
    for (let i = 0; i < outline.length - 1; i++) {
      indices.push(i, i + 1);
    }

    const geometry = new PIXI.Geometry()
      .addAttribute('aVertexPosition', vertices, 2)
      .addAttribute('aUvs', uvs, 2)
      .addIndex(indices);

    const mesh = new PIXI.Mesh({ geometry });
    mesh.tint = color;

    return mesh;
  }
}
```

---

## ã‚·ãƒ³ãƒœãƒ«ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰è¾å…¸

### åº§æ¨™ç³»å¤‰æ›
```
screenToLayer(screenX, screenY) â†’ {x, y}  // camera-system.js
```

### EventBuså®šç¾©
```
stroke:start  â†’ { layerId, settings }
stroke:point  â†’ { points, settings }
stroke:end    â†’ { strokeData, settings }

ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
javascript

// StrokeData (data-models.js)
{
  points: [{x, y, pressure, time}],
  isSingleDot: boolean,
  color: number,
  size: number,
  layerId: string
}

BrushSettings (brush-settings.js)
javascript

{
  size: number,          // åŸºæº–ã‚µã‚¤ã‚º
  color: number,         // 0xRRGGBB
  minPhysicalWidth: number  // æœ€å°ç‰©ç†å¹…
}
```

---

## å®Ÿè£…é †åº
```
Day 1: Phase 1 ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å¾©æ—§
  â”œâ”€ DrawingEngine.updatePreview() å®Ÿè£…
  â”œâ”€ EventBusé€£æºä¿®æ­£
  â””â”€ å‹•ä½œç¢ºèªï¼ˆç·šãŒå³åº§ã«å¼•ã‘ã‚‹ï¼‰

Day 2: Phase 2 åœ§åŠ›ã‚·ã‚¹ãƒ†ãƒ æ•´ç†
  â”œâ”€ PressureHandlerç´”åŒ–
  â”œâ”€ StrokeRecorderç´”åŒ–
  â””â”€ baselineå‹•ä½œç¢ºèª

Day 3: Phase 3 perfect-freehandçµ±åˆ
  â”œâ”€ CDNè¿½åŠ ï¼ˆindex.htmlï¼‰
  â”œâ”€ StrokeRendereræ›¸ãç›´ã—
  â”œâ”€ Meshæç”»ç¢ºèª
  â””â”€ å˜ç‹¬ç‚¹æç”»ç¢ºèª

å‰Šé™¤ã™ã¹ãäºŒé‡å®Ÿè£…

    stroke-renderer.jsã®å¤ã„Graphics.lineStyle()æç”»ã‚³ãƒ¼ãƒ‰
    drawing-engine.jså†…ã®åº§æ¨™å¤‰æ›ï¼ˆcamera-systemã«çµ±ä¸€ï¼‰
    è¤‡æ•°ç®‡æ‰€ã«ã‚ã‚‹devicePixelRatioè¨ˆç®—
