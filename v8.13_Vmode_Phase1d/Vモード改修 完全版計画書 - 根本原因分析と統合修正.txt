# Vモード改修 完全版計画書 - 根本原因分析と統合修正

**対象バージョン**: v8.13_Vmode_Phase1c  
**作成日**: 2025-10-22  
**重要度**: 🔴 最優先 - システム全体の連携不整合  

---

## 🚨 根本的問題の発見

### 問題の本質
現行の改修計画書は**layer-system.js と layer-transform.js のみ**に着目していましたが、実際には以下の**システム全体の連携不整合**が発生しています:

1. **Vキーイベントフローの断絶**: keyboard-handler → layer-system → layer-transform の連携が二重化
2. **変形確定処理の欠落**: `onRebuildRequired` コールバックが未設定のため Graphics が再構築されない
3. **座標系の不一致**: camera-system の vKeyPressed 状態と layer-transform の isVKeyPressed が非同期
4. **カーソル管理の競合**: camera-system と layer-transform が独立してカーソルを制御
5. **イベントバス統合の不完全**: Vモード関連イベントが config.js のキーマップと不整合

---

## 📊 現状のシステム連携調査結果

### Vキーイベントフロー（現状）

```
[keyboard-handler.js]
  ↓ keydown 'KeyV' 検出
  ↓ eventBus.emit('keyboard:vkey-pressed')
  ↓
[layer-system.js]
  ↓ eventBus.on('keyboard:vkey-pressed')
  ↓ transform.enterMoveMode() / exitMoveMode()
  ↓
[layer-transform.js]
  ↓ isVKeyPressed = true/false
  ↓ cameraSystem.setVKeyPressed(true/false) ← ここで camera-system に通知
  ↓
[camera-system.js]
  ↓ vKeyPressed = true/false
  ↓ _emitCursorUpdate() ← カーソル更新
```

**問題点**: 
- keyboard-handler.js が独自に vKeyPressed 状態を保持（二重管理）
- layer-system.js の `_setupVKeyEvents()` でトグル処理を実装（責務の混在）
- camera-system.js の Hキーハンドラーと layer-transform.js の Hキーハンドラーが競合

### 変形確定フロー（現状）

```
[layer-system.js]
  ↓ exitMoveMode() 呼び出し
  ↓
[layer-transform.js]
  ↓ exitMoveMode(activeLayer)
  ↓ confirmTransform(layer) は呼ばれていない！
```

**根本原因**:
- `layer-transform.js:exitMoveMode()` は状態変更のみで確定処理を実行しない
- `layer-system.js:exitMoveMode()` も `confirmTransform()` を呼んでいない
- PHASE 1 で追加予定の `onRebuildRequired` コールバックが未設定

### 反転機能フロー（現状）

```
[layer-transform.js]
  ↓ _setupFlipKeyEvents() - Hキー検出
  ↓ onFlipRequest('horizontal')
  ↓
[layer-system.js]
  ↓ initTransform() で onFlipRequest コールバック設定
  ↓ this.flipActiveLayer(direction)
  ↓
[layer-transform.js]
  ↓ flipLayer(layer, direction)
  ✓ 動作するはず
```

**問題点**:
- `layer-system.js:initTransform()` の実行タイミングが不明確
- `transform.app` が未設定の場合に `onFlipRequest` が null のまま

---

## 🎯 改修方針の再定義

### 設計原則

1. **単一責任の原則 (SRP)**
   - keyboard-handler: キー入力の検出とイベント発火のみ
   - layer-system: レイヤー管理とビジネスロジック
   - layer-transform: 変形計算とUI制御
   - camera-system: カメラ制御とカーソル管理

2. **イベント駆動アーキテクチャ**
   - 全ての状態変更を EventBus 経由で通知
   - 直接的なメソッド呼び出しを最小化

3. **初期化順序の明確化**
   - core-engine.js で依存関係を明示的に解決
   - LayerTransform の初期化を setupCrossReferences() で確実に実行

---

## 🔧 修正計画（優先度順）

### PHASE 0: 初期化フロー修正 🔴 **最優先**

**目的**: LayerTransform のコールバック設定を確実に実行

**修正ファイル**: `core-engine.js`

```javascript
// setupCrossReferences() 内で LayerTransform を確実に初期化

setupCrossReferences() {
    this.cameraSystem.setLayerManager(this.layerSystem);
    this.cameraSystem.setDrawingEngine(this.drawingEngine);
    
    this.layerSystem.setCameraSystem(this.cameraSystem);
    this.layerSystem.setApp(this.app);
    
    // 🔥 追加: LayerTransform の確実な初期化
    if (this.layerSystem.transform) {
        if (!this.layerSystem.transform.app) {
            this.layerSystem.initTransform();
        }
    }
    
    this.clipboardSystem.setLayerManager(this.layerSystem);
}
```

**影響**:
- ✅ `onFlipRequest` が確実に設定される
- ✅ `onRebuildRequired` などの新規コールバックも設定可能
- ✅ 初期化順序のエラーを防止

---

### PHASE 1: 変形確定処理修正 🔴 **最優先**

**目的**: Vモード終了時に変形を確実に反映

**修正ファイル**: `layer-system.js`, `layer-transform.js`

#### 1-1. layer-transform.js: exitMoveMode() 修正

**現状の問題**: exitMoveMode() が状態変更のみで確定処理を実行しない

```javascript
// 修正前
exitMoveMode(activeLayer) {
    if (!this.isVKeyPressed) return;
    
    this.isVKeyPressed = false;
    this.isDragging = false;
    
    if (this.cameraSystem?.setVKeyPressed) {
        this.cameraSystem.setVKeyPressed(false);
        this.cameraSystem.hideGuideLines();
    }
    
    if (this.transformPanel) {
        this.transformPanel.classList.remove('show');
    }
    
    this._updateCursor();
}

// 修正後
exitMoveMode(activeLayer) {
    if (!this.isVKeyPressed) return;
    
    // 🔥 追加: Vモード終了前に変形確定
    if (activeLayer && this._isTransformNonDefault(this.transforms.get(activeLayer.layerData?.id))) {
        this.confirmTransform(activeLayer);
    }
    
    this.isVKeyPressed = false;
    this.isDragging = false;
    
    if (this.cameraSystem?.setVKeyPressed) {
        this.cameraSystem.setVKeyPressed(false);
        this.cameraSystem.hideGuideLines();
    }
    
    if (this.transformPanel) {
        this.transformPanel.classList.remove('show');
    }
    
    this._updateCursor();
}
```

#### 1-2. layer-system.js: initTransform() に onRebuildRequired 追加

**既存の confirmTransform() の処理を onRebuildRequired に移行**

```javascript
initTransform() {
    if (!this.transform || !this.app) return;
    
    this.transform.init(this.app, this.cameraSystem);
    
    // 🔥 追加: Graphics リビルドコールバック
    this.transform.onRebuildRequired = (layer, transformedPaths) => {
        const success = this.safeRebuildLayer(layer, transformedPaths);
        
        if (success) {
            this.requestThumbnailUpdate(this.getLayerIndex(layer));
            
            if (this.animationSystem?.generateCutThumbnail) {
                const cutIndex = this.animationSystem.getCurrentCutIndex();
                setTimeout(() => {
                    this.animationSystem.generateCutThumbnail(cutIndex);
                }, 100);
            }
        }
    };
    
    this.transform.onTransformComplete = (layer, pathsBackup) => {
        // Undo/Redo 登録
        if (window.History && !window.History._manager.isApplying) {
            const layerId = layer.layerData.id;
            const pathsAfter = structuredClone(layer.layerData.paths);
            
            const entry = {
                name: 'layer-transform-complete',
                do: () => {
                    this.safeRebuildLayer(layer, pathsAfter);
                    this.requestThumbnailUpdate(this.getLayerIndex(layer));
                },
                undo: () => {
                    this.safeRebuildLayer(layer, pathsBackup);
                    this.requestThumbnailUpdate(this.getLayerIndex(layer));
                },
                meta: { layerId, type: 'transform' }
            };
            window.History.push(entry);
        }
        
        this.eventBus.emit('layer:transform-confirmed', {
            layerId: layer.layerData.id
        });
    };
    
    // ... 既存のコールバック設定 ...
    
    // 🔥 追加: アクティブレイヤー取得コールバック（PHASE 4 用）
    this.transform.onGetActiveLayer = () => {
        return this.getActiveLayer();
    };
}
```

#### 1-3. layer-system.js: confirmLayerTransform() メソッド削除

**理由**: 既に exitMoveMode() 内で確定処理が実行されるため不要

```javascript
// 削除: confirmLayerTransform() メソッド全体を削除
// ↓ exitMoveMode() で確定処理を実行するため不要になった
```

**影響**:
- ✅ Vモード終了時に変形が確実に反映される
- ✅ Graphics 再構築が自動実行される
- ✅ Undo/Redo に正しく記録される

---

### PHASE 2: Hキー反転機能修正 🟡

**目的**: Vモード時の Hキー反転を確実に動作させる

**問題点**: camera-system.js の Hキーハンドラーと競合している

#### 2-1. camera-system.js: Hキーハンドラー修正

```javascript
_handleCameraFlipKeys(e) {
    // 🔥 修正: Vモード時は処理しない
    if (this.vKeyPressed) return;
    
    if (!e.code === 'KeyH' || e.ctrlKey || e.altKey || e.metaKey) return;
    
    const centerX = this.config.canvas.width / 2;
    const centerY = this.config.canvas.height / 2;
    const worldCenter = this.worldContainer.toGlobal({ x: centerX, y: centerY });
    
    if (e.shiftKey) {
        this.verticalFlipped = !this.verticalFlipped;
        this.worldContainer.scale.y *= -1;
    } else {
        this.horizontalFlipped = !this.horizontalFlipped;
        this.worldContainer.scale.x *= -1;
    }
    
    const newWorldCenter = this.worldContainer.toGlobal({ x: centerX, y: centerY });
    this.worldContainer.x += worldCenter.x - newWorldCenter.x;
    this.worldContainer.y += worldCenter.y - newWorldCenter.y;
    
    this._emitTransformChanged();
    e.preventDefault();
}
```

#### 2-2. layer-transform.js: _setupFlipKeyEvents() 確認

**現状で問題なし** - 既に入力フォーカス判定が実装済み

**影響**:
- ✅ Vモード時に Hキーでレイヤー反転
- ✅ 非Vモード時に Hキーでカメラ反転
- ✅ 入力フォーカス時は両方とも無効

---

### PHASE 3: ホイール操作追加 🟢

**目的**: Vモード時のホイール操作を追加

**修正ファイル**: `layer-transform.js`

#### 3-1. _setupWheelEvents() 実装確認

**現状**: 既に実装済み（コードを確認）

**確認事項**:
- ✅ `onGetActiveLayer` コールバックが PHASE 1 で設定される
- ✅ ホイール: スケール変更
- ✅ Shift+ホイール: 回転変更

**影響**:
- ✅ Vモード時にホイールで拡大縮小
- ✅ Vモード時に Shift+ホイールで回転

---

### PHASE 4: カーソル管理の統合 🟡

**目的**: カーソル制御の重複を解消

**修正ファイル**: `layer-transform.js`

#### 4-1. _updateCursor() 修正

```javascript
_updateCursor() {
    // 🔥 削除: 直接カーソルを変更しない
    // camera-system に任せる
    
    // const canvas = this._getSafeCanvas();
    // if (!canvas) return;
    // 
    // if (this.isVKeyPressed) {
    //     canvas.style.cursor = 'grab';
    // } else {
    //     canvas.style.cursor = 'default';
    // }
    
    // 🔥 追加: camera-system のカーソル更新をトリガー
    if (this.cameraSystem?.updateCursor) {
        this.cameraSystem.updateCursor();
    }
}
```

**影響**:
- ✅ カーソル制御が camera-system に統一される
- ✅ ドラッグ中のカーソル変更が正しく動作する

---

### PHASE 5: keyboard-handler.js の二重管理解消 🟢

**目的**: Vキー状態管理の一元化

**修正ファイル**: `keyboard-handler.js`

#### 5-1. vKeyPressed 状態管理削除

```javascript
// 削除: 独自の vKeyPressed 管理を削除
// let vKeyPressed = false;

function handleKeyDown(e) {
    const eventBus = window.TegakiEventBus;
    const keymap = window.TEGAKI_KEYMAP;
    
    if (!eventBus || !keymap) return;
    if (isInputFocused()) return;
    
    // ... 既存の処理 ...
    
    // 🔥 修正: EventBus発火のみ（状態管理は layer-system に任せる）
    if (e.code === 'KeyV' && !e.ctrlKey && !e.shiftKey && !e.altKey) {
        eventBus.emit('keyboard:vkey-pressed', { pressed: true });
        e.preventDefault();
        return;
    }
    
    // ... 既存の処理 ...
}

function handleKeyUp(e) {
    // 🔥 削除: Vキー解放イベントは不要（トグル方式のため）
    // if (e.code === 'KeyV') {
    //     ...
    // }
}
```

**影響**:
- ✅ 状態管理が layer-system に一元化される
- ✅ keyboard-handler は純粋にイベント発火のみに専念

---

## 🧪 テストプラン

### テストケース 1: Vモード起動・解除

1. Vキー押下 → Vモード起動
   - ✅ ガイドライン表示
   - ✅ 変形パネル表示
   - ✅ カーソルが grab に変更

2. Vキー再押下 → Vモード解除
   - ✅ 変形が確定される
   - ✅ Graphics が再構築される
   - ✅ ガイドライン非表示
   - ✅ 変形パネル非表示
   - ✅ カーソルが default に戻る

### テストケース 2: 変形操作

1. Vモード時に矢印キーで移動
   - ✅ レイヤーが移動する
   - ✅ スライダー値が更新される

2. Vモード時に Shift+矢印キーで拡大縮小・回転
   - ✅ 拡大縮小が動作する
   - ✅ 回転が動作する

3. Vモード時にホイール操作
   - ✅ ホイール: 拡大縮小
   - ✅ Shift+ホイール: 回転

4. Vモード終了時
   - ✅ 変形が座標に焼き込まれる
   - ✅ Undo で元に戻せる

### テストケース 3: 反転機能

1. Vモード時に Hキー
   - ✅ レイヤーが水平反転する
   - ✅ ボタン状態が更新される

2. Vモード時に Shift+H
   - ✅ レイヤーが垂直反転する

3. 非Vモード時に Hキー
   - ✅ カメラが水平反転する（レイヤーではない）

### テストケース 4: エラーケース

1. レイヤーが存在しない状態で Vモード
   - ✅ エラーが発生しない

2. 変形中にウィンドウフォーカス喪失
   - ✅ Vモードが自動解除される
   - ✅ 変形が確定される

3. 入力フォーカス中に Hキー
   - ✅ 反転処理が実行されない

---

## 📝 シンボル辞典（完全版）

### EventBus イベント一覧

```javascript
// Vモード関連
'keyboard:vkey-pressed'        // Vキー押下（トグル）
'layer:transform-confirmed'    // 変形確定完了
'layer:updated'                // レイヤー更新
'layer:flipped'                // レイヤー反転

// カメラ関連
'camera:cursor-changed'        // カーソル変更
'camera:transform-changed'     // カメラ変形変更
```

### 主要メソッド一覧

#### layer-system.js
- `initTransform()` - LayerTransform 初期化とコールバック設定
- `enterLayerMoveMode()` - Vモード開始
- `exitLayerMoveMode()` - Vモード終了（変形確定を含む）
- `flipActiveLayer(direction)` - アクティブレイヤー反転
- `safeRebuildLayer(layer, paths)` - レイヤー Graphics 再構築

#### layer-transform.js
- `init(app, cameraSystem)` - 初期化
- `enterMoveMode()` - Vモード状態変更
- `exitMoveMode(layer)` - Vモード解除＋変形確定
- `confirmTransform(layer)` - 変形確定＋座標焼き込み
- `flipLayer(layer, direction)` - レイヤー反転
- `applyTransformToPaths(layer, transform)` - パスへ変形適用

#### camera-system.js
- `setVKeyPressed(pressed)` - Vキー状態設定
- `updateCursor()` - カーソル更新
- `showGuideLines()` / `hideGuideLines()` - ガイドライン表示制御

---

## 🎯 期待される効果

### 機能性
- ✅ Vモード起動・解除が確実に動作
- ✅ 変形確定が自動実行される
- ✅ Hキー反転が確実に動作
- ✅ ホイール操作が追加される

### 保守性
- ✅ 責務分離が明確化される
- ✅ 初期化順序が明示的になる
- ✅ 状態管理が一元化される
- ✅ コールバック方式で疎結合を維持

### 拡張性
- ✅ 新しい変形操作の追加が容易
- ✅ Undo/Redo 対応が完備
- ✅ EventBus 統合が完全化

---

## ⚠️ 既知の制約事項

1. **PixiJS v8.13 の制約**
   - Matrix 変換は PixiJS の標準機能に依存
   - Graphics 再構築時のパフォーマンス

2. **ブラウザ互換性**
   - ホイールイベントは { passive: false } が必要
   - PointerEvent 必須（IE11 非対応）

3. **座標精度**
   - 浮動小数点演算による微小な誤差
   - 変形確定時に structuredClone でデータ複製

---

## 🚀 実装順序（推奨）

1. **Day 1**: PHASE 0 + PHASE 1
   - 初期化フロー修正
   - 変形確定処理修正
   - テストケース 1, 2, 4 実施

2. **Day 2**: PHASE 2 + PHASE 4
   - Hキー反転修正
   - カーソル管理統合
   - テストケース 3 実施

3. **Day 3**: PHASE 3 + PHASE 5
   - ホイール操作追加
   - keyboard-handler 整理
   - 全体統合テスト

---

## 📚 参考資料

- PixiJS v8 Matrix API: https://pixijs.download/dev/docs/PIXI.Matrix.html
- PointerEvent Spec: https://www.w3.org/TR/pointerevents/
- EventBus パターン: https://github.com/EventBus

---

**改訂履歴**
- v1.0 (2025-10-22): 初版作成 - 根本原因分析と統合修正計画