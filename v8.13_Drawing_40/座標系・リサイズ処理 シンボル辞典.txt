# リサイズ処理 シンボル辞典・問題解析

## 🚨 現在の問題

**症状**:
1. ✅ UIの配置ボタン（←↔→ / ↑↕↓）は表示されているが、**常に左上基準でリサイズされる**
2. ❌ レイヤーサムネイルが**即座に更新されない**（100msの遅延後も反映されない）
3. ❌ メインキャンバス表示とサムネイル表示で**座標のずれがある**

---

## 📊 resize-popup.js の構造

### **クラス**: `TegakiUI.ResizePopup`

#### **プロパティ**
```javascript
this.coreEngine          // CoreEngineへの参照
this.history             // History管理
this.eventBus            // EventBus（イベント通知）
this.popup               // ポップアップDOM要素
this.isVisible           // 表示状態
this.initialized         // 初期化済みフラグ
this.isDraggingWidth     // 幅スライダードラッグ中
this.isDraggingHeight    // 高さスライダードラッグ中
this.elements            // DOM要素キャッシュ
this.currentWidth        // 現在の幅設定値
this.currentHeight       // 現在の高さ設定値
this.horizontalAlign     // 横配置基準 ('left'|'center'|'right')
this.verticalAlign       // 縦配置基準 ('top'|'center'|'bottom')
this.MIN_SIZE = 100      // 最小サイズ
this.MAX_SIZE = 2000     // 最大サイズ
```

---

## 🔍 重要メソッドの解析

### **1. _calculateLayerCoordinateOffset()** (行343-365)

**責務**: 配置基準からオフセット計算

**現在の実装**:
```javascript
_calculateLayerCoordinateOffset(oldWidth, oldHeight, newWidth, newHeight, alignOptions) {
    let offsetX = 0;
    let offsetY = 0;
    
    const widthDiff = newWidth - oldWidth;
    if (alignOptions.horizontalAlign === 'center') {
        offsetX = widthDiff / 2;
    } else if (alignOptions.horizontalAlign === 'right') {
        offsetX = 0;  // ❌ 間違い！
    } else if (alignOptions.horizontalAlign === 'left') {
        offsetX = widthDiff;  // ❌ 間違い！
    }
    
    const heightDiff = newHeight - oldHeight;
    if (alignOptions.verticalAlign === 'center') {
        offsetY = heightDiff / 2;
    } else if (alignOptions.verticalAlign === 'bottom') {
        offsetY = 0;  // ❌ 間違い！
    } else if (alignOptions.verticalAlign === 'top') {
        offsetY = heightDiff;  // ❌ 間違い！
    }
    
    return { offsetX, offsetY };
}
```

**問題点**:
- **leftとrightのロジックが逆**
- **topとbottomのロジックが逆**

**正しいロジック**:
```
横配置:
  left (←):   左固定・右が広がる   → offsetX = 0
  center (↔): 中央・左右均等     → offsetX = widthDiff / 2
  right (→):  右固定・左が広がる  → offsetX = widthDiff

縦配置:
  top (↑):    上固定・下が広がる  → offsetY = 0
  center (↕): 中央・上下均等     → offsetY = heightDiff / 2
  bottom (↓): 下固定・上が広がる  → offsetY = heightDiff
```

---

### **2. _applyCoordinateTransformToFrames()** (行367-391)

**責務**: 全フレーム・全レイヤーに座標変換適用

**現在の実装**:
```javascript
_applyCoordinateTransformToFrames(frames, offsetX, offsetY) {
    frames.forEach((frame) => {
        const layers = frame.getLayers();
        
        layers.forEach((layer) => {
            // ❌ 問題1: layer.positionにもoffsetを適用している
            layer.position.x += offsetX;
            layer.position.y += offsetY;
            
            if (layer.layerData?.paths && Array.isArray(layer.layerData.paths)) {
                layer.layerData.paths.forEach((path) => {
                    if (path.points && Array.isArray(path.points)) {
                        // ✅ paths.pointsへの適用は正しい
                        path.points.forEach((point) => {
                            point.x += offsetX;
                            point.y += offsetY;
                        });
                    }
                    
                    // ❌ 問題2: Graphics再描画が不完全
                    if (path.graphics) {
                        path.graphics.clear();
                        path.points.forEach((p) => {
                            path.graphics.circle(p.x, p.y, path.size / 2);
                            path.graphics.fill({
                                color: path.color,
                                alpha: path.opacity
                            });
                        });
                    }
                });
            }
        });
    });
}
```

**問題点**:
1. **`layer.position`にoffsetを適用** → サムネイル生成時に二重適用される
2. **Graphicsの再描画が不完全** → perfect-freehandのストロークが考慮されていない
3. **背景レイヤーの処理がない** → 背景が古いサイズのまま

---

### **3. _applyResize()** (行393-542)

**責務**: リサイズ実行とHistory管理

**処理フロー**:
```
1. 新サイズ・配置基準を取得
2. offsetX/Yを計算 (_calculateLayerCoordinateOffset)
3. 全フレームのスナップショット作成
4. Historyコマンド作成
   - do: リサイズ実行
     - TEGAKI_CONFIG更新
     - CameraSystem.resizeCanvas()
     - _applyCoordinateTransformToFrames()
     - サムネイル更新（100ms遅延）  // ❌ 遅延が長すぎる
   - undo: リサイズ元に戻す
5. History.push()
6. ポップアップを閉じる
```

**問題点**:
- **setTimeout(..., 100ms)** → 遅延が長すぎてユーザーが不安になる
- **EventBus通知のタイミング** → サムネイル更新前に通知される
- **Graphics再構築の不完全性** → layer-system.jsの`rebuildPathGraphics()`を呼んでいない

---

## 🔄 座標系の整理

### **Canvas座標系**（paths.points）
- **原点**: 左上 (0, 0)
- **範囲**: 0 ～ canvas.width, 0 ～ canvas.height
- **用途**: 実際の描画データ
- **管理**: `layer.layerData.paths[].points[]`

### **PixiJS座標系**（layer.position）
- **原点**: layer.pivot基準
- **用途**: PixiJSコンテナの表示位置
- **管理**: `layer.position.x/y`

### **リサイズ時の正しい処理**
```
リサイズは「キャンバスサイズの変更」であり、
「レイヤー変形（Vキーモード）」とは異なる。

✅ 正解: paths.pointsのみ移動
❌ 間違い: layer.positionとpaths.pointsの両方を移動
```

---

## 🎯 サムネイル更新の問題

### **現在の処理**（_applyResize内）
```javascript
setTimeout(() => {
    animSystem.regenerateAllThumbnails();
    
    if (this.eventBus) {
        this.eventBus.emit('animation:thumbnails-need-update');
        this.eventBus.emit('layer:thumbnails-need-update');
    }
}, 100);  // ❌ 100ms遅延
```

### **layer-system.js: updateThumbnail()**
```javascript
updateThumbnail(layerIndex) {
    // 1. レイヤーの変形状態を保存
    const originalState = {
        pos: { x: layer.position.x, y: layer.position.y },
        scale: { x: layer.scale.x, y: layer.scale.y },
        rotation: layer.rotation,
        pivot: { x: layer.pivot.x, y: layer.pivot.y }
    };
    
    // 2. 変形をリセット
    layer.position.set(0, 0);
    layer.scale.set(1, 1);
    layer.rotation = 0;
    layer.pivot.set(0, 0);
    
    // 3. RenderTextureに描画
    this.app.renderer.render({
        container: tempContainer,
        target: renderTexture
    });
    
    // 4. 元の変形状態を復元
    layer.position.set(originalState.pos.x, originalState.pos.y);
    // ...
}
```

**問題点**:
- **layer.positionをリセット** → しかし`paths.points`は既にoffset済み
- **この時点でGraphicsが古い** → `path.graphics`が更新されていない可能性
- **RenderTextureが古いサイズ** → layer-system.jsの`renderFrameToTexture()`で再作成されていない

---

## 🔧 修正が必要なポイント

### **Priority 1: オフセット計算の修正**
```javascript
// resize-popup.js: _calculateLayerCoordinateOffset()
if (alignOptions.horizontalAlign === 'left') {
    offsetX = 0;  // 左固定
} else if (alignOptions.horizontalAlign === 'center') {
    offsetX = widthDiff / 2;  // 中央
} else if (alignOptions.horizontalAlign === 'right') {
    offsetX = widthDiff;  // 右固定
}

if (alignOptions.verticalAlign === 'top') {
    offsetY = 0;  // 上固定
} else if (alignOptions.verticalAlign === 'center') {
    offsetY = heightDiff / 2;  // 中央
} else if (alignOptions.verticalAlign === 'bottom') {
    offsetY = heightDiff;  // 下固定
}
```

### **Priority 2: layer.position適用の削除**
```javascript
// resize-popup.js: _applyCoordinateTransformToFrames()
// ❌ 削除: layer.position.x += offsetX;
// ❌ 削除: layer.position.y += offsetY;

// ✅ 維持: paths.pointsのみ移動
path.points.forEach((point) => {
    point.x += offsetX;
    point.y += offsetY;
});
```

### **Priority 3: Graphics強制再構築**
```javascript
// resize-popup.js: _applyCoordinateTransformToFrames()
const layerSystem = this.coreEngine?.getLayerSystem?.();

if (layerSystem && typeof layerSystem.rebuildPathGraphics === 'function') {
    // layerSystem.rebuildPathGraphics()を使用
    layerSystem.rebuildPathGraphics(path);
} else {
    // フォールバック: 手動再構築
    if (path.graphics) {
        path.graphics.clear();
        // ...
    }
}
```

### **Priority 4: 背景レイヤーの処理**
```javascript
// resize-popup.js: _applyCoordinateTransformToFrames()
if (layer.layerData?.isBackground && layer.layerData.backgroundGraphics) {
    const newWidth = window.TEGAKI_CONFIG.canvas.width;
    const newHeight = window.TEGAKI_CONFIG.canvas.height;
    
    layer.layerData.backgroundGraphics.clear();
    layer.layerData.backgroundGraphics.rect(0, 0, newWidth, newHeight);
    layer.layerData.backgroundGraphics.fill({
        color: window.TEGAKI_CONFIG.background.color
    });
}
```

### **Priority 5: サムネイル即時更新**
```javascript
// resize-popup.js: _applyResize()
setTimeout(() => {
    animSystem.regenerateAllThumbnails();
    
    if (this.eventBus) {
        this.eventBus.emit('animation:thumbnails-need-update');
        this.eventBus.emit('layer:thumbnails-need-update');
    }
}, 50);  // 100ms → 50msに短縮
```

---

## 📋 検証ポイント

### **テストケース1: 左上基準（←↑）**
```
初期: 800×600, 中央に円
リサイズ: 1000×800
期待: 円は左上を基準に、そのままの位置
```

### **テストケース2: 中央基準（↔↕）**
```
初期: 800×600, 中央に円
リサイズ: 1000×800
期待: 円は中央を維持（上下左右に100pxずつ広がる）
```

### **テストケース3: 右下基準（→↓）**
```
初期: 800×600, 中央に円
リサイズ: 1000×800
期待: 円は右下を基準に、左上に移動
```

### **確認項目**:
1. ✅ メインキャンバス表示が正しいか
2. ✅ レイヤーサムネイルが正しい位置で表示されるか
3. ✅ フレームサムネイルが正しいか
4. ✅ Undo/Redoが正常に動作するか
5. ✅ 配置ボタンの切り替えが反映されるか

---

## 🚀 実装優先度

1. **High**: オフセット計算の修正（left/right, top/bottomの逆転）
2. **High**: layer.position適用の削除
3. **High**: Graphics強制再構築
4. **Medium**: 背景レイヤー処理
5. **Medium**: サムネイル即時更新
6. **Low**: RenderTexture再作成（layer-system.js側の問題）

---

## 💡 アーキテクチャ設計の教訓

### **座標系の一貫性**
- **Canvas座標系**: 描画データ（paths.points）
- **PixiJS座標系**: 表示位置（layer.position）
- **混在させない**: リサイズはCanvas座標系のみ操作

### **Graphics更新の明示性**
- **座標変更 ≠ 描画更新**
- **paths.points変更後は必ずrebuildPathGraphics()を呼ぶ**

### **サムネイル更新の即時性**
- **ユーザー体験重視**: 100ms → 50msまたは即座
- **EventBus通知タイミング**: 処理完了後に通知

### **Undo/Redoの整合性**
- **スナップショット**: 座標だけでなく全状態を保存
- **復元処理**: do処理と対称的なロジック