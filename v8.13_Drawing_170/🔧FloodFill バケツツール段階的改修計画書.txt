================================================================================
FloodFill バケツツール段階的改修計画書
根本修正版: Canvas2D FloodFill + GPU最適化ハイブリッド方式
================================================================================

【問題診断結果】
❌ 現在のSDF距離場FloodFillは設計レベルで破綻
  - 距離場に境界情報なし (内側/外側の区別不可)
  - 等高線追跡アルゴリズム (領域塗りつぶし不可)
  - 白紙領域で全面塗りつぶし発生

【新アーキテクチャ方針】
✅ Canvas2D標準FloodFillアルゴリズムを採用
✅ GPU最適化は描画処理に集中
✅ 段階的実装で確実な動作保証


================================================================================
Phase 1: Canvas2D FloodFill基本実装 (最優先)
================================================================================

【目標】
標準的なBFSベースFloodFillで閉領域塗りつぶしを確実に実現

【新規作成ファイル】
1. system/drawing/canvas-floodfill.js

【改修ファイル】
1. system/drawing/fill-tool.js
2. index.html (canvas-floodfill.js読み込み追加)

【削除対象】
❌ system/drawing/webgpu/shaders/sdf-fill-compute.wgsl (不要)

--------------------------------------------------------------------------------
【Phase 1 処理フロー】
--------------------------------------------------------------------------------

1. fill-tool.js: fill(localX, localY)
   ↓
2. canvas-floodfill.js: floodFill(imageData, x, y, fillColor)
   - Canvas2DでレイヤーをImageDataに変換
   - BFSで閉領域探索
   - 境界判定: 色差 < threshold
   ↓
3. ImageData → GPU Texture変換
   ↓
4. PixiJS Sprite(texture) を mask として適用
   ↓
5. Graphics.fill() で塗りつぶし


--------------------------------------------------------------------------------
【Phase 1 実装詳細】
--------------------------------------------------------------------------------

■ canvas-floodfill.js (新規作成):

/**
 * @file system/drawing/canvas-floodfill.js
 * @description Canvas2D FloodFill - BFS Standard Implementation
 * 
 * 【親ファイル (依存)】
 * - config.js (TEGAKI_CONFIG)
 * 
 * 【子ファイル (依存される)】
 * - system/drawing/fill-tool.js (floodFill呼び出し)
 */

(function() {
    'use strict';

    class CanvasFloodFill {
        constructor() {
            this.colorThreshold = 10; // 色差閾値 (0-255)
            this.maxPixels = 2000000;  // 最大処理ピクセル数
        }

        /**
         * レイヤーを Canvas2D ImageData に変換
         */
        layerToImageData(layer, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            // PixiJSレイヤーをCanvasに描画
            const app = window.drawingApp;
            if (app && app.renderer) {
                const renderTexture = PIXI.RenderTexture.create({
                    width, height
                });
                app.renderer.render(layer, { renderTexture });

                const pixels = app.renderer.extract.pixels(renderTexture);
                const imageData = ctx.createImageData(width, height);
                imageData.data.set(pixels);

                renderTexture.destroy(true);
                return imageData;
            }

            return ctx.getImageData(0, 0, width, height);
        }

        /**
         * 標準FloodFill (BFS)
         */
        floodFill(imageData, startX, startY, fillColor) {
            const { width, height, data } = imageData;
            const startIdx = (startY * width + startX) * 4;

            // クリック位置の色取得
            const targetR = data[startIdx];
            const targetG = data[startIdx + 1];
            const targetB = data[startIdx + 2];
            const targetA = data[startIdx + 3];

            // 塗りつぶし色と同じなら何もしない
            if (this._colorsMatch(
                targetR, targetG, targetB, targetA,
                fillColor.r, fillColor.g, fillColor.b, fillColor.a
            )) {
                return imageData;
            }

            // BFS用キューと訪問済みフラグ
            const queue = [{ x: startX, y: startY }];
            const visited = new Set();
            visited.add(startY * width + startX);

            let processedPixels = 0;

            while (queue.length > 0 && processedPixels < this.maxPixels) {
                const { x, y } = queue.shift();
                const idx = (y * width + x) * 4;

                // 現在位置を塗る
                data[idx] = fillColor.r;
                data[idx + 1] = fillColor.g;
                data[idx + 2] = fillColor.b;
                data[idx + 3] = fillColor.a;

                processedPixels++;

                // 4方向探索
                const neighbors = [
                    { x: x + 1, y },
                    { x: x - 1, y },
                    { x, y: y + 1 },
                    { x, y: y - 1 }
                ];

                for (const neighbor of neighbors) {
                    const nx = neighbor.x;
                    const ny = neighbor.y;

                    // 範囲外チェック
                    if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
                        continue;
                    }

                    const nIdx = (ny * width + nx) * 4;
                    const visitKey = ny * width + nx;

                    // 訪問済みチェック
                    if (visited.has(visitKey)) {
                        continue;
                    }

                    // 色差判定
                    const r = data[nIdx];
                    const g = data[nIdx + 1];
                    const b = data[nIdx + 2];
                    const a = data[nIdx + 3];

                    if (this._colorsMatch(r, g, b, a, targetR, targetG, targetB, targetA)) {
                        queue.push({ x: nx, y: ny });
                        visited.add(visitKey);
                    }
                }
            }

            if (processedPixels >= this.maxPixels) {
                console.warn('⚠️ FloodFill: Max pixel limit reached');
            }

            return imageData;
        }

        /**
         * 色差判定
         */
        _colorsMatch(r1, g1, b1, a1, r2, g2, b2, a2) {
            const dr = Math.abs(r1 - r2);
            const dg = Math.abs(g1 - g2);
            const db = Math.abs(b1 - b2);
            const da = Math.abs(a1 - a2);

            return (dr + dg + db + da) <= this.colorThreshold * 4;
        }

        /**
         * ImageData を PixiJS Texture に変換
         */
        imageDataToTexture(imageData) {
            const { width, height, data } = imageData;
            
            const resource = new PIXI.BufferResource(
                new Uint8Array(data.buffer), 
                { width, height }
            );

            const baseTexture = new PIXI.BaseTexture(resource, {
                width, height,
                format: PIXI.FORMATS.RGBA,
                type: PIXI.TYPES.UNSIGNED_BYTE
            });

            return new PIXI.Texture(baseTexture);
        }

        setColorThreshold(threshold) {
            this.colorThreshold = Math.max(0, Math.min(255, threshold));
        }
    }

    window.CanvasFloodFill = new CanvasFloodFill();
    console.log('✅ canvas-floodfill.js loaded');

})();


■ fill-tool.js 改修内容:

async _fillLayerWithCanvas2D(layer, color, alpha, localX, localY, layerManager) {
    const CONFIG = window.TEGAKI_CONFIG;
    const width = CONFIG.canvas.width;
    const height = CONFIG.canvas.height;

    try {
        // 1. レイヤーをImageDataに変換
        const imageData = window.CanvasFloodFill.layerToImageData(layer, width, height);

        // 2. 座標を整数化
        const x = Math.floor(localX);
        const y = Math.floor(localY);

        // 3. 色をRGBA形式に変換
        const fillColor = {
            r: (color >> 16) & 0xFF,
            g: (color >> 8) & 0xFF,
            b: color & 0xFF,
            a: Math.floor(alpha * 255)
        };

        // 4. FloodFill実行
        const filledData = window.CanvasFloodFill.floodFill(
            imageData, x, y, fillColor
        );

        // 5. ImageData → Texture変換
        const maskTexture = window.CanvasFloodFill.imageDataToTexture(filledData);

        // 6. マスク適用して描画
        const pathsBackup = this._clonePathsDataSafely(layer.layerData.pathsData);
        this._clearLayerGraphics(layer, layer.layerData);

        const fillGraphics = new PIXI.Graphics();
        fillGraphics.rect(0, 0, width, height);
        fillGraphics.fill({ color, alpha });

        const maskSprite = new PIXI.Sprite(maskTexture);
        fillGraphics.mask = maskSprite;

        layer.addChild(maskSprite);
        layer.addChild(fillGraphics);

        // 7. pathsData記録
        const pathData = {
            id: `fill_canvas2d_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            type: 'fill',
            tool: 'fill',
            color, alpha,
            graphics: fillGraphics,
            maskGraphics: maskSprite,
            timestamp: Date.now(),
            settings: { color, opacity: alpha, mode: 'fill-canvas2d' }
        };

        layer.layerData.pathsData.push(pathData);

        this._registerHistory(layer, layerManager, pathsBackup, color, alpha, 'fill-canvas2d');

        const layerIndex = layerManager.getActiveLayerIndex();
        layerManager.requestThumbnailUpdate(layerIndex);

        if (this.eventBus) {
            this.eventBus.emit('layer:filled', {
                layerId: layer.layerData.id,
                color, alpha,
                method: 'canvas2d-floodfill'
            });
        }

    } catch (error) {
        console.error('❌ FillTool: Canvas2D FloodFill error:', error);
        this._fillLayerLegacy(layer, color, alpha, layerManager);
    }
}

// fill() メソッド内で呼び出し
async fill(localX, localY) {
    // ... 前処理 ...

    // Canvas2D FloodFill優先
    await this._fillLayerWithCanvas2D(
        activeLayer, fillColor, fillAlpha, 
        localX, localY, layerManager
    );
}


■ index.html 修正:

<!-- FloodFill追加 (fill-tool.jsの前) -->
<script src="system/drawing/canvas-floodfill.js"></script>
<script src="system/drawing/fill-tool.js"></script>


--------------------------------------------------------------------------------
【Phase 1 依存関係】
--------------------------------------------------------------------------------

canvas-floodfill.js:
  → config.js (TEGAKI_CONFIG)
  → PixiJS (PIXI.RenderTexture, PIXI.BaseTexture)

fill-tool.js:
  → canvas-floodfill.js (window.CanvasFloodFill)
  → layer-system.js (LayerManager)
  → brush-settings.js (BrushSettings)
  → event-bus.js (TegakiEventBus)
  → history.js (History)


================================================================================
Phase 2: 色差閾値UI追加
================================================================================

【目標】
バケツツールの感度調整機能を提供

【改修ファイル】
1. ui/ui-panels.js (ツール設定パネル拡張)
2. system/drawing/fill-tool.js (閾値パラメータ追加)

【処理フロー】
UI Slider → canvas-floodfill.js.setColorThreshold() → 閾値更新

【実装詳細】

■ ui-panels.js に追加:

// ツールパネル内にスライダー追加
<label>
  塗りつぶし感度
  <input type="range" id="fillColorThreshold" 
         min="0" max="50" value="10" step="1">
  <span id="fillThresholdValue">10</span>
</label>

// イベント登録
document.getElementById('fillColorThreshold').addEventListener('input', (e) => {
    const value = parseInt(e.target.value);
    document.getElementById('fillThresholdValue').textContent = value;
    window.CanvasFloodFill.setColorThreshold(value);
});


================================================================================
Phase 3: GPU最適化 (オプション)
================================================================================

【目標】
大規模領域塗りつぶしの高速化

【方針】
Canvas2D FloodFillは維持 (正確性重視)
GPU: マスクテクスチャの最適化のみ

【改修ファイル】
1. system/drawing/canvas-floodfill.js
   - imageDataToTexture() でGPU転送最適化
   - Texture圧縮形式の検討

【実装例】

imageDataToTexture(imageData) {
    const { width, height, data } = imageData;
    
    // GPU最適化: アルファチャンネルのみ抽出
    const alphaOnly = new Uint8Array(width * height);
    for (let i = 0; i < alphaOnly.length; i++) {
        alphaOnly[i] = data[i * 4 + 3]; // Alpha channel
    }

    const resource = new PIXI.BufferResource(alphaOnly, { width, height });
    const baseTexture = new PIXI.BaseTexture(resource, {
        width, height,
        format: PIXI.FORMATS.ALPHA,  // メモリ効率化
        type: PIXI.TYPES.UNSIGNED_BYTE
    });

    return new PIXI.Texture(baseTexture);
}


================================================================================
Phase 4: 段階的境界ぼかし
================================================================================

【目標】
塗りつぶし境界のアンチエイリアス

【改修ファイル】
1. system/drawing/canvas-floodfill.js (境界検出追加)

【実装方針】
1. FloodFill時に境界ピクセルを記録
2. 境界に対して Gaussian Blur 適用
3. マスクテクスチャに反映

【実装例】

floodFill(imageData, startX, startY, fillColor, feather = 0) {
    // ... 標準FloodFill ...

    if (feather > 0) {
        this._applyFeatherToEdges(imageData, edgePixels, feather);
    }

    return imageData;
}

_applyFeatherToEdges(imageData, edges, radius) {
    // Gaussian Blur (簡易版)
    for (const edge of edges) {
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = edge.x + dx;
                const ny = edge.y + dy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist <= radius) {
                    const idx = (ny * width + nx) * 4;
                    const factor = 1.0 - (dist / radius);
                    imageData.data[idx + 3] *= factor;
                }
            }
        }
    }
}


================================================================================
実装優先度とスケジュール
================================================================================

Phase 1: Canvas2D FloodFill基本  [優先度: ★★★★★] 2-3日
  → 最優先。確実な動作保証。

Phase 2: 色差閾値UI            [優先度: ★★★★☆] 0.5日
  → Phase 1の直後に実装推奨

Phase 3: GPU最適化             [優先度: ★★☆☆☆] 1-2日
  → パフォーマンス問題が出たら実装

Phase 4: 境界ぼかし             [優先度: ★★☆☆☆] 1-2日
  → 品質向上オプション


================================================================================
デバッグ・検証コマンド
================================================================================

// Phase 1検証
const layer = window.layerManager.getActiveLayer();
const imageData = window.CanvasFloodFill.layerToImageData(layer, 800, 600);
console.log('ImageData:', imageData.width, imageData.height, imageData.data.length);

// FloodFill単体テスト
const fillColor = { r: 255, g: 0, b: 0, a: 255 };
const filled = window.CanvasFloodFill.floodFill(imageData, 250, 150, fillColor);
console.log('Fill Result:', filled);

// 色差閾値テスト
window.CanvasFloodFill.setColorThreshold(25);
console.log('Threshold:', window.CanvasFloodFill.colorThreshold);

// パフォーマンス測定
performance.mark('fill-start');
await window.FillTool.fill(250, 150);
performance.mark('fill-end');
const measure = performance.measure('fill', 'fill-start', 'fill-end');
console.log('Fill Time:', measure.duration.toFixed(2), 'ms');


================================================================================
Phase間の互換性
================================================================================

Phase 1: 単独で完全動作
Phase 2: Phase 1のUI拡張 (非破壊)
Phase 3: Phase 1の最適化 (アルゴリズム変更なし)
Phase 4: Phase 1の品質向上 (オプション機能)

各Phaseは独立してON/OFF可能:
  window.TEGAKI_CONFIG.fillTool = {
    useCanvas2D: true,        // Phase 1
    colorThreshold: 10,       // Phase 2
    gpuOptimized: false,      // Phase 3
    featherEnabled: false,    // Phase 4
    featherRadius: 2
  };


================================================================================
既存コード削除計画
================================================================================

Phase 1実装後に削除可能:
❌ webgpu-compute-sdf.js の以下メソッド:
   - computeFloodFillMask()
   - runFloodFillShader()
   - _createFillBuffers()

❌ sdf-fill-compute.wgsl (ファイル全体)

⚠️ 削除前にバックアップ推奨:
   将来的なSDF FloodFill再実装の参考用


================================================================================
補足: なぜCanvas2D方式を採用するか
================================================================================

【利点】
✅ 確実性: 30年以上の実績あるアルゴリズム
✅ デバッグ容易: ピクセル単位で検証可能
✅ 拡張性: 境界ぼかし、パターン塗り等の追加が容易
✅ 互換性: 全ブラウザで動作保証

【欠点】
⚠️ 速度: 大規模領域 (100万ピクセル超) で遅延
   → Phase 3でGPU最適化により解決

【SDF方式との比較】
SDF FloodFill (案2):
  - 理論: 距離場による高速領域判定
  - 問題: 境界情報の欠落、アルゴリズム複雑化
  - 結果: 実装困難、動作不安定

Canvas2D FloodFill (採用案):
  - 理論: 標準BFS/DFS
  - 利点: 確実性、実装容易、保守性高
  - 結果: 段階的拡張可能


================================================================================
EOF
================================================================================