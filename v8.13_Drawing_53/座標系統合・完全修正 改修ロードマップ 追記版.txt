# 座標系統合・完全修正 改修ロードマップ v1.1

## 前置き

v1.0の改修実施により、多くの実装上の落とし穴が判明しました。
このドキュメントは v1.0 を補完し、今後の同様プロジェクトで同じ問題を避けるための記録です。

---

## ■ 改修後に判明した実装上の落とし穴

### 1. worldTransform の親チェーン問題

**問題:**
```
Layer.toLocal(worldPoint) が期待と異なる結果を返す
理由: toLocal()は親チェーン全体の worldTransform を使用するため、
      worldContainer のoffset (position) が含まれてしまう
```

**症状:**
- Local座標が負数になる
- worldContainer.position = (228, 232.5) がそのまま逆変換に含まれる
- Layer.toLocal() ≠ 手動逆算

**根本原因:**
```
PIXI v8のtoLocal()は「グローバル座標 → ローカル座標」の変換
= 親チェーン全体の worldTransform を適用する

図示:
Screen座標 
  → PIXI worldTransform (stage→worldContainer→...→Layer)
  → Layer.toLocal() ❌ この時点で worldContainer.offset が含まれる
```

**解決方法:**
```javascript
// ❌ 使ってはいけない:
const local = layer.toLocal(worldPoint);

// ✓ 正しい:
// 親チェーンを手動で逆算（worldContainer の直前まで）
// 各コンテナの position/scale/rotation を逆順に適用
```

**対策:**
- worldToLocal() は手動逆算実装のみ
- PIXI の toLocal() は参考にするが使用しない
- 親チェーンを明示的に走査する

---

### 2. 二重変換の陥阱

**問題:**
```
drawing-engine.js で Local座標に変換 → strokeRecorder.startStroke()
strokeRecorder.addPoint() でさらに screenToLayer() を呼ぶ
結果: 座標が二重に変換されて誤った値になる
```

**症状:**
```
期待値: Local (32, 44)
実際: Points (-195, -180) ← screenToLayer()による誤り
```

**根本原因:**
```
インターフェース設計の曖昧性
- startStroke(x, y) のパラメータが「何座標か」明示されていない
- 歴史的に screenToLayer() を内部で呼んでいた
- drawing-engine側で座標変換後に呼んだのに、内部でも変換された
```

**解決方法:**
```javascript
// ❌ 曖昧な設計:
startStroke(x, y)  // x, y が何座標か不明確

// ✓ 明確な設計:
startStroke(localX, localY)  // ローカル座標であることを明示
// または
startStrokeFromEvent(event)  // イベントから内部で変換
```

**対策:**
- パラメータ名に座標系を明示（localX, worldX, screenX など）
- メソッド名でも座標系を区別（startStrokeLocal, startStrokeFromEvent など）
- ドキュメント化: メソッドの入力座標系を@paramで明記

---

### 3. layerSystem / layerManager の命名混乱

**問題:**
```
drawing-engine.js は window.layerSystem を参照
実装は window.layerManager オブジェクト
結果: getActiveLayer() が呼ばれず、ペン描画ができない
```

**症状:**
```
window.layerSystem: undefined ❌
window.layerManager: object ✓
drawingEngine.currentLayer = null ← 常に null
```

**根本原因:**
```
ファイルの責務分担が不明確
- layerSystem: クラス定義（TegakiLayerSystem）
- layerManager: インスタンス（実際に使う object）
- drawing-engine側はどちらを使うべきか不明瞭
```

**解決方法:**
```javascript
// drawing-engine.js constructor:
this.layerSystem = layerSystem || window.layerManager;
// フォールバックを準備するしかない
```

**対策:**
- グローバルオブジェクトの命名を統一
  - `window.layerManager` 一択にするか
  - `window.TegakiLayerSystem` クラス、`window.layerSystem` インスタンスにするか
- core-runtime.js で明示的に割り当て
  ```javascript
  window.layerSystem = window.layerManager;  // 明示的な統一
  ```
- ドキュメント: 「何がグローバルに公開されるか」リストを作成

---

### 4. CoordinateSystem の初期化タイミング

**問題:**
```
CoordinateSystem.init() のタイミングが遅い/曖昧
デバッグコンソールから呼び出す際に未初期化状態になる
```

**症状:**
```
const cs = window.CoordinateSystem;
cs.screenClientToCanvas()  // ❌ app/config/eventBus が null のため失敗
```

**根本原因:**
```
init() が複数箇所で呼ばれる可能性
- drawing-engine.js constructor
- core-runtime.js setupCoordinateSystem()
- 重複初期化またはタイミングズレ
```

**解決方法:**
```javascript
// 初期化状態を確認:
if (!CoordinateSystem.app) {
    throw new Error('CoordinateSystem not initialized');
}
```

**対策:**
- init()を1回限りに
  ```javascript
  init() {
      if (this.app) return;  // 2回目以降は何もしない
      // 初期化処理
  }
  ```
- 初期化完了フラグを用意
  ```javascript
  this.isInitialized = false;
  ```

---

## ■ 改修ロードマップ v1.1 修正版

### Phase 0: 座標変換システムの完全統合【修正版】

**追加実装:**

1. **worldToLocal() は手動逆算のみ**
   ```javascript
   // ❌ 使わない:
   // if (container.toLocal) {
   //     return container.toLocal(...);
   // }
   
   // ✓ 常に手動計算:
   // 親チェーンを逆順で適用
   ```

2. **worldContainer の直前まで遡る**
   ```javascript
   while (node && node !== worldContainer) {
       // 各 node の position/scale/rotation を逆算
   }
   ```

3. **エラーハンドリング**
   ```javascript
   if (Math.abs(scale.x) < 1e-6) {
       throw new Error('特異行列: スケール0');
   }
   ```

---

### Phase 1: 描画エンジンの座標変換適用【修正版】

**修正点:**

1. **layerSystem の正体を明確に**
   ```javascript
   this.layerSystem = layerSystem || window.layerManager;
   // フォールバック必須
   ```

2. **Local座標変換を明示**
   ```javascript
   const local = coordinateSystem.worldToLocal(world.x, world.y, activeLayer);
   localX = local.x;  // パラメータ名で座標系を明記
   localY = local.y;
   ```

3. **strokeRecorder への入力は Local座標**
   ```javascript
   this.strokeRecorder.startStroke(localX, localY, pressure);
   // startStroke(localX, localY) は二重変換しない
   ```

---

### Phase 1-2: StrokeRecorder の座標系統一【新規】

**責務の明確化:**

```
❌ 古い責務:
startStroke(screenX, screenY)
  → 内部で screenToLayer() 呼んで Local座標に変換

✓ 新しい責務:
startStroke(localX, localY)
  → 受け取った Local座標をそのまま記録
  → 座標変換は drawing-engine側で完結
```

**実装:**
```javascript
startStroke(localX, localY, rawPressure) {
    // 二重変換しない
    // そのまま記録
    this.addPoint(localX, localY, rawPressure);
}

addPoint(localX, localY, rawPressure) {
    // screenToLayer() を呼ばない
    this.points.push({
        x: localX,
        y: localY,
        // ...
    });
}
```

---

## ■ 座標系統合の完全フロー（確定版）

```
PointerEvent (clientX, clientY)
  ↓
[Core-Runtime]
  ↓
DrawingEngine.startDrawing(x, y, nativeEvent)
  ↓
[座標変換パイプライン]
  screenClientToCanvas()  ← DPI補正
  ↓
  canvasToWorld()  ← worldContainer逆行列
  ↓
  worldToLocal()  ← 手動逆算（親チェーン遡査）
  ↓
[ローカル座標確定]
  ↓
StrokeRecorder.startStroke(localX, localY, pressure)
  ↓ (二重変換しない)
  ↓
points: [{x, y, pressure, time, ...}]
  ↓
StrokeRenderer.renderPreview(points)
  ↓
Layer.addChild(preview)  ← ローカル座標で描画
```

---

## ■ 今後の実装チェックリスト

### 座標系を扱うコード追加時

- [ ] パラメータ名に座標系を明示（localX, worldX, screenX）
- [ ] メソッド名でも座標系を区別可能に
- [ ] @param, @returns でドキュメント化
- [ ] 二重変換がないか確認
- [ ] 手動逆算の場合、親チェーンスキャン範囲を明示
- [ ] worldContainer のoffset が含まれていないか確認

### デバッグ時

- [ ] 各段階の座標値を確認（Screen → Canvas → World → Local）
- [ ] worldTransform.tx/ty に worldContainer.position が含まれているか確認
- [ ] 親階層の構造を確認
- [ ] 二重変換していないか確認

### テスト項目

- [ ] 初期状態で座標が一致するか
- [ ] ズーム/パン後も座標が一致するか
- [ ] レイヤー移動後も座標が一致するか
- [ ] Retina/DPI補正環境で座標が一致するか
- [ ] Canvas resize後も座標が一致するか

---

## ■ グローバルオブジェクト統一提案

**現状:**
```
window.CoordinateSystem        (✓ 統一)
window.TEGAKI_COORDINATE_SYSTEM (重複)
window.cameraSystem             (✓ 統一)
window.layerSystem              (未定義)
window.layerManager             (✓ 実装)
window.TegakiLayerSystem        (クラス)
```

**提案:**
```javascript
// core-runtime.js で明示的に統一
window.CoordinateSystem = window.CoordinateSystem;  // 既存
window.CameraSystem = window.cameraSystem;           // 昇格
window.LayerSystem = window.layerManager;            // 統一
window.DrawingEngine = window.drawingEngine;         // 明示化

// 削除候補:
// window.TEGAKI_COORDINATE_SYSTEM (重複)
// window.TegakiLayerSystem (クラス定義の副作用)
```

---

## ■ 今後の Phase 計画

### Phase 2: リサイズ処理の座標系統合
- canvas resize時の worldContainer 位置調整
- 中心保持・等間隔保持のアルゴリズム

### Phase 3: レイヤーシステムの座標同期
- Vキーレイヤー移動時の座標正確性
- サムネイル即時更新

### Phase 4: UI調整
- スライダー色統一（maroon系）

### Phase 5: 統合テスト・検証
- すべてのシナリオを検証

---

## ■ まとめ

**v1.0実装の知見:**

1. **PIXI v8の toLocal() は信頼できない** → 手動逆算が必須
2. **二重変換は命名で防ぐ** → パラメータ名に座標系を明示
3. **グローバルオブジェクトは統一** → window.layerManager に一本化
4. **初期化タイミングは明確に** → init()は1回限り
5. **座標変換の境界を明確に** → 各レイヤーの責務を分離

これらを遵守することで、座標系の問題は未然に防げます。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
座標系統合・完全修正 改修ロードマップ
v8.13_Drawing_48 → 座標系統合版
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 現状の問題点
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. ペン入力位置と描画出力位置のズレ（初期状態から）
2. リサイズ時：キャンバスは正しいが内容は左上原点で強制リサイズ、ペン位置がさらにズレる
3. レイヤーサムネイル反応遅延、Vキーによるレイヤー変形が反映されない
4. Vキーでのアクティブレイヤー移動でペン座標がズレる
5. スライダーが青系（maroon系に統一したい）

根本原因：Screen→Canvas→World→Local の座標変換が統一されていない


■ 改修方針
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 座標変換を coordinate-system.js に完全統合
- DPI/DPR/CSSスケールを考慮した変換関数を一元化
- drawing-engine.js は座標変換に依存せずワールド座標で動作
- camera-system.js は表示変換のみ担当
- すべてのpointerイベントは統一された変換パイプラインを通す


■ ファイル責務の再定義
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
coordinate-system.js : Screen↔Canvas↔World↔Local 変換の完全統合
camera-system.js     : worldContainerのtransform管理、リサイズ、ズーム・パン
drawing-engine.js    : ワールド座標でのペン描画ロジック（座標変換依存を排除）
layer-transform.js   : レイヤー単位のtransform、Vキー操作
stroke-recorder.js   : ローカル座標でのストローク記録
resize-popup.js      : リサイズUI、座標系を意識した中心保持処理


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 0: 座標変換システムの完全統合【最優先・基盤】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

目的：
すべての座標変換を coordinate-system.js に集約し、
DPI/DPR/CSS変形を正確に考慮した変換を提供する。

対象ファイル：
- coordinate-system.js （大幅拡張）

参考ファイル：
- camera-system.js （worldContainer参照）
- core-engine.js （app/renderer参照）

処理フロー内の位置：
PointerEvent → CoordinateSystem変換 → DrawingEngine → StrokeRecorder → Renderer

実装内容：
1. 既存の screenToWorld() を完全書き換え
   - getBoundingClientRect()でCSS位置取得
   - renderer.width/heightとrect.width/heightの比率でDPI補正
   - worldContainer.transform.worldTransformの逆行列適用

2. 新規API追加
   screenClientToCanvas(app, clientX, clientY)
     → {x, y} // Canvas内部ピクセル座標
   
   canvasToWorld(app, canvasX, canvasY)
     → {x, y} // ワールド座標（カメラ補正済み）
   
   screenClientToWorld(app, clientX, clientY)
     → {x, y} // Screen→Canvas→World の統合版
   
   worldToLocal(worldPoint, container)
     → {x, y} // container.toLocal()のラッパー
   
   screenClientToLocal(app, clientX, clientY, container)
     → {x, y} // Screen→World→Local の統合版

3. 逆変換も実装
   worldToCanvas(app, worldX, worldY)
   canvasToScreen(app, canvasX, canvasY)
   localToWorld(localPoint, container)
   localToScreen(app, localPoint, container)

主要メソッド定義：
```
CoordinateSystem.prototype.screenClientToCanvas(app, clientX, clientY)
CoordinateSystem.prototype.canvasToWorld(app, canvasX, canvasY) 
CoordinateSystem.prototype.screenClientToWorld(app, clientX, clientY)
CoordinateSystem.prototype.worldToLocal(worldPoint, container)
CoordinateSystem.prototype.screenClientToLocal(app, clientX, clientY, container)
```

検証項目：
□ Retina環境でDPR補正が正確か
□ CSSでcanvasを拡大縮小してもズレないか
□ worldContainerをズーム・移動してもマウス位置が正確か
□ レイヤー移動後もtoLocal変換が正確か


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 1: 描画エンジンの座標変換適用
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

目的：
drawing-engine.js のすべてのpointerイベントで
Phase 0の統一変換APIを使用する。

対象ファイル：
- drawing-engine.js
- stroke-recorder.js

参考ファイル：
- coordinate-system.js （Phase 0で実装したAPI）
- pressure-handler.js

処理フロー内の位置：
[PointerEvent] 
  → DrawingEngine.onPointerDown/Move/Up 
  → CoordinateSystem.screenClientToLocal(app, e.clientX, e.clientY, activeLayer)
  → StrokeRecorder.addPoint(localX, localY, pressure)
  → StrokeRenderer.render()

実装内容：
1. drawing-engine.js 内のすべてのpointer処理を書き換え
   - 既存：event.offsetX/offsetY や layerX/layerY を直接使用
   - 新規：coordinateSystem.screenClientToLocal() 経由

2. stroke-recorder.js での座標記録確認
   - points配列がローカル座標で統一されているか確認
   - ワールド座標やスクリーン座標が混入していないか確認

3. pressure-handler.js の座標も同様に変換適用

主要変更箇所：
```
// drawing-engine.js
onPointerDown(e) {
  const local = this.coordinateSystem.screenClientToLocal(
    this.app, e.clientX, e.clientY, this.activeLayer.container
  );
  this.strokeRecorder.startStroke(local.x, local.y, e.pressure);
}
```

検証項目：
□ ペン入力位置と描画位置が完全に一致するか
□ カメラズーム・パン後も描画位置が正確か
□ レイヤー移動後も描画位置が正確か
□ 筆圧が正しく適用されているか


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 2: リサイズ処理の座標系統合
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

目的：
リサイズ時の座標系破綻を修正。
中心保持・等間隔保持などの基準点を正確に適用。

対象ファイル：
- resize-popup.js
- camera-system.js
- core-runtime.js （リサイズイベント）

参考ファイル：
- coordinate-system.js
- layer-system-complete.js

処理フロー内の位置：
[ResizePopup: ユーザー操作] 
  → CameraSystem.resizeCanvas(newW, newH, anchorOptions)
  → renderer.resize()
  → worldContainer.scale/position 再計算
  → EventBus: 'canvas:resized'
  → 各システムが座標系を再同期

実装内容：
1. camera-system.js にリサイズメソッド追加
   resizeCanvas(newWidth, newHeight, options)
     options: { anchor: 'center' | 'top-left' | 'top-right' ... }
   
   処理内容：
   - 現在のワールド座標での中心点を取得
   - renderer.resize(newWidth, newHeight)
   - anchor指定に応じてworldContainer.position/scaleを再計算
   - 中心点が維持されるように逆算

2. resize-popup.js の実行ボタン処理を修正
   - 既存：直接renderer操作
   - 新規：cameraSystem.resizeCanvas() 経由

3. core-runtime.js のwindowリサイズハンドラも同様に修正

主要メソッド定義：
```
CameraSystem.prototype.resizeCanvas(width, height, options = {})
CameraSystem.prototype.getWorldBounds()
CameraSystem.prototype.maintainViewCenter(oldBounds, newBounds)
```

検証項目：
□ リサイズ後も描画位置がズレないか
□ 中心保持が正確に動作するか
□ 等間隔保持（上下左右等間隔）が動作するか
□ リサイズ後の描画もズレないか


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 3: レイヤーシステムの座標同期
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

目的：
Vキーでのレイヤー移動・変形時の座標ズレ解消。
サムネイル更新の遅延解消。

対象ファイル：
- layer-transform.js
- layer-system-complete.js
- layer-panel-renderer.js
- timeline-thumbnail-utils.js

参考ファイル：
- coordinate-system.js
- camera-system.js

処理フロー内の位置：
[Vキー押下] 
  → KeyboardHandler 
  → LayerTransform.enableTransform()
  → [ドラッグ] CoordinateSystem.screenClientToWorld()
  → layer.container.position更新
  → EventBus: 'layer:transform-changed'
  → ThumbnailUtils.updateThumbnail()

実装内容：
1. layer-transform.js のドラッグ処理を座標系統合
   - 既存：pointer座標を直接使用
   - 新規：coordinateSystem.screenClientToWorld() で変換
   - レイヤーのlocalへの変換も考慮

2. layer-system-complete.js のtransform反映
   - レイヤー移動後のstroke座標を再計算しない（ローカル座標なので不要）
   - worldContainer経由での表示のみ更新

3. timeline-thumbnail-utils.js のサムネイル更新最適化
   - transform変更時に即座に再生成
   - 既存：遅延バッチ処理
   - 新規：EventBus: 'layer:transform-changed' に即応答

4. layer-panel-renderer.js のサムネイル表示同期
   - Vキー変形が即座に反映されるようイベント購読

主要変更箇所：
```
// layer-transform.js
onDrag(e) {
  const world = this.coordinateSystem.screenClientToWorld(
    this.app, e.clientX, e.clientY
  );
  const delta = { x: world.x - this.startWorld.x, y: world.y - this.startWorld.y };
  this.activeLayer.container.position.set(
    this.startPosition.x + delta.x,
    this.startPosition.y + delta.y
  );
  EventBus.emit('layer:transform-changed', { layerId: this.activeLayer.id });
}
```

検証項目：
□ Vキーでのレイヤー移動が正確か
□ 移動後の描画位置がズレないか
□ サムネイルが即座に更新されるか
□ Vキー変形がサムネイルに反映されるか


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 4: UI調整（スライダー色統一）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

目的：
resize-popup.js のスライダー色をmaroon系に統一。
他のポップアップUIと一貫性を持たせる。

対象ファイル：
- resize-popup.js
- ui/slider-utils.js （あれば）
- styles/main.css

参考ファイル：
- settings-popup.js （maroon系スライダーの参考）
- quick-access-popup.js

処理フロー内の位置：
UIレンダリング時の色指定

実装内容：
1. resize-popup.js のスライダー生成部分
   - 既存：color指定なし or 青系
   - 新規：trackColor: '#8b4545', thumbColor: '#a0522d' など

2. styles/main.css でのスタイル統一
   - .resize-popup input[type="range"] のカスタムスタイル
   - maroon系に統一

3. slider-utils.js が存在する場合は共通化
   - createSlider() のデフォルト色をmaroonに

主要変更箇所：
```
// resize-popup.js
const widthSlider = SliderUtils.createSlider({
  trackColor: '#8b4545',
  thumbColor: '#a0522d',
  // ...
});
```

検証項目：
□ スライダーがmaroon系で表示されるか
□ 他のポップアップと色調が統一されているか


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 5: 統合テスト・検証
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

目的：
すべての改修が正しく統合され、座標ズレが完全に解消されたか確認。

テストシナリオ：
1. 初期描画テスト
   □ ツール起動直後、ペン描画位置とカーソル位置が一致
   □ Retina/非Retina環境で動作確認

2. カメラ操作後の描画テスト
   □ ズームイン・アウト後も描画位置が正確
   □ パン（移動）後も描画位置が正確

3. リサイズテスト
   □ 中心保持でリサイズ後、既存描画が正しい位置
   □ 左上基準でリサイズ後、既存描画が正しい位置
   □ リサイズ後の新規描画も正確

4. レイヤー操作テスト
   □ Vキーでレイヤー移動後、そのレイヤーへの描画が正確
   □ レイヤー移動直後もペン位置がズレない
   □ サムネイルが即座に更新される

5. 複合操作テスト
   □ ズーム→リサイズ→レイヤー移動→描画 が正確
   □ 長時間使用でも座標ズレが発生しない

6. UI動作確認
   □ スライダーがmaroon系で統一されている
   □ 全ポップアップの色調が一貫している


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
将来拡張への準備
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

この座標系統合により以下が実装可能になる：

1. ベクター消しゴム
   - ストロークがローカル座標で統一されているため
     ブーリアン演算が正確に適用できる

2. MSDF消しゴム
   - SDF生成時の座標変換が明確になる
   - シェーダでのUV変換が正確になる

3. レイヤー回転・変形
   - transformが正確に適用される基盤ができる

4. パスアニメーション
   - ローカル座標での移動・変形が正確になる


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
改修優先度と依存関係
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase 0 → Phase 1 → Phase 2 → Phase 3 → Phase 4 → Phase 5
  ↓         ↓         ↓         ↓         ↓         ↓
 必須     必須     必須     必須     任意     必須

Phase 0 を完了しないと他のPhaseは意味を成さない。
Phase 1-3 は座標系の実運用部分なので必須。
Phase 4 は見た目の統一なので優先度は低い。
Phase 5 は全体検証なので最後に必須。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
改修時の注意事項
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 座標変換は必ず coordinate-system.js 経由
   - 直接 event.offsetX や layerX を使わない
   - 直接 container.toLocal/toGlobal を呼ばない

2. DPI/DPRは常に考慮
   - getBoundingClientRect() と renderer.width/height の比率
   - window.devicePixelRatio

3. worldContainer の transform は camera-system.js が管理
   - 他のコードから直接操作しない

4. ストロークはローカル座標で記録
   - ワールド座標やスクリーン座標での記録は禁止

5. EventBus でシステム間連携
   - 'camera:transform-changed'
   - 'layer:transform-changed'
   - 'canvas:resized'

6. コンソールログは最小限
   - 不具合時はエラーを throw して検索可能にする


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
END
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━