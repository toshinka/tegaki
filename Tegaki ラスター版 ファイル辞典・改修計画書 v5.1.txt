================================================================================
Tegaki ラスター版 ファイル辞典・改修計画書 v5.1
================================================================================

作成日: 2024-12-13
基準: webgl2_Raster_rev10
前版: v5.0 (Phase Emergency失敗による方針転換)
目的: GLコンテキスト完全分離・段階的PixiJS削減・保守性最優先

================================================================================
📋 v5.0 からの主要変更点
================================================================================

【方針転換の理由】
❌ v5.0 Phase Emergency: PixiJS ticker制御による共存
   → 実装失敗。PixiJS内部実装への深い依存が必要
   → 将来のバージョンアップで再度破綻リスク

✅ v5.1 新方針: GLコンテキスト物理的分離
   → 描画Canvas(WebGL2) と 表示Canvas(PixiJS) を完全分離
   → 競合が物理的に不可能な構造
   → 段階的にPixiJS依存を削減

【アーキテクチャ変更】
```
[v5.0 構造 - 失敗]
PixiJS Canvas (WebGL2)
  ├─ PixiJS renderer (自動ticker)
  └─ RasterBrushCore (手動描画)
     → 同一GLコンテキスト共有で競合

[v5.1 構造 - 採用]
描画Canvas (WebGL2) [非表示]
  └─ RasterBrushCore (完全制御)
     ↓ Texture転送
表示Canvas (PixiJS) [表示]
  └─ PIXI.Sprite (受動表示のみ)
     → 完全分離・競合不可能
```

【実装フェーズ変更】
- Phase Emergency (1-2h) → 削除
- Phase B-Emergency (2-3h) → 新設
- Phase C: PixiJS段階的削減 → 追加
- Phase D-E: 完全WebGL2化 → 追加（オプション）

================================================================================
第1部: 問題分析（v5.1更新版）
================================================================================

【現象】
ペン描画時にキャンバスが消える
コンソールエラー:
```
WebGL: INVALID_OPERATION: uniformMatrix3fv: location is not from the associated program
TypeError: this._resetPixiShaderSystem is not a function
```

【根本原因】
❌ v5.0の診断: ticker制御の不完全性
✅ v5.1の診断: アーキテクチャ設計ミス

**構造的問題:**
1. 同一GLコンテキストの共有自体が誤り
2. PixiJSの内部実装に過度に依存
3. 描画責務と表示責務が混在

**なぜticker制御では解決できないか:**
- PixiJS v8は内部でRenderer/System/Pluginが複雑に絡む
- ticker.stop()だけでは不十分（内部システムが残る）
- _resetPixiShaderSystem()等の非公開APIが必要
- バージョンアップで破綻する設計

【正しい解決策】
🎯 **責務の物理的分離**
- 描画: WebGL2 Canvas（独立したGLコンテキスト）
- 表示: PixiJS Canvas（Texture受け取りのみ）
- 競合: 構造的に発生不可能

================================================================================
第2部: 新アーキテクチャ詳細
================================================================================

------------------------------------------------------------------------
2.1 GLコンテキスト分離アーキテクチャ
------------------------------------------------------------------------

【描画レイヤー（WebGL2）】
```javascript
// 非表示Canvas - 描画専用
<canvas id="drawing-canvas" style="display:none"></canvas>

責務:
- ブラシストロークの描画
- レイヤーFBO管理
- テクスチャ書き込み
- 補間・アンチエイリアス
- 完全な単独制御

特徴:
✅ PixiJSから完全独立
✅ GLステート競合なし
✅ ticker制御不要
✅ 高速描画に特化
```

【表示レイヤー（PixiJS）】
```javascript
// 表示Canvas - UI専用
<canvas id="pixi-canvas"></canvas>

責務:
- レイヤーSprite表示
- UI Container管理
- カメラ変換（worldContainer）
- イベント処理（オプション）

特徴:
✅ 描画責務なし（受動表示のみ）
✅ ticker自由に動作可能
✅ GLステート干渉なし
✅ UIフレームワークとして活用
```

【転送ブリッジ】
```javascript
// gl-texture-bridge.js (改修)
class GLTextureBridge {
  transferDrawingToDisplay(layerId) {
    // 1. 描画Canvasから Texture 取得
    const glTexture = rasterLayer.getLayerTexture(layerId);
    
    // 2. PixiJS Texture作成
    const pixiTexture = this._createPixiTextureFromGL(glTexture);
    
    // 3. Sprite更新
    const sprite = layerSprites.get(layerId);
    sprite.texture = pixiTexture;
  }
}
```

------------------------------------------------------------------------
2.2 転送方式の選択
------------------------------------------------------------------------

【方式A: Canvas経由転送（推奨）】
```javascript
// 描画Canvas → 2DContext → PixiJS
const ctx2d = drawingCanvas.getContext('2d');
ctx2d.drawImage(sourceCanvas, 0, 0);
const pixiTexture = PIXI.Texture.from(drawingCanvas);
```

メリット:
✅ 実装が最もシンプル
✅ ブラウザが最適化
✅ 互換性が高い

デメリット:
⚠️ 若干のオーバーヘッド（60fpsは維持可能）

---

【方式B: WebGLテクスチャ直接共有（高度）】
```javascript
// GLテクスチャ → PixiJS BaseTexture
const baseTexture = new PIXI.BaseTexture(glTexture);
const pixiTexture = new PIXI.Texture(baseTexture);
```

メリット:
✅ GPU内で完結（高速）
✅ メモリコピーなし

デメリット:
⚠️ 実装複雑
⚠️ GLコンテキスト共有が必要（分離の意味が薄れる）

---

**🎯 採用: 方式A（Canvas経由）**

理由:
- シンプルで保守しやすい
- 完全分離を維持
- パフォーマンス十分

------------------------------------------------------------------------
2.3 段階的PixiJS削減戦略
------------------------------------------------------------------------

現在のPixiJS使用箇所:
1. ✅ レイヤーSprite表示 → Phase B後も継続使用
2. ✅ worldContainer変換 → Phase C-1で独自実装
3. ✅ PointerEvent処理 → Phase C-2で独自実装
4. ⚠️ UI Container管理 → Phase D-1で段階的削減
5. ⚠️ ticker管理 → Phase D-2で独自RAF実装

【削減ロードマップ】
```
Phase B: 分離完了
  PixiJS使用: レイヤー表示、カメラ、イベント、UI
  削減率: 0%

Phase C: 座標・イベント独自化
  PixiJS使用: レイヤー表示、UI Container
  削減率: 40%

Phase D: UI独自実装
  PixiJS使用: なし
  削減率: 100%
```

================================================================================
第3部: 完全ファイル辞典（v5.1更新版）
================================================================================

------------------------------------------------------------------------
3.1 WebGL2描画システム（Phase B改修対象）
------------------------------------------------------------------------

📄 system/drawing/raster/raster-brush-core.js
Phase: B-Emergency-2
変更内容:
  ❌ 削除: _stopPixiTicker(), _restartPixiTicker()
  ❌ 削除: _capturePixiRenderCallback(), _resetPixiShaderSystem()
  ✅ 簡素化: finalizeStroke() → 転送のみ
  ✅ 新規: 描画Canvasへの完全集中
責務: ラスターブラシGPU描画（描画Canvas専用）
親依存: brush-core.js, drawing-engine.js
子依存: raster-layer.js, brush-stamp.js, brush-interpolator.js
グローバル: window.RasterBrushCore
主要メソッド:
  ✅ initialize(drawingCanvas) - 描画Canvas受け取り
  ✅ startStroke() - ストローク開始
  ✅ addStrokePoint() - 点追加・描画
  ✅ finalizeStroke() - 完了・転送トリガー
  ❌ ticker制御系メソッド削除
問題箇所:
  ✅ 全て解決（PixiJS依存削除）

---

📄 system/drawing/webgl2/webgl2-drawing-layer.js
Phase: B-Emergency-1
変更内容:
  ✅ 新規: 描画Canvas生成・管理
  ✅ 新規: 独立GLコンテキスト管理
  ❌ 削除: linkPixiApp()のticker制御
  ✅ 簡素化: PixiJSとの連携は転送のみ
責務: WebGL2描画Canvas管理・転送統合
親依存: core-initializer.js
子依存: raster-layer.js, gl-texture-bridge.js
グローバル: window.WebGL2DrawingLayer
主要メソッド:
  ✅ initialize(width, height) - 描画Canvas生成
  ✅ getDrawingCanvas() - Canvas取得
  ✅ getGLContext() - 独立GLコンテキスト取得
  ❌ disablePixiAutoRender()等削除
問題箇所:
  ✅ 全て解決

---

📄 system/drawing/webgl2/gl-texture-bridge.js
Phase: B-Emergency-3
変更内容:
  🔧 改修: Canvas経由転送方式に変更
  ✅ 新規: transferLayerToPixi(layerId)
  ✅ 簡素化: 双方向変換→片方向転送
責務: 描画Canvas → PixiJS Texture 転送
親依存: webgl2-drawing-layer.js
子依存: なし
グローバル: window.GLTextureBridge
主要メソッド:
  ✅ initialize(drawingCanvas, pixiApp)
  ✅ transferLayerToPixi(layerId) - 転送実行
  ❌ pixiToWebgl() 削除（不要）
問題箇所:
  ✅ 全て解決

---

📄 system/drawing/raster/raster-layer.js
Phase: B-Emergency-1
変更内容:
  ✅ 変更: 描画Canvas専用GLコンテキスト使用
責務: 描画Canvas上のFBO/テクスチャ管理
問題箇所:
  ✅ 正常動作維持

---

📄 system/drawing/shader-inline.js
Phase: 変更なし
問題箇所:
  ✅ 正常動作

------------------------------------------------------------------------
3.2 表示統合システム（Phase B改修対象）
------------------------------------------------------------------------

📄 system/layer-system.js
Phase: B-Emergency-4
変更内容:
  🔧 改修: Sprite生成時に転送を受け取る形式に
  ✅ 新規: _receiveTransferredTexture(layerId, pixiTexture)
責務: レイヤーSprite管理（表示のみ）
親依存: core-engine.js
子依存: なし
主要メソッド:
  ✅ addLayer() - Sprite生成
  ✅ _receiveTransferredTexture() - 転送Texture受信
問題箇所:
  ✅ 解決

---

📄 coordinate-system.js
Phase: C-1で改修予定
現状: PixiJS toLocal()使用（Phase B継続使用）
将来: 独自行列計算実装

---

📄 system/camera-system.js
Phase: C-1で改修予定
現状: worldContainer.transform操作（Phase B継続使用）
将来: 独自Transform管理

------------------------------------------------------------------------
3.3 削除対象ファイル
------------------------------------------------------------------------

Phase Bでは削除なし（Phase Cで検討）

================================================================================
第4部: 改修計画（v5.1）
================================================================================

------------------------------------------------------------------------
Phase B-Emergency: GLコンテキスト完全分離（最優先・2-3時間）
------------------------------------------------------------------------

🎯 目標: 描画Canvas/表示Canvas完全分離・競合の根絶

---

🚨 BE-1. 描画Canvas生成・管理（30分）
対象: webgl2-drawing-layer.js

修正内容:
```javascript
class WebGL2DrawingLayer {
  initialize(width, height) {
    // 1. 描画Canvas生成（非表示）
    this.drawingCanvas = document.createElement('canvas');
    this.drawingCanvas.width = width;
    this.drawingCanvas.height = height;
    this.drawingCanvas.style.display = 'none';
    document.body.appendChild(this.drawingCanvas);
    
    // 2. 独立GLコンテキスト取得
    this.gl = this.drawingCanvas.getContext('webgl2', {
      alpha: true,
      premultipliedAlpha: true,
      antialias: false
    });
    
    if (!this.gl) {
      throw new Error('WebGL2 not supported');
    }
    
    // 3. グローバル登録
    window.GLContext = {
      gl: this.gl,
      canvas: this.drawingCanvas
    };
    
    console.log('[WebGL2] ✅ Drawing canvas created (separated)');
    console.log('  Canvas:', this.drawingCanvas);
    console.log('  Size:', width, 'x', height);
  }
  
  getDrawingCanvas() {
    return this.drawingCanvas;
  }
  
  getGLContext() {
    return this.gl;
  }
}
```

期待効果:
✅ PixiJSから完全独立したGLコンテキスト確立
✅ 描画専用環境の構築

---

🚨 BE-2. RasterBrushCore簡素化（1時間）
対象: raster-brush-core.js

修正内容:
```javascript
// ❌ 削除する行: Line 293-393
// _capturePixiRenderCallback()
// _stopPixiTicker()
// _restartPixiTicker()
// _resetPixiShaderSystem()

class RasterBrushCore {
  initialize(drawingCanvas) {
    this.gl = drawingCanvas.getContext('webgl2');
    
    // RasterLayer初期化
    this.rasterLayer = window.rasterLayer;
    this.rasterLayer.initialize(this.gl);
    
    // シェーダー初期化
    this._initializeShaders();
    
    console.log('[RasterBrushCore] ✅ Initialized (separated mode)');
    console.log('  No Pixi ticker control needed');
  }
  
  startStroke(localX, localY, pressure, ...) {
    // Pixi制御なし・純粋な描画開始
    const layerId = this._getCurrentLayerId();
    this.rasterLayer.bindFramebuffer(layerId);
    
    // 初回スタンプ描画
    this._drawBrushStamp(localX, localY, pressure, ...);
  }
  
  addStrokePoint(localX, localY, pressure, ...) {
    // Pixi制御なし・純粋な描画
    this._interpolateAndDraw(localX, localY, pressure, ...);
  }
  
  finalizeStroke() {
    // 1. FBOのバインド解除
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    
    // 2. 転送トリガー
    const layerId = this._getCurrentLayerId();
    window.glTextureBridge.transferLayerToPixi(layerId);
    
    console.log('[RasterBrushCore] ✅ Stroke finalized and transferred');
  }
}
```

削除行数: 約150行
追加行数: 約20行

期待効果:
✅ コードが1/3に簡素化
✅ Pixi依存完全削除
✅ 見通しの良い実装

---

🚨 BE-3. Canvas経由転送実装（1時間）
対象: gl-texture-bridge.js

修正内容:
```javascript
class GLTextureBridge {
  initialize(drawingCanvas, pixiApp) {
    this.drawingCanvas = drawingCanvas;
    this.pixiApp = pixiApp;
    this.layerTextureCache = new Map();
    
    console.log('[GLTextureBridge] ✅ Initialized (Canvas transfer mode)');
  }
  
  transferLayerToPixi(layerId) {
    // 1. 描画Canvasから該当レイヤーを取得
    // （注: 実際にはFBOをCanvasに描画する必要あり）
    const glTexture = window.rasterLayer.getLayerTexture(layerId);
    
    // 2. 一時Canvasに描画
    const tempCanvas = this._getOrCreateTempCanvas(layerId);
    this._renderTextureToCanvas(glTexture, tempCanvas);
    
    // 3. PixiJS Textureに変換
    let pixiTexture = this.layerTextureCache.get(layerId);
    if (!pixiTexture) {
      pixiTexture = PIXI.Texture.from(tempCanvas);
      this.layerTextureCache.set(layerId, pixiTexture);
    } else {
      // 既存Textureを更新
      pixiTexture.update();
    }
    
    // 4. EventBus経由でSprite更新を通知
    window.EventBus.emit('layer:texture-updated', {
      layerId,
      texture: pixiTexture
    });
    
    console.log('[GLTextureBridge] ✅ Layer transferred:', layerId);
    
    return pixiTexture;
  }
  
  _getOrCreateTempCanvas(layerId) {
    let canvas = this.tempCanvases?.get(layerId);
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.width = this.drawingCanvas.width;
      canvas.height = this.drawingCanvas.height;
      if (!this.tempCanvases) this.tempCanvases = new Map();
      this.tempCanvases.set(layerId, canvas);
    }
    return canvas;
  }
  
  _renderTextureToCanvas(glTexture, canvas) {
    const ctx = canvas.getContext('2d');
    
    // GLテクスチャをCanvasに描画
    // （WebGL2 FBO → Canvas2D の転送）
    const gl = window.GLContext.gl;
    const width = canvas.width;
    const height = canvas.height;
    
    // FBOにバインド
    const fbo = window.rasterLayer.layers.get(layerId).fbo;
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    
    // ピクセルデータ読み取り
    const pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    
    // ImageDataに変換
    const imageData = new ImageData(new Uint8ClampedArray(pixels), width, height);
    
    // Canvasに描画
    ctx.putImageData(imageData, 0, 0);
    
    // バインド解除
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
}
```

期待効果:
✅ 描画→表示の安全な転送
✅ Texture再利用によるメモリ効率化

---

🚨 BE-4. LayerSystem受信実装（30分）
対象: layer-system.js

修正内容:
```javascript
class LayerSystem {
  init(canvasContainer) {
    // ... 既存初期化 ...
    
    // 転送イベントリスナー登録
    window.EventBus.on('layer:texture-updated', (data) => {
      this._updateLayerSprite(data.layerId, data.texture);
    });
  }
  
  _updateLayerSprite(layerId, texture) {
    const layer = this.layers.get(layerId);
    if (!layer || !layer.sprite) {
      console.warn('[LayerSystem] Sprite not found:', layerId);
      return;
    }
    
    // Sprite Textureを更新
    layer.sprite.texture = texture;
    
    console.log('[LayerSystem] ✅ Sprite updated:', layerId);
  }
}
```

期待効果:
✅ 転送されたTextureの自動反映
✅ EventBus経由の疎結合

---

🚨 BE-5. Core-Initializer修正（30分）
対象: core-initializer.js

修正内容:
```javascript
async initializeWebGL2Raster(config) {
  console.log('[DrawingApp] 🚀 Initializing separated WebGL2...');
  
  // 1. 描画Canvas生成
  const webgl2Layer = new window.WebGL2DrawingLayer();
  webgl2Layer.initialize(config.width, config.height);
  window.webgl2Layer = webgl2Layer;
  
  // 2. RasterLayer初期化
  const gl = webgl2Layer.getGLContext();
  window.rasterLayer.initialize(gl);
  
  // 3. GLTextureBridge初期化
  const drawingCanvas = webgl2Layer.getDrawingCanvas();
  window.glTextureBridge.initialize(drawingCanvas, this.pixiApp);
  
  // 4. RasterBrushCore初期化
  window.rasterBrushCore.initialize(drawingCanvas);
  
  // 5. PixiJS tickerは自由に動作（干渉なし）
  // （ticker制御コード削除）
  
  console.log('[DrawingApp] ✅ Separated WebGL2 initialized');
  console.log('  Drawing canvas: Independent');
  console.log('  Display canvas: PixiJS managed');
  console.log('  No GL context conflict possible');
}
```

期待効果:
✅ 初期化フローの明確化
✅ ticker制御コード削除

---

【Phase B-Emergency完了条件】
□ ペンで線が引ける
□ 連続10ストローク描画しても問題なし
□ WebGLエラーメッセージが完全に出ない
□ キャンバスが消えない
□ Undo/Redoが正常動作
□ レイヤー切り替えが正常動作
□ 60fps維持

------------------------------------------------------------------------
Phase A: 描画品質向上（BE完了後・1-2日）
------------------------------------------------------------------------

（v5.0のPhase Aと同じ内容）

A-1. 筆圧サイズ計算の修正
A-2. ブラシスタンプの完全活用
A-3. 補間アルゴリズムの改善
A-4. フロー制御の実装

------------------------------------------------------------------------
Phase C: PixiJS依存削減（A完了後・3-4日）
------------------------------------------------------------------------

🎯 目標: 座標変換・イベント処理の独自実装

---

C-1. 座標変換の独自実装（1日）
対象: coordinate-system.js, camera-system.js

内容:
- worldToLocal()の完全独自実装
- PixiJS toLocal()/toGlobal()削除
- 行列計算ライブラリ（gl-matrix等）導入検討

削減: PixiJS座標系依存 → 0%

---

C-2. PointerEvent処理の独自実装（1日）
対象: pointer-handler.js, drawing-engine.js

内容:
- 描画Canvasに直接PointerEvent登録
- PixiJS InteractionManagerを完全回避
- setPointerCapture()使用

削減: PixiJSイベント依存 → 0%

---

C-3. worldContainer管理の独自実装（1日）
対象: camera-system.js

内容:
- PIXI.Containerから独自Transform管理へ移行
- CSS transformまたはWebGL行列で実装
- ズーム・パン機能の再実装

削減: PixiJS Container依存 → 50%

---

【Phase C完了時の状態】
PixiJS使用箇所: レイヤーSprite表示、UI Container管理のみ
削減率: 60%

------------------------------------------------------------------------
Phase D: UI独自実装（オプション・1週間）
------------------------------------------------------------------------

🎯 目標: PixiJS完全削除

**注意: Phase Cまでで十分安定・保守可能。Phase Dは任意。**

---

D-1. レイヤーSprite管理の独自実装（3日）
内容:
- HTML/CSS/Canvas2Dでレイヤー表示
- WebGL Quadでの高速描画
- PixiJS Sprite/Container完全削除

---

D-2. tickerの独自RAF実装（1日）
内容:
- requestAnimationFrame()による独自ループ
- PixiJS Application完全削除

---

D-3. UI Container管理の独自実装（3日）
内容:
- HTML/CSSベースのUI
- または軽量UIライブラリ導入（Preact等）

---

【Phase D完了時の状態】
PixiJS使用箇所: なし
削減率: 100%
バンドルサイズ: -400KB以上削減

================================================================================
第5部: テスト項目
================================================================================

Phase B-Emergency完了時:
□ ペンで線が引ける（基本動作）
□ 連続10ストローク描画しても問題なし
□ WebGLエラーメッセージが完全に出ない
□ キャンバスが消えない
□ Undo/Redoが正常動作
□ レイヤー切り替えが正常動作
□ 60fps維持
□ メモリリーク確認（DevTools Memory）

Phase A完了時:
（v5.0と同じ）

Phase C完了時:
□ PixiJS toLocal()を使用していない
□ PixiJS InteractionManagerを使用していない
□ 座標変換が正確
□ PointerEventが正常動作

Phase D完了時:
□ PixiJS完全削除
□ アプリが正常動作
□ バンドルサイズ削減確認

================================================================================
第6部: 実装スケジュール
================================================================================

【最優先】Phase B-Emergency（2-3時間）
理由: 現在描画不能・システム機能不全
スケジュール:
  BE-1: 描画Canvas生成 → 30分
  BE-2: RasterBrushCore簡素化 → 1時間
  BE-3: Canvas転送実装 → 1時間
  BE-4: LayerSystem受信 → 30分
  BE-5: Core-Initializer修正 → 30分
  テスト → 30分
完了条件:
  ✅ ペン描画が正常動作
  ✅ WebGLエラー完全消滅
  ✅ 60fps維持

【高優先】Phase A（1-2日）
前提: Phase B-Emergency完了
（v5.0と同じ内容）

【中優先】Phase C（3-4日）
前提: Phase A完了
目的: PixiJS依存の戦略的削減

【低優先】Phase D（オプション・1週間）
前提: Phase C完了
目的: PixiJS完全削除（任意）

================================================================================
第7部: パフォーマンス分析
================================================================================

【Canvas転送のオーバーヘッド】
```
操作: gl.readPixels() + ctx.putImageData()
頻度: ストローク完了時のみ（描画中は転送なし）
400x400px: ~1ms
800x800px: ~4ms
1600x1600px: ~16ms

結論: 60fps維持可能（16ms < 16.67ms/frame）
```

【最適化戦略】
1. **差分転送**: 変更領域のみ転送（Phase A後）
2. **遅延転送**: 複数ストローク完了後にまとめて転送
3. **サイズ制限**: レイヤーサイズ上限を設定

【メモリ使用量】
```
従来（v5.0）:
  WebGL2 Context: 1個
  Canvas: 1個（PixiJS管理）
  
新構造（v5.1）:
  WebGL2 Context: 1個（描画専用）
  Canvas: 2個（描画 + PixiJS表示）
  
増加量: Canvas 1個分（400x400 = 640KB程度）

結論: 許容範囲内
```

================================================================================
第8部: アーキテクチャ比較
================================================================================

【v5.0 vs v5.1】

| 項目 | v5.0 (ticker制御) | v5.1 (完全分離) |
|------|-------------------|-----------------|
| GLコンテキスト | 共有 | 分離 |
| 競合リスク | 高 | なし |
| 実装複雑度 | 高 | 低 |
| PixiJS依存 | 高 | 段階的削減 |
| 保守性 | 低 | 高 |
| パフォーマンス | 高 | 中〜高 |
| 将来性 | 低 | 高 |

【Phase別PixiJS依存度】

```
Phase B-Emergency完了:
  PixiJS依存: 80%
  - レイヤー表示: PixiJS
  - 座標変換: PixiJS
  - イベント: PixiJS
  - UI: PixiJS

Phase C完了:
  PixiJS依存: 40%
  - レイヤー表示: PixiJS
  - 座標変換: 独自実装 ✅
  - イベント: 独自実装 ✅
  - UI: PixiJS

Phase D完了:
  PixiJS依存: 0%
  - レイヤー表示: 独自実装 ✅
  - 座標変換: 独自実装 ✅
  - イベント: 独自実装 ✅
  - UI: 独自実装 ✅
```

================================================================================
第9部: 削除コード一覧
================================================================================

【Phase B-Emergencyで削除】

📄 raster-brush-core.js
```javascript
// Line 293-346: _capturePixiRenderCallback()
// Line 374-397: _stopPixiTicker()
// Line 409-438: _restartPixiTicker()
// Line 809: this._resetPixiShaderSystem()
// Line 451-488: _cleanupGLState() （簡素化）

削除行数: 約180行
```

📄 webgl2-drawing-layer.js
```javascript
// Line 383: linkPixiApp()のticker制御部分
// disablePixiAutoRender()（v5.0追加予定だったもの）
// enablePixiAutoRender()（v5.0追加予定だったもの）

削除行数: 約50行
```

📄 core-initializer.js
```javascript
// Line 274-284: ticker制御確認部分
// Line 473: ticker手動開始

削除行数: 約20行
```

**合計削除: 約250行**
**合計追加: 約150行（Phase B）**
**純減: 約100行**

================================================================================
第10部: デバッグ指針
================================================================================

【Phase B-Emergency実装時】

1. **描画Canvas確認**
```javascript
// コンソールで確認
console.log('Drawing Canvas:', window.GLContext.canvas);
console.log('GL Context:', window.GLContext.gl);
console.log('Is separated:', 
  window.GLContext.canvas !== window.pixiApp.view
);
```

2. **転送確認**
```javascript
// 転送イベント監視
window.EventBus.on('layer:texture-updated', (data) => {
  console.log('Transfer:', data.layerId);
});
```

3. **パフォーマンス測定**
```javascript
// 転送時間測定
const start = performance.now();
window.glTextureBridge.transferLayerToPixi(layerId);
const duration = performance.now() - start;
console.log('Transfer time:', duration.toFixed(2), 'ms');
```

【段階的検証】
1. BE-1実装 → Canvas生成確認
2. BE-2実装 → 描画動作確認（表示はまだ）
3. BE-3実装 → 転送動作確認
4. BE-4実装 → 表示反映確認
5. BE-5実装 → 統合動作確認

【問題が続く場合】
- ❌ Phase Bでも解決しない場合は設計根本ミス
- ✅ Phase B構造なら物理的に競合不可能
- 🔍 他の問題（シェーダーバグ等）の可能性を調査

================================================================================
第11部: 今後の展望
================================================================================

【Phase B完了後の選択肢】

**パターン1: Phase Cで停止（推奨）**
```
PixiJS依存: 40%
メリット:
  ✅ 安定性確保
  ✅ 保守コスト低
  ✅ PixiJSのUI機能活用
デメリット:
  ⚠️ 若干のPixiJS依存
```

**パターン2: Phase Dまで完遂（意欲的）**
```
PixiJS依存: 0%
メリット:
  ✅ 完全独立
  ✅ バンドルサイズ削減
  ✅ 完全制御
デメリット:
  ⚠️ UI実装コスト大
  ⚠️ 開発期間長期化
```

【判断基準】
- Phase B完了後、2週間運用
- 安定性・パフォーマンス確認
- PixiJS依存度が問題か評価
- Phase Cへ進むか判断

【将来的な技術選択肢】
1. **WebGPU移行** (Phase D完了後)
   - より高速な描画
   - 最新GPU機能活用
   
2. **WebAssembly活用** (Phase C以降)
   - 補間計算の高速化
   - ブラシエンジンのWASM実装
   
3. **OffscreenCanvas** (Phase C以降)
   - Worker描画
   - UIスレッド分離

================================================================================
第12部: まとめ
================================================================================

【現状評価】
全体進捗: 65%
- 基本構造: ✅ 完成
- 描画システム: 🚨 機能不全（Phase Bで修正）
- WebGL2実装: ⚠️ 70%完成
- UI: ✅ 正常動作

【v5.0からの改善点】
✅ 問題の根本原因を正確に特定
✅ アーキテクチャレベルでの解決策
✅ 保守性を最優先
✅ 段階的PixiJS削減戦略
✅ 実装の大幅簡素化

【Phase B-Emergencyの価値】
- ⏱️ 実装時間: 2-3時間
- 🎯 効果: 完全解決
- 📉 コード削減: 100行
- 🔧 保守性: 大幅向上
- 🚀 将来性: 独立性確保

【次のアクション】
1. ✅ Phase B-Emergency実装（2-3時間）
2. ✅ 動作確認（基本テスト）
3. ✅ Phase A実装開始（品質向上）
4. 🤔 Phase C実装判断（2週間後）

【成功の鍵】
✅ 物理的分離による競合の根絶
✅ シンプルな実装
✅ 段階的な依存削減
✅ 徹底的なテスト

================================================================================
付録A: 実装チェックリスト
================================================================================

【Phase B-Emergency】

BE-1: 描画Canvas生成
  □ Canvas要素作成
  □ display:none設定
  □ WebGL2コンテキスト取得
  □ window.GLContext登録
  □ サイズ設定確認

BE-2: RasterBrushCore簡素化
  □ ticker関連メソッド削除
  □ initialize()修正
  □ startStroke()確認
  □ addStrokePoint()確認
  □ finalizeStroke()修正

BE-3: Canvas転送実装
  □ transferLayerToPixi()実装
  □ _renderTextureToCanvas()実装
  □ gl.readPixels()動作確認
  □ putImageData()動作確認
  □ EventBus emit確認

BE-4: LayerSystem受信
  □ イベントリスナー登録
  □ _updateLayerSprite()実装
  □ Texture更新確認

BE-5: Core-Initializer修正
  □ 初期化フロー修正
  □ ticker制御コード削除
  □ 独立Canvas確認

【テスト】
  □ 1ストローク描画
  □ 10ストローク連続描画
  □ WebGLエラーなし
  □ 60fps維持
  □ Undo/Redo動作
  □ レイヤー切り替え

================================================================================
付録B: コンソールコマンド
================================================================================

【Phase B動作確認】

```javascript
// Canvas分離確認
console.log('Separated:', 
  window.GLContext.canvas !== window.pixiApp.view
);

// 転送テスト
window.glTextureBridge.transferLayerToPixi('layer_xxx');

// パフォーマンス測定
TegakiDebug.measureTransferPerformance();

// メモリ確認
TegakiDebug.checkMemoryUsage();
```

【デバッグ用拡張】

```javascript
// debug-utils.jsに追加
window.TegakiDebug.measureTransferPerformance = function() {
  const layerId = window.layerManager.getActiveLayerId();
  const iterations = 10;
  const times = [];
  
  for (let i = 0; i < iterations; i++) {
    const start = performance.now();
    window.glTextureBridge.transferLayerToPixi(layerId);
    times.push(performance.now() - start);
  }
  
  const avg = times.reduce((a, b) => a + b) / times.length;
  console.log('Transfer performance:', {
    average: avg.toFixed(2) + 'ms',
    min: Math.min(...times).toFixed(2) + 'ms',
    max: Math.max(...times).toFixed(2) + 'ms',
    samples: iterations
  });
};
```

================================================================================
END OF DOCUMENT v5.1
================================================================================