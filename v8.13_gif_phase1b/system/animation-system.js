// ===== system/animation-system.js - CUT„Éª„É¨„Ç§„É§„Éº2Ê¨°ÂÖÉ„Éû„Éà„É™„ÇØ„Çπ‰øÆÊ≠£Áâà =====
// „ÄêPhase 1ÂÆüË£Ö„ÄëCUTÁã¨Á´ãÊÄßÁ¢∫‰øù„Éª„É¨„Ç§„É§„ÉºÂàÜÈõ¢Áµ±Âêà„Éª„Çµ„É†„Éç„Ç§„É´ÁîüÊàê‰øÆÊ≠£
// „Äê‰øÆÊ≠£ÂÆå‰∫Ü„ÄëLayerSystem„Çµ„É†„Éç„Ç§„É´Ê©üËÉΩÁµ±Âêà„ÉªÊèèÁîªÂèçÊò†Âà∂Âæ°ÊîπÂñÑ
// PixiJS v8.13 ÂØæÂøú

(function() {
    'use strict';
    
    class AnimationSystem {
        constructor() {
            this.animationData = this.createDefaultAnimation();
            this.layerSystem = null;
            this.cameraSystem = null;
            this.app = null;
            this.eventBus = window.TegakiEventBus;
            this.playbackTimer = null;
            this.isAnimationMode = false;
            this.initialCutCreated = false;
            
            // „ÄêPhase 1„ÄëCUTÁã¨Á´ãÊÄßÁ¢∫‰øù„Éï„É©„Ç∞
            this.isInitializing = false;
            this.cutSwitchInProgress = false;
            this.hasInitialized = false;
            
            // „ÄêPhase 1„ÄëCUT-„É¨„Ç§„É§„Éº2Ê¨°ÂÖÉ„Éû„Éà„É™„ÇØ„ÇπÁä∂ÊÖãÁÆ°ÁêÜ
            this.cutLayerStates = new Map(); // cutId -> layerStateSnapshot
            this.activeLayerSync = false; // ÂêåÊúüÂà∂Âæ°„Éï„É©„Ç∞
            
            // CUT„ÇØ„É™„ÉÉ„Éó„Éú„Éº„ÉâÁÆ°ÁêÜ
            this.cutClipboard = {
                cutData: null,
                timestamp: null,
                sourceId: null
            };
        }
        
        init(layerSystem, app) {
            // ÈáçË§áÂàùÊúüÂåñÈò≤Ê≠¢
            if (this.hasInitialized) {
                console.log('üé¨ AnimationSystem already initialized - skipping');
                return;
            }
            
            console.log('üé¨ AnimationSystem initializing (CUT„Éª„É¨„Ç§„É§„Éº2Ê¨°ÂÖÉ„Éû„Éà„É™„ÇØ„Çπ‰øÆÊ≠£Áâà)...');
            this.layerSystem = layerSystem;
            this.app = app;
            
            // EventBusÁ¢∫Ë™ç
            if (!this.eventBus) {
                console.error('‚ùå EventBus not available in AnimationSystem');
                return;
            }
            
            // LayerSystem„ÅÆAPIÁ¢∫Ë™ç
            if (!this.layerSystem || !this.layerSystem.layers) {
                console.error('‚ùå LayerSystem not properly initialized');
                return;
            }
            
            // „ÄêPhase 1„ÄëÂèåÊñπÂêëÂèÇÁÖßË®≠ÂÆö
            this.layerSystem.animationSystem = this;
            
            // CUT„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Ç§„Éô„É≥„ÉàÁôªÈå≤
            this.setupCutClipboardEvents();
            
            // ÂàùÊúüÂåñÂÆå‰∫Ü„Éï„É©„Ç∞
            this.hasInitialized = true;
            
            // ÂàùÊúüCUT‰ΩúÊàêÔºà‰∏ÄÂ∫¶„Å†„ÅëÔºâ
            setTimeout(() => {
                if (!this.initialCutCreated && !this.isInitializing) {
                    this.createInitialCutIfNeeded();
                }
            }, 100);
            
            console.log('‚úÖ AnimationSystem initialized (Phase 1: CUTÁã¨Á´ãÊÄßÁ¢∫‰øù)');
            
            // UIÂàùÊúüÂåñ„Å´ÂøÖË¶Å„Å™„Ç§„Éô„É≥„ÉàÈÅÖÂª∂Áô∫Ë°å
            setTimeout(() => {
                if (this.eventBus) {
                    this.eventBus.emit('animation:system-ready');
                }
            }, 150);
            
            this.eventBus.emit('animation:initialized');
        }
        
        // „ÄêPhase 1„ÄëCUT„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Ç§„Éô„É≥„ÉàÁôªÈå≤
        setupCutClipboardEvents() {
            if (!this.eventBus) return;
            
            this.eventBus.on('cut:copy-current', () => {
                this.copyCurrent();
            });
            
            this.eventBus.on('cut:paste-right-adjacent', () => {
                this.pasteRightAdjacent();
            });
            
            this.eventBus.on('cut:paste-new', () => {
                this.pasteAsNew();
            });
            
            console.log('‚úÖ CUT clipboard events registered');
        }
        
        // „ÄêPhase 1Ê†∏ÂøÉÂÆüË£Ö„Äë„Ç¢„ÇØ„ÉÜ„Ç£„ÉñCUT„ÅÆ„Åø„Å´„É¨„Ç§„É§„ÉºÂ§âÊõ¥„ÇíÂèçÊò†
        syncLayerToActiveCutOnly(layerId, updateData) {
            const activeCut = this.getCurrentCut();
            if (!activeCut) {
                console.warn('No active CUT for layer sync');
                return;
            }
            
            // „Ç¢„ÇØ„ÉÜ„Ç£„ÉñCUT„ÅÆ„É¨„Ç§„É§„Éº„Éá„Éº„Çø„ÅÆ„ÅøÊõ¥Êñ∞
            const layerIndex = activeCut.layers.findIndex(l => l.id === layerId);
            if (layerIndex !== -1) {
                // „ÄêÈáçË¶Å„Äë„Ç¢„ÇØ„ÉÜ„Ç£„ÉñCUT„ÅÆ„ÅøÊõ¥Êñ∞
                if (updateData.transform) {
                    activeCut.layers[layerIndex].transform = { 
                        ...activeCut.layers[layerIndex].transform, 
                        ...updateData.transform 
                    };
                }
                if (updateData.visible !== undefined) {
                    activeCut.layers[layerIndex].visible = updateData.visible;
                }
                if (updateData.opacity !== undefined) {
                    activeCut.layers[layerIndex].opacity = updateData.opacity;
                }
                if (updateData.paths) {
                    activeCut.layers[layerIndex].paths = updateData.paths;
                }
                
                activeCut.layers[layerIndex].timestamp = Date.now();
                
                console.log('üéØ Layer synced to ACTIVE CUT only:', layerId, 'in', activeCut.name);
                
                // „ÄêPhase 1„ÄëLayerSystem„Çµ„É†„Éç„Ç§„É´Ê©üËÉΩ„ÇíÊ¥ªÁî®„Åó„Åü„Çµ„É†„Éç„Ç§„É´ÁîüÊàê
                this.requestCutThumbnailUpdate(this.getCurrentCutIndex());
                
                if (this.eventBus) {
                    this.eventBus.emit('animation:active-cut-layer-updated', {
                        cutIndex: this.getCurrentCutIndex(),
                        layerId: layerId,
                        updateData: updateData
                    });
                }
            }
        }
        
        // „ÄêPhase 1„ÄëLayerSystem„Åã„ÇâÂëº„Å≥Âá∫„Åï„Çå„Çã updateCurrentCutLayer „É°„ÇΩ„ÉÉ„Éâ
        updateCurrentCutLayer(layerIndex, updateData) {
            if (!this.layerSystem || !this.layerSystem.layers[layerIndex]) {
                console.warn('Invalid layer for CUT update:', layerIndex);
                return;
            }
            
            const layer = this.layerSystem.layers[layerIndex];
            const layerId = layer.layerData.id;
            
            // „ÄêÊ†∏ÂøÉ„Äë„Ç¢„ÇØ„ÉÜ„Ç£„ÉñCUT„ÅÆ„Åø„Å´ÂèçÊò†
            this.syncLayerToActiveCutOnly(layerId, updateData);
            
            return this.getCurrentCut()?.layers?.find(l => l.id === layerId);
        }
        
        // „ÄêPhase 1„ÄëÂàùÊúüCUT‰ΩúÊàêÔºàÈáçË§áÈò≤Ê≠¢Âº∑ÂåñÔºâ
        createInitialCutIfNeeded() {
            // Âé≥ÂØÜ„Å™ÈáçË§áÈò≤Ê≠¢„ÉÅ„Çß„ÉÉ„ÇØ
            if (this.initialCutCreated || this.animationData.cuts.length > 0 || this.isInitializing) {
                return;
            }
            
            // LayerSystemÊ∫ñÂÇôÁ¢∫Ë™ç
            if (!this.layerSystem || !this.layerSystem.layers) {
                return;
            }
            
            this.isInitializing = true;
            
            try {
                if (this.layerSystem.layers.length > 0) {
                    console.log('üé¨ Creating initial CUT with existing layers');
                    
                    const initialCut = this.createNewCutFromCurrentLayers();
                    this.initialCutCreated = true;
                    
                    console.log('‚úÖ Initial CUT1 created:', initialCut.name);
                    
                    if (this.eventBus) {
                        this.eventBus.emit('animation:initial-cut-created', { 
                            cutId: initialCut.id,
                            cutIndex: 0
                        });
                    }
                }
            } finally {
                this.isInitializing = false;
            }
        }
        
        createDefaultAnimation() {
            const config = window.TEGAKI_CONFIG.animation;
            return {
                cuts: [],
                settings: {
                    fps: config.defaultFPS,
                    loop: true
                },
                playback: {
                    isPlaying: false,
                    currentCutIndex: 0,
                    startTime: 0
                }
            };
        }
        
        // „ÄêPhase 1„ÄëÊñ∞Ë¶èCUT‰ΩúÊàêÔºöÁã¨Á´ã„É¨„Ç§„É§„ÉºÁä∂ÊÖã‰øùÊåÅ
        createNewCutFromCurrentLayers() {
            const cutLayers = this.captureCurrentLayersForCut();
            
            const cut = {
                id: 'cut_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                name: `CUT${this.animationData.cuts.length + 1}`,
                duration: window.TEGAKI_CONFIG.animation.defaultCutDuration,
                layers: cutLayers,
                thumbnail: null
            };
            
            this.animationData.cuts.push(cut);
            
            // CUTÂàá„ÇäÊõø„ÅàÔºàÂ∫ßÊ®ô‰øùÊåÅÔºâ
            this.switchToActiveCutSafely(this.animationData.cuts.length - 1, false);
            
            console.log('üé¨ New Cut created:', cut.name, 'with', cut.layers.length, 'layers');
            
            // „Çµ„É†„Éç„Ç§„É´ÁîüÊàê
            setTimeout(() => {
                this.requestCutThumbnailUpdate(this.animationData.cuts.length - 1);
            }, 100);
            
            if (this.eventBus) {
                this.eventBus.emit('animation:cut-created', { 
                    cutId: cut.id, 
                    cutIndex: this.animationData.cuts.length - 1 
                });
            }
            
            return cut;
        }
        
        // Êñ∞Ë¶èÁ©∫CUT‰ΩúÊàê
        createNewBlankCut() {
            const cut = {
                id: 'cut_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                name: `CUT${this.animationData.cuts.length + 1}`,
                duration: window.TEGAKI_CONFIG.animation.defaultCutDuration,
                layers: [],
                thumbnail: null
            };
            
            this.animationData.cuts.push(cut);
            const newIndex = this.animationData.cuts.length - 1;
            
            console.log('üé¨ Blank Cut created:', cut.name);
            
            this.switchToActiveCutSafely(newIndex, false);
            
            // ËÉåÊôØ„É¨„Ç§„É§„ÉºËøΩÂä†
            if (this.layerSystem) {
                const bgLayer = this.layerSystem.createLayer('ËÉåÊôØ', true);
                if (bgLayer) {
                    const newLayer = this.layerSystem.createLayer('„É¨„Ç§„É§„Éº1', false);
                }
            }
            
            if (this.eventBus) {
                this.eventBus.emit('animation:cut-created', { 
                    cutId: cut.id, 
                    cutIndex: newIndex 
                });
            }
            
            return cut;
        }
        
        createNewEmptyCut() {
            return this.createNewBlankCut();
        }
        
        // „ÄêPhase 1„ÄëÁèæÂú®„ÅÆ„É¨„Ç§„É§„Éº„ÇíCUTÁî®„Å´ÂÆåÂÖ®Áã¨Á´ã„Ç≥„Éî„Éº
        captureCurrentLayersForCut() {
            const copiedLayers = [];
            
            if (!this.layerSystem || !this.layerSystem.layers) {
                return copiedLayers;
            }
            
            // „É¨„Ç§„É§„ÉºIDÈáçË§áÈò≤Ê≠¢
            const processedIds = new Set();
            
            this.layerSystem.layers.forEach(originalLayer => {
                if (!originalLayer || !originalLayer.layerData) return;
                
                const layerId = originalLayer.layerData.id;
                
                // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                if (processedIds.has(layerId)) {
                    console.warn('Duplicate layer skipped:', layerId);
                    return;
                }
                processedIds.add(layerId);
                
                // Â§âÂΩ¢„Éá„Éº„ÇøÂèñÂæó
                const transform = this.layerSystem.layerTransforms.get(layerId) || {
                    x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1
                };
                
                // „Éë„Çπ„Éá„Éº„Çø„ÅÆÂÆåÂÖ®Áã¨Á´ã„Ç≥„Éî„Éº
                const pathsData = originalLayer.layerData.paths ? 
                    originalLayer.layerData.paths.map(path => ({
                        id: path.id + '_cut_' + Date.now(),
                        points: path.points ? path.points.map(point => ({ ...point })) : [],
                        size: path.size || 16,
                        color: path.color || 0x000000,
                        opacity: path.opacity || 1.0,
                        tool: path.tool || 'pen'
                    })) : [];
                
                // CUTÂ∞ÇÁî®„É¨„Ç§„É§„Éº„Éá„Éº„Çø‰ΩúÊàêÔºàÁã¨Á´ãÊÄßÁ¢∫‰øùÔºâ
                const cutLayerData = {
                    id: layerId,
                    name: originalLayer.layerData.name,
                    visible: originalLayer.layerData.visible !== false,
                    opacity: originalLayer.layerData.opacity || 1.0,
                    isBackground: originalLayer.layerData.isBackground || false,
                    transform: { ...transform },
                    paths: pathsData,
                    timestamp: Date.now()
                };
                
                copiedLayers.push(cutLayerData);
            });
            
            console.log('üì∏ Captured', copiedLayers.length, 'unique layers for CUT');
            return copiedLayers;
        }
        
        // „ÄêPhase 1„ÄëÊñπÂêë„Ç≠„Éº‰øÆÊ≠£ÔºàÂ∑¶Âè≥Ê≠£Â∏∏ÂåñÔºâ
        goToPreviousFrame() {
            // Âè≥„Ç≠„Éº ‚Üí Ê¨°„ÅÆCUT„Å´Â§âÊõ¥Ôºà‰øÆÊ≠£Ôºâ
            if (this.animationData.cuts.length === 0) return;
            
            this.stopPlaybackLoop();
            this.animationData.playback.isPlaying = false;
            
            let newIndex = this.animationData.playback.currentCutIndex + 1;
            if (newIndex >= this.animationData.cuts.length) {
                newIndex = 0;
            }
            
            this.animationData.playback.currentCutIndex = newIndex;
            this.switchToActiveCutSafely(newIndex);
            
            if (this.eventBus) {
                this.eventBus.emit('animation:frame-changed', { 
                    cutIndex: newIndex, 
                    direction: 'next'
                });
            }
        }
        
        goToNextFrame() {
            // Â∑¶„Ç≠„Éº ‚Üí Ââç„ÅÆCUT„Å´Â§âÊõ¥Ôºà‰øÆÊ≠£Ôºâ
            if (this.animationData.cuts.length === 0) return;
            
            this.stopPlaybackLoop();
            this.animationData.playback.isPlaying = false;
            
            let newIndex = this.animationData.playback.currentCutIndex - 1;
            if (newIndex < 0) {
                newIndex = this.animationData.cuts.length - 1;
            }
            
            this.animationData.playback.currentCutIndex = newIndex;
            this.switchToActiveCutSafely(newIndex);
            
            if (this.eventBus) {
                this.eventBus.emit('animation:frame-changed', { 
                    cutIndex: newIndex, 
                    direction: 'previous'
                });
            }
        }
        
        // „ÄêPhase 1„ÄëCUTÂàá„ÇäÊõø„ÅàÔºöÁã¨Á´ãÊÄßÁ¢∫‰øùÂº∑Âåñ
        switchToActiveCutSafely(cutIndex, resetTransform = true) {
            if (this.cutSwitchInProgress) {
                setTimeout(() => this.switchToActiveCutSafely(cutIndex, resetTransform), 50);
                return;
            }
            
            const cut = this.animationData.cuts[cutIndex];
            if (!cut || !this.layerSystem) {
                console.warn('Cut or LayerSystem not available:', cutIndex);
                return;
            }
            
            console.log('üé¨ Switching to cut:', cutIndex, cut.name);
            
            this.cutSwitchInProgress = true;
            
            // „ÄêÊ†∏ÂøÉ„ÄëÁèæÂú®„ÅÆCUT„Éá„Éº„Çø„Çí‰øùÂ≠òÔºàÁã¨Á´ãÊÄßÁ¢∫‰øùÔºâ
            this.saveCurrentCutLayerStatesBeforeSwitch();
            
            // ÁèæÂú®„ÅÆCUT„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÊõ¥Êñ∞
            this.animationData.playback.currentCutIndex = cutIndex;
            
            // LayerSystem„ÇíÊåáÂÆöCUT„Å´Âàá„ÇäÊõø„Åà
            this.setActiveCut(cutIndex, resetTransform);
            
            this.cutSwitchInProgress = false;
            
            if (this.eventBus) {
                this.eventBus.emit('animation:cut-applied', { cutIndex });
            }
        }
        
        switchToActiveCut(cutIndex) {
            return this.switchToActiveCutSafely(cutIndex, true);
        }
        
        // „ÄêPhase 1„ÄëCUTÂàá„ÇäÊõø„ÅàÂâç„ÅÆÁä∂ÊÖã‰øùÂ≠òÔºàÁã¨Á´ãÊÄßÁ¢∫‰øùÔºâ
        saveCurrentCutLayerStatesBeforeSwitch() {
            const currentCut = this.getCurrentCut();
            if (!currentCut || !this.layerSystem) return;
            
            // LayerSystem‚ÜíCUTÂêåÊúüÔºà„Ç¢„ÇØ„ÉÜ„Ç£„ÉñCUT„ÅÆ„ÅøÔºâ
            const currentLayers = this.captureCurrentLayersForCut();
            currentCut.layers = currentLayers;
            
            console.log('üíæ Current CUT layers saved before switch (Áã¨Á´ãÊÄßÁ¢∫‰øù)');
        }
        
        // „ÄêPhase 1„ÄëLayerSystemÁµ±ÂêàÔºöCUTÁã¨Á´ãÊÄßÁ¢∫‰øùÁâà
        setActiveCut(cutIndex, resetTransform = true) {
            const cut = this.animationData.cuts[cutIndex];
            if (!cut || !this.layerSystem) return;
            
            // LayerSystem„É¨„Ç§„É§„Éº„ÇíÂÆâÂÖ®„Å´Á†¥Ê£Ñ
            this.clearLayerSystemLayers();
            
            // CUT„Éá„Éº„Çø„Åã„ÇâLayerSystem„É¨„Ç§„É§„Éº„ÇíÁã¨Á´ãÂÜçÊßãÁØâ
            this.rebuildLayersFromCutData(cut.layers, resetTransform);
            
            // LayerSystem UIÊõ¥Êñ∞
            if (this.layerSystem.updateLayerPanelUI) {
                this.layerSystem.updateLayerPanelUI();
            }
            
            console.log('‚úÖ LayerSystem synchronized with CUT', cutIndex, '(Áã¨Á´ãÊÄßÁ¢∫‰øù)');
        }
        
        clearLayerSystemLayers() {
            if (!this.layerSystem || !this.layerSystem.layers) return;
            
            // „É¨„Ç§„É§„Éº„ÇíÂÆâÂÖ®„Å´Á†¥Ê£Ñ
            const layersToDestroy = [...this.layerSystem.layers];
            
            layersToDestroy.forEach(layer => {
                try {
                    // „Éë„ÇπGraphics„ÇíÁ†¥Ê£Ñ
                    if (layer.layerData && layer.layerData.paths) {
                        layer.layerData.paths.forEach(path => {
                            if (path.graphics && path.graphics.destroy) {
                                path.graphics.destroy();
                            }
                        });
                    }
                    
                    // Container„Åã„ÇâÂâäÈô§
                    if (layer.parent) {
                        layer.parent.removeChild(layer);
                    }
                    
                    // LayerËá™‰Ωì„ÇíÁ†¥Ê£Ñ
                    if (layer.destroy) {
                        layer.destroy();
                    }
                } catch (error) {
                    console.warn('Layer destruction failed:', error);
                }
            });
            
            // ÈÖçÂàó„Çí„ÇØ„É™„Ç¢
            this.layerSystem.layers = [];
            this.layerSystem.layerTransforms.clear();
            this.layerSystem.activeLayerIndex = -1;
            
            console.log('üóëÔ∏è LayerSystem layers cleared (Áã¨Á´ãÊÄßÁ¢∫‰øù)');
        }
        
        // „ÄêPhase 1„ÄëCUT„Éá„Éº„Çø„Åã„ÇâÁã¨Á´ã„É¨„Ç§„É§„ÉºÂÜçÊßãÁØâ
        rebuildLayersFromCutData(cutLayers, resetTransform = true) {
            if (!cutLayers || !Array.isArray(cutLayers)) return;
            
            cutLayers.forEach((cutLayerData, index) => {
                try {
                    // PIXI„Ç≥„É≥„ÉÜ„Éä‰ΩúÊàê
                    const layer = new PIXI.Container();
                    layer.label = cutLayerData.id;
                    layer.layerData = {
                        id: cutLayerData.id,
                        name: cutLayerData.name,
                        visible: cutLayerData.visible,
                        opacity: cutLayerData.opacity,
                        isBackground: cutLayerData.isBackground,
                        paths: []
                    };
                    
                    // Â§âÂΩ¢„Éá„Éº„ÇøË®≠ÂÆö
                    const transform = {
                        x: cutLayerData.transform?.x || 0,
                        y: cutLayerData.transform?.y || 0,
                        rotation: cutLayerData.transform?.rotation || 0,
                        scaleX: cutLayerData.transform?.scaleX || 1,
                        scaleY: cutLayerData.transform?.scaleY || 1
                    };
                    this.layerSystem.layerTransforms.set(cutLayerData.id, transform);
                    
                    // ËÉåÊôØ„É¨„Ç§„É§„ÉºÂá¶ÁêÜ
                    if (cutLayerData.isBackground) {
                        const bg = new PIXI.Graphics();
                        bg.rect(0, 0, this.layerSystem.config.canvas.width, this.layerSystem.config.canvas.height);
                        bg.fill(this.layerSystem.config.background.color);
                        layer.addChild(bg);
                        layer.layerData.backgroundGraphics = bg;
                    }
                    
                    // „Éë„Çπ„Éá„Éº„Çø„Åã„ÇâGraphics„ÇíÂÜçÁîüÊàê
                    cutLayerData.paths.forEach(pathData => {
                        const path = this.rebuildPathFromData(pathData);
                        if (path) {
                            layer.layerData.paths.push(path);
                            layer.addChild(path.graphics);
                        }
                    });
                    
                    // „É¨„Ç§„É§„Éº„ÅÆË°®Á§∫Ë®≠ÂÆöÈÅ©Áî®
                    layer.visible = cutLayerData.visible;
                    layer.alpha = cutLayerData.opacity;
                    
                    // Â§âÂΩ¢ÈÅ©Áî®
                    if (!resetTransform && this.hasTransform(transform)) {
                        this.applyTransformToLayer(layer, transform);
                    } else {
                        layer.position.set(0, 0);
                        layer.pivot.set(0, 0);
                        layer.rotation = 0;
                        layer.scale.set(1, 1);
                    }
                    
                    // LayerSystem„Å´ËøΩÂä†
                    this.layerSystem.layers.push(layer);
                    this.layerSystem.layersContainer.addChild(layer);
                    
                } catch (error) {
                    console.error('Layer rebuild failed for index', index, ':', error);
                }
            });
            
            // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„É¨„Ç§„É§„ÉºË®≠ÂÆö
            if (this.layerSystem.layers.length > 0) {
                this.layerSystem.activeLayerIndex = this.layerSystem.layers.length - 1;
            }
            
            console.log('‚úÖ Rebuilt', this.layerSystem.layers.length, 'layers from CUT data (Áã¨Á´ãÊÄßÁ¢∫‰øù)');
        }
        
        hasTransform(transform) {
            return transform.x !== 0 || transform.y !== 0 || 
                   transform.rotation !== 0 || Math.abs(transform.scaleX) !== 1 || 
                   Math.abs(transform.scaleY) !== 1;
        }
        
        applyTransformToLayer(layer, transform) {
            if (!transform || !layer) return;
            
            const centerX = this.layerSystem.config.canvas.width / 2;
            const centerY = this.layerSystem.config.canvas.height / 2;
            
            if (transform.rotation !== 0 || Math.abs(transform.scaleX) !== 1 || 
                Math.abs(transform.scaleY) !== 1) {
                layer.pivot.set(centerX, centerY);
                layer.position.set(centerX + (transform.x || 0), centerY + (transform.y || 0));
                layer.rotation = transform.rotation || 0;
                layer.scale.set(transform.scaleX || 1, transform.scaleY || 1);
            } else if (transform.x !== 0 || transform.y !== 0) {
                layer.pivot.set(0, 0);
                layer.position.set(transform.x || 0, transform.y || 0);
                layer.rotation = 0;
                layer.scale.set(1, 1);
            }
            
            console.log('üîß Transform applied to layer:', layer.layerData?.id, transform);
        }
        
        // „Éë„Çπ„Éá„Éº„Çø„Åã„ÇâPath+Graphics„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂÜçÊßãÁØâ
        rebuildPathFromData(pathData) {
            if (!pathData || !pathData.points || pathData.points.length === 0) {
                return null;
            }
            
            try {
                const graphics = new PIXI.Graphics();
                
                // PixiJS v8.13ÂΩ¢Âºè„Åß„ÅÆÊèèÁîª
                pathData.points.forEach(point => {
                    graphics.circle(point.x, point.y, pathData.size / 2);
                    graphics.fill({
                        color: pathData.color,
                        alpha: pathData.opacity
                    });
                });
                
                return {
                    id: pathData.id,
                    points: pathData.points,
                    size: pathData.size,
                    color: pathData.color,
                    opacity: pathData.opacity,
                    tool: pathData.tool,
                    graphics: graphics
                };
                
            } catch (error) {
                console.error('‚ùå Error rebuilding path:', error);
                return null;
            }
        }
        
        // „ÄêPhase 1„Äë„Çµ„É†„Éç„Ç§„É´ÁîüÊàêÔºöLayerSystem„Çµ„É†„Éç„Ç§„É´Ê©üËÉΩÊ¥ªÁî®
        requestCutThumbnailUpdate(cutIndex) {
            if (!this.layerSystem || !this.layerSystem.requestThumbnailUpdate) {
                console.warn('LayerSystem thumbnail feature not available');
                return;
            }
            
            const cut = this.animationData.cuts[cutIndex];
            if (!cut) return;
            
            try {
                // LayerSystem„ÅÆÊó¢Â≠ò„Çµ„É†„Éç„Ç§„É´Ê©üËÉΩ„ÇíÊ¥ªÁî®
                // ÂÖ®„É¨„Ç§„É§„Éº„ÅÆ„Çµ„É†„Éç„Ç§„É´Êõ¥Êñ∞„Çí„É™„ÇØ„Ç®„Çπ„Éà
                for (let i = 0; i < this.layerSystem.layers.length; i++) {
                    this.layerSystem.requestThumbnailUpdate(i);
                }
                
                // ÂêàÊàê„Çµ„É†„Éç„Ç§„É´ÁîüÊàêÔºàÁ∞°Áï•ÂåñÔºâ
                setTimeout(() => {
                    this.generateSimplifiedCutThumbnail(cutIndex);
                }, 200);
                
                console.log('üì∏ CUT thumbnail update requested:', cut.name);
                
                if (this.eventBus) {
                    this.eventBus.emit('animation:thumbnail-requested', { cutIndex });
                }
                
            } catch (error) {
                console.error('CUT thumbnail request failed:', error);
            }
        }
        
        // „ÄêPhase 1„ÄëÁ∞°Áï•ÂåñCUT„Çµ„É†„Éç„Ç§„É´ÁîüÊàê
        generateSimplifiedCutThumbnail(cutIndex) {
            const cut = this.animationData.cuts[cutIndex];
            if (!cut) return;
            
            try {
                // Á∞°Áï•ÂåñÔºöÊúÄ‰∏ä‰Ωç„É¨„Ç§„É§„Éº„ÅÆ„Çµ„É†„Éç„Ç§„É´„Çí‰ΩøÁî®
                if (this.layerSystem.layers.length > 0) {
                    const topLayer = this.layerSystem.layers[this.layerSystem.layers.length - 1];
                    
                    // LayerSystem„ÅÆ„Çµ„É†„Éç„Ç§„É´ÁîüÊàêÊ©üËÉΩ„ÇíÊ¥ªÁî®
                    if (this.layerSystem.updateThumbnail) {
                        this.layerSystem.updateThumbnail(this.layerSystem.layers.length - 1);
                    }
                    
                    // „Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº„Å®„Åó„Å¶Ë®≠ÂÆö
                    cut.thumbnail = { simplified: true, timestamp: Date.now() };
                    
                    console.log('üì∏ Simplified thumbnail generated for', cut.name);
                    
                    if (this.eventBus) {
                        this.eventBus.emit('animation:thumbnail-generated', { cutIndex });
                    }
                }
            } catch (error) {
                console.error('Simplified thumbnail generation failed:', error);
            }
        }
        
        // CUT„Ç≥„Éî„Éº„Éª„Éö„Éº„Çπ„ÉàÊ©üËÉΩ
        copyCurrent() {
            const currentCut = this.getCurrentCut();
            if (!currentCut) return false;
            
            this.saveCurrentCutLayerStatesBeforeSwitch();
            
            const copiedCutData = this.deepCopyCutData(currentCut);
            
            this.cutClipboard.cutData = copiedCutData;
            this.cutClipboard.timestamp = Date.now();
            this.cutClipboard.sourceId = currentCut.id;
            
            console.log('üìã CUT copied to clipboard:', currentCut.name);
            
            if (this.eventBus) {
                this.eventBus.emit('cut:copied', {
                    cutId: currentCut.id,
                    cutName: currentCut.name
                });
            }
            
            return true;
        }
        
        pasteRightAdjacent() {
            if (!this.cutClipboard.cutData) return false;
            
            const currentCutIndex = this.animationData.playback.currentCutIndex;
            const insertIndex = currentCutIndex + 1;
            
            const pastedCut = this.createCutFromClipboard(this.cutClipboard.cutData);
            if (!pastedCut) return false;
            
            this.animationData.cuts.splice(insertIndex, 0, pastedCut);
            this.switchToActiveCutSafely(insertIndex, false);
            
            console.log('üìã CUT pasted as right adjacent:', pastedCut.name);
            
            if (this.eventBus) {
                this.eventBus.emit('cut:pasted-right-adjacent', {
                    cutId: pastedCut.id,
                    cutIndex: insertIndex
                });
            }
            
            return true;
        }
        
        pasteAsNew() {
            if (!this.cutClipboard.cutData) return false;
            
            const pastedCut = this.createCutFromClipboard(this.cutClipboard.cutData);
            if (!pastedCut) return false;
            
            this.animationData.cuts.push(pastedCut);
            const newIndex = this.animationData.cuts.length - 1;
            
            this.switchToActiveCutSafely(newIndex, false);
            
            console.log('üìã CUT pasted as new:', pastedCut.name);
            
            if (this.eventBus) {
                this.eventBus.emit('cut:pasted-new', {
                    cutId: pastedCut.id,
                    cutIndex: newIndex
                });
            }
            
            return true;
        }
        
        deepCopyCutData(cutData) {
            if (!cutData) return null;
            
            const copiedLayers = cutData.layers ? cutData.layers.map(layerData => ({
                id: layerData.id,
                name: layerData.name,
                visible: layerData.visible,
                opacity: layerData.opacity,
                isBackground: layerData.isBackground,
                transform: layerData.transform ? { ...layerData.transform } : { x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1 },
                paths: layerData.paths ? layerData.paths.map(pathData => ({
                    id: pathData.id,
                    points: pathData.points ? pathData.points.map(point => ({ ...point })) : [],
                    size: pathData.size,
                    color: pathData.color,
                    opacity: pathData.opacity,
                    tool: pathData.tool
                })) : [],
                timestamp: layerData.timestamp
            })) : [];
            
            return {
                name: cutData.name,
                duration: cutData.duration,
                layers: copiedLayers,
                thumbnail: null,
                originalId: cutData.id,
                copyTimestamp: Date.now()
            };
        }
        
        createCutFromClipboard(clipboardData) {
            if (!clipboardData || !clipboardData.layers) return null;
            
            const cut = {
                id: 'cut_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                name: clipboardData.name + '_copy',
                duration: clipboardData.duration,
                layers: clipboardData.layers.map(layerData => {
                    return {
                        ...layerData,
                        id: layerData.id + '_copy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                        timestamp: Date.now()
                    };
                }),
                thumbnail: null
            };
            
            setTimeout(() => {
                const cutIndex = this.animationData.cuts.findIndex(c => c.id === cut.id);
                if (cutIndex !== -1) {
                    this.requestCutThumbnailUpdate(cutIndex);
                }
            }, 200);
            
            return cut;
        }
        
        // === ÂÜçÁîüÂà∂Âæ°„É°„ÇΩ„ÉÉ„Éâ ===
        
        play() {
            if (this.animationData.cuts.length === 0) return;
            
            this.animationData.playback.isPlaying = true;
            this.animationData.playback.startTime = Date.now();
            
            this.startPlaybackLoop();
            
            if (this.eventBus) {
                this.eventBus.emit('animation:playback-started');
            }
        }
        
        pause() {
            this.animationData.playback.isPlaying = false;
            this.stopPlaybackLoop();
            
            if (this.eventBus) {
                this.eventBus.emit('animation:playback-paused');
            }
        }
        
        stop() {
            this.animationData.playback.isPlaying = false;
            this.stopPlaybackLoop();
            
            if (this.eventBus) {
                this.eventBus.emit('animation:playback-stopped');
            }
        }
        
        togglePlayStop() {
            if (this.animationData.playback.isPlaying) {
                this.stop();
            } else {
                this.play();
            }
        }
        
        togglePlayPause() {
            if (this.animationData.playback.isPlaying) {
                this.pause();
            } else {
                this.play();
            }
        }
        
        startPlaybackLoop() {
            if (this.playbackTimer) {
                clearInterval(this.playbackTimer);
            }
            
            const fps = this.animationData.settings.fps;
            const frameTime = 1000 / fps;
            
            this.playbackTimer = setInterval(() => {
                this.updatePlayback();
            }, frameTime);
        }
        
        stopPlaybackLoop() {
            if (this.playbackTimer) {
                clearInterval(this.playbackTimer);
                this.playbackTimer = null;
            }
        }
        
        // „ÄêPhase 1„ÄëÂÜçÁîüÊôÇÁîªÈù¢Êõ¥Êñ∞‰øÆÊ≠£
        updatePlayback() {
            if (!this.animationData.playback.isPlaying) return;
            
            const currentCut = this.animationData.cuts[
                this.animationData.playback.currentCutIndex
            ];
            
            if (!currentCut) return;
            
            const elapsed = (Date.now() - this.animationData.playback.startTime) / 1000;
            
            if (elapsed >= currentCut.duration) {
                this.animationData.playback.currentCutIndex++;
                
                if (this.animationData.playback.currentCutIndex >= 
                    this.animationData.cuts.length) {
                    if (this.animationData.settings.loop) {
                        this.animationData.playback.currentCutIndex = 0;
                    } else {
                        this.stop();
                        return;
                    }
                }
                
                this.animationData.playback.startTime = Date.now();
                
                // „Äê‰øÆÊ≠£„ÄëÂÜçÁîüÊôÇ„Å´„Ç≠„É£„É≥„Éê„ÇπÊèèÁîª„ÇíÊõ¥Êñ∞
                this.switchToActiveCutWithRender(this.animationData.playback.currentCutIndex);
                
                if (this.eventBus) {
                    this.eventBus.emit('animation:cut-changed', { 
                        cutIndex: this.animationData.playback.currentCutIndex,
                        renderUpdated: true
                    });
                }
            }
        }
        
        // „ÄêPhase 1„ÄëÊèèÁîªÊõ¥Êñ∞‰ªò„ÅçCUTÂàá„ÇäÊõø„Åà
        async switchToActiveCutWithRender(cutIndex) {
            this.setActiveCut(cutIndex);
            
            // LayerSystemÊèèÁîªÁä∂ÊÖã„ÇíÂº∑Âà∂Êõ¥Êñ∞
            if (this.layerSystem) {
                // ÂÖ®„É¨„Ç§„É§„Éº„ÅÆÂÜçÊèèÁîª„Çí„É™„ÇØ„Ç®„Çπ„Éà
                for (let i = 0; i < this.layerSystem.layers.length; i++) {
                    this.layerSystem.requestThumbnailUpdate(i);
                }
            }
            
            // ÊèèÁîª„Ç®„É≥„Ç∏„É≥„Å´ÂÜçÊèèÁîªË¶ÅÊ±Ç
            if (this.app) {
                this.app.renderer.render(this.layerSystem.layersContainer);
            }
        }
        
        // === „Ç≤„ÉÉ„Çø„Éº„É°„ÇΩ„ÉÉ„Éâ ===
        
        getAnimationData() {
            return this.animationData;
        }
        
        getCurrentCutIndex() {
            return this.animationData.playback.currentCutIndex;
        }
        
        getCutCount() {
            return this.animationData.cuts.length;
        }
        
        getCurrentCut() {
            return this.animationData.cuts[this.animationData.playback.currentCutIndex] || null;
        }
        
        getCurrentCutLayers() {
            const currentCut = this.getCurrentCut();
            return currentCut ? currentCut.layers : [];
        }
        
        hasInitialCut() {
            return this.animationData.cuts.length > 0;
        }
        
        getAllCuts() {
            return this.animationData.cuts;
        }
        
        getCutInfo(cutIndex) {
            const cut = this.animationData.cuts[cutIndex];
            if (!cut) return null;
            
            return {
                id: cut.id,
                name: cut.name,
                duration: cut.duration,
                layerCount: cut.layers.length,
                thumbnail: cut.thumbnail,
                isActive: cutIndex === this.animationData.playback.currentCutIndex
            };
        }
        
        getPlaybackState() {
            return {
                isPlaying: this.animationData.playback.isPlaying,
                currentCutIndex: this.animationData.playback.currentCutIndex,
                fps: this.animationData.settings.fps,
                loop: this.animationData.settings.loop,
                cutsCount: this.animationData.cuts.length
            };
        }
        
        isInAnimationMode() {
            return this.isAnimationMode;
        }
        
        toggleAnimationMode() {
            this.isAnimationMode = !this.isAnimationMode;
            
            console.log('üé¨ Animation mode:', this.isAnimationMode ? 'ON' : 'OFF');
            
            if (this.isAnimationMode) {
                this.createInitialCutIfNeeded();
                
                if (this.eventBus) {
                    this.eventBus.emit('animation:mode-entered');
                }
            } else {
                if (this.animationData.playback.isPlaying) {
                    this.stop();
                }
                if (this.eventBus) {
                    this.eventBus.emit('animation:mode-exited');
                }
            }
            
            return this.isAnimationMode;
        }
        
        // === „Åù„ÅÆ‰ªñ„ÅÆ„É°„ÇΩ„ÉÉ„Éâ ===
        
        deleteCut(cutIndex) {
            if (cutIndex < 0 || cutIndex >= this.animationData.cuts.length) return;
            
            if (this.animationData.cuts.length <= 1) {
                console.warn('Cannot delete the last remaining cut');
                return false;
            }
            
            const cut = this.animationData.cuts[cutIndex];
            
            if (cut.thumbnail) {
                if (cut.thumbnail.destroy) {
                    cut.thumbnail.destroy();
                }
            }
            
            this.animationData.cuts.splice(cutIndex, 1);
            
            if (this.animationData.playback.currentCutIndex >= cutIndex) {
                this.animationData.playback.currentCutIndex = Math.max(0, 
                    this.animationData.playback.currentCutIndex - 1
                );
            }
            
            console.log('üóëÔ∏è Cut deleted:', cutIndex);
            
            if (this.eventBus) {
                this.eventBus.emit('animation:cut-deleted', { cutIndex });
            }
            
            return true;
        }
        
        updateCutDuration(cutIndex, duration) {
            const cut = this.animationData.cuts[cutIndex];
            if (!cut) return;
            
            cut.duration = Math.max(0.1, Math.min(10, duration));
            
            console.log('‚è±Ô∏è Cut duration updated:', cut.name, cut.duration + 's');
            
            if (this.eventBus) {
                this.eventBus.emit('animation:cut-duration-changed', { 
                    cutIndex, 
                    duration: cut.duration 
                });
            }
        }
        
        // === LayerSystemÈÄ£Êê∫„É°„ÇΩ„ÉÉ„Éâ ===
        
        addLayerToCurrentCut(layerData) {
            const currentCut = this.getCurrentCut();
            if (!currentCut) return null;
            
            const existingLayer = currentCut.layers.find(layer => layer.id === layerData.id);
            if (existingLayer) return existingLayer;
            
            const cutLayerData = {
                id: layerData.id,
                name: layerData.name,
                visible: layerData.visible !== false,
                opacity: layerData.opacity || 1.0,
                isBackground: layerData.isBackground || false,
                transform: layerData.transform || { x: 0, y: 0, rotation: 0, scaleX: 1, scaleY: 1 },
                paths: layerData.paths || [],
                timestamp: Date.now()
            };
            
            currentCut.layers.push(cutLayerData);
            
            console.log('üìù Layer added to current CUT:', layerData.id);
            
            if (this.eventBus) {
                this.eventBus.emit('animation:layer-added-to-cut', {
                    cutIndex: this.animationData.playback.currentCutIndex,
                    layerId: layerData.id
                });
            }
            
            return cutLayerData;
        }
        
        updateLayerInCurrentCut(layerId, updateData) {
            const currentCut = this.getCurrentCut();
            if (!currentCut) return null;
            
            const layerIndex = currentCut.layers.findIndex(layer => layer.id === layerId);
            if (layerIndex === -1) return null;
            
            Object.assign(currentCut.layers[layerIndex], updateData);
            
            console.log('üìù Layer updated in current CUT:', layerId);
            
            if (this.eventBus) {
                this.eventBus.emit('animation:cut-layer-updated', {
                    cutIndex: this.animationData.playback.currentCutIndex,
                    layerIndex,
                    layerId,
                    updateData
                });
            }
            
            return currentCut.layers[layerIndex];
        }
        
        // ÁèæÂú®CUT„ÅÆÂÖ®„É¨„Ç§„É§„ÉºÁä∂ÊÖã„Çí‰øùÂ≠ò
        saveCutLayerStates() {
            const currentCut = this.getCurrentCut();
            if (!currentCut || !this.layerSystem) return;
            
            const savedLayers = this.captureCurrentLayersForCut();
            currentCut.layers = savedLayers;
            
            console.log('üíæ Cut layer states saved:', currentCut.name, savedLayers.length, 'layers');
            
            setTimeout(() => {
                this.requestCutThumbnailUpdate(this.animationData.playback.currentCutIndex);
            }, 100);
            
            if (this.eventBus) {
                this.eventBus.emit('animation:cut-updated', { 
                    cutIndex: this.animationData.playback.currentCutIndex,
                    cutId: currentCut.id
                });
            }
        }
        
        // === „Ç∑„Çπ„ÉÜ„É†„É°„ÇΩ„ÉÉ„Éâ ===
        
        updateSettings(settings) {
            if (!settings) return;
            
            Object.assign(this.animationData.settings, settings);
            
            if (this.animationData.playback.isPlaying && settings.fps) {
                this.stopPlaybackLoop();
                this.startPlaybackLoop();
            }
            
            console.log('‚öôÔ∏è Animation settings updated:', settings);
            
            if (this.eventBus) {
                this.eventBus.emit('animation:settings-updated', { settings });
            }
        }
        
        clearAnimation() {
            this.stop();
            
            this.animationData.cuts.forEach(cut => {
                if (cut.thumbnail && cut.thumbnail.destroy) {
                    cut.thumbnail.destroy();
                }
            });
            
            this.animationData = this.createDefaultAnimation();
            this.initialCutCreated = false;
            this.isInitializing = false;
            this.cutSwitchInProgress = false;
            this.hasInitialized = false;
            
            // „ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„ÇØ„É™„Ç¢
            this.cutClipboard.cutData = null;
            this.cutClipboard.timestamp = null;
            this.cutClipboard.sourceId = null;
            
            console.log('üóëÔ∏è Animation data cleared');
            
            if (this.eventBus) {
                this.eventBus.emit('animation:cleared');
            }
        }
        
        // === „Éá„Éê„ÉÉ„Ç∞„É°„ÇΩ„ÉÉ„Éâ ===
        
        debugCutLayerMatrix() {
            const matrix = this.animationData.cuts.map((cut, cutIndex) => ({
                cutIndex,
                cutId: cut.id,
                cutName: cut.name,
                layerCount: cut.layers.length,
                layers: cut.layers.map(layer => ({
                    layerId: layer.id,
                    layerName: layer.name,
                    pathCount: layer.paths ? layer.paths.length : 0,
                    transform: layer.transform,
                    visible: layer.visible
                }))
            }));
            
            console.log('üßä CUT-„É¨„Ç§„É§„Éº2Ê¨°ÂÖÉ„Éû„Éà„É™„ÇØ„Çπ:');
            matrix.forEach(cut => {
                console.log(`  CUT${cut.cutIndex + 1}: ${cut.cutName} (${cut.layerCount} layers)`);
                cut.layers.forEach(layer => {
                    console.log(`    ‚îî‚îÄ ${layer.layerName}: ${layer.pathCount} paths, visible: ${layer.visible}`);
                });
            });
            
            return matrix;
        }
        
        debugThumbnailStatus() {
            const status = this.animationData.cuts.map(cut => ({
                cutName: cut.name,
                hasThumbnail: !!cut.thumbnail,
                thumbnailType: cut.thumbnail ? (cut.thumbnail.simplified ? 'simplified' : 'full') : 'none'
            }));
            
            console.log('üñºÔ∏è „Çµ„É†„Éç„Ç§„É´ÁîüÊàêÁä∂Ê≥Å:', status);
            return status;
        }
        
        debugInfo() {
            const clipboardInfo = {
                hasCutData: !!this.cutClipboard.cutData,
                timestamp: this.cutClipboard.timestamp,
                sourceId: this.cutClipboard.sourceId
            };
            
            const info = {
                isAnimationMode: this.isAnimationMode,
                cutsCount: this.animationData.cuts.length,
                initialCutCreated: this.initialCutCreated,
                hasInitialCut: this.hasInitialCut(),
                isPlaying: this.animationData.playback.isPlaying,
                currentCut: this.animationData.playback.currentCutIndex,
                settings: this.animationData.settings,
                eventBusAvailable: !!this.eventBus,
                cutClipboard: clipboardInfo,
                hasInitialized: this.hasInitialized,
                isInitializing: this.isInitializing,
                cutSwitchInProgress: this.cutSwitchInProgress,
                layerSystemIntegration: {
                    hasLayerSystem: !!this.layerSystem,
                    layerCount: this.layerSystem ? this.layerSystem.layers.length : 0,
                    hasAnimationSystemRef: this.layerSystem ? !!this.layerSystem.animationSystem : false
                }
            };
            
            console.log('AnimationSystem Debug Info (CUT„Éª„É¨„Ç§„É§„Éº2Ê¨°ÂÖÉ„Éû„Éà„É™„ÇØ„Çπ‰øÆÊ≠£Áâà):');
            console.log('üéØ Phase 1 ‰øÆÊ≠£ÂÆå‰∫ÜÈ†ÖÁõÆ:');
            console.log('  - ‚úÖ CUTÁã¨Á´ãÊÄßÁ¢∫‰øù: syncLayerToActiveCutOnly()');
            console.log('  - ‚úÖ ÊñπÂêë„Ç≠„Éº‰øÆÊ≠£: Â∑¶Âè≥„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥Ê≠£Â∏∏Âåñ');
            console.log('  - ‚úÖ „Çµ„É†„Éç„Ç§„É´ÁîüÊàê‰øÆÊ≠£: LayerSystem„Çµ„É†„Éç„Ç§„É´Ê©üËÉΩÁµ±Âêà');
            console.log('  - ‚úÖ ÂÜçÁîüÊôÇÁîªÈù¢Êõ¥Êñ∞: switchToActiveCutWithRender()');
            console.log('  - ‚úÖ „É¨„Ç§„É§„ÉºAPIÁµ±Âêà: updateCurrentCutLayer()ÂÆüË£Ö');
            console.log('  - ‚úÖ Â∫ßÊ®ôÂ§âÊèõAPIÁµ±‰∏Ä„ÉªEventBusÂÆåÂÖ®Áµ±Âêà');
            console.log('üìä „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã:', info);
            
            return info;
        }
    }
    
    // „Ç∞„É≠„Éº„Éê„É´ÂÖ¨Èñã
    window.TegakiAnimationSystem = AnimationSystem;
    
    console.log('‚úÖ animation-system.js loaded (CUT„Éª„É¨„Ç§„É§„Éº2Ê¨°ÂÖÉ„Éû„Éà„É™„ÇØ„Çπ‰øÆÊ≠£Áâà)');
    console.log('üéØ Phase 1ÂÆüË£ÖÂÆå‰∫Ü:');
    console.log('  - üÜï CUTÁã¨Á´ãÊÄßÁ¢∫‰øù: „Ç¢„ÇØ„ÉÜ„Ç£„ÉñCUT„ÅÆ„Åø„Å´ÊèèÁîªÂèçÊò†');
    console.log('  - üÜï ÊñπÂêë„Ç≠„ÉºÊ≠£Â∏∏Âåñ: Â∑¶Âè≥„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥‰øÆÊ≠£');
    console.log('  - üÜï „Çµ„É†„Éç„Ç§„É´ÁîüÊàê‰øÆÊ≠£: LayerSystem„Çµ„É†„Éç„Ç§„É´Ê©üËÉΩÁµ±Âêà');
    console.log('  - üÜï ÂÜçÁîüÊôÇÁîªÈù¢Êõ¥Êñ∞: ÊèèÁîª„Ç®„É≥„Ç∏„É≥ÈÄ£Êê∫Âº∑Âåñ');
    console.log('  - üÜï „É¨„Ç§„É§„ÉºAPIÁµ±Âêà: AnimationSystem-LayerSystemÂèåÊñπÂêëÈÄ£Êê∫');
    console.log('  - üîß Â∫ßÊ®ôÂ§âÊèõAPIÁµ±‰∏Ä„ÉªEventBusÁµ±Âêà„ÉªPixiJS v8.13ÂÆåÂÖ®ÂØæÂøú');
    console.log('  - üö´ „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜÊéíÈô§„Éª‰∫åÈáçÂÆüË£ÖÊéíÈô§„ÉªËÇ•Â§ßÂåñÈò≤Ê≠¢');

})();