================================================================================
TEGAKI Drawing Tool - 段階的改修計画書
================================================================================
作成日: 2025-01-XX
対象バージョン: v8.13_Drawing_29

本計画書は後続改修担当Claudeが参照する技術文書です。
各Phase毎に改修するファイル、参照するファイル、フロー位置、使用メソッドを記載。


================================================================================
Phase 1: 致命的エラー修正（アプリ起動可能化）
================================================================================

【目的】
アプリケーション初期化失敗を解消し、最低限の動作を可能にする。

【エラー概要】
1. StatusDisplayRenderer初期化失敗
   - settingsManager引数未渡し
   - getAllSettings()メソッド不在

2. Export機能の依存関係エラー
   - TEGAKI_EXPORT_MANAGER初期化タイミング遅延

--------------------------------------------------------------------------------
Phase 1-A: SettingsManager統合修正
--------------------------------------------------------------------------------

【改修対象ファイル】
- core-initializer.js (Line 97付近)
- ui/status-display-renderer.js (Line 92)

【参照ファイル】
- system/settings-manager.js (SettingsManager実装確認)

【フロー位置】
CoreInitializer.initialize()
  └─> setupEventBusListeners()
       └─> new StatusDisplayRenderer() ← ここで失敗

【問題詳細】
core-initializer.js:97
```javascript
const statusDisplay = new window.TegakiUI.StatusDisplayRenderer();
// SettingsManagerインスタンスを渡していない
```

status-display-renderer.js:92
```javascript
const settings = this.settingsManager.getAllSettings();
// getAllSettings()メソッドは存在しない（get()を使うべき）
```

【修正内容】

■ core-initializer.js
```javascript
// setupEventBusListeners()内で

// SettingsManagerインスタンス作成
const settingsManager = new window.TegakiSettingsManager(
    window.TegakiEventBus, 
    window.TEGAKI_CONFIG
);
window.TegakiSettingsManager = settingsManager; // グローバル登録

// StatusDisplayRendererに渡す
const statusDisplay = new window.TegakiUI.StatusDisplayRenderer(
    window.TegakiEventBus, 
    settingsManager
);
```

■ ui/status-display-renderer.js
```javascript
// Line 92付近
_updateBrushInfo() {
    if (!this.settingsManager) return;
    
    // 修正前: const settings = this.settingsManager.getAllSettings();
    // 修正後:
    const settings = this.settingsManager.get(); // 引数なしで全設定取得
    
    const tool = settings.currentTool || 'pen';
    const size = settings.brushSize || 5;
    const color = settings.strokeColor || '#000000';
    // ... 以下同様
}
```

【使用メソッド】
- SettingsManager.constructor(eventBus, config)
- SettingsManager.get() ※引数なしで全設定オブジェクト返却

【検証方法】
- アプリ起動時にコンソールエラーが出ないこと
- 画面右上にステータス表示が出ること（ツール名、ブラシサイズ）


--------------------------------------------------------------------------------
Phase 1-B: ExportManager初期化順序修正
--------------------------------------------------------------------------------

【改修対象ファイル】
- core-initializer.js (Line 211-256: initializeExportSystem)
- core-initializer.js (Line 90付近: initializePopupManager)

【参照ファイル】
- system/popup-manager.js (依存関係チェック機構)
- system/export-manager.js (ExportManager実装)
- core-runtime.js (initializeExportSystem実装)

【フロー位置】
CoreInitializer.initialize()
  ├─> initializePopupManager()
  │    ├─> register('export', ..., {waitFor: ['TEGAKI_EXPORT_MANAGER']})
  │    └─> initializeAll() → 依存関係不足で初期化待機
  │
  └─> initializeExportSystem()
       └─> 非同期で500ms後に試行開始 ← タイミング遅延が原因

【問題詳細】
- PopupManagerがExportPopupを登録時に`TEGAKI_EXPORT_MANAGER`を要求
- ExportManagerの初期化が非同期タイマーで遅延
- PopupManagerのリトライ機構が20回×200msで完了するが、ExportManagerが間に合わない

【修正内容】

■ core-initializer.js
```javascript
// initializePopupManager()内で export popup登録を削除

function initializePopupManager(app, coreEngine) {
    const popupManager = new window.TegakiPopupManager(window.TegakiEventBus);
    
    popupManager.register('settings', ...);
    popupManager.register('quickAccess', ...);
    popupManager.register('album', ...);
    popupManager.register('resize', ...);
    
    // ★ exportは登録しない（後でExportManager初期化後に登録）
    
    popupManager.initializeAll();
    window.PopupManager = popupManager;
    
    return popupManager;
}

// DrawingApp.initializeExportSystem()を改修
initializeExportSystem() {
    const tryInit = () => {
        // animationSystem確認
        if (!window.animationSystem || !window.CoreRuntime) {
            setTimeout(tryInit, 200);
            return;
        }
        
        // Exporter系確認
        if (!window.ExportManager || !window.PNGExporter || 
            !window.APNGExporter || !window.GIFExporter) {
            setTimeout(tryInit, 200);
            return;
        }
        
        // CoreRuntime経由でExportManager初期化
        const success = window.CoreRuntime.initializeExportSystem(
            this.pixiApp,
            () => {
                // ★ 初期化成功後にExportPopup登録
                if (window.PopupManager && window.TEGAKI_EXPORT_MANAGER) {
                    window.PopupManager.register('export', window.TegakiExportPopup, {
                        exportManager: window.TEGAKI_EXPORT_MANAGER
                    }, { 
                        priority: 5,
                        waitFor: [] // 依存関係なし（既に作成済み）
                    });
                    
                    // 即座に初期化
                    window.PopupManager.initialize('export');
                }
                
                if (window.TegakiEventBus) {
                    window.TegakiEventBus.emit('export:manager:initialized');
                }
            }
        );
        
        if (!success) setTimeout(tryInit, 200);
    };
    
    // イベント駆動 + タイマーの併用
    if (window.TegakiEventBus) {
        window.TegakiEventBus.on('animation:system-ready', tryInit);
        window.TegakiEventBus.on('animation:initialized', tryInit);
    }
    
    setTimeout(tryInit, 300); // 初回トリガー
}
```

【使用メソッド】
- PopupManager.register(name, PopupClass, dependencies, config)
- PopupManager.initialize(name)
- CoreRuntime.initializeExportSystem(pixiApp, onSuccessCallback)

【検証方法】
- コンソールに "⚠️ Popup 'export' still waiting" が出ないこと
- サイドバーのエクスポートアイコンをクリックしてポップアップが表示されること


================================================================================
Phase 2: リサイズ機能の完全修復
================================================================================

【目的】
キャンバスリサイズ時の不具合（背景透明化、方向指定無視、History不具合）を解消。

--------------------------------------------------------------------------------
Phase 2-A: レイヤー座標シフト実装
--------------------------------------------------------------------------------

【改修対象ファイル】
- core-engine.js (Line 615-718: resizeCanvas)

【参照ファイル】
- ui/resize-popup.js (アライメントオプション生成)
- system/layer-system.js (レイヤー構造)

【フロー位置】
ResizePopup._applyResize()
  └─> CoreEngine.resizeCanvas(newWidth, newHeight, alignOptions)
       ├─> オフセット計算（Line 628-652）
       └─> 背景レイヤー再描画（Line 674-689）
            ★ レイヤー座標シフト未実装 ← ここを追加

【問題詳細】
core-engine.js:628-652でoffsetX/offsetYを計算しているが、
その値を使ってレイヤー座標をシフトする処理が存在しない。

【修正内容】

■ core-engine.js
```javascript
resizeCanvas(newWidth, newHeight, options = {}) {
    const oldWidth = CONFIG.canvas.width;
    const oldHeight = CONFIG.canvas.height;
    
    const horizontalAlign = options.horizontalAlign || 'center';
    const verticalAlign = options.verticalAlign || 'center';
    
    // オフセット計算
    let offsetX = 0;
    let offsetY = 0;
    
    const widthDiff = newWidth - oldWidth;
    const heightDiff = newHeight - oldHeight;
    
    if (horizontalAlign === 'left') {
        offsetX = 0;
    } else if (horizontalAlign === 'center') {
        offsetX = widthDiff / 2;
    } else if (horizontalAlign === 'right') {
        offsetX = widthDiff;
    }
    
    if (verticalAlign === 'top') {
        offsetY = 0;
    } else if (verticalAlign === 'center') {
        offsetY = heightDiff / 2;
    } else if (verticalAlign === 'bottom') {
        offsetY = heightDiff;
    }
    
    // CONFIG更新
    CONFIG.canvas.width = newWidth;
    CONFIG.canvas.height = newHeight;
    
    // カメラシステム更新
    this.cameraSystem.resizeCanvas(newWidth, newHeight);
    
    // ★ 追加: 全フレーム・全レイヤーの座標シフト
    const frames = this.animationSystem?.animationData?.frames || [];
    frames.forEach(frame => {
        const layers = frame.getLayers();
        layers.forEach(layer => {
            // 背景レイヤーはスキップ
            if (layer.layerData?.isBackground) return;
            
            // 各レイヤーの座標をシフト
            layer.position.x += offsetX;
            layer.position.y += offsetY;
            
            // paths座標もシフト（必要に応じて）
            if (layer.layerData?.paths) {
                layer.layerData.paths.forEach(path => {
                    if (path.points) {
                        path.points.forEach(point => {
                            point.x += offsetX;
                            point.y += offsetY;
                        });
                    }
                    
                    // Graphics再描画
                    if (path.graphics) {
                        path.graphics.clear();
                        path.points.forEach(p => {
                            path.graphics.circle(p.x, p.y, path.size / 2);
                            path.graphics.fill({
                                color: path.color,
                                alpha: path.opacity
                            });
                        });
                    }
                });
            }
        });
    });
    
    // 背景レイヤー再描画（既存処理）
    const layers = this.layerSystem.getLayers();
    layers.forEach(layer => {
        if (layer.layerData.isBackground && layer.layerData.backgroundGraphics) {
            // ... 既存の背景再描画処理
        }
    });
    
    // 以下既存処理
    // ...
}
```

【使用メソッド】
- AnimationSystem.animationData.frames
- Frame.getLayers()
- PIXI.Container.position.x/y

【検証方法】
- 横配置「←」選択、幅を広げる → 右側に余白ができること
- 縦配置「↑」選択、高さを広げる → 下側に余白ができること


--------------------------------------------------------------------------------
Phase 2-B: 背景色修正
--------------------------------------------------------------------------------

【改修対象ファイル】
- core-engine.js (Line 674-689)

【参照ファイル】
- config.js (background.color定義確認)

【問題詳細】
背景レイヤー再描画時に透明チェックパターン（color1, color2）を描画しているが、
本来は単色背景（CONFIG.background.color）を描画すべき。

【修正内容】

■ core-engine.js
```javascript
layers.forEach(layer => {
    if (layer.layerData.isBackground && layer.layerData.backgroundGraphics) {
        layer.layerData.backgroundGraphics.clear();
        
        // ★ 修正: 単色背景に変更
        layer.layerData.backgroundGraphics.rect(0, 0, newWidth, newHeight);
        layer.layerData.backgroundGraphics.fill({
            color: CONFIG.background.color
        });
        
        // 以前のチェックパターンは削除
    }
});
```

【検証方法】
- リサイズ実行後、背景がクリーム色（#f0e0d6）になること


--------------------------------------------------------------------------------
Phase 2-C: Historyコマンド改善
--------------------------------------------------------------------------------

【改修対象ファイル】
- ui/resize-popup.js (Line 397-443)

【参照ファイル】
- system/history.js (Historyコマンド構造)

【問題詳細】
ResizePopup._applyResize()内でHistoryコマンドを作成しているが、
undo時にレイヤー座標の復元処理が不足している。

【修正内容】

■ ui/resize-popup.js
```javascript
_applyResize() {
    // ... 既存処理

    // ★ レイヤー座標スナップショット取得
    const frames = this.coreEngine.getAnimationSystem()?.animationData?.frames || [];
    const layerPositionSnapshots = [];
    
    frames.forEach((frame, frameIndex) => {
        const layers = frame.getLayers();
        const frameSnapshot = {
            frameIndex: frameIndex,
            layers: layers.map(layer => ({
                id: layer.layerData.id,
                x: layer.position.x,
                y: layer.position.y,
                paths: layer.layerData?.paths ? 
                    layer.layerData.paths.map(p => ({
                        id: p.id,
                        points: p.points.map(pt => ({x: pt.x, y: pt.y}))
                    })) : []
            }))
        };
        layerPositionSnapshots.push(frameSnapshot);
    });
    
    const command = {
        name: 'resize-canvas',
        do: () => {
            this.coreEngine.resizeCanvas(newWidth, newHeight, alignOptions);
        },
        undo: () => {
            // 元のサイズに戻す
            this.coreEngine.resizeCanvas(oldWidth, oldHeight, {
                horizontalAlign: 'center',
                verticalAlign: 'center'
            });
            
            // ★ レイヤー座標を復元
            const currentFrames = this.coreEngine.getAnimationSystem()?.animationData?.frames || [];
            layerPositionSnapshots.forEach(frameSnap => {
                const frame = currentFrames[frameSnap.frameIndex];
                if (!frame) return;
                
                const layers = frame.getLayers();
                frameSnap.layers.forEach(layerSnap => {
                    const layer = layers.find(l => l.layerData.id === layerSnap.id);
                    if (!layer) return;
                    
                    layer.position.x = layerSnap.x;
                    layer.position.y = layerSnap.y;
                    
                    // paths座標復元
                    if (layer.layerData?.paths) {
                        layer.layerData.paths.forEach(path => {
                            const pathSnap = layerSnap.paths.find(p => p.id === path.id);
                            if (!pathSnap) return;
                            
                            path.points.forEach((point, idx) => {
                                if (pathSnap.points[idx]) {
                                    point.x = pathSnap.points[idx].x;
                                    point.y = pathSnap.points[idx].y;
                                }
                            });
                            
                            // Graphics再描画
                            if (path.graphics) {
                                path.graphics.clear();
                                path.points.forEach(p => {
                                    path.graphics.circle(p.x, p.y, path.size / 2);
                                    path.graphics.fill({color: path.color, alpha: path.opacity});
                                });
                            }
                        });
                    }
                });
            });
        },
        meta: { 
            type: 'resize-canvas', 
            from: { width: oldWidth, height: oldHeight },
            to: { width: newWidth, height: newHeight },
            align: alignOptions
        }
    };
    
    this.history.push(command);
    this.hide();
}
```

【検証方法】
- リサイズ実行後、Ctrl+Zで元のサイズ・位置に戻ること


================================================================================
Phase 3: CUT→FRAME名称統一（遅延可）
================================================================================

【目的】
コード全体で"CUT"から"FRAME"への名称統一を完了。
既に animation-system.js は完了しているため、残存箇所を修正。

【調査対象ファイル】
- 全ファイル内の "cut" / "CUT" という文字列検索

【確認事項】
1. 変数名: currentCut → currentFrame
2. メソッド名: createCut → createFrame
3. イベント名: 'cut:switched' → 'frame:switched'
4. コメント・ログメッセージ内の "CUT" → "FRAME"

【優先度】
Phase 1, 2が完了し、動作安定後に実施。
既存機能が動作していれば緊急性は低い。


================================================================================
Phase 4: 追加改善（任意）
================================================================================

【Phase 4-A: ステータス表示の強化】
- 現在のフレーム名表示
- Historyスタック深度表示

【Phase 4-B: エクスポートプレビュー修復】
- Export PopupのプレビューボタンがBlob生成できるよう改修
- 画像2で見えた「プレビュー」ボタンの再有効化

【Phase 4-C: ResizePopupのUI改善】
- スライダードラッグ時の視覚フィードバック向上
- プリセットボタン追加（Instagram正方形、Twitter等）


================================================================================
補足情報
================================================================================

【グローバルシンボル一覧】
- window.TEGAKI_CONFIG - 設定オブジェクト
- window.TegakiEventBus - イベントバスインスタンス
- window.TegakiSettingsManager - SettingsManagerクラス
- window.PopupManager - PopupManagerインスタンス
- window.TEGAKI_EXPORT_MANAGER - ExportManagerインスタンス
- window.History - HistoryManagerインスタンス
- window.CoreRuntime - CoreRuntimeオブジェクト
- window.coreEngine - CoreEngineインスタンス
- window.drawingEngine - DrawingEngineインスタンス
- window.layerManager - LayerSystemインスタンス
- window.cameraSystem - CameraSystemインスタンス
- window.animationSystem - AnimationSystemインスタンス

【初期化順序】
1. PIXI.Application初期化
2. CoreEngine.constructor
3. CoreEngine.initialize()
   - CameraSystem.init()
   - LayerSystem.init()
   - DrawingEngine初期化
   - AnimationSystem.init()
   - UnifiedKeyHandler作成
4. PopupManager初期化
5. StatusDisplayRenderer初期化
6. ExportManager初期化（非同期）

【SettingsManager仕様】
- get() - 引数なしで全設定オブジェクト返却
- get(key) - キー指定で値取得
- set(key, value, skipEvent) - 設定変更
- update(updates) - 複数設定一括変更
- ❌ getAllSettings() は存在しない

【PopupManager仕様】
- register(name, PopupClass, dependencies, config)
  - config.waitFor: 依存グローバルシンボル配列
  - config.priority: 初期化優先度（数値小=優先）
- initialize(name) - 個別初期化
- initializeAll() - 全初期化（依存不足は遅延初期化キューへ）

【ResizePopup座標系】
- horizontalAlign: 'left' / 'center' / 'right'
  - UI上の「←」ボタン = 'left' = 右側に余白
  - UI上の「→」ボタン = 'right' = 左側に余白
- verticalAlign: 'top' / 'center' / 'bottom'
  - UI上の「↑」ボタン = 'top' = 下側に余白
  - UI上の「↓」ボタン = 'bottom' = 上側に余白


================================================================================
改修後の検証チェックリスト
================================================================================

Phase 1検証:
□ アプリ起動時にコンソールエラーが出ない
□ 画面右上にステータス表示が出る（ツール名、サイズ）
□ サイドバーのエクスポートアイコンでポップアップが開く
□ エクスポートポップアップ内にPNG/GIF等のタブが表示される

Phase 2検証:
□ リサイズポップアップを開ける
□ 幅/高さスライダーが動作する
□ 横配置「←」でリサイズ → 右側に余白ができる
□ 横配置「→」でリサイズ → 左側に余白ができる
□ 縦配置「↑」でリサイズ → 下側に余白ができる
□ 縦配置「↓」でリサイズ → 上側に余白ができる
□ リサイズ後の背景色がクリーム色（透明チェックでない）
□ リサイズ後に描画した線が正しい位置に描かれる
□ Ctrl+Zで元のサイズ・レイヤー位置に戻る

全体検証:
□ ペンツールで描画できる
□ 消しゴムツールで消せる
□ レイヤー追加・削除できる
□ フレーム作成・削除できる（Shift+N, Delete等）
□ アニメーション再生できる（Ctrl+Space）


================================================================================
終了
================================================================================