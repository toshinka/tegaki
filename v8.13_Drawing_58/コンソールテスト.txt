 ✅ config.js (Phase 2完全版) loaded
    - BRUSH_DEFAULTS追加完了
 ✅ system/event-bus.js Phase 2: 優先度機能追加版 loaded
 ✅ data-models.js (マスクスプライト不可視版) loaded
 ✅ batch-api.js (Phase 6: History統合版) loaded
 ✅ popup-manager.js (quick-access除外対応版) loaded
 ✅ camera-system.js (v2.0: リサイズ修正版) loaded
 ✅ layer-transform.js (Phase 4完了: Vモード反転機能完全版) loaded
 ✅ layer-system.js (v2.0.1: 反転機能修復版) loaded
 ✅ drawing-clipboard.js Phase4改修版+確定イベント loaded
    - ✅ CTRL+V behavior: overwrite active layer
    - ✅ Commit events: paste:commit, operation:commit
    - ✅ Thumbnail auto-update on paste
 ✅ history.js (Phase 3: Redo null参照修正版) loaded
 ✅ animation-system.js (Phase 1改修版・フレーム名統一: xF形式) loaded
 ✅ pressure-handler.js (Phase 3: 距離ベースフィルタ追加版) loaded
    - applyDistanceFilter() 追加
    - 短距離: alpha=0.9 (即座反映)
    - 長距離: alpha=0.3 (スムージング強)
 ✅ curve-interpolator.js (Phase 3) loaded
    - Catmull-Rom スプライン補間
    - 適応的サンプリング対応
    - tiltX/Y/twist データ補間対応
 ✅ system/drawing/stroke-renderer.js loaded (グローバル登録修正版)
 ✅ system/drawing/thumbnail-system.js Phase 1完全版 loaded
 ✅ brush-settings.js (API統一版) loaded
    - ✅ getOpacity() / setOpacity() 追加
    - ✅ brush:opacity-changed イベント購読追加
 ✅ drawing-engine.js (Phase 2完全修正版 - 安全な互換実装) loaded
 ✅ quick-export-ui.js (無効化版) loaded
 ✅ export-manager.js (CUT→FRAME完全修正版) loaded
 ✅ png-exporter.js (単一フレーム専用・プレビュー対応) loaded
 ✅ apng-exporter.js (CUT→FRAME完全修正版) loaded
 ✅ gif-exporter.js (CUT→FRAME完全修正版) loaded
 ✅ webp-exporter.js (静止画・動画自動判定対応版) loaded
 ✅ mp4-exporter.js (Phase 8完成版) loaded
 ✅ pdf-exporter.js (CUT→FRAME完全対応版) loaded
 ✅ dom-builder.js (ID重複解消版) loaded
    - #pen-settings → #legacy-pen-settings に変更
    - pen-size-slider → legacy-pen-size-slider に変更
dom-builder.js:497    - quick-access-popup.jsとのID競合を完全解消
slider-utils.js:197 ✅ ui/slider-utils.js loaded
slider-utils.js:198    - 責務: スライダーUIの統一実装
slider-utils.js:199    - DRY原則: settings-popup.js と ui-panels.js で共有
slider-utils.js:200    - API: createSlider() / createSimpleSlider()
keyboard-handler.js:318 ✅ keyboard-handler.js (P/Eサイドバー同期版) loaded
resize-popup.js:452 ✅ resize-popup.js (Phase 4完了: ロジック削減版) loaded
status-display-renderer.js:138 ✅ status-display-renderer.js (Phase 1改修版) loaded
timeline-ui.js:981 ✅ timeline-ui.js (Phase 4完了: レイヤー変形連携版) loaded
album-popup.js:473 ✅ album-popup.js (FRAME改修版) loaded
settings-popup.js:583 ✅ settings-popup.js (即応性完全修正版) loaded
settings-popup.js:584    - CSS transition完全除去（!important付き）
settings-popup.js:585    - DOM更新を同期的に即座実行
settings-popup.js:586    - quick-access/resize-popupと完全同等の動作
quick-access-popup.js:538 ✅ quick-access-popup.js (背景ドラッグ + 閉じるボタン版) loaded
quick-access-popup.js:539    - 背景ドラッグで移動可能（スライダー/ボタン以外）
quick-access-popup.js:540    - 右上×ボタンで閉じる
quick-access-popup.js:541    - 画面外クリックで閉じない（常時開きっぱなし可能）
export-popup.js:423 ✅ export-popup.js (frameInfo修正版＋PDF有効化) loaded
ui-panels.js:408 ✅ ui-panels.js (サイドバー同期・色調整版) loaded
core-runtime.js:713 ✅ core-runtime.js (Phase 1-3完全版: ThumbnailSystem統合) loaded
core-engine.js:724 ✅ core-engine.js (Phase2完全修正版) loaded
core-initializer.js:347 ✅ core-initializer.js (完全修正版・SettingsManager＋ExportPopup対応) loaded
drawing-clipboard.js:19 DrawingClipboard: Initializing...
drawing-clipboard.js:26 ✅ DrawingClipboard initialized (Phase4改修版 + 確定イベント)
thumbnail-system.js:43 ✅ ThumbnailSystem initialized
core-initializer.js:63 ✅ SettingsManager initialized
popup-manager.js:16 ✅ PopupManager initialized
popup-manager.js:42 📋 Popup "settings" registered (priority: 1)
popup-manager.js:42 📋 Popup "quickAccess" registered (priority: 2)
popup-manager.js:42 📋 Popup "album" registered (priority: 3)
popup-manager.js:42 📋 Popup "resize" registered (priority: 4)
popup-manager.js:102 🔧 Initializing all popups...
popup-manager.js:87 ✅ Popup "settings" initialized successfully
popup-manager.js:87 ✅ Popup "quickAccess" initialized successfully
popup-manager.js:87 ✅ Popup "album" initialized successfully
popup-manager.js:87 ✅ Popup "resize" initialized successfully
popup-manager.js:118 📊 Popup initialization: 4 ready, 0 deferred
popup-manager.js:42 📋 Popup "export" registered (priority: 5)
popup-manager.js:87 ✅ Popup "export" initialized successfully
core-initializer.js:245 ✅ ExportPopup registered and initialized
// ===== Graphics の描画内容を詳細確認 =====

const layerMgr = window.CoreRuntime.internal.layerManager;
const activeLayer = layerMgr.getActiveLayer();
const lastChild = activeLayer.children[activeLayer.children.length - 1];

console.log('=== Graphics 描画内容 ===');
console.log('lastChild:', lastChild);
console.log('lastChild.constructor.name:', lastChild.constructor.name);

// PixiJS v8の Graphics の内部構造確認
if (lastChild.geometry) {
    console.log('geometry:', lastChild.geometry);
    console.log('geometry.graphicsData:', lastChild.geometry.graphicsData);
    console.log('geometry.batches:', lastChild.geometry.batches);
}

// バウンディングボックス確認
try {
    const bounds = lastChild.getBounds();
    console.log('bounds:', {
        x: bounds.x,
        y: bounds.y,
        width: bounds.width,
        height: bounds.height
    });
} catch (e) {
    console.log('getBounds error:', e);
}

// 手動でテスト描画
console.log('=== 手動テスト描画 ===');

const testGraphics = new PIXI.Graphics();
testGraphics.circle(100, 100, 50);
testGraphics.fill({ color: 0xFF0000, alpha: 1.0 });

activeLayer.addChild(testGraphics);
console.log('✓ 赤い円を (100, 100) に追加');
console.log('  → 画面に赤い円が見えますか？');

// もう一つ、線を描画
const testLine = new PIXI.Graphics();
testLine.moveTo(0, 0);
testLine.lineTo(200, 200);
testLine.stroke({ width: 5, color: 0x00FF00, alpha: 1.0 });

activeLayer.addChild(testLine);
console.log('✓ 緑の線を (0,0) → (200,200) に追加');
console.log('  → 画面に緑の線が見えますか？');

// 既存の描画ストロークのデータ確認
console.log('=== レイヤーのpathsデータ ===');
console.log('activeLayer.layerData.paths:', activeLayer.layerData?.paths);
console.log('paths.length:', activeLayer.layerData?.paths?.length);

if (activeLayer.layerData?.paths?.length > 0) {
    const lastPath = activeLayer.layerData.paths[activeLayer.layerData.paths.length - 1];
    console.log('last path:', lastPath);
    console.log('last path.graphics:', lastPath.graphics);
    console.log('last path.points:', lastPath.points?.slice(0, 3)); // 最初の3点
}
VM80:7 === Graphics 描画内容 ===
VM80:8 lastChild: or {_events: i, _eventsCount: 0, uid: 21, _updateFlags: 0, renderGroup: null, …}
VM80:9 lastChild.constructor.name: or
VM80:21 bounds: {x: 0, y: 0, width: 0, height: 0}
VM80:32 === 手動テスト描画 ===
VM80:39 ✓ 赤い円を (100, 100) に追加
VM80:40   → 画面に赤い円が見えますか？
VM80:49 ✓ 緑の線を (0,0) → (200,200) に追加
VM80:50   → 画面に緑の線が見えますか？
VM80:53 === レイヤーのpathsデータ ===
VM80:54 activeLayer.layerData.paths: [{…}]
VM80:55 paths.length: 1
VM80:59 last path: {id: 'path_1761709381209_1p5s15cpi', points: Array(1), color: 8388608, size: 10, opacity: 85, …}
VM80:60 last path.graphics: or {_events: i, _eventsCount: 0, uid: 21, _updateFlags: 0, renderGroup: null, …}
VM80:61 last path.points: [{…}]
undefined
// ===== 即座修正: StrokeRenderer を v8 対応版に置き換え =====

window.StrokeRenderer = class StrokeRenderer {
    constructor(app, layerSystem, cameraSystem) {
        this.app = app;
        this.layerSystem = layerSystem;
        this.cameraSystem = cameraSystem;
        this.resolution = window.devicePixelRatio || 1;
        this.minPhysicalWidth = 1 / this.resolution;
        this.currentTool = 'pen';
    }
    
    setTool(tool) {
        this.currentTool = tool;
    }
    
    calculateWidth(pressure, brushSize) {
        const minRatio = Math.max(0.3, this.minPhysicalWidth);
        const ratio = Math.max(minRatio, pressure || 0.5);
        return Math.max(this.minPhysicalWidth, brushSize * ratio);
    }
    
    renderPreview(points, settings) {
        const graphics = new PIXI.Graphics();
        if (points.length === 0) return graphics;
        
        if (this.currentTool === 'eraser') {
            graphics.blendMode = 'erase';
        }
        
        // 単独点
        if (points.length === 1) {
            const p = points[0];
            const width = this.calculateWidth(p.pressure, settings.size);
            graphics.circle(p.x, p.y, width / 2);
            graphics.fill({
                color: this.currentTool === 'eraser' ? 0xFFFFFF : settings.color,
                alpha: settings.alpha || 1.0
            });
            return graphics;
        }
        
        // PixiJS v8: 各線分ごとに stroke() を呼ぶ
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i + 1];
            const w1 = this.calculateWidth(p1.pressure, settings.size);
            const w2 = this.calculateWidth(p2.pressure, settings.size);
            const avgWidth = (w1 + w2) / 2;
            
            graphics.moveTo(p1.x, p1.y);
            graphics.lineTo(p2.x, p2.y);
            graphics.stroke({
                width: avgWidth,
                color: this.currentTool === 'eraser' ? 0xFFFFFF : settings.color,
                alpha: settings.alpha || 1.0,
                cap: 'round',
                join: 'round'
            });
        }
        
        return graphics;
    }
    
    renderStroke(layer, strokeData, settings) {
        if (!layer || !strokeData || !strokeData.points || strokeData.points.length === 0) {
            return null;
        }
        
        const graphics = new PIXI.Graphics();
        
        if (this.currentTool === 'eraser') {
            graphics.blendMode = 'erase';
        }
        
        // 単独点
        if (strokeData.isSingleDot || strokeData.points.length === 1) {
            const p = strokeData.points[0];
            const width = this.calculateWidth(p.pressure || 0.5, settings.size);
            
            graphics.circle(p.x, p.y, width / 2);
            graphics.fill({
                color: this.currentTool === 'eraser' ? 0xFFFFFF : settings.color,
                alpha: settings.opacity || 1.0
            });
        } else {
            // PixiJS v8: 各線分ごとに stroke() を呼ぶ（重要！）
            for (let i = 0; i < strokeData.points.length - 1; i++) {
                const p1 = strokeData.points[i];
                const p2 = strokeData.points[i + 1];
                const w1 = this.calculateWidth(p1.pressure || 0.5, settings.size);
                const w2 = this.calculateWidth(p2.pressure || 0.5, settings.size);
                const avgWidth = (w1 + w2) / 2;
                
                graphics.moveTo(p1.x, p1.y);
                graphics.lineTo(p2.x, p2.y);
                graphics.stroke({
                    width: avgWidth,
                    color: settings.color,
                    alpha: settings.opacity || 1.0,
                    cap: 'round',
                    join: 'round'
                });
            }
        }
        
        const pathData = {
            id: 'path_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            points: strokeData.points,
            color: settings.color,
            size: settings.size,
            opacity: settings.opacity || 1.0,
            tool: this.currentTool,
            isComplete: true,
            graphics: graphics
        };
        
        return pathData;
    }
    
    updateResolution() {
        this.resolution = window.devicePixelRatio || 1;
        this.minPhysicalWidth = 1 / this.resolution;
    }
};

// DrawingEngineに再注入
const engine = window.CoreRuntime.internal.drawingEngine;
engine.strokeRenderer = new window.StrokeRenderer(
    engine.app,
    engine.layerSystem,
    engine.cameraSystem
);

console.log('✅ StrokeRenderer fixed for PixiJS v8');
console.log('キャンバスでドラッグして描画してください！');
VM83:135 ✅ StrokeRenderer fixed for PixiJS v8
VM83:136 キャンバスでドラッグして描画してください！
undefined
