# ペン関連シンボル辞典 v2.0 - P/E+ドラッグ現状分析

## 📊 現状サマリー

### ✅ 実装済み
- BrushSettings: サイズ/不透明度管理
- DrawingEngine: tool:size-opacity-changed購読
- ToolSizeManager: drag-size-update→size-opacity-changed変換
- KeyboardHandler: P/E+ドラッグ検出、累積delta計算
- DragVisualFeedback: ビジュアルフィードバック表示

### ❌ 問題点
1. **ToolSizeManagerがBrushSettingsを取得できない**
   - `_getBrushSettings()`が`window.drawingEngine.settings`のみを参照
   - 初期化タイミングで`window.drawingEngine`が未定義
   
2. **DrawingEngineの参照パス不統一**
   - `window.drawingEngine` (ToolSizeManager)
   - `window.drawingApp.drawingEngine` (レガシー)
   - `window.CoreRuntime.internal.drawingEngine` (新)

3. **ツール状態の二重管理**
   - ToolSizeManagerが独自に`penSize/penOpacity`を保持
   - BrushSettingsも同じ値を保持
   - 同期ロジックが複雑

---

## 🔍 1. BrushSettings (system/drawing/brush-settings.js)

### クラス定義
```javascript
class BrushSettings {
  // プロパティ
  size: number                  // ★ ブラシサイズ
  color: number                 // ★ ブラシ色 (0xRRGGBB)
  opacity: number               // ★ 不透明度 (0.0-1.0)
  thinning: number
  smoothing: number
  streamline: number
  pressureCorrection: number
  // ...他設定
}
```

### 主要メソッド
- `getBrushSize()` → number
- `setBrushSize(size)` → emit('brushSizeChanged')
- `getBrushOpacity()` → number
- `setBrushOpacity(opacity)` → emit('brushOpacityChanged')
- `getCurrentSettings()` → Object

### グローバル登録
```javascript
window.TegakiDrawing.BrushSettings = BrushSettings
window.BrushSettings = BrushSettings
globalThis.BrushSettings = BrushSettings
```

---

## 🔍 2. DrawingEngine (system/drawing/drawing-engine.js)

### 初期化フロー
```javascript
constructor(cameraSystem, layerManager, eventBus, config) {
  this._initializeBrushSettings()  // 同期的にBrushSettings生成
  this.settings = new BrushSettings(config, eventBus)
  // ...
  this.subscribeToSettings()       // イベント購読
}
```

### イベント購読
```javascript
subscribeToSettings() {
  // ★ P/E+ドラッグ対応
  this.eventBus.on('tool:size-opacity-changed', ({ tool, size, opacity }) => {
    if (!tool || tool === this.currentTool) {
      if (size !== undefined) {
        this.settings.setBrushSize(size)
      }
      if (opacity !== undefined) {
        this.settings.setBrushOpacity(opacity)
      }
    }
  })
  
  // 他の設定イベント...
}
```

### グローバル登録
```javascript
window.TegakiDrawing.DrawingEngine = DrawingEngine
```

### 参照パス（レガシー互換）
- `window.drawingApp.drawingEngine`
- `window.coreEngine.drawingEngine`
- `window.CoreRuntime.internal.drawingEngine`

---

## 🔍 3. ToolSizeManager (system/tool-size-manager.js)

### 役割
P/E+ドラッグのdelta値を実際のsize/opacityに変換し、`tool:size-opacity-changed`を発行

### 問題のある実装
```javascript
_getBrushSettings() {
  // ❌ window.drawingEngine のみを参照
  if (!window.drawingEngine?.settings) {
    return null
  }
  return window.drawingEngine.settings
}
```

### 期待される動作
```javascript
// ツール状態は独自に保持せず、BrushSettingsから取得すべき
this.eventBus.on('tool:drag-size-start', (data) => {
  // 開始値をBrushSettingsから取得
  const brushSettings = this._getBrushSettings()
  this.dragState = {
    tool: data.tool,
    startSize: data.startSize,      // KeyboardHandlerから渡される
    startOpacity: data.startOpacity // KeyboardHandlerから渡される
  }
})

this.eventBus.on('tool:drag-size-update', (data) => {
  // deltaから新しい値を計算
  const newSize = clamp(
    this.dragState.startSize + data.deltaX * sensitivity,
    min, max
  )
  const newOpacity = clamp(
    this.dragState.startOpacity - data.deltaY * sensitivity,
    min, max
  )
  
  // BrushSettingsに反映
  this._updateBrushSettings(newSize, newOpacity)
  
  // tool:size-opacity-changedを発行（DrawingEngine/DragVisualFeedback向け）
  this.eventBus.emit('tool:size-opacity-changed', {
    tool: data.tool,
    size: newSize,
    opacity: newOpacity
  })
})
```

---

## 🔍 4. KeyboardHandler (ui/keyboard-handler.js)

### ドラッグ状態管理
```javascript
const dragState = {
  pKeyPressed: boolean,      // Pキー押下中
  eKeyPressed: boolean,      // Eキー押下中
  isDragging: boolean,       // ドラッグ中
  dragStartX: number,        // 開始X座標（画面座標）
  dragStartY: number,        // 開始Y座標（画面座標）
  activeTool: 'pen'|'eraser'|null
}
```

### イベント発火フロー
```javascript
// 1. マウスダウン
handleMouseDown(e) {
  dragState.dragStartX = e.clientX
  dragState.dragStartY = e.clientY
  
  const brushSettings = getBrushSettings()
  const startSize = brushSettings.getBrushSize()
  const startOpacity = brushSettings.getBrushOpacity()
  
  // ★ ドラッグ開始を通知
  TegakiEventBus.emit('tool:drag-size-start', {
    tool: dragState.activeTool,
    startSize,
    startOpacity
  })
  
  dragState.isDragging = true
}

// 2. マウス移動
handleMouseMove(e) {
  // ★ 開始位置からの累積差分
  const deltaX = e.clientX - dragState.dragStartX
  const deltaY = e.clientY - dragState.dragStartY
  
  TegakiEventBus.emit('tool:drag-size-update', {
    tool: dragState.activeTool,
    deltaX,  // 累積差分（前回差分ではない）
    deltaY
  })
}

// 3. マウスアップ
handleMouseUp(e) {
  TegakiEventBus.emit('tool:drag-size-end')
  dragState.isDragging = false
}
```

### BrushSettings取得ロジック
```javascript
function getBrushSettings() {
  const candidates = [
    window.coreEngine?.drawingEngine,
    window.drawingApp?.drawingEngine,
    window.CoreEngine?.drawingEngine,
    window.drawingEngine
  ]
  
  for (const c of candidates) {
    if (c?.settings) return c.settings        // ★ settingsを優先
    if (c?.brushSettings) return c.brushSettings
  }
  return null
}
```

---

## 🔍 5. DragVisualFeedback (ui/drag-visual-feedback.js)

### イベント購読
```javascript
_setupEventListeners() {
  this.eventBus.on('tool:drag-size-start', (data) => {
    this._handleDragStart(data)  // 表示開始
  })
  
  this.eventBus.on('tool:size-opacity-changed', (data) => {
    this._handleDragUpdate(data) // ビジュアル更新
  })
  
  this.eventBus.on('tool:drag-size-end', () => {
    this._handleDragEnd()        // フェードアウト
  })
  
  // カーソル追従
  document.addEventListener('mousemove', (e) => {
    this.currentX = e.clientX
    this.currentY = e.clientY
    if (this.isActive) this._updatePosition()
  })
}
```

---

## 🔍 6. CoreRuntime (core-runtime.js)

### DrawingEngine参照の設定
```javascript
setupLegacyCompatibility() {
  window.drawingApp = {
    pixiApp: this.internal.app,
    cameraSystem: this.internal.cameraSystem,
    layerManager: this.internal.layerManager,
    drawingEngine: this.internal.drawingEngine,  // ★ここに格納
    app: this.internal.app
  }
}
```

### PointerEvent処理（Phase 12）
```javascript
handlePointerDown(event) {
  // ★ P/Eキー押下中はサイズ変更モード
  if (window.KeyboardHandler) {
    const debugState = window.KeyboardHandler.getDebugState?.()
    if (debugState && (debugState.pKeyPressed || debugState.eKeyPressed)) {
      return  // 描画しない
    }
  }
  
  // 通常の描画処理
  const screenX = event.global.x
  const screenY = event.global.y
  this.internal.drawingEngine.startDrawing(screenX, screenY, event)
}
```

---

## 🎯 問題の根本原因

### 1. 初期化タイミングの問題
```
// 現在の初期化順序
1. BrushSettings生成 (drawing-engine.js)
2. ToolSizeManager生成 (core-initializer.js)
3. CoreRuntime.setupLegacyCompatibility()
   → window.drawingApp.drawingEngine設定
```

**ToolSizeManager生成時、`window.drawingEngine`は未定義**

### 2. 参照パスの不統一
```javascript
// ToolSizeManager
window.drawingEngine.settings  // ❌ 存在しない

// KeyboardHandler
window.coreEngine?.drawingEngine.settings     // ✅
window.drawingApp?.drawingEngine.settings     // ✅
```

### 3. ツール状態の二重管理
```javascript
// ToolSizeManager
this.penSize = 10
this.penOpacity = 0.85

// BrushSettings
this.size = 10
this.opacity = 0.85

// 同期処理
_updateBrushSettings(size, opacity) {
  brushSettings.setBrushSize(size)
  brushSettings.setBrushOpacity(opacity)
}

// さらにToolSizeManagerでも保持
if (data.tool === 'pen') {
  this.penSize = newSize
  this.penOpacity = newOpacity
}
```

→ データの所有権が曖昧

---

## 🔧 改修方針

### SOLID原則に基づく責務分離

#### 1. BrushSettings (データ保持)
- サイズ/不透明度/色の**唯一の情報源**
- ツールごとの状態は持たない（常に現在値のみ）
- EventBus経由で変更を通知

#### 2. ToolSizeManager (計算・変換)
- ドラッグdelta → size/opacity変換
- **状態は一時的なdragStateのみ保持**
- BrushSettingsから現在値を取得
- 計算結果をBrushSettingsに反映

#### 3. DrawingEngine (描画統合)
- BrushSettingsを保持（`this.settings`）
- tool:size-opacity-changedを購読
- 描画時にsettings.getStrokeOptions()を使用

#### 4. KeyboardHandler (入力検出)
- キー/マウスイベント検出
- BrushSettingsから開始値を取得
- tool:drag-size-startを発行

### 参照パス統一

```javascript
// ToolSizeManager
_getBrushSettings() {
  // 複数パスを試行（フォールバック）
  const sources = [
    () => window.drawingApp?.drawingEngine?.settings,
    () => window.coreEngine?.drawingEngine?.settings,
    () => window.CoreRuntime?.internal?.drawingEngine?.settings
  ]
  
  for (const fn of sources) {
    try {
      const settings = fn()
      if (settings) return settings
    } catch {}
  }
  
  return null
}
```

---

## 📋 改修チェックリスト

### system/tool-size-manager.js
- [ ] `_getBrushSettings()`を複数パス対応に修正
- [ ] `penSize/penOpacity/eraserSize/eraserOpacity`プロパティ削除
- [ ] ツール状態管理をdragStateのみに限定
- [ ] `_updateBrushSettings()`を簡素化

### ui/keyboard-handler.js
- [ ] `getBrushSettings()`の参照パス順序確認
- [ ] P/E+ドラッグ中の描画防止確認

### system/drawing/drawing-engine.js
- [ ] `subscribeToSettings()`でtool:size-opacity-changed購読確認
- [ ] toolフィルタリングロジック確認

### core-runtime.js
- [ ] `window.drawingEngine`グローバル登録追加（互換性）
- [ ] PointerEvent処理でP/E判定確認

### ui/drag-visual-feedback.js
- [ ] イベント購読確認
- [ ] カーソル追従確認

---

## 🎓 設計原則の遵守

### DRY (Don't Repeat Yourself)
- ❌ ツール状態をToolSizeManagerとBrushSettingsで二重管理
- ✅ BrushSettingsを唯一の情報源とする

### SRP (Single Responsibility Principle)
- BrushSettings: 設定値の保持のみ
- ToolSizeManager: ドラッグ計算・変換のみ
- DrawingEngine: 描画統合のみ
- KeyboardHandler: 入力検出のみ

### OCP (Open/Closed Principle)
- BrushSettingsへのアクセスは抽象化（_getBrushSettings）
- 新しい参照パス追加が容易

### LSP (Liskov Substitution Principle)
- EventBus経由の疎結合
- 各コンポーネントは独立して動作可能

### ISP (Interface Segregation Principle)
- 最小限のAPIのみ公開
- getBrushSize/setBrushSizeなど明確なインターフェース

### DIP (Dependency Inversion Principle)
- 具体的な実装ではなくEventBusに依存
- コンポーネント間の直接参照を最小化

---

## 🚀 次のステップ

1. ToolSizeManager改修（_getBrushSettings改善、状態削除）
2. CoreRuntime改修（window.drawingEngine追加）
3. 動作確認（P+ドラッグ、E+ドラッグ）
4. エッジケース確認（初期化タイミング、ツール切替）