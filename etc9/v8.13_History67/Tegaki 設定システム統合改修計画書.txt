Tegaki 設定システム統合改修計画書
Version: v8.13_History57 → v8.13_History58
対象: 後続Claude向け段階的改修手順
改修目的
EventBus統合の完全化、API統一、設定適用フローの確立によるDRY/SOLID原則の徹底
前提確認（Phase 0）
実行前チェックリスト
javascript// ブラウザコンソールで実行
console.log('EventBus:', !!window.TegakiEventBus);
console.log('BrushSettings:', !!window.TegakiDrawing?.BrushSettings);
console.log('SettingsManager:', !!window.TegakiSettingsManager);
console.log('CoreRuntime:', !!window.CoreRuntime);
console.log('DrawingEngine:', !!window.CoreRuntime?.internal?.drawingEngine);
全てtrueであることを確認。falseがある場合は該当ファイルの読み込み順を確認。

Phase 1: DrawingEngineのEventBus統合完全化
影響範囲: system/drawing/drawing-engine.jsのみ
リスク: 低（メソッド追加のみ）
依存ファイル: system/event-bus.js, system/drawing/brush-settings.js, system/drawing/pressure-handler.js
1-1. 現状分析
問題箇所
javascript// drawing-engine.js L12-20（現状）
constructor(cameraSystem, layerManager, eventBus, config) {
  this.eventBus = eventBus; // 保持はしているが購読していない
  // BrushSettings は EventBus を購読している
  this.settings = new window.TegakiDrawing.BrushSettings(config, eventBus);
}
```

#### データフロー（現状）
```
settings-popup.js
  ↓ EventBus.emit('settings:pressure-correction')
BrushSettings.constructor
  ↓ eventBus.on('settings:pressure-correction')
BrushSettings.setPressureCorrection()
  ↓ this.pressureCorrection = value
（❌ここで止まる。PressureHandlerに伝わらない）
1-2. 実装手順
Step 1: subscribeToSettings() メソッド追加
drawing-engine.js のコンストラクタ末尾に追加:
javascriptconstructor(cameraSystem, layerManager, eventBus, config) {
  // ... 既存コード ...
  
  // 🆕 EventBus購読の初期化
  this.subscribeToSettings();
}

subscribeToSettings() {
  if (!this.eventBus) return;
  
  // 筆圧補正の変更を購読
  this.eventBus.on('settings:pressure-correction', ({ value }) => {
    if (this.settings) {
      this.settings.setPressureCorrection(value);
    }
    if (this.pressureHandler) {
      this.pressureHandler.correctionFactor = value;
    }
  });
  
  // 線補正の変更を購読
  this.eventBus.on('settings:smoothing', ({ value }) => {
    if (this.settings) {
      this.settings.setSmoothing(value);
    }
  });
  
  // 筆圧カーブの変更を購読
  this.eventBus.on('settings:pressure-curve', ({ curve }) => {
    if (this.settings) {
      this.settings.setPressureCurve(curve);
    }
    if (this.pressureHandler) {
      this.pressureHandler.curve = curve;
    }
  });
}
Step 2: PressureHandlerに適用プロパティ追加
確認必須: pressure-handler.js に以下のプロパティが存在するか確認:
javascript// pressure-handler.js
class PressureHandler {
  constructor() {
    this.correctionFactor = 1.0; // ← これが存在するか確認
    this.curve = 'linear'; // ← これが存在するか確認
  }
  
  getCorrectedPressure(rawPressure) {
    let corrected = rawPressure * this.correctionFactor; // ← 使用されているか確認
    // ...
  }
}
存在しない場合: PressureHandlerのコンストラクタに追加し、getCorrectedPressure()内で使用するよう修正。
1-3. 検証項目
javascript// ブラウザコンソールで実行
const engine = window.CoreRuntime.internal.drawingEngine;

// 1. subscribeToSettings が存在するか
console.log('subscribeToSettings:', typeof engine.subscribeToSettings);

// 2. EventBus購読が動作するか
window.TegakiEventBus.emit('settings:pressure-correction', { value: 1.5 });
console.log('BrushSettings:', engine.settings.pressureCorrection); // 1.5
console.log('PressureHandler:', engine.pressureHandler?.correctionFactor); // 1.5

// 3. 実際の描画で反映されるか（手動テスト）
// - 筆圧補正スライダーを変更
// - ペンタブレットで描画
// - 線の太さが変化することを確認
```

### 1-4. データフロー（改修後）
```
settings-popup.js
  ↓ EventBus.emit('settings:pressure-correction', {value})
  ├→ BrushSettings.setPressureCorrection(value)
  └→ DrawingEngine.subscribeToSettings()
       └→ PressureHandler.correctionFactor = value
            ↓
       StrokeRecorder.recordPoint()
            ↓
       PressureHandler.getCorrectedPressure()
            ↓ rawPressure * correctionFactor
       StrokeRenderer.renderStroke()

Phase 2: CoreRuntime API拡張
影響範囲: core-runtime.jsのみ
リスク: 極低（APIメソッド追加のみ）
依存ファイル: system/drawing/brush-settings.js
2-1. API設計
原則

EventBusを経由せず直接BrushSettingsを操作
戻り値で成功/失敗を明示（boolean）
値の検証はBrushSettings側で行う

2-2. 実装手順
core-runtime.js の api オブジェクトに追加:
javascriptapi: {
  // ... 既存のメソッド ...
  
  // === 設定関連API（Phase 2追加） ===
  
  setPressureCorrection(value) {
    const engine = CoreRuntime.internal.drawingEngine;
    if (!engine?.settings) return false;
    
    engine.settings.setPressureCorrection(value);
    return true;
  },
  
  setSmoothing(value) {
    const engine = CoreRuntime.internal.drawingEngine;
    if (!engine?.settings) return false;
    
    engine.settings.setSmoothing(value);
    return true;
  },
  
  setPressureCurve(curve) {
    const engine = CoreRuntime.internal.drawingEngine;
    if (!engine?.settings) return false;
    
    engine.settings.setPressureCurve(curve);
    return true;
  },
  
  // 🆕 設定取得API（デバッグ用）
  getSettings() {
    const engine = CoreRuntime.internal.drawingEngine;
    if (!engine?.settings) return null;
    
    return engine.settings.getCurrentSettings();
  }
}
2-3. 検証項目
javascript// ブラウザコンソールで実行
const api = window.CoreRuntime.api;

// 1. APIが存在するか
console.log('setPressureCorrection:', typeof api.setPressureCorrection);
console.log('setSmoothing:', typeof api.setSmoothing);
console.log('setPressureCurve:', typeof api.setPressureCurve);
console.log('getSettings:', typeof api.getSettings);

// 2. 動作確認
console.log(api.setPressureCorrection(1.8)); // true
console.log(api.setSmoothing(0.7)); // true
console.log(api.setPressureCurve('ease-in')); // true

// 3. 値が反映されているか
const settings = api.getSettings();
console.log(settings);
// {
//   pressureCorrection: 1.8,
//   smoothing: 0.7,
//   pressureCurve: 'ease-in',
//   ...
// }
```

### 2-4. API呼び出し経路
```
外部スクリプト/DevTools
  ↓
CoreRuntime.api.setPressureCorrection(1.5)
  ↓ 直接呼び出し（EventBus経由しない）
BrushSettings.setPressureCorrection(1.5)
  ↓ EventBus.emit('brush:pressure-correction-changed')
DrawingEngine.subscribeToSettings()
  ↓
PressureHandler.correctionFactor = 1.5

Phase 3: スライダー実装の完全統一
影響範囲: ui/settings-popup.js, ui/slider-utils.js
リスク: 中（UI動作の変更）
依存ファイル: system/event-bus.js
3-1. 現状分析
問題箇所
settings-popup.js L175-254:
javascriptsetupPressureCorrectionListener() {
  const slider = document.getElementById('pressure-correction-slider');
  const valueDisplay = document.getElementById('pressure-correction-value');
  
  // 独自のスライダー実装（重複）
  slider.addEventListener('input', (e) => { ... });
}
ui-panels.js L272-312:
javascriptcreateSlider: function(sliderId, min, max, initial, callback) {
  // 別のスライダー実装（重複）
}
slider-utils.js:
javascript// 既に統一実装が存在
window.SliderUtils = {
  createSlider(options) { ... }
};
3-2. 実装手順
Step 1: settings-popup.js のリファクタリング
削除する箇所:

setupPressureCorrectionListener() の独自実装（L175-203）
setupSmoothingListener() の独自実装（L205-233）
setupPressureCurveListener() の独自実装（L235-254）

置き換え後:
javascript// settings-popup.js
setupPressureCorrectionListener() {
  const container = document.getElementById('pressure-correction-container');
  const slider = document.getElementById('pressure-correction-slider');
  const valueDisplay = document.getElementById('pressure-correction-value');
  
  if (!slider || !valueDisplay) return;
  
  // 🆕 SliderUtils を使用
  window.SliderUtils.bindSlider({
    slider: slider,
    valueDisplay: valueDisplay,
    min: 0.1,
    max: 3.0,
    step: 0.1,
    initialValue: this.currentSettings.pressureCorrection || 1.0,
    formatValue: (v) => v.toFixed(1),
    onInput: (value) => {
      // リアルタイムプレビュー
      this.eventBus.emit('settings:pressure-correction', { value });
    },
    onCommit: (value) => {
      // 確定時のみ保存
      this.updateSetting('pressureCorrection', value);
    }
  });
}

setupSmoothingListener() {
  const slider = document.getElementById('smoothing-slider');
  const valueDisplay = document.getElementById('smoothing-value');
  
  if (!slider || !valueDisplay) return;
  
  window.SliderUtils.bindSlider({
    slider: slider,
    valueDisplay: valueDisplay,
    min: 0.0,
    max: 1.0,
    step: 0.05,
    initialValue: this.currentSettings.smoothing || 0.5,
    formatValue: (v) => v.toFixed(2),
    onInput: (value) => {
      this.eventBus.emit('settings:smoothing', { value });
    },
    onCommit: (value) => {
      this.updateSetting('smoothing', value);
    }
  });
}
Step 2: slider-utils.js の拡張確認
必要なメソッドが存在するか確認:
javascript// slider-utils.js
window.SliderUtils = {
  // 既存
  createSlider(options) { ... },
  
  // 🆕 必要なら追加
  bindSlider(options) {
    const { slider, valueDisplay, min, max, step, initialValue, formatValue, onInput, onCommit } = options;
    
    slider.min = min;
    slider.max = max;
    slider.step = step;
    slider.value = initialValue;
    valueDisplay.textContent = formatValue(initialValue);
    
    slider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      valueDisplay.textContent = formatValue(value);
      if (onInput) onInput(value);
    });
    
    slider.addEventListener('change', (e) => {
      const value = parseFloat(e.target.value);
      if (onCommit) onCommit(value);
    });
  }
};
3-3. 検証項目
javascript// 1. SliderUtils.bindSlider が存在するか
console.log('bindSlider:', typeof window.SliderUtils.bindSlider);

// 2. 設定ポップアップを開く
// - 筆圧補正スライダーが動作するか
// - 値の表示が更新されるか
// - EventBusにイベントが発火されるか

// 3. EventBus監視
window.TegakiEventBus.on('settings:pressure-correction', (data) => {
  console.log('筆圧補正変更:', data);
});

Phase 4: localStorage操作のSettingsManager完全移管
影響範囲: ui/settings-popup.js, system/settings-manager.js
リスク: 中（設定保存ロジックの変更）
依存ファイル: system/event-bus.js
4-1. 現状分析
問題箇所
settings-popup.js L235-244:
javascriptsaveSettings(partial) {
  const stored = localStorage.getItem('tegaki_settings');
  const current = stored ? JSON.parse(stored) : {};
  const updated = { ...current, ...partial };
  localStorage.setItem('tegaki_settings', JSON.stringify(updated));
}
❌ 問題: UIコンポーネントが永続化層を直接操作している（責務違反）
4-2. 実装手順
Step 1: SettingsManager の確認
settings-manager.js が以下のメソッドを持つか確認:
javascript// system/settings-manager.js
class SettingsManager {
  updateSetting(key, value) { ... } // 必須
  getSetting(key) { ... } // 必須
  getAll() { ... } // 必須
  reset() { ... } // 推奨
}
存在しない場合: 以下を追加
javascriptclass SettingsManager {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.settings = this.loadFromStorage();
  }
  
  updateSetting(key, value) {
    this.settings[key] = value;
    this.saveToStorage();
    this.eventBus.emit(`settings:${this.toKebabCase(key)}`, { value });
  }
  
  getSetting(key) {
    return this.settings[key];
  }
  
  getAll() {
    return { ...this.settings };
  }
  
  loadFromStorage() {
    const stored = localStorage.getItem('tegaki_settings');
    return stored ? JSON.parse(stored) : this.getDefaults();
  }
  
  saveToStorage() {
    localStorage.setItem('tegaki_settings', JSON.stringify(this.settings));
  }
  
  getDefaults() {
    return {
      pressureCorrection: 1.0,
      smoothing: 0.5,
      pressureCurve: 'linear',
      statusPanelVisible: true
    };
  }
  
  toKebabCase(str) {
    return str.replace(/([A-Z])/g, '-$1').toLowerCase();
  }
}
Step 2: settings-popup.js の修正
削除する箇所:
javascript// ❌ 削除
saveSettings(partial) {
  const stored = localStorage.getItem('tegaki_settings');
  // ...
}
置き換え後:
javascript// settings-popup.js
constructor(eventBus) {
  this.eventBus = eventBus;
  this.settingsManager = window.TegakiSettingsManager; // 🆕 参照を保持
  this.currentSettings = this.settingsManager.getAll();
}

updateSetting(key, value) {
  this.settingsManager.updateSetting(key, value); // 🆕 SettingsManager経由
  this.currentSettings[key] = value; // ローカルキャッシュ更新
}

// onCommit 時に呼び出し
setupPressureCorrectionListener() {
  window.SliderUtils.bindSlider({
    // ...
    onCommit: (value) => {
      this.updateSetting('pressureCorrection', value); // 🆕 統一API使用
    }
  });
}
Step 3: CoreRuntime での SettingsManager 初期化確認
core-initializer.js または core-runtime.js:
javascript// 初期化シーケンスで SettingsManager を生成
const settingsManager = new window.SettingsManager(eventBus);
window.TegakiSettingsManager = settingsManager;

CoreRuntime.internal.settingsManager = settingsManager;
4-3. 検証項目
javascript// 1. SettingsManager が初期化されているか
console.log('SettingsManager:', window.TegakiSettingsManager);

// 2. 設定の保存・読み込み
const manager = window.TegakiSettingsManager;
manager.updateSetting('pressureCorrection', 2.0);
console.log(manager.getSetting('pressureCorrection')); // 2.0

// 3. localStorage に保存されているか
const stored = localStorage.getItem('tegaki_settings');
console.log(JSON.parse(stored));
// { pressureCorrection: 2.0, ... }

// 4. ページリロード後に復元されるか
// - リロード
// - console.log(window.TegakiSettingsManager.getSetting('pressureCorrection')); // 2.0

Phase 5: 最終検証とクリーンアップ
5-1. API統一性チェック
javascript// ブラウザコンソールで実行
const api = window.CoreRuntime.api;

// === 描画関連API ===
console.log('✓ undo:', typeof api.undo);
console.log('✓ redo:', typeof api.redo);
console.log('✓ clearCanvas:', typeof api.clearCanvas);

// === レイヤー関連API ===
console.log('✓ addLayer:', typeof api.addLayer);
console.log('✓ deleteLayer:', typeof api.deleteLayer);
console.log('✓ selectLayer:', typeof api.selectLayer);

// === 設定関連API（Phase 2追加） ===
console.log('✓ setPressureCorrection:', typeof api.setPressureCorrection);
console.log('✓ setSmoothing:', typeof api.setSmoothing);
console.log('✓ setPressureCurve:', typeof api.setPressureCurve);
console.log('✓ getSettings:', typeof api.getSettings);

// === エクスポート関連API ===
console.log('✓ exportPNG:', typeof api.exportPNG);
console.log('✓ exportGIF:', typeof api.exportGIF);
5-2. EventBus統合完全性チェック
javascript// 全てのイベントが購読されているか確認
const eventBus = window.TegakiEventBus;

// デバッグモード有効化（実装されている場合）
if (eventBus.setDebug) eventBus.setDebug(true);

// 設定変更イベントの発火テスト
eventBus.emit('settings:pressure-correction', { value: 1.5 });
eventBus.emit('settings:smoothing', { value: 0.7 });
eventBus.emit('settings:pressure-curve', { curve: 'ease-out' });

// 購読者が反応しているか確認
const engine = window.CoreRuntime.internal.drawingEngine;
console.log('BrushSettings:', engine.settings.getCurrentSettings());
console.log('PressureHandler:', engine.pressureHandler);
5-3. 二重実装チェック
❌ 削除済みを確認すべきコード
settings-popup.js:

✅ setupPressureCorrectionListener() の独自スライダー実装
✅ saveSettings() の localStorage 直接操作

ui-panels.js:

⚠️ createSlider() が slider-utils.js と重複していないか確認

javascript// ui-panels.js を確認
console.log('ui-panels.createSlider:', typeof window.TegakiUI?.UIPanels?.createSlider);
console.log('SliderUtils.createSlider:', typeof window.SliderUtils?.createSlider);

// 重複がある場合は ui-panels.js の createSlider を削除し、
// SliderUtils.createSlider を使用するよう修正
5-4. 座標系混在チェック
javascript// coordinate-system.js が正しく使用されているか確認
const CoordSys = window.CoordinateSystem;

// 描画エンジンが CoordinateSystem を使用しているか
const engine = window.CoreRuntime.internal.drawingEngine;
console.log('DrawingEngine uses CoordSys:', !!engine.coordSys);

// 直接 PIXI 座標を使用している箇所がないか検索
// ❌ 禁止: point.x, point.y の直接使用
// ✅ 推奨: CoordSys.toCanvas(point), CoordSys.toWorld(point)
5-5. 全機能回帰テスト
描画機能

 ペンタブレットで筆圧が効く
 筆圧補正スライダーで太さが変わる
 線補正スライダーでスムージングが変わる
 消しゴムツールが動作する

設定機能

 設定ポップアップが開く
 スライダーがリアルタイムで反映される
 設定がlocalStorageに保存される
 ページリロード後に設定が復元される

API動作

 CoreRuntime.api.setPressureCorrection(2.0) が動作
 CoreRuntime.api.getSettings() で現在値取得
 EventBus経由の設定変更が動作

レイヤー・履歴

 Undo/Redo が動作
 レイヤー追加・削除が動作
 アニメーション再生が動作


改修完了の定義
機能要件

 Phase 1: DrawingEngine が EventBus を完全購読
 Phase 2: CoreRuntime.api に設定関連メソッド追加
 Phase 3: スライダー実装を slider-utils.js に統一
 Phase 4: localStorage 操作を SettingsManager に集約

非機能要件

 DRY原則: 重複コードなし（スライダー、localStorage）
 SOLID原則: 単一責任（UI/永続化層の分離）
 API統一: 全ての設定変更が CoreRuntime.api 経由で可能
 EventBus統合: 全ての設定変更がイベント経由で伝播

コード品質

 console.log 削除（デバッグログ最小限）
 二重実装なし
 座標系の統一（CoordinateSystem使用）
 グローバル汚染の最小化


トラブルシューティング
筆圧補正が効かない場合
javascript// 1. PressureHandler に correctionFactor が存在するか
const handler = window.CoreRuntime.internal.drawingEngine.pressureHandler;
console.log('correctionFactor:', handler.correctionFactor);

// 2. EventBus が購読されているか
const engine = window.CoreRuntime.internal.drawingEngine;
console.log('subscribeToSettings:', typeof engine.subscribeToSettings);

// 3. 手動でイベント発火してみる
window.TegakiEventBus.emit('settings:pressure-correction', { value: 2.0 });
console.log('After emit:', handler.correctionFactor); // 2.0 になるはず
設定が保存されない場合
javascript// 1. SettingsManager が初期化されているか
console.log('SettingsManager:', window.TegakiSettingsManager);

// 2. localStorage を直接確認
console.log(localStorage.getItem('tegaki_settings'));

// 3. settings-popup.js が SettingsManager を使用しているか
// → saveSettings() メソッドが存在しないことを確認
スライダーが動作しない場合
javascript// 1. SliderUtils が存在するか
console.log('SliderUtils:', window.SliderUtils);

// 2. DOM要素が存在するか
const slider = document.getElementById('pressure-correction-slider');
console.log('Slider element:', slider);

// 3. イベントリスナーが登録されているか
// → Chrome DevTools の Event Listeners タブで確認

後続Claude向け指示

Phase 1から順番に実行（スキップ禁止）
各Phase完了後、必ず検証項目を全てチェック
エラー発生時は該当Phaseのみロールバック
既存機能の破壊的変更は絶対禁止
コード生成時は完全なファイル内容を提示（省略禁止）
不明点は先に質問、推測実装禁止
file://で動作確認を忘れずに

改修中に発見した問題は即報告:

API不一致 → BatchAPIで統一
EventBus統合不完全 → 該当箇所を指摘
二重実装 → DRY原則違反として報告
座標系混在 → CoordinateSystemで統一確認

Good luck, Claude. Keep the data flow clear and the responsibilities separated.