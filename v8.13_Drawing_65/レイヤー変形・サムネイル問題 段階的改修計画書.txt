# レイヤー変形・サムネイル問題 段階的改修計画書

## 問題の概要

### 報告された不具合
1. レイヤーサムネイルが古い（回転・スケール変更が未反映）
2. Vモード編集がレイヤーパネルに反映されない
3. Vモード時のアクティブレイヤー反転ボタン・ショートカットが効かない
4. Vモードドラッグで NaNpx になり絵が飛ぶ

### 根本原因（GPT5案分析より）
- `_handleLayerDrag()` が `layer:updated` のみ発火、`layer:transform-updated` 未発火
- 座標変換で undefined/null が数値計算に混入 → NaN 発生
- イベント名・ペイロード構造の不整合
- UI側が `layer:transform-updated` を購読していない

---

## 改修方針

### 設計原則（ガイドラインv2.2準拠）
- イベント名: `component:action` 形式統一
- 座標系: パラメータ名に明示（localX, worldX等）
- 数値扱い: DOM出力前に `Number()` で型保証、`px` 文字列混入防止
- 二重変換防止: 座標変換は coordinate-system.js 経由のみ

### 改修スコープ
- ✅ Phase 1: イベント発火の修正（最優先・即効性あり）
- ✅ Phase 2: 座標系 NaN 対策（安定性向上）
- ✅ Phase 3: UI受信側の整備（完全性確保）
- ✅ Phase 4: ショートカット整合性（操作性改善）

---

## Phase 1: イベント発火の修正（所要時間: 30分〜1時間）

### 目的
レイヤー変形時に適切なイベントを発火し、サムネイル・パネル更新を即座に反映

### 修正対象ファイル
**主ファイル**: `system/layer-transform.js`
**参考ファイル**: `system/layer-system.js`, `system/event-bus.js`

### 処理フロー上の位置
```
ユーザー操作（Vキー + ドラッグ）
  → _handleLayerDrag()【修正箇所】
    → PIXI layer.position 更新
    → EventBus.emit()【追加箇所】
      → thumbnail-system.js（Phase 3で購読追加）
      → layer-panel-renderer.js（Phase 3で購読追加）
```

### 修正内容

#### `_handleLayerDrag()` 末尾に追加
```javascript
// ========== Phase 1: イベント発火追加 ==========
// レイヤーのインデックス・ID取得
const layerIndex = this.getLayerIndex(layer); // 既存メソッド使用
const layerId = layer.layerData?.id;

// transform値を数値型で確実に取得（文字列・NaN防止）
const transformPayload = {
  x: Number(layer.position?.x || 0),
  y: Number(layer.position?.y || 0),
  scaleX: Number(layer.scale?.x || 1),
  scaleY: Number(layer.scale?.y || 1),
  rotation: Number(layer.rotation || 0)
};

// 3種類のイベント発火（ガイドラインv2.2準拠）
if (window.TegakiEventBus) {
  // 1) 汎用レイヤー更新イベント
  window.TegakiEventBus.emit('layer:updated', {
    component: 'layer',
    action: 'dragged',
    data: { layerIndex, layerId }
  });
  
  // 2) Transform専用イベント（UI更新用）
  window.TegakiEventBus.emit('layer:transform-updated', {
    component: 'layer',
    action: 'transform-updated',
    data: { layerIndex, layerId, transform: transformPayload }
  });
  
  // 3) サムネイル更新イベント（回転・スケール反映用）
  window.TegakiEventBus.emit('thumbnail:layer-updated', {
    component: 'drawing',
    action: 'transform-applied',
    data: { layerIndex, layerId }
  });
}
```

### 検証方法
```javascript
// DevToolsコンソールで実行
window.TegakiEventBus?.on('*', (ev) => console.log('EVENT:', ev));
// Vモードでレイヤードラッグ → 3つのイベントが出力されることを確認
```

### 期待される効果
- サムネイルが即座に更新される（問題1解決）
- レイヤーパネルが即座に更新される（問題2解決）
- NaN問題の一部が改善（数値型保証により）

---

## Phase 2: 座標系 NaN 対策（所要時間: 30分〜1時間）

### 目的
座標変換で NaN が発生しても安全に処理し、ログで発生源を可視化

### 修正対象ファイル
**主ファイル**: `coordinate-system.js`
**参考ファイル**: `system/camera-system.js`, `system/drawing/drawing-engine.js`

### 処理フロー上の位置
```
PointerEvent.clientX/Y
  → screenClientToCanvas()
    → canvasToWorld()
      → worldToLocal()【修正箇所】
        → NaN検出・ログ出力【追加】
        → 安全なフォールバック値返却【追加】
```

### 修正内容

#### `CoordinateSystem.worldToLocal()` の戻り値直前に追加
```javascript
// ========== Phase 2: NaN防御チェック ==========
// 既存の計算結果を result に格納している箇所の直後
const result = { localX: calcX, localY: calcY };

// NaN検出とログ出力
if (!isFinite(result.localX) || !isFinite(result.localY)) {
  console.warn('[CoordinateSystem] worldToLocal produced NaN/Infinity', {
    input: { worldX, worldY },
    output: result,
    layerId: layer?.layerData?.id,
    layerTransform: {
      x: layer?.position?.x,
      y: layer?.position?.y,
      scaleX: layer?.scale?.x,
      scaleY: layer?.scale?.y,
      rotation: layer?.rotation
    }
  });
  
  // 安全なフォールバック（描画位置を原点に戻す）
  return { localX: 0, localY: 0 };
}

return result;
```

#### `screenClientToCanvas()` のDPR補正確認
```javascript
// 既存コードの確認項目（修正不要の場合もあり）
function screenClientToCanvas(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  
  // ✅ 確認: rect.left/top が数値であることを保証
  const canvasX = (clientX - rect.left) * dpr;
  const canvasY = (clientY - rect.top) * dpr;
  
  return { canvasX, canvasY };
}
```

### 検証方法
```javascript
// DevToolsコンソールで強制的にNaNを発生させる
const layer = window.CoreRuntime?.internal?.layerManager?.getActiveLayer();
layer.rotation = NaN; // 意図的に壊す
// Vモードでドラッグ → コンソールにwarningが出力され、座標は(0,0)に戻る
```

### 期待される効果
- NaN発生時に画面が破綻しない（問題4解決）
- ログでNaN発生源が特定可能（デバッグ効率向上）

---

## Phase 3: UI受信側の整備（所要時間: 1時間）

### 目的
サムネイル・レイヤーパネルが `layer:transform-updated` を購読し、transform値を反映

### 修正対象ファイル
**主ファイル**: 
- `system/drawing/thumbnail-system.js`
- `ui/layer-panel-renderer.js`

**参考ファイル**: `system/event-bus.js`

### 処理フロー上の位置
```
EventBus.emit('layer:transform-updated', {...})
  → thumbnail-system.js【修正箇所】
    → updateLayerThumbnail()
      → RenderTexture生成（transform反映）
  → layer-panel-renderer.js【修正箇所】
    → updateLayerEntryTransform()
      → DOM更新（回転・スケール表示）
```

### 修正内容

#### `thumbnail-system.js` の `init()` に購読追加
```javascript
// ========== Phase 3-A: thumbnail-system購読追加 ==========
init() {
  // 既存の初期化処理...
  
  // Transform更新イベントを購読
  window.TegakiEventBus?.on('layer:transform-updated', (ev) => {
    const { layerIndex, layerId, transform } = ev.data || {};
    
    // サムネイル再生成（回転・スケールを反映）
    this.updateLayerThumbnail(layerIndex, layerId);
  });
}

// updateLayerThumbnail() メソッドの確認項目
updateLayerThumbnail(layerIndex, layerId) {
  const layer = this.getLayerByIndex(layerIndex);
  if (!layer) return;
  
  // ✅ 確認: layer.rotation, layer.scale.x/y を参照してRenderTexture生成
  // （既存実装を確認し、必要なら transform 適用コードを追加）
}
```

#### `layer-panel-renderer.js` に購読・更新メソッド追加
```javascript
// ========== Phase 3-B: layer-panel購読追加 ==========
init() {
  // 既存の初期化処理...
  
  // Transform更新イベントを購読
  window.TegakiEventBus?.on('layer:transform-updated', (ev) => {
    const { layerIndex, layerId, transform } = ev.data || {};
    this.updateLayerEntryTransform(layerIndex, transform);
  });
}

// 新規メソッド追加
updateLayerEntryTransform(layerIndex, transform) {
  const layerEntry = document.querySelector(`[data-layer-index="${layerIndex}"]`);
  if (!layerEntry) return;
  
  // transform値をDOMに反映（例: サムネイル回転表示）
  const thumbnail = layerEntry.querySelector('.layer-thumbnail');
  if (thumbnail && transform) {
    thumbnail.style.transform = `
      translate(${transform.x}px, ${transform.y}px)
      rotate(${transform.rotation}rad)
      scale(${transform.scaleX}, ${transform.scaleY})
    `;
  }
}
```

### 検証方法
```javascript
// レイヤーを回転・スケール変更 → リアルタイムでサムネイル・パネルが更新される
// 非アクティブレイヤーも正しく更新されることを確認
```

### 期待される効果
- 非アクティブレイヤーのサムネイルも即座に更新（問題1完全解決）
- レイヤーパネルでtransform状態が視覚的に確認可能（問題2完全解決）

---

## Phase 4: ショートカット整合性（所要時間: 30分）

### 目的
Vモード時の反転ショートカットを正しく動作させる

### 修正対象ファイル
**主ファイル**: `ui/keyboard-handler.js`
**参考ファイル**: `system/layer-system.js`, `system/state-manager.js`

### 処理フロー上の位置
```
KeyDown イベント（例: H キー）
  → keyboard-handler.js【修正箇所】
    → モード判定（isLayerMoveMode）【確認箇所】
    → layerSystem.flipActiveLayer()【呼び出し確認】
      → layer.scale.x *= -1（内部処理）
      → layer:transform-updated 発火【Phase 1で追加済み】
```

### 修正内容

#### `keyboard-handler.js` の反転ショートカット修正
```javascript
// ========== Phase 4: ショートカット修正 ==========
// 既存の反転キー処理（例: H キー = 水平反転）
if (event.code === 'KeyH') {
  const layerSystem = window.CoreRuntime?.internal?.layerManager;
  
  // ✅ モード判定の確認（否定条件の誤りに注意）
  if (!layerSystem?.isLayerMoveMode) return; // Vモードでない場合はスキップ
  
  // ✅ メソッド存在確認
  if (typeof layerSystem.flipActiveLayer !== 'function') {
    console.warn('[KeyboardHandler] flipActiveLayer() not found on layerSystem');
    return;
  }
  
  // 反転実行
  layerSystem.flipActiveLayer({ axis: 'horizontal' });
  
  // Phase 1で追加した layer:transform-updated が内部で発火されることを期待
  // （万が一発火していなければ、ここで補助的に発火）
  const active = layerSystem.getActiveLayer();
  if (active) {
    window.TegakiEventBus?.emit('layer:transform-updated', {
      component: 'layer',
      action: 'flipped',
      data: {
        layerIndex: layerSystem.getLayerIndex(active),
        layerId: active?.layerData?.id,
        transform: {
          x: active.position?.x || 0,
          y: active.position?.y || 0,
          scaleX: active.scale?.x || 1,
          scaleY: active.scale?.y || 1,
          rotation: active.rotation || 0
        }
      }
    });
  }
  
  event.preventDefault();
}
```

#### `layer-system.js` の `flipActiveLayer()` 確認項目
```javascript
// 既存メソッドの確認（修正不要の場合もあり）
flipActiveLayer({ axis }) {
  const layer = this.getActiveLayer();
  if (!layer) return;
  
  if (axis === 'horizontal') {
    layer.scale.x *= -1;
  } else if (axis === 'vertical') {
    layer.scale.y *= -1;
  }
  
  // ✅ 確認: ここで layer:transform-updated を発火しているか
  // （Phase 1の修正で _handleLayerDrag 内で発火していれば問題なし）
}
```

### 検証方法
```javascript
// 1. Vキーを押してレイヤー移動モードに入る
// 2. Hキーを押す → アクティブレイヤーが水平反転
// 3. サムネイル・パネルも即座に更新される
// 4. 非Vモード時はHキーが効かないことを確認
```

### 期待される効果
- Vモード時の反転操作が正常動作（問題3解決）
- ショートカット・UIボタン両方で動作統一

---

## デバッグ手順（全Phase共通）

### 1. イベントログ監視
```javascript
// DevToolsコンソールで全イベントを監視
window.TegakiEventBus?.on('*', (ev) => {
  console.log('[EventBus]', ev.component + ':' + ev.action, ev.data);
});
```

### 2. 座標変換テスト
```javascript
// TegakiDebugが存在する場合
TegakiDebug?.drawing?.inspectEngine?.();

// 手動テスト
const coord = window.CoordinateSystem;
const result = coord.worldToLocal(100, 200, activeLayer);
console.log('worldToLocal result:', result); // NaN確認
```

### 3. レイヤー状態確認
```javascript
const layerSystem = window.CoreRuntime?.internal?.layerManager;
console.log('isLayerMoveMode:', layerSystem?.isLayerMoveMode);
console.log('activeLayer:', layerSystem?.getActiveLayer());
```

---

## 改修後の検証チェックリスト

### 基本動作確認
- [ ] ペン描画でサムネイルが即座に更新される
- [ ] Vモードでレイヤードラッグ → サムネイル・パネルが即座に更新
- [ ] 回転・スケール変更 → サムネイルに反映
- [ ] 非アクティブレイヤーのサムネイルも正しく更新
- [ ] ドラッグ時に NaNpx が発生しない

### Vモード動作確認
- [ ] Vキーでレイヤー移動モードに入る
- [ ] ドラッグでレイヤー位置が変わる
- [ ] H/Vキーで反転操作が動作
- [ ] 反転ボタン（UI）が動作
- [ ] Vキー解除で通常描画モードに戻る

### 座標系精度確認（ガイドラインv2.2準拠）
- [ ] 初期状態でペン位置と描画位置が一致
- [ ] ズーム後も描画位置が正確
- [ ] パン後も描画位置が正確
- [ ] Canvas resize 後も描画位置が正確

---

## トラブルシューティング

### サムネイルが更新されない場合
1. Phase 1の `layer:transform-updated` が発火しているか確認
2. Phase 3の `thumbnail-system.js` が購読しているか確認
3. `updateLayerThumbnail()` 内で transform を参照しているか確認

### NaNpx が解消されない場合
1. Phase 2のログ出力で発生源を特定
2. `layer.rotation`/`layer.scale.x/y` が undefined でないか確認
3. `screenClientToCanvas()` の DPR 補正を確認

### ショートカットが効かない場合
1. `isLayerMoveMode` の状態を確認
2. `flipActiveLayer()` メソッドが存在するか確認
3. モード判定の条件分岐（否定の有無）を確認

---

## 今後の展開（Phase 5以降）

本改修完了後、以下のタイミングでガイドラインv2.2 Phase 2移行を検討：

### Phase 2移行の前提条件
- ✅ 本改修（Phase 1〜4）が完全動作
- ✅ 座標系テスト6項目すべて合格
- ✅ ペン/消しゴム基本動作が安定

### Phase 2移行の内容（参考）
- `drawing-engine.js` → `brush-core.js` 改称
- `eraser-mask-renderer.js` 廃止
- ペン/消しゴム共通パイプライン統合
- BrushRenderer実装

### 判断基準
本改修で**ユーザー体験の緊急課題を解決**した後、Phase 2移行の必要性を再評価する。

---

## 参考資料

- `🚨ブラウザお絵かきツール v8.13 - プロジェクト運用ガイドライン v2.2.txt`
- `GPT5案.txt`（本計画書の基礎）
- PixiJS v8.13 公式ドキュメント
- EventBus実装規約（`system/event-bus.js`）

---

## 改修履歴

| Phase | 実施日 | 担当Claude | 状態 | 備考 |
|-------|--------|-----------|------|------|
| Phase 1 | 未実施 | - | 計画中 | イベント発火修正 |
| Phase 2 | 未実施 | - | 計画中 | NaN対策 |
| Phase 3 | 未実施 | - | 計画中 | UI受信整備 |
| Phase 4 | 未実施 | - | 計画中 | ショートカット修正 |

---

## 最終確認項目（全Phase完了後）

- [ ] GPT5案.txtで指摘された4つの問題すべて解決
- [ ] ガイドラインv2.2の座標系規約に準拠
- [ ] イベント名が `component:action` 形式で統一
- [ ] 数値型保証（`Number()`使用）が徹底
- [ ] NaN発生時のログ出力が機能
- [ ] サムネイル・パネル・ショートカットすべて正常動作

**改修完了後、この計画書を `CHANGELOG.md` に追記してください。**