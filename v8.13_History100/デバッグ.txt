/**
 * P/E+ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ãƒ‡ãƒãƒƒã‚°ã‚³ãƒãƒ³ãƒ‰é›† (æ”¹å–„ç‰ˆ)
 * 
 * ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è²¼ã‚Šä»˜ã‘ã¦å®Ÿè¡Œã—ã¦ãã ã•ã„
 */

window.debugPenDrag = {
    /**
     * å…¨ä½“çŠ¶æ³ã‚’ãƒã‚§ãƒƒã‚¯
     */
    checkAll() {
        console.log('=== P/E+ãƒ‰ãƒ©ãƒƒã‚° ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ ===\n');
        
        // EventBus
        console.log('1. EventBus:');
        console.log('  å­˜åœ¨:', !!window.TegakiEventBus);
        console.log('  ãƒªã‚¹ãƒŠãƒ¼æ•°:', window.TegakiEventBus?._events ? 
            Object.keys(window.TegakiEventBus._events).length : 0);
        
        // ToolSizeManager
        console.log('\n2. ToolSizeManager:');
        const tsm = window.toolSizeManager;
        if (tsm) {
            console.log('  å­˜åœ¨: âœ…');
            const info = tsm.getDebugInfo();
            console.log('  ãƒšãƒ³ã‚µã‚¤ã‚º:', info.penSize);
            console.log('  ãƒšãƒ³ä¸é€æ˜åº¦:', info.penOpacity);
            console.log('  ãƒ‰ãƒ©ãƒƒã‚°ä¸­:', !!info.dragState);
            console.log('  BrushSettingså–å¾—å¯:', info.brushSettings);
            if (info.brushSettingsDetails) {
                console.log('  ç¾åœ¨ã®BrushSettings:', info.brushSettingsDetails);
            }
        } else {
            console.log('  å­˜åœ¨: âŒ');
        }
        
        // DrawingEngine
        console.log('\n3. DrawingEngine:');
        const de = window.coreEngine?.drawingEngine || window.drawingApp?.drawingEngine;
        if (de) {
            console.log('  å­˜åœ¨: âœ…');
            console.log('  settings:', !!de.settings);
            console.log('  currentTool:', de.currentTool);
            if (de.settings) {
                console.log('  settings.size:', de.settings.size);
                console.log('  settings.opacity:', de.settings.opacity);
            }
        } else {
            console.log('  å­˜åœ¨: âŒ');
        }
        
        // KeyboardHandler
        console.log('\n4. KeyboardHandler:');
        if (window.KeyboardHandler) {
            const state = window.KeyboardHandler.getDebugState?.();
            if (state) {
                console.log('  Pã‚­ãƒ¼æŠ¼ä¸‹:', state.pKeyPressed);
                console.log('  Eã‚­ãƒ¼æŠ¼ä¸‹:', state.eKeyPressed);
                console.log('  ãƒ‰ãƒ©ãƒƒã‚°ä¸­:', state.isDragging);
                console.log('  ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ„ãƒ¼ãƒ«:', state.activeTool);
            }
        }
        
        // DragVisualFeedback
        console.log('\n5. DragVisualFeedback:');
        const feedback = document.getElementById('drag-visual-feedback');
        console.log('  DOMè¦ç´ :', !!feedback);
        console.log('  è¡¨ç¤ºä¸­:', feedback?.style.display !== 'none');
        
        console.log('\n=====================================');
    },
    
    /**
     * EventBusã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ç¢ºèª
     */
    checkEventListeners() {
        console.log('=== EventBus ãƒªã‚¹ãƒŠãƒ¼ç¢ºèª ===\n');
        
        if (!window.TegakiEventBus?._events) {
            console.log('EventBusæœªåˆæœŸåŒ–');
            return;
        }
        
        const events = window.TegakiEventBus._events;
        const targetEvents = [
            'tool:drag-size-start',
            'tool:drag-size-update',
            'tool:drag-size-end',
            'tool:size-opacity-changed',
            'brushSizeChanged',
            'brushOpacityChanged'
        ];
        
        targetEvents.forEach(evt => {
            const listeners = events[evt];
            console.log(`${evt}:`, listeners ? `${listeners.length}å€‹` : '0å€‹');
            if (listeners && listeners.length > 0) {
                console.log('  â†’ ãƒªã‚¹ãƒŠãƒ¼ç™»éŒ²æ¸ˆã¿ âœ…');
            }
        });
        
        console.log('\n=====================================');
    },
    
    /**
     * P/E+ãƒ‰ãƒ©ãƒƒã‚°ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
     */
    async simulateDrag(tool = 'pen', sizeChange = 10, opacityChange = 0.1) {
        console.log(`\n=== ${tool} ãƒ‰ãƒ©ãƒƒã‚°ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ ===`);
        
        if (!window.TegakiEventBus) {
            console.error('âŒ EventBus ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return;
        }
        
        const de = window.coreEngine?.drawingEngine || window.drawingApp?.drawingEngine;
        if (!de?.settings) {
            console.error('âŒ DrawingEngine.settings ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return;
        }
        
        const initialSize = de.settings.size;
        const initialOpacity = de.settings.opacity;
        
        console.log('åˆæœŸå€¤:', { size: initialSize, opacity: initialOpacity });
        
        // 1. ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
        console.log('\n1. tool:drag-size-start ç™ºè¡Œ...');
        window.TegakiEventBus.emit('tool:drag-size-start', {
            tool: tool,
            startSize: initialSize,
            startOpacity: initialOpacity
        });
        
        await this._wait(300);
        
        // 2. ãƒ‰ãƒ©ãƒƒã‚°æ›´æ–°
        console.log('2. tool:drag-size-update ç™ºè¡Œ...');
        window.TegakiEventBus.emit('tool:drag-size-update', {
            tool: tool,
            deltaX: sizeChange / 0.1,  // æ„Ÿåº¦0.1ã§å‰²ã‚‹
            deltaY: -opacityChange / 0.002  // æ„Ÿåº¦0.002ã§å‰²ã‚‹
        });
        
        await this._wait(300);
        
        // 3. ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
        console.log('3. tool:drag-size-end ç™ºè¡Œ...');
        window.TegakiEventBus.emit('tool:drag-size-end');
        
        await this._wait(300);
        
        // 4. çµæœç¢ºèª
        const finalSize = de.settings.size;
        const finalOpacity = de.settings.opacity;
        
        console.log('\nçµæœ:', { 
            size: finalSize, 
            opacity: finalOpacity 
        });
        
        const sizeChanged = Math.abs(finalSize - initialSize) > 0.1;
        const opacityChanged = Math.abs(finalOpacity - initialOpacity) > 0.01;
        
        console.log('\nå¤‰æ›´æ¤œå‡º:', {
            ã‚µã‚¤ã‚º: sizeChanged ? 'âœ… å¤‰æ›´ã•ã‚ŒãŸ' : 'âŒ å¤‰æ›´ãªã—',
            ä¸é€æ˜åº¦: opacityChanged ? 'âœ… å¤‰æ›´ã•ã‚ŒãŸ' : 'âŒ å¤‰æ›´ãªã—'
        });
        
        if (sizeChanged && opacityChanged) {
            console.log('\nğŸ‰ P/E+ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ã¯æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™ï¼');
        } else {
            console.log('\nâš ï¸ P/E+ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ã«å•é¡ŒãŒã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™');
            console.log('   checkEventListeners() ã§ãƒªã‚¹ãƒŠãƒ¼ç™»éŒ²ã‚’ç¢ºèªã—ã¦ãã ã•ã„');
        }
        
        console.log('\n=====================================');
    },
    
    /**
     * æ‰‹å‹•ã§ã‚µã‚¤ã‚ºå¤‰æ›´ã‚’ãƒ†ã‚¹ãƒˆ
     */
    testDirectChange(size, opacity) {
        console.log(`\n=== ç›´æ¥å¤‰æ›´ãƒ†ã‚¹ãƒˆ (${size}px, ${opacity}) ===`);
        
        const de = window.coreEngine?.drawingEngine || window.drawingApp?.drawingEngine;
        if (!de?.settings) {
            console.error('âŒ DrawingEngine.settings ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return;
        }
        
        console.log('å¤‰æ›´å‰:', {
            size: de.settings.size,
            opacity: de.settings.opacity
        });
        
        de.settings.setBrushSize(size);
        de.settings.setBrushOpacity(opacity);
        
        console.log('å¤‰æ›´å¾Œ:', {
            size: de.settings.size,
            opacity: de.settings.opacity
        });
        
        console.log('âœ… ç›´æ¥å¤‰æ›´å®Œäº†');
    },
    
    /**
     * ç¾åœ¨ã®è¨­å®šã‚’è¡¨ç¤º
     */
    showCurrent() {
        const de = window.coreEngine?.drawingEngine || window.drawingApp?.drawingEngine;
        if (!de) {
            console.error('âŒ DrawingEngine ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return;
        }
        
        console.log('=== ç¾åœ¨ã®è¨­å®š ===');
        console.log('ãƒ„ãƒ¼ãƒ«:', de.currentTool || 'unknown');
        if (de.settings) {
            console.log('ã‚µã‚¤ã‚º:', de.settings.size);
            console.log('ä¸é€æ˜åº¦:', de.settings.opacity);
            console.log('è‰²:', de.settings.color);
        }
    },
    
    /**
     * ãƒ„ãƒ¼ãƒ«åˆ‡æ›¿ãƒ†ã‚¹ãƒˆ
     */
    switchTool(tool) {
        if (!['pen', 'eraser'].includes(tool)) {
            console.error('âŒ ãƒ„ãƒ¼ãƒ«ã¯ "pen" ã¾ãŸã¯ "eraser" ã‚’æŒ‡å®šã—ã¦ãã ã•ã„');
            return;
        }
        
        console.log(`\n=== ãƒ„ãƒ¼ãƒ«åˆ‡æ›¿: ${tool} ===`);
        
        if (window.CoreRuntime?.api?.setTool) {
            window.CoreRuntime.api.setTool(tool);
            console.log('âœ… CoreRuntime.api.setTool() ã§åˆ‡æ›¿å®Œäº†');
        } else {
            const de = window.coreEngine?.drawingEngine || window.drawingApp?.drawingEngine;
            if (de?.setTool) {
                de.setTool(tool);
                console.log('âœ… DrawingEngine.setTool() ã§åˆ‡æ›¿å®Œäº†');
            } else {
                console.error('âŒ ãƒ„ãƒ¼ãƒ«åˆ‡æ›¿ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
        }
        
        this.showCurrent();
    },
    
    /**
     * å¾…æ©Ÿé–¢æ•°
     */
    _wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    },
    
    /**
     * è‡ªå‹•è¨ºæ–­å®Ÿè¡Œ
     */
    async runDiagnostics() {
        console.log('ğŸ” P/E+ãƒ‰ãƒ©ãƒƒã‚° è‡ªå‹•è¨ºæ–­é–‹å§‹\n');
        
        this.checkAll();
        console.log('\n');
        
        this.checkEventListeners();
        console.log('\n');
        
        await this.simulateDrag('pen', 5, 0.1);
        
        console.log('\nğŸ” è¨ºæ–­å®Œäº†');
    }
};

// ä½¿ã„æ–¹ã‚’è¡¨ç¤º
console.log(`
ğŸ”§ P/E+ãƒ‰ãƒ©ãƒƒã‚° ãƒ‡ãƒãƒƒã‚°ã‚³ãƒãƒ³ãƒ‰ (æ”¹å–„ç‰ˆ)

ã€æ¨å¥¨ã€‘ã¾ãšè‡ªå‹•è¨ºæ–­ã‚’å®Ÿè¡Œ:
  debugPenDrag.runDiagnostics()

å€‹åˆ¥ã‚³ãƒãƒ³ãƒ‰:
1. å…¨ä½“çŠ¶æ…‹ç¢ºèª
   debugPenDrag.checkAll()

2. EventBusãƒªã‚¹ãƒŠãƒ¼ç¢ºèª
   debugPenDrag.checkEventListeners()

3. ãƒ‰ãƒ©ãƒƒã‚°ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
   debugPenDrag.simulateDrag('pen', 10, 0.1)
   debugPenDrag.simulateDrag('eraser', 15, 0.2)

4. ç›´æ¥å¤‰æ›´ãƒ†ã‚¹ãƒˆ
   debugPenDrag.testDirectChange(20, 0.9)

5. ç¾åœ¨ã®è¨­å®šè¡¨ç¤º
   debugPenDrag.showCurrent()

6. ãƒ„ãƒ¼ãƒ«åˆ‡æ›¿ãƒ†ã‚¹ãƒˆ
   debugPenDrag.switchTool('pen')
   debugPenDrag.switchTool('eraser')
`);